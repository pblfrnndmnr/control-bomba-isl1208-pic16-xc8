Disassembly Listing for Control_BOMBA_RTC_ISL1208_V6
Generated From:
/home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/dist/ISL1208_XC8_16f877a/production/Control_BOMBA_RTC_ISL1208_V6.X.production.cof
22/01/2015 00:11:17

---  /opt/microchip/xc8/v1.31/sources/pic/ftdiv.c  ------------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (C) 2006 HI-TECH Software
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_dividend	(*(unsigned short long *)&f1)
11:            #define	f2_as_divisor	(*(unsigned short long *)&f2)
12:            #define	f3_as_quot	(*(unsigned short long *)&f3)
13:            
14:            // floating addition
15:            #ifdef _OLDLIB
16:            #define	cntr		sign2
17:            float
18:            __ftdiv(float f2, float f1)
19:            {
20:            	unsigned char	exp1, exp2, sign1, sign2;
21:            	float	f3;
22:            	
23:            	f3_as_quot = 0;
24:            	sign1 = __ftunpack(&f1_as_dividend, &exp1);
25:            	if(exp1 == 0)
26:            		return f3;
27:            	sign2 = __ftunpack(&f2_as_divisor, &exp2);
28:            	if(exp2 == 0)
29:            		return f3;
30:            	exp1 -= exp2-127+8;	// compute new exponent
31:            	sign1 ^= sign2;
32:            	cntr = 16+8;
33:            	do {
34:            		f3_as_quot <<= 1;
35:            		if(f1_as_dividend >= f2_as_divisor) {
36:            			f1_as_dividend -= f2_as_divisor;
37:            			f3_as_quot |= 1;
38:            		}
39:            		f1_as_dividend <<= 1;
40:            	} while(--cntr != 0);
41:            	__ftpack(&f3_as_quot, exp1);
42:            	if(sign1)
43:            		f3_as_quot |= 0x800000;
44:            	return f3;
45:            }
46:            #else
47:            #define	exp2	sign
48:            float
49:            __ftdiv(float f2, float f1)
50:            {
51:            	unsigned char	exp, sign, cntr;
52:            	float	f3;
53:            	
54:            	// unpack the operands
55:            	if((exp = f1_as_dividend >> 15) == 0)
161F  084F     MOVF f1, W
1620  00D2     MOVWF prec
1621  0850     MOVF 0x50, W
1622  00D3     MOVWF ap
1623  0851     MOVF 0x51, W
1624  00D4     MOVWF flag
1625  1003     BCF STATUS, 0x0
1626  0D53     RLF ap, W
1627  0D54     RLF flag, W
1628  00D9     MOVWF exp
1629  08D9     MOVF exp, F
162A  1D03     BTFSS STATUS, 0x2
162B  2E30     GOTO 0x630
56:            		return 0.0;
162C  01CC     CLRF f2
162D  01CD     CLRF 0x4D
162E  01CE     CLRF 0x4E
162F  0008     RETURN
57:            	if((exp2 = f2_as_divisor >> 15) == 0)
1630  084C     MOVF f2, W
1631  00D2     MOVWF prec
1632  084D     MOVF 0x4D, W
1633  00D3     MOVWF ap
1634  084E     MOVF 0x4E, W
1635  00D4     MOVWF flag
1636  1003     BCF STATUS, 0x0
1637  0D53     RLF ap, W
1638  0D54     RLF flag, W
1639  00DA     MOVWF c
163A  08DA     MOVF c, F
163B  1D03     BTFSS STATUS, 0x2
163C  2E41     GOTO 0x641
58:            		return 0.0;
163D  01CC     CLRF f2
163E  01CD     CLRF 0x4D
163F  01CE     CLRF 0x4E
1640  0008     RETURN
59:            	f3_as_quot = 0;
1642  01D6     CLRF f3
1643  01D7     CLRF _val
1644  01D8     CLRF 0x58
60:            	exp -= exp2-127+8;	// compute new exponent
1641  3089     MOVLW 0x89
1645  075A     ADDWF c, W
1646  00D2     MOVWF prec
1647  02D9     SUBWF exp, F
61:            	sign = f1_as_dividend >> 16;
1648  0851     MOVF 0x51, W
1649  00DA     MOVWF c
62:            	sign ^= (unsigned char)(f2_as_divisor >> 16);
164A  084E     MOVF 0x4E, W
164B  06DA     XORWF c, F
63:            	sign &= 0x80;
164C  3080     MOVLW 0x80
164D  05DA     ANDWF c, F
64:            	f1_as_dividend |= 0x8000UL;
164F  17D0     BSF 0x50, 0x7
65:            	f1_as_dividend &= 0xFFFFUL;
1650  01D1     CLRF 0x51
66:            	f2_as_divisor |= 0x8000UL;
1651  17CD     BSF 0x4D, 0x7
67:            	f2_as_divisor &= 0xFFFFUL;
1652  01CE     CLRF 0x4E
68:            	cntr = 16+8;
164E  3018     MOVLW 0x18
1653  00D5     MOVWF width
69:            	do {
70:            		f3_as_quot <<= 1;
1654  1003     BCF STATUS, 0x0
1655  0DD6     RLF f3, F
1656  0DD7     RLF _val, F
1657  0DD8     RLF 0x58, F
71:            		if(f1_as_dividend >= f2_as_divisor) {
1658  084E     MOVF 0x4E, W
1659  0251     SUBWF 0x51, W
165A  1D03     BTFSS STATUS, 0x2
165B  2E62     GOTO 0x662
165C  084D     MOVF 0x4D, W
165D  0250     SUBWF 0x50, W
165E  1D03     BTFSS STATUS, 0x2
165F  2E62     GOTO 0x662
1660  084C     MOVF f2, W
1661  024F     SUBWF f1, W
1662  1C03     BTFSS STATUS, 0x0
1663  2E70     GOTO 0x670
72:            			f1_as_dividend -= f2_as_divisor;
1664  084C     MOVF f2, W
1665  02CF     SUBWF f1, F
1666  084D     MOVF 0x4D, W
1667  1C03     BTFSS STATUS, 0x0
1668  0F4D     INCFSZ 0x4D, W
1669  02D0     SUBWF 0x50, F
166A  084E     MOVF 0x4E, W
166B  1C03     BTFSS STATUS, 0x0
166C  0A4E     INCF 0x4E, W
166D  02D1     SUBWF 0x51, F
73:            			f3_as_quot |= 1;
166E  1456     BSF f3, 0x0
74:            		}
75:            		f1_as_dividend <<= 1;
166F  1003     BCF STATUS, 0x0
1670  0DCF     RLF f1, F
1671  0DD0     RLF 0x50, F
1672  0DD1     RLF 0x51, F
76:            	} while(--cntr != 0);
1673  0BD5     DECFSZ width, F
1674  2E54     GOTO 0x654
77:            	return __ftpack(f3_as_quot, exp, sign);
1675  0856     MOVF f3, W
1676  00A3     MOVWF x
1677  0857     MOVF _val, W
1678  00A4     MOVWF dato
1679  0858     MOVF 0x58, W
167A  00A5     MOVWF y
167B  0859     MOVF exp, W
167C  00A6     MOVWF x
167D  085A     MOVF c, W
167E  00A7     MOVWF i
167F  27C2     CALL 0x7C2
1680  0823     MOVF x, W
1681  00CC     MOVWF f2
1682  0824     MOVF dato, W
1683  00CD     MOVWF 0x4D
1684  0825     MOVF y, W
1685  00CE     MOVWF 0x4E
78:            }
1686  0008     RETURN
79:            #endif	
---  /opt/microchip/xc8/v1.31/sources/common/wmul.c  ----------------------------------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             unsigned int
3:             __wmul(unsigned int multiplier, unsigned int multiplicand)
4:             {
5:                     unsigned int product;
6:             
7:             #ifdef _PIC18
8:             
9:             #define LOWBYTE(x)  (*(unsigned char *)(&x))
10:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
11:            
12:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
13:            /*
14:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
15:                   a  b
16:            *      c  d
17:            -----------
18:                 |   bd
19:                 |ad  0
20:                 |bc  0
21:            +  ac| 0  0 (we ignore this intermediate product
22:                         because it does not affect the low 16 bits of the result)
23:            ===========
24:             */
25:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
26:                    product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
27:                    product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
28:            
29:            #else
30:            
31:            	product = 0;
0784  01A7     CLRF i
0785  01A8     CLRF mth
32:            	do {
33:            		if(multiplier & 1)
0786  1C23     BTFSS x, 0x0
0787  2F8E     GOTO 0x78E
34:            			product += multiplicand;
0788  0825     MOVF y, W
0789  07A7     ADDWF i, F
078A  1803     BTFSC STATUS, 0x0
078B  0AA8     INCF mth, F
078C  0826     MOVF x, W
078D  07A8     ADDWF mth, F
35:            		multiplicand <<= 1;
078E  1003     BCF STATUS, 0x0
078F  0DA5     RLF y, F
0790  0DA6     RLF x, F
36:            		multiplier >>= 1;
0791  1003     BCF STATUS, 0x0
0792  0CA4     RRF dato, F
0793  0CA3     RRF x, F
37:            	} while(multiplier != 0);
0794  0824     MOVF dato, W
0795  0423     IORWF x, W
0796  1D03     BTFSS STATUS, 0x2
0797  2F86     GOTO 0x786
38:            
39:            #endif
40:                    return product;
0798  0828     MOVF mth, W
0799  00A4     MOVWF dato
079A  0827     MOVF i, W
079B  00A3     MOVWF x
41:            }
079C  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/lwtoft.c  --------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            
11:            // Convert unsigned int to float
12:            
13:            #ifdef _OLDLIB
14:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
15:            float
16:            __lwtoft(unsigned int c)
17:            {
18:            	float	f1;
19:            	
20:            	if(c == 0)
21:            		return 0.0;
22:            	f1_as_mant1 = c;
23:            	__ftpack(&f1_as_mant1, 127+15);
24:            	return f1;
25:            }
26:            #else
27:            float
28:            __lwtoft(unsigned int c)
29:            {
30:            	return __ftpack(c, 127+15, 0);
15F9  0830     MOVF c, W
15FA  00A3     MOVWF x
15FB  0831     MOVF divisor, W
15FC  00A4     MOVWF dato
15FD  308E     MOVLW 0x8E
15FE  01A5     CLRF y
15FF  00A6     MOVWF x
1600  01A7     CLRF i
1601  27C2     CALL 0x7C2
1602  0823     MOVF x, W
1603  00B0     MOVWF c
1604  0824     MOVF dato, W
1605  00B1     MOVWF divisor
1606  0825     MOVF y, W
1607  00B2     MOVWF 0x32
31:            }
1608  0008     RETURN
32:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/lwmod.c  ---------------------------------------------------
1:             // word unsigned modulus
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwmod(unsigned int divisor, unsigned int dividend)
07C7  082B     MOVF sec, W
0F73  0871     MOVF canal, W
7:             #else
8:             __lwmod(unsigned int dividend, unsigned int divisor)
9:             #endif
10:            {
11:            	unsigned char	counter;
12:            
13:            	if(divisor != 0) {
07C7  082B     MOVF sec, W
07C8  042A     IORWF Data, W
07C9  1903     BTFSC STATUS, 0x2
07CA  2FE6     GOTO 0x7E6
0F73  0871     MOVF canal, W
0F74  0470     IORWF divisor, W
0F75  1903     BTFSC STATUS, 0x2
0F76  2F92     GOTO 0x792
14:            		counter = 1;
07CB  01AE     CLRF sign
0F77  01F4     CLRF counter
15:            		while((divisor & 0x8000) == 0) {
07CD  1BAB     BTFSC sec, 0x7
07CE  2FD3     GOTO 0x7D3
07D2  2FCC     GOTO 0x7CC
0F79  1BF1     BTFSC canal, 0x7
0F7A  2F7F     GOTO 0x77F
0F7E  2F78     GOTO 0x778
16:            			divisor <<= 1;
07CC  0AAE     INCF sign, F
07CF  1003     BCF STATUS, 0x0
07D0  0DAA     RLF Data, F
07D1  0DAB     RLF sec, F
0F78  0AF4     INCF counter, F
0F7B  1003     BCF STATUS, 0x0
0F7C  0DF0     RLF divisor, F
0F7D  0DF1     RLF canal, F
17:            			counter++;
07CC  0AAE     INCF sign, F
0F78  0AF4     INCF counter, F
18:            		}
19:            		do {
20:            			if(divisor <= dividend)
07D3  082B     MOVF sec, W
07D4  022D     SUBWF day, W
07D5  1D03     BTFSS STATUS, 0x2
07D6  2FD9     GOTO 0x7D9
07D7  082A     MOVF Data, W
07D8  022C     SUBWF hr, W
07D9  1C03     BTFSS STATUS, 0x0
07DA  2FE2     GOTO 0x7E2
0F7F  0871     MOVF canal, W
0F80  0273     SUBWF counter, W
0F81  1D03     BTFSS STATUS, 0x2
0F82  2F85     GOTO 0x785
0F83  0870     MOVF divisor, W
0F84  0272     SUBWF dividend, W
0F85  1C03     BTFSS STATUS, 0x0
0F86  2F8E     GOTO 0x78E
21:            				dividend -= divisor;
07DB  082A     MOVF Data, W
07DC  02AC     SUBWF hr, F
07DD  082B     MOVF sec, W
07DE  1C03     BTFSS STATUS, 0x0
07DF  03AD     DECF day, F
07E0  02AD     SUBWF day, F
0F87  0870     MOVF divisor, W
0F88  02F2     SUBWF dividend, F
0F89  0871     MOVF canal, W
0F8A  1C03     BTFSS STATUS, 0x0
0F8B  03F3     DECF counter, F
0F8C  02F3     SUBWF counter, F
22:            			divisor >>= 1;
07E1  1003     BCF STATUS, 0x0
07E2  0CAB     RRF sec, F
07E3  0CAA     RRF Data, F
0F8D  1003     BCF STATUS, 0x0
0F8E  0CF1     RRF canal, F
0F8F  0CF0     RRF divisor, F
23:            		} while(--counter != 0);
07E4  0BAE     DECFSZ sign, F
07E5  2FD3     GOTO 0x7D3
0F90  0BF4     DECFSZ counter, F
0F91  2F7F     GOTO 0x77F
24:            	}
25:            	return dividend;
07E6  082D     MOVF day, W
07E7  00AB     MOVWF sec
07E8  082C     MOVF hr, W
07E9  00AA     MOVWF Data
0F92  0873     MOVF counter, W
0F93  00F1     MOVWF canal
0F94  0872     MOVF dividend, W
0F95  00F0     MOVWF divisor
26:            }
07EA  0008     RETURN
0F96  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/lwdiv.c  ---------------------------------------------------
1:             // word unsigned division
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwdiv(unsigned int divisor, unsigned int dividend)
7:             #else
8:             __lwdiv(unsigned int dividend, unsigned int divisor)
9:             #endif
10:            {
11:            	unsigned int	quotient;
12:            	unsigned char	counter;
13:            
14:            	quotient = 0;
079D  01A7     CLRF i
079E  01A8     CLRF mth
15:            	if(divisor != 0) {
079F  0824     MOVF dato, W
07A0  0423     IORWF x, W
07A1  1903     BTFSC STATUS, 0x2
07A2  2FC2     GOTO 0x7C2
16:            		counter = 1;
07A3  01A9     CLRF year
17:            		while((divisor & 0x8000) == 0) {
07A5  1BA4     BTFSC dato, 0x7
07A6  2FAB     GOTO 0x7AB
07AA  2FA4     GOTO 0x7A4
18:            			divisor <<= 1;
07A4  0AA9     INCF year, F
07A7  1003     BCF STATUS, 0x0
07A8  0DA3     RLF x, F
07A9  0DA4     RLF dato, F
19:            			counter++;
07A4  0AA9     INCF year, F
20:            		}
21:            		do {
22:            			quotient <<= 1;
07AB  1003     BCF STATUS, 0x0
07AC  0DA7     RLF i, F
07AD  0DA8     RLF mth, F
23:            			if(divisor <= dividend) {
07AE  0824     MOVF dato, W
07AF  0226     SUBWF x, W
07B0  1D03     BTFSS STATUS, 0x2
07B1  2FB4     GOTO 0x7B4
07B2  0823     MOVF x, W
07B3  0225     SUBWF y, W
07B4  1C03     BTFSS STATUS, 0x0
07B5  2FBE     GOTO 0x7BE
24:            				dividend -= divisor;
07B6  0823     MOVF x, W
07B7  02A5     SUBWF y, F
07B8  0824     MOVF dato, W
07B9  1C03     BTFSS STATUS, 0x0
07BA  03A6     DECF x, F
07BB  02A6     SUBWF x, F
25:            				quotient |= 1;
07BC  1427     BSF i, 0x0
26:            			}
27:            			divisor >>= 1;
07BD  1003     BCF STATUS, 0x0
07BE  0CA4     RRF dato, F
07BF  0CA3     RRF x, F
28:            		} while(--counter != 0);
07C0  0BA9     DECFSZ year, F
07C1  2FAB     GOTO 0x7AB
29:            	}
30:            	return quotient;
07C2  0828     MOVF mth, W
07C3  00A4     MOVWF dato
07C4  0827     MOVF i, W
07C5  00A3     MOVWF x
31:            }
07C6  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/lbmod.c  ---------------------------------------------------
1:             // byte unsigned modulus
2:             
3:             unsigned char
4:             __lbmod(unsigned char dividend, unsigned char divisor)
0BF6  00A5     MOVWF y
0FBF  00F2     MOVWF dividend
5:             {
6:             	unsigned char	rem;
7:             	unsigned char	counter;
8:             
9:             	counter = 8;
0BF7  3008     MOVLW 0x8
0BF8  00A6     MOVWF x
0FC0  3008     MOVLW 0x8
0FC1  00F3     MOVWF counter
10:            	rem = 0;
0BF9  01A7     CLRF i
0FC2  01F4     CLRF counter
11:            	do {
12:            		rem = (rem << 1) | (dividend >> 7);
0BFA  0825     MOVF y, W
0BFB  00A4     MOVWF dato
0BFC  3007     MOVLW 0x7
0BFD  1003     BCF STATUS, 0x0
0BFE  0CA4     RRF dato, F
0BFF  3EFF     ADDLW 0xFF
0C00  1003     BCF STATUS, 0x0
0C01  1D03     BTFSS STATUS, 0x2
0C02  2BFE     GOTO 0x3FE
0C03  0D27     RLF i, W
0C04  0424     IORWF dato, W
0C05  00A7     MOVWF i
0FC3  0872     MOVF dividend, W
0FC4  00F1     MOVWF canal
0FC5  3007     MOVLW 0x7
0FC6  1003     BCF STATUS, 0x0
0FC7  0CF1     RRF canal, F
0FC8  3EFF     ADDLW 0xFF
0FC9  1003     BCF STATUS, 0x0
0FCA  1D03     BTFSS STATUS, 0x2
0FCB  2FC7     GOTO 0x7C7
0FCC  0D74     RLF counter, W
0FCD  0471     IORWF canal, W
0FCE  00F4     MOVWF counter
13:            		dividend <<= 1;
0C06  1003     BCF STATUS, 0x0
0C07  0DA5     RLF y, F
0FCF  1003     BCF STATUS, 0x0
0FD0  0DF2     RLF dividend, F
14:            		if(divisor <= rem)
0C08  0823     MOVF x, W
0C09  0227     SUBWF i, W
0C0A  1C03     BTFSS STATUS, 0x0
0C0B  2C0E     GOTO 0x40E
0FD1  0870     MOVF divisor, W
0FD2  0274     SUBWF counter, W
0FD3  1C03     BTFSS STATUS, 0x0
0FD4  2FD7     GOTO 0x7D7
15:            			rem -= divisor;
0C0C  0823     MOVF x, W
0C0D  02A7     SUBWF i, F
0FD5  0870     MOVF divisor, W
0FD6  02F4     SUBWF counter, F
16:            	} while(--counter != 0);
0C0E  0BA6     DECFSZ x, F
0C0F  2BFA     GOTO 0x3FA
0FD7  0BF3     DECFSZ counter, F
0FD8  2FC3     GOTO 0x7C3
17:            	return rem;
0C10  0827     MOVF i, W
0FD9  0874     MOVF counter, W
18:            }
0C11  0008     RETURN
0FDA  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/lbdiv.c  ---------------------------------------------------
1:             // byte unsigned division
2:             
3:             unsigned char
4:             __lbdiv(unsigned char dividend, unsigned char divisor)
0B90  00A4     MOVWF dato
5:             {
6:             	unsigned char	quotient;
7:             	unsigned char	counter;
8:             
9:             	quotient = 0;
0B91  01A6     CLRF x
10:            	if(divisor != 0) {
0B92  0823     MOVF x, W
0B93  1903     BTFSC STATUS, 0x2
0B94  2BA9     GOTO 0x3A9
11:            		counter = 1;
0B95  01A5     CLRF y
12:            		while((divisor & 0x80) == 0) {
0B97  1BA3     BTFSC x, 0x7
0B98  2B9C     GOTO 0x39C
0B9B  2B96     GOTO 0x396
13:            			divisor <<= 1;
0B99  1003     BCF STATUS, 0x0
0B9A  0DA3     RLF x, F
14:            			counter++;
0B96  0AA5     INCF y, F
15:            		}
16:            		do {
17:            			quotient <<= 1;
0B9C  1003     BCF STATUS, 0x0
0B9D  0DA6     RLF x, F
18:            			if(divisor <= dividend) {
0B9E  0823     MOVF x, W
0B9F  0224     SUBWF dato, W
0BA0  1C03     BTFSS STATUS, 0x0
0BA1  2BA6     GOTO 0x3A6
19:            				dividend -= divisor;
0BA2  0823     MOVF x, W
0BA3  02A4     SUBWF dato, F
20:            				quotient |= 1;
0BA4  1426     BSF x, 0x0
21:            			}
22:            			divisor >>= 1;
0BA5  1003     BCF STATUS, 0x0
0BA6  0CA3     RRF x, F
23:            		} while(--counter != 0);
0BA7  0BA5     DECFSZ y, F
0BA8  2B9C     GOTO 0x39C
24:            	}
25:            	return quotient;
0BA9  0826     MOVF x, W
26:            }
0BAA  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/isdigit.c  -------------------------------------------------
1:             #include	<ctype.h>
2:             
3:             #ifndef isdigit
4:             
5:             #ifdef _CTYPE_BIT_FUNCS_
6:             
7:             bit
8:             isdigit(char c)
0776  00A4     MOVWF dato
9:             #else
10:            int
11:            isdigit(int c)
12:            #endif
13:            {
14:            	return c <= '9' && c >= '0';
0777  303A     MOVLW 0x3A
0778  01A3     CLRF x
0779  0224     SUBWF dato, W
077A  1803     BTFSC STATUS, 0x0
077B  2F82     GOTO 0x782
077C  3030     MOVLW 0x30
077D  0224     SUBWF dato, W
077E  1C03     BTFSS STATUS, 0x0
077F  2F82     GOTO 0x782
0780  01A3     CLRF x
0781  0AA3     INCF x, F
0782  0C23     RRF x, W
15:            }
0783  0008     RETURN
16:            
17:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/fttol.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
11:            
12:            // Convert float to long
13:            
14:            #ifdef _OLDLIB
15:            long
16:            __fttol(float f1)
17:            {
18:            	unsigned char	sign1, exp1;
19:            	unsigned long	lval;
20:            
21:            	sign1 = __ftunpack(&f1_as_mant1, &exp1);
22:            	lval = f1_as_mant1;
23:            	exp1 -= 127+15;
24:            	if((signed char)exp1 < 0) {
25:            		if((signed char)exp1 < -15)
26:            			return 0;
27:            		do
28:            			lval >>= 1;
29:            		while(++exp1 != 0);
30:            	} else {
31:            		if(exp1 >= 32)
32:            			return 00;
33:            		while(exp1 != 0) {
34:            			lval <<= 1;
35:            			exp1--;
36:            		}
37:            	}
38:            	if(sign1)
39:            		lval = -lval;
40:            	return lval;
41:            }
42:            #else
43:            long
44:            __fttol(float f1)
45:            {
46:            	unsigned char	sign1, exp1;
47:            	unsigned long	lval;
48:            
49:            	if((exp1 = f1_as_mant1 >> 15) == 0)
0817  0823     MOVF x, W
0818  00A7     MOVWF i
0819  0824     MOVF dato, W
081A  00A8     MOVWF mth
081B  0825     MOVF y, W
081C  00A9     MOVWF year
081D  1003     BCF STATUS, 0x0
081E  0D28     RLF mth, W
081F  0D29     RLF year, W
0820  00AF     MOVWF quotient
0821  08AF     MOVF quotient, F
0822  1D03     BTFSS STATUS, 0x2
0823  2829     GOTO 0x29
50:            		return 0;
0824  01A3     CLRF x
0825  01A4     CLRF dato
0826  01A5     CLRF y
0827  01A6     CLRF x
0828  0008     RETURN
51:            	sign1 = f1_as_mant1 >> 23;
0829  0823     MOVF x, W
082A  00A7     MOVWF i
082B  0824     MOVF dato, W
082C  00A8     MOVWF mth
082D  0825     MOVF y, W
082E  00A9     MOVWF year
082F  3017     MOVLW 0x17
0830  1003     BCF STATUS, 0x0
0831  0CA9     RRF year, F
0832  0CA8     RRF mth, F
0833  0CA7     RRF i, F
0834  3EFF     ADDLW 0xFF
0835  1D03     BTFSS STATUS, 0x2
0836  2830     GOTO 0x30
0837  0827     MOVF i, W
0838  00AA     MOVWF Data
52:            	f1_as_mant1 |= 0x8000UL;
0839  17A4     BSF dato, 0x7
53:            	f1_as_mant1 &= 0xFFFFUL;
083A  01A5     CLRF y
54:            	lval = f1_as_mant1;
083B  0823     MOVF x, W
083C  00AB     MOVWF sec
083D  0824     MOVF dato, W
083E  00AC     MOVWF hr
083F  0825     MOVF y, W
0840  00AD     MOVWF day
0842  01AE     CLRF sign
55:            	exp1 -= 127+15;
0841  308E     MOVLW 0x8E
0843  02AF     SUBWF quotient, F
56:            	if((signed char)exp1 < 0) {
0844  1FAF     BTFSS quotient, 0x7
0845  2853     GOTO 0x53
57:            		if((signed char)exp1 < -15)
0846  082F     MOVF quotient, W
0847  3A80     XORLW 0x80
0848  3E8F     ADDLW 0x8F
0849  1C03     BTFSS STATUS, 0x0
084A  2824     GOTO 0x24
58:            			return 0;
59:            		do
60:            			lval >>= 1;
084B  1003     BCF STATUS, 0x0
084C  0CAE     RRF sign, F
084D  0CAD     RRF day, F
084E  0CAC     RRF hr, F
084F  0CAB     RRF sec, F
61:            		while(++exp1 != 0);
0850  0FAF     INCFSZ quotient, F
0851  284B     GOTO 0x4B
0852  2861     GOTO 0x61
62:            	} else {
63:            		if(exp1 >= 24)
0853  3018     MOVLW 0x18
0854  022F     SUBWF quotient, W
0855  1803     BTFSC STATUS, 0x0
0856  2824     GOTO 0x24
64:            			return 0;
65:            		while(exp1 != 0) {
0857  08AF     MOVF quotient, F
0860  2857     GOTO 0x57
66:            			lval <<= 1;
085A  1003     BCF STATUS, 0x0
085B  0DAB     RLF sec, F
085C  0DAC     RLF hr, F
085D  0DAD     RLF day, F
085E  0DAE     RLF sign, F
67:            			exp1--;
085F  03AF     DECF quotient, F
68:            		}
0857  08AF     MOVF quotient, F
0858  1903     BTFSC STATUS, 0x2
0859  2861     GOTO 0x61
69:            	}
70:            	if(sign1)
0861  082A     MOVF Data, W
0862  1903     BTFSC STATUS, 0x2
0863  286F     GOTO 0x6F
71:            		lval = -lval;
0864  09AB     COMF sec, F
0865  09AC     COMF hr, F
0866  09AD     COMF day, F
0867  09AE     COMF sign, F
0868  0AAB     INCF sec, F
0869  1903     BTFSC STATUS, 0x2
086A  0AAC     INCF hr, F
086B  1903     BTFSC STATUS, 0x2
086C  0AAD     INCF day, F
086D  1903     BTFSC STATUS, 0x2
086E  0AAE     INCF sign, F
72:            	return lval;
086F  082E     MOVF sign, W
0870  00A6     MOVWF x
0871  082D     MOVF day, W
0872  00A5     MOVWF y
0873  082C     MOVF hr, W
0874  00A4     MOVWF dato
0875  082B     MOVF sec, W
0876  00A3     MOVWF x
73:            }
0877  0008     RETURN
74:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/ftsub.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
11:            #define	f2_as_mant2	(*(unsigned short long *)&f2)
12:            
13:            // floating addition
14:            
15:            float
16:            #ifdef __PICC__
17:            #warning TODO: update cgpic and this file to use the other prototype
18:            __ftsub(float f2, float f1)
19:            #else
20:            __ftsub(float f1, float f2)
21:            #endif
22:            {
23:            	f2_as_mant2 ^= 0x800000;
1609  3080     MOVLW 0x80
160A  06B9     XORWF 0x39, F
24:            	return __ftadd(f1, f2);
160B  083A     MOVF f1, W
160C  00AB     MOVWF sec
160D  083B     MOVF 0x3B, W
160E  00AC     MOVWF hr
160F  083C     MOVF 0x3C, W
1610  00AD     MOVWF day
1611  0837     MOVF mes, W
1612  00AE     MOVWF sign
1613  0838     MOVF anio, W
1614  00AF     MOVWF quotient
1615  0839     MOVF 0x39, W
1616  00B0     MOVWF c
1617  2702     CALL 0x702
1618  082B     MOVF sec, W
1619  00B7     MOVWF mes
161A  082C     MOVF hr, W
161B  00B8     MOVWF anio
161C  082D     MOVF day, W
161D  00B9     MOVWF 0x39
25:            }
161E  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/ftmul.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_plier	(*(unsigned short long *)&f1)
11:            #define	f2_as_plicand	(*(unsigned short long *)&f2)
12:            
13:            // floating addition
14:            
15:            #ifdef _OLDLIB
16:            #define	f3_as_product		(*(unsigned short long *)&f3)
17:            float
18:            __ftmul(float f1, float f2)
19:            {
20:            	unsigned char	exp1, sign1, cntr;
21:            	float	f3;
22:            	
23:            	f3_as_product = 0;
24:            	sign1 = __ftunpack(&f1_as_plier, &exp1);
25:            	sign1 ^= __ftunpack(&f2_as_plicand, &cntr);
26:            	if(cntr == 0 || exp1 == 0)
27:            		return f3;
28:            	exp1 += cntr-127-6;	// compute new exponent
29:            	cntr = 7;
30:            	do {
31:            		if(f1_as_plier & 1)
32:            			f3_as_product += f2_as_plicand;
33:            		f1_as_plier >>= 1;
34:            		f2_as_plicand <<= 1;
35:            	} while(--cntr != 0);
36:            	cntr = 9;
37:            	do {
38:            		if(f1_as_plier & 1)
39:            			f3_as_product += f2_as_plicand;
40:            		f1_as_plier >>= 1;
41:            		f3_as_product >>= 1;
42:            	} while(--cntr != 0);
43:            	__ftpack(&f3_as_product, exp1);
44:            	if(sign1)
45:            		f3_as_product |= 0x800000;
46:            	return f3;
47:            }
48:            #else
49:            #define	exp2	sign
50:            float
51:            __ftmul(float f1, float f2)
52:            {
53:            	unsigned char	exp, sign, cntr;
54:            	unsigned short long	f3_as_product;
55:            
56:            	if((exp = f1_as_plier >> 15) == 0)
1687  083D     MOVF f1, W
1688  00C3     MOVWF dow
1689  083E     MOVF 0x3E, W
168A  00C4     MOVWF a
168B  083F     MOVF 0x3F, W
168C  00C5     MOVWF dia
168D  1003     BCF STATUS, 0x0
168E  0D44     RLF a, W
168F  0D45     RLF dia, W
1690  00C6     MOVWF y
1691  08C6     MOVF y, F
1692  1D03     BTFSS STATUS, 0x2
1693  2E98     GOTO 0x698
57:            		return 0.0;
1694  01BD     CLRF f1
1695  01BE     CLRF 0x3E
1696  01BF     CLRF 0x3F
1697  0008     RETURN
58:            	if((exp2 = f2_as_plicand >> 15) == 0)
1698  0840     MOVF f2, W
1699  00C3     MOVWF dow
169A  0841     MOVF 0x41, W
169B  00C4     MOVWF a
169C  0842     MOVF m, W
169D  00C5     MOVWF dia
169E  1003     BCF STATUS, 0x0
169F  0D44     RLF a, W
16A0  0D45     RLF dia, W
16A1  00CB     MOVWF sign
16A2  08CB     MOVF sign, F
16A3  1D03     BTFSS STATUS, 0x2
16A4  2EA9     GOTO 0x6A9
59:            		return 0.0;
16A5  01BD     CLRF f1
16A6  01BE     CLRF 0x3E
16A7  01BF     CLRF 0x3F
16A8  0008     RETURN
60:            	exp += exp2-127-6;	// compute new exponent
16A9  084B     MOVF sign, W
16AA  3E7B     ADDLW 0x7B
16AB  07C6     ADDWF y, F
61:            	sign = f1_as_plier >> 16;
16AC  083F     MOVF 0x3F, W
16AD  00CB     MOVWF sign
62:            	sign ^= (unsigned char)(f2_as_plicand >> 16);
16AE  0842     MOVF m, W
16AF  06CB     XORWF sign, F
63:            	sign &= 0x80;
16B0  3080     MOVLW 0x80
16B1  05CB     ANDWF sign, F
64:            	f1_as_plier |= 0x8000UL;
16B3  17BE     BSF 0x3E, 0x7
65:            	//f1_as_plier &= 0xFFFFUL;		// not required
66:            	f2_as_plicand |= 0x8000UL;
16B4  17C1     BSF 0x41, 0x7
67:            	f2_as_plicand &= 0xFFFFUL;
16B5  01C2     CLRF m
68:            	f3_as_product = 0;
16B6  01C7     CLRF f
16B7  01C8     CLRF 0x48
16B8  01C9     CLRF 0x49
69:            	cntr = 7;
16B2  3007     MOVLW 0x7
16B9  00CA     MOVWF cntr
70:            	do {
71:            		if(f1_as_plier & 1)
16BA  1C3D     BTFSS f1, 0x0
16BB  2ECA     GOTO 0x6CA
72:            			f3_as_product += f2_as_plicand;
16BC  0840     MOVF f2, W
16BD  07C7     ADDWF f, F
16BE  0841     MOVF 0x41, W
16BF  1103     BCF STATUS, 0x2
16C0  1803     BTFSC STATUS, 0x0
16C1  0A41     INCF 0x41, W
16C2  1D03     BTFSS STATUS, 0x2
16C3  07C8     ADDWF 0x48, F
16C4  0842     MOVF m, W
16C5  1103     BCF STATUS, 0x2
16C6  1803     BTFSC STATUS, 0x0
16C7  0A42     INCF m, W
16C8  1D03     BTFSS STATUS, 0x2
16C9  07C9     ADDWF 0x49, F
73:            		f1_as_plier >>= 1;
16CA  1003     BCF STATUS, 0x0
16CB  0CBF     RRF 0x3F, F
16CC  0CBE     RRF 0x3E, F
16CD  0CBD     RRF f1, F
74:            		f2_as_plicand <<= 1;
16CE  1003     BCF STATUS, 0x0
16CF  0DC0     RLF f2, F
16D0  0DC1     RLF 0x41, F
16D1  0DC2     RLF m, F
75:            	} while(--cntr != 0);
16D2  0BCA     DECFSZ cntr, F
16D3  2EBA     GOTO 0x6BA
76:            	cntr = 9;
16D4  3009     MOVLW 0x9
16D5  00CA     MOVWF cntr
77:            	do {
78:            		if(f1_as_plier & 1)
16D6  1C3D     BTFSS f1, 0x0
16D7  2EE6     GOTO 0x6E6
79:            			f3_as_product += f2_as_plicand;
16D8  0840     MOVF f2, W
16D9  07C7     ADDWF f, F
16DA  0841     MOVF 0x41, W
16DB  1103     BCF STATUS, 0x2
16DC  1803     BTFSC STATUS, 0x0
16DD  0A41     INCF 0x41, W
16DE  1D03     BTFSS STATUS, 0x2
16DF  07C8     ADDWF 0x48, F
16E0  0842     MOVF m, W
16E1  1103     BCF STATUS, 0x2
16E2  1803     BTFSC STATUS, 0x0
16E3  0A42     INCF m, W
16E4  1D03     BTFSS STATUS, 0x2
16E5  07C9     ADDWF 0x49, F
80:            		f1_as_plier >>= 1;
16E6  1003     BCF STATUS, 0x0
16E7  0CBF     RRF 0x3F, F
16E8  0CBE     RRF 0x3E, F
16E9  0CBD     RRF f1, F
81:            		f3_as_product >>= 1;
16EA  1003     BCF STATUS, 0x0
16EB  0CC9     RRF 0x49, F
16EC  0CC8     RRF 0x48, F
16ED  0CC7     RRF f, F
82:            	} while(--cntr != 0);
16EE  0BCA     DECFSZ cntr, F
16EF  2ED6     GOTO 0x6D6
83:            	return __ftpack(f3_as_product, exp, sign);
16F0  0847     MOVF f, W
16F1  00A3     MOVWF x
16F2  0848     MOVF 0x48, W
16F3  00A4     MOVWF dato
16F4  0849     MOVF 0x49, W
16F5  00A5     MOVWF y
16F6  0846     MOVF y, W
16F7  00A6     MOVWF x
16F8  084B     MOVF sign, W
16F9  00A7     MOVWF i
16FA  27C2     CALL 0x7C2
16FB  0823     MOVF x, W
16FC  00BD     MOVWF f1
16FD  0824     MOVF dato, W
16FE  00BE     MOVWF 0x3E
16FF  0825     MOVF y, W
1700  00BF     MOVWF 0x3F
84:            }
1701  0008     RETURN
85:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/ftadd.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
11:            #define	f2_as_mant2	(*(unsigned short long *)&f2)
12:            
13:            // floating addition
14:            #ifdef _OLDLIB
15:            float
16:            __ftadd(float f1, float f2)
17:            {
18:            	unsigned char	exp1, exp2, sign1, sign2, cntr;
19:            	
20:            	if(sizeof(f1_as_mant1) != 3)
21:            		return 0;
22:            	sign1 = __ftunpack(&f1_as_mant1, &exp1);
23:            	if(exp1 == 0)
24:            		return f2;
25:            	sign2 = __ftunpack(&f2_as_mant2, &exp2);
26:            	if(exp2 != 0) {
27:            		cntr = 6;
28:            		// determine the smaller number. 
29:            		if(exp1 < exp2) {
30:            			if((unsigned char)(exp2-exp1) > sizeof(f1)*8) {
31:            				// return f2
32:            				f1_as_mant1 = 0;
33:            				exp1 = exp2;
34:            				sign1 = sign2;
35:            			} else {
36:            				// f1 has the smaller exponent - we can shift f2_as_mant2 up to 6 bits
37:            				// left, decrementing exp2.
38:            				do {
39:            					f2_as_mant2 <<= 1;
40:            					exp2--;
41:            				} while(exp2 != exp1 && --cntr != 0);
42:            				while(exp1 != exp2) {
43:            					f1_as_mant1 >>= 1;
44:            					exp1++;
45:            				}
46:            			}
47:            		} else if(exp1 != exp2) {
48:            			if((unsigned char)(exp1-exp2) > sizeof(f1)*8)
49:            				f2_as_mant2 = 0;
50:            			else {
51:            				// f2 has the smaller exponent - we can shift f1_as_mant1 up to 6 bits
52:            				// left, decrementing exp2.
53:            				do {
54:            					f1_as_mant1 <<= 1;
55:            					exp1--;
56:            				} while(exp2 != exp1 && --cntr != 0);
57:            				while(exp1 != exp2) {
58:            					f2_as_mant2 >>= 1;
59:            					exp2++;
60:            				}
61:            			}
62:            		}
63:            		if(sign1 != 0) { 
64:            			f1_as_mant1 ^= 0xFFFFFF;
65:            			f1_as_mant1++;
66:            		}
67:            		if(sign2 != 0) {
68:            			f2_as_mant2 ^= 0xFFFFFF;
69:            			f2_as_mant2++;
70:            		}
71:            		sign1 = 0;
72:            		f1_as_mant1 += f2_as_mant2;
73:            		if(f1_as_mant1 & 0x800000) {
74:            			f1_as_mant1 ^= 0xFFFFFF;
75:            			f1_as_mant1++;
76:            			sign1 = 1;
77:            		}
78:            	}
79:            	__ftpack(&f1_as_mant1, exp1);
80:            	if(sign1)
81:            		f1_as_mant1 ^= 0x800000;
82:            	return f1;
83:            }
84:            #else
85:            float
86:            __ftadd(float f1, float f2)
87:            {
88:            	unsigned char	exp1, exp2, sign;
89:            
90:            	exp1 = f1_as_mant1 >> 15;
1702  082B     MOVF sec, W
1703  00B1     MOVWF divisor
1704  082C     MOVF hr, W
1705  00B2     MOVWF 0x32
1706  082D     MOVF day, W
1707  00B3     MOVWF dividend
1708  1003     BCF STATUS, 0x0
1709  0D32     RLF 0x32, W
170A  0D33     RLF dividend, W
170B  00B6     MOVWF sign
91:            	exp2 = f2_as_mant2 >> 15;
170C  082E     MOVF sign, W
170D  00B1     MOVWF divisor
170E  082F     MOVF quotient, W
170F  00B2     MOVWF 0x32
1710  0830     MOVF c, W
1711  00B3     MOVWF dividend
1712  1003     BCF STATUS, 0x0
1713  0D32     RLF 0x32, W
1714  0D33     RLF dividend, W
1715  00B5     MOVWF counter
92:            	if(exp1 == 0 || exp1 < exp2  && (unsigned char)(exp2-exp1) > sizeof(f1)*8)
1716  0836     MOVF sign, W
1717  1903     BTFSC STATUS, 0x2
1718  2F25     GOTO 0x725
1719  0835     MOVF counter, W
171A  0236     SUBWF sign, W
171B  0835     MOVF counter, W
171C  1803     BTFSC STATUS, 0x0
171D  2F2D     GOTO 0x72D
171E  00B1     MOVWF divisor
171F  0836     MOVF sign, W
1720  02B1     SUBWF divisor, F
1721  3019     MOVLW 0x19
1722  0231     SUBWF divisor, W
1723  1C03     BTFSS STATUS, 0x0
1724  2F2C     GOTO 0x72C
93:            		return f2;
1725  082E     MOVF sign, W
1726  00AB     MOVWF sec
1727  082F     MOVF quotient, W
1728  00AC     MOVWF hr
1729  0830     MOVF c, W
172A  00AD     MOVWF day
172B  0008     RETURN
94:            	if(exp2 == 0 || exp1 > exp2  && (unsigned char)(exp1-exp2) > sizeof(f1)*8)
172C  0835     MOVF counter, W
172D  1903     BTFSC STATUS, 0x2
172E  0008     RETURN
172F  0836     MOVF sign, W
1730  0235     SUBWF counter, W
1731  1803     BTFSC STATUS, 0x0
1732  2F3B     GOTO 0x73B
1733  0836     MOVF sign, W
1734  00B1     MOVWF divisor
1735  0835     MOVF counter, W
1736  02B1     SUBWF divisor, F
1737  3019     MOVLW 0x19
1738  0231     SUBWF divisor, W
1739  1803     BTFSC STATUS, 0x0
173A  0008     RETURN
95:            		return f1;
96:            	sign = 6;
173B  3006     MOVLW 0x6
173C  00B4     MOVWF sign
97:            	if(f1_as_mant1 & 0x800000L)
173D  1BAD     BTFSC day, 0x7
98:            		sign |= 0x80;
173E  17B4     BSF sign, 0x7
99:            	if(f2_as_mant2 & 0x800000L)
173F  1BB0     BTFSC c, 0x7
100:           		sign |= 0x40;
1740  1734     BSF sign, 0x6
101:           	f1_as_mant1 |= 0x8000UL;
1741  17AC     BSF hr, 0x7
102:           	f1_as_mant1 &= 0xFFFFUL;
1742  01AD     CLRF day
103:           	f2_as_mant2 |= 0x8000UL;
1743  17AF     BSF quotient, 0x7
104:           	f2_as_mant2 &= 0xFFFFUL;
1744  01B0     CLRF c
105:           	// determine the smaller number. 
106:           	if(exp1 < exp2) {
1745  0835     MOVF counter, W
1746  0236     SUBWF sign, W
1747  1803     BTFSC STATUS, 0x0
1748  2F62     GOTO 0x762
107:           		// f1 has the smaller exponent - we can shift f2_as_mant2 up to 6 bits
108:           		// left, decrementing exp2.
109:           		do {
110:           			f2_as_mant2 <<= 1;
1749  1003     BCF STATUS, 0x0
174A  0DAE     RLF sign, F
174B  0DAF     RLF quotient, F
174C  0DB0     RLF c, F
111:           			exp2--;
174D  03B5     DECF counter, F
112:           		} while(exp2 != exp1 && --sign & 7);
174E  0835     MOVF counter, W
174F  0636     XORWF sign, W
1750  1903     BTFSC STATUS, 0x2
1751  2F5D     GOTO 0x75D
1752  03B4     DECF sign, F
1753  0834     MOVF sign, W
1754  3907     ANDLW 0x7
1755  1903     BTFSC STATUS, 0x2
1756  2F5D     GOTO 0x75D
1757  2F49     GOTO 0x749
113:           		while(exp1 != exp2) {
175D  0836     MOVF sign, W
175E  0635     XORWF counter, W
175F  1903     BTFSC STATUS, 0x2
1760  2F7E     GOTO 0x77E
1761  2F58     GOTO 0x758
114:           			f1_as_mant1 >>= 1;
1758  1003     BCF STATUS, 0x0
1759  0CAD     RRF day, F
175A  0CAC     RRF hr, F
175B  0CAB     RRF sec, F
115:           			exp1++;
175C  0AB6     INCF sign, F
116:           		}
117:           	} else if(exp1 > exp2) {
1762  0836     MOVF sign, W
1763  0235     SUBWF counter, W
1764  1803     BTFSC STATUS, 0x0
1765  2F7E     GOTO 0x77E
118:           		// f2 has the smaller exponent - we can shift f1_as_mant1 up to 6 bits
119:           		// left, decrementing exp2.
120:           		do {
121:           			f1_as_mant1 <<= 1;
1766  1003     BCF STATUS, 0x0
1767  0DAB     RLF sec, F
1768  0DAC     RLF hr, F
1769  0DAD     RLF day, F
122:           			exp1--;
176A  03B6     DECF sign, F
123:           		} while(exp2 != exp1 && --sign & 7);
176B  0835     MOVF counter, W
176C  0636     XORWF sign, W
176D  1903     BTFSC STATUS, 0x2
176E  2F7A     GOTO 0x77A
176F  03B4     DECF sign, F
1770  0834     MOVF sign, W
1771  3907     ANDLW 0x7
1772  1903     BTFSC STATUS, 0x2
1773  2F7A     GOTO 0x77A
1774  2F66     GOTO 0x766
124:           		while(exp1 != exp2) {
177A  0836     MOVF sign, W
177B  0635     XORWF counter, W
177C  1D03     BTFSS STATUS, 0x2
177D  2F75     GOTO 0x775
125:           			f2_as_mant2 >>= 1;
1775  1003     BCF STATUS, 0x0
1776  0CB0     RRF c, F
1777  0CAF     RRF quotient, F
1778  0CAE     RRF sign, F
126:           			exp2++;
1779  0AB5     INCF counter, F
127:           		}
128:           	}
129:           	if(sign & 0x80) { 
177E  1FB4     BTFSS sign, 0x7
177F  2F89     GOTO 0x789
130:           		// complement and add 1
131:           		f1_as_mant1 ^= 0xFFFFFFUL;
1780  30FF     MOVLW 0xFF
1781  06AB     XORWF sec, F
1782  06AC     XORWF hr, F
1783  06AD     XORWF day, F
132:           		f1_as_mant1++;
1784  0AAB     INCF sec, F
1785  1903     BTFSC STATUS, 0x2
1786  0AAC     INCF hr, F
1787  1903     BTFSC STATUS, 0x2
1788  0AAD     INCF day, F
133:           	}
134:           	if(sign & 0x40) {
1789  1F34     BTFSS sign, 0x6
178A  2F94     GOTO 0x794
135:           		// complement and add 1
136:           		f2_as_mant2 ^= 0xFFFFFFUL;
178B  30FF     MOVLW 0xFF
178C  06AE     XORWF sign, F
178D  06AF     XORWF quotient, F
178E  06B0     XORWF c, F
137:           		f2_as_mant2++;
178F  0AAE     INCF sign, F
1790  1903     BTFSC STATUS, 0x2
1791  0AAF     INCF quotient, F
1792  1903     BTFSC STATUS, 0x2
1793  0AB0     INCF c, F
138:           	}
139:           	sign = 0;
1794  01B4     CLRF sign
140:           	f2_as_mant2 += f1_as_mant1;
1795  082B     MOVF sec, W
1796  07AE     ADDWF sign, F
1797  082C     MOVF hr, W
1798  1103     BCF STATUS, 0x2
1799  1803     BTFSC STATUS, 0x0
179A  0A2C     INCF hr, W
179B  1D03     BTFSS STATUS, 0x2
179C  07AF     ADDWF quotient, F
179D  082D     MOVF day, W
179E  1103     BCF STATUS, 0x2
179F  1803     BTFSC STATUS, 0x0
17A0  0A2D     INCF day, W
17A1  1D03     BTFSS STATUS, 0x2
17A2  07B0     ADDWF c, F
141:           	if(f2_as_mant2 & 0x800000UL) {
17A3  1FB0     BTFSS c, 0x7
17A4  2FB0     GOTO 0x7B0
142:           		f2_as_mant2 ^= 0xFFFFFFUL;
17A5  30FF     MOVLW 0xFF
17A6  06AE     XORWF sign, F
17A7  06AF     XORWF quotient, F
17A8  06B0     XORWF c, F
143:           		f2_as_mant2++;
17A9  0AAE     INCF sign, F
17AA  1903     BTFSC STATUS, 0x2
17AB  0AAF     INCF quotient, F
17AC  1903     BTFSC STATUS, 0x2
17AD  0AB0     INCF c, F
144:           		sign = 1;
17AE  01B4     CLRF sign
17AF  0AB4     INCF sign, F
145:           	}
146:           	return __ftpack(f2_as_mant2, exp1, sign);
17B0  082E     MOVF sign, W
17B1  00A3     MOVWF x
17B2  082F     MOVF quotient, W
17B3  00A4     MOVWF dato
17B4  0830     MOVF c, W
17B5  00A5     MOVWF y
17B6  0836     MOVF sign, W
17B7  00A6     MOVWF x
17B8  0834     MOVF sign, W
17B9  00A7     MOVWF i
17BA  27C2     CALL 0x7C2
17BB  0823     MOVF x, W
17BC  00AB     MOVWF sec
17BD  0824     MOVF dato, W
17BE  00AC     MOVWF hr
17BF  0825     MOVF y, W
17C0  00AD     MOVWF day
147:           
148:           }
17C1  0008     RETURN
149:           #endif
---  /opt/microchip/xc8/v1.31/sources/common/float.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             #include	"ftarith.h"
7:             
8:             
9:             //	unpack the operand pointed to. Store the exponent into the location pointed to by exp,
10:            //	and return the sign (zero is positive)
11:            
12:            #ifdef _OLDLIB
13:            
14:            unsigned char
15:            __ftunpack(unsigned short long * arg, unsigned char * exp)
16:            {
17:            	unsigned char	sign;
18:            
19:            	*exp = sign = *arg >> 15;
20:            	if(sign == 0) {
21:            		*arg = 0;
22:            		return 0;
23:            	}
24:            	sign = 0;
25:            	*arg |= 0x8000;
26:            	if(*arg & 0x800000)
27:            		sign++;
28:            	*arg &= 0xFFFF;
29:            	return sign;
30:            }
31:            
32:            // normalize and pack the supplied argument into floating point format
33:            
34:            void
35:            __ftpack(unsigned short long * arg, unsigned char exp)
36:            {
37:            	if(exp == 0 || *arg == 0) {
38:            		*arg = 0;
39:            		return;
40:            	}
41:            	while(*arg & 0xFE0000UL) {
42:            		exp++;
43:            		*arg >>= 1;
44:            	}
45:            	while(*arg & 0xFF0000UL) {
46:            		exp++;
47:            		(*arg)++;
48:            		*arg >>= 1;
49:            	}
50:            	while(!(*arg & 0x8000UL)) {
51:            		exp--;
52:            		*arg <<= 1;
53:            	}
54:            	if(!(exp & 1))
55:            		*arg &= ~0x8000L;
56:            	exp >>= 1;
57:            	*arg |= (unsigned short long)exp << 16;
58:            }
59:            
60:            #else
61:            float
62:            __ftpack(unsigned short long arg, unsigned char exp, unsigned char sign)
63:            {
64:            	if(exp == 0 || arg == 0)
17C2  0826     MOVF x, W
17C3  1903     BTFSC STATUS, 0x2
17C4  2FCA     GOTO 0x7CA
17C5  0825     MOVF y, W
17C6  0424     IORWF dato, W
17C7  0423     IORWF x, W
17C8  1D03     BTFSS STATUS, 0x2
17C9  2FD3     GOTO 0x7D3
65:            		return 0.0;
17CA  01A3     CLRF x
17CB  01A4     CLRF dato
17CC  01A5     CLRF y
17CD  0008     RETURN
66:            	while(arg & 0xFE0000UL) {
17D3  30FE     MOVLW 0xFE
17D4  0525     ANDWF y, W
17D5  1903     BTFSC STATUS, 0x2
17D6  2FE2     GOTO 0x7E2
17D7  2FCE     GOTO 0x7CE
67:            		exp++;
17CE  0AA6     INCF x, F
68:            		arg >>= 1;
17CF  1003     BCF STATUS, 0x0
17D0  0CA5     RRF y, F
17D1  0CA4     RRF dato, F
17D2  0CA3     RRF x, F
69:            	}
70:            	while(arg & 0xFF0000UL) {
17E2  30FF     MOVLW 0xFF
17E3  0525     ANDWF y, W
17E4  1903     BTFSC STATUS, 0x2
17E5  2FEC     GOTO 0x7EC
17E6  2FD8     GOTO 0x7D8
71:            		exp++;
17D8  0AA6     INCF x, F
72:            		(arg)++;
17D9  0AA3     INCF x, F
17DA  1903     BTFSC STATUS, 0x2
17DB  0AA4     INCF dato, F
17DC  1903     BTFSC STATUS, 0x2
17DD  0AA5     INCF y, F
73:            		arg >>= 1;
17DE  1003     BCF STATUS, 0x0
17DF  0CA5     RRF y, F
17E0  0CA4     RRF dato, F
17E1  0CA3     RRF x, F
74:            	}
75:            	while(!(arg & 0x8000UL)) {
17EC  1FA4     BTFSS dato, 0x7
17ED  2FE7     GOTO 0x7E7
76:            		exp--;
17E7  03A6     DECF x, F
77:            		arg <<= 1;
17E8  1003     BCF STATUS, 0x0
17E9  0DA3     RLF x, F
17EA  0DA4     RLF dato, F
17EB  0DA5     RLF y, F
78:            	}
79:            	if(!(exp & 1))
17EE  1C26     BTFSS x, 0x0
80:            		arg &= ~0x8000L;
17EF  13A4     BCF dato, 0x7
81:            	exp >>= 1;
17F0  1003     BCF STATUS, 0x0
17F1  0CA6     RRF x, F
82:            	arg |= (unsigned short long)exp << 16;
17F2  0826     MOVF x, W
17F3  00AA     MOVWF Data
17F4  01A9     CLRF year
17F5  01A8     CLRF mth
17F6  0828     MOVF mth, W
17F7  04A3     IORWF x, F
17F8  0829     MOVF year, W
17F9  04A4     IORWF dato, F
17FA  082A     MOVF Data, W
17FB  04A5     IORWF y, F
83:            	if (sign)
17FC  0827     MOVF i, W
17FD  1D03     BTFSS STATUS, 0x2
84:            		arg |= 0x800000UL;
17FE  17A5     BSF y, 0x7
85:               return *(float*)&arg;	
86:            }
17FF  0008     RETURN
87:            
88:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/doprnt.c  --------------------------------------------------
1:             #include	<stdio.h>
2:             #include	<ctype.h>
3:             #include	<stdlib.h>
4:             #include	<string.h>
5:             #include	<stdarg.h>
6:             #include	<conio.h>
7:             #include	<sys.h>
8:             #include	<math.h>
9:             #include	<float.h>
10:            
11:            // disable unused variable warnings
12:            // the compiler will optimize them away, so no harm is done
13:            #pragma warning disable 350
14:            
15:            /*
16:             *	doprnt - versions depends on conditional compilation.
17:             *	Can be customized with defines.
18:             *
19:             *	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
20:             *
21:             *	$Header$
22:             *
23:             */
24:            
25:            #ifndef	CUSTOM_PRINTF
26:            
27:             // define all flags, thus enabling all features
28:            
29:            #define	BASEM	0xC0
30:            #define	OPTSIGN	0x00
31:            #define	SPCSIGN	0x01
32:            #define	MANSIGN	0x02
33:            #define	NEGSIGN	0x03
34:            #define	FILL	0x04
35:            #define	LEFT	0x08
36:            #define	LONG	0x10
37:            #define	UPCASE	0x20
38:            #define	TEN		0x00
39:            #define	EIGHT	0x40
40:            #define	SIXTEEN	0x80
41:            #define	UNSIGN	0xC0
42:            #ifdef	__FLOAT
43:            #define	EFMT	0x100
44:            #define	GFMT	0x200
45:            #define	FFMT	0x400
46:            #endif	// __FLOAT
47:            #define	ALTERN	0x800
48:            #define POINTER	0x2000
49:            #define HEXUPCASE
50:            #define HEXLOWCASE
51:            
52:             // defines for ifdef only, not used as flags
53:            #define	WIDTH	1		// width used
54:            #define	STAR	1		// width or precision as an arg
55:            #define	STRING	1		// %s used
56:            #define	CHAR	1		// %c used
57:            #define	PERCPERC	1	// %% used
58:            #define	SPRINTF	1		// sprintf is used
59:            #define	PRINTF	1		// printf is used
60:            #define	MULTRAD	1		// handle multiple radices
61:            #define	RETVALUE	1	// return value is needed
62:            
63:            #else	// CUSTOM_PRINTF
64:            
65:            #if	defined(HEXUPCASE) || defined(HEXLOWCASE)
66:            #define	SIXTEEN
67:            #endif
68:            
69:            #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
70:            #ifndef UPCASE
71:            #define	UPCASE
72:            #endif
73:            #endif
74:            
75:             // make sure we have the right values for each define
76:            #ifdef	OPTSIGN
77:            #undef	OPTSIGN
78:            #define	OPTSIGN	0x00
79:            #endif
80:            #ifdef	SPCSIGN
81:            #undef	SPCSIGN
82:            #define	SPCSIGN	0x01
83:            #endif
84:            #ifdef	MANSIGN
85:            #undef	MANSIGN
86:            #define	MANSIGN	0x02
87:            #define	SPCSIGN	0x01
88:            #endif
89:            #ifdef	NEGSIGN
90:            #undef	NEGSIGN
91:            #define	NEGSIGN	0x03
92:            #endif
93:            #ifdef	FILL
94:            #define	WIDTH	1
95:            #undef	FILL
96:            #define	FILL	0x04
97:            #endif
98:            #ifdef	LEFT
99:            #undef	LEFT
100:            // LEFT without WIDTH is meaningless
101:           #ifdef	WIDTH
102:           #define	LEFT	0x08
103:           #endif
104:           #endif
105:           #ifdef	LONG
106:           #undef	LONG
107:           #define	LONG	0x10
108:           #define	__LONG	1
109:           #endif
110:           #ifdef	UPCASE
111:           #undef	UPCASE
112:           #define	UPCASE	0x20
113:           #endif
114:           #ifdef	TEN	
115:           #undef	TEN	
116:           #define	TEN		0x00
117:           #endif
118:           #ifdef	EIGHT
119:           #undef	EIGHT
120:           #define	EIGHT	0x40
121:           #endif
122:           #ifdef	SIXTEEN
123:           #undef	SIXTEEN
124:           #define	SIXTEEN	0x80
125:           #endif
126:           #ifdef	UNSIGN
127:           #undef	UNSIGN
128:           #define	UNSIGN	0xC0
129:           #endif
130:           #ifdef	EFMT
131:           #undef	EFMT
132:           #define	EFMT	0x100
133:           #endif
134:           #ifdef	GFMT
135:           #undef	GFMT
136:           #define	GFMT	0x200
137:           #endif
138:           #ifdef	FFMT
139:           #undef	FFMT
140:           #define	FFMT	0x400
141:           #endif
142:           #ifdef	ALTERN
143:           #undef	ALTERN
144:           #define	ALTERN	0x800
145:           #endif
146:           #ifdef	POINTER
147:           #undef	POINTER
148:           #define POINTER	0x2000
149:           #ifndef	SIXTEEN
150:           #define	SIXTEEN	0x80
151:           #endif
152:           #endif
153:           #ifdef	PRECISION
154:           #undef	PRECISION
155:           #define PRECISION	0x4000
156:           #endif
157:           
158:           #if	defined(TEN) && !defined(EIGHT) && !defined(SIXTEEN) && defined(UNSIGN)
159:           #undef	UNSIGN
160:           #define	UNSIGN	0x40
161:           #define	BASEM	UNSIGN
162:           #endif
163:           #if	defined(UNSIGN) && (defined(EIGHT) || defined(SIXTEEN))
164:           #define	MULTRAD	1
165:           #define	BASEM	(UNSIGN)
166:           #endif
167:           #if	defined(TEN) && !defined(SIXTEEN) && defined(EIGHT) && !defined(UNSIGN)
168:           #define	BASEM	EIGHT
169:           #define	MULTRAD	1
170:           #endif
171:           #if	defined(TEN) && defined(SIXTEEN) && !defined(EIGHT) && !defined(UNSIGN)
172:           #define	BASEM	SIXTEEN
173:           #define	MULTRAD	1
174:           #endif
175:           #if	defined(SIXTEEN) && defined(EIGHT) && !defined(BASEM)
176:           #define	BASEM	(SIXTEEN|EIGHT)
177:           #define	MULTRAD	1
178:           #endif
179:           
180:           #endif
181:           
182:            // float code needs these flags
183:           #if	defined(EFMT) || defined(GFMT) || defined(FFMT)
184:           #ifndef	__FLOAT
185:           #define	__FLOAT	1
186:           #endif
187:           #define	FLOATFORMAT	0x700
188:           #ifdef	PRECISION
189:           #define	DEFPREC	0x1000
190:           #endif
191:           #endif
192:           
193:           #ifdef	__FLOAT
194:           //#ifndef	MANSIGN
195:           //#define	MANSIGN	0x02
196:           //#endif
197:           //#ifndef	SPCSIGN
198:           //#define	SPCSIGN	0x01
199:           //#endif
200:           #ifndef	NEGSIGN
201:           #define	NEGSIGN	0x03
202:           #endif
203:           //#ifndef	WIDTH
204:           //#define	WIDTH	1
205:           //#endif
206:           #endif
207:           
208:           #ifdef	SPCSIGN
209:           #define	putsign()	pputc(flag & SPCSIGN ? '-' : '+')
210:           #else
211:           #define	putsign()	pputc('-')
212:           #endif	// SPCSIGN
213:           
214:           // were there ANY % formats defined?
215:           #if	defined(FLOATFORMAT) || defined(TEN) || defined(EIGHT) || defined(SIXTEEN) || \
216:           	defined(CHAR) || defined(POINTER) || defined(STRING) || defined(UNSIGN) || defined(PERCPERC)
217:           #define	ANYFORMAT
218:           #else
219:           #undef	ANYFORMAT
220:           #endif
221:           
222:           #ifdef	CHAR
223:           #ifndef	PERCPERC
224:           #define	PERCPERC
225:           #endif
226:           #endif
227:           
228:           #if	!defined(PRINTF) && !defined(VPRINTF) && !defined(SPRINTF) && !defined(VSPRINTF)
229:           #error	Must define at least one of PRINTF SPRINTF or VSPRINTF
230:           #endif
231:           
232:           #if	i8086 && SMALL_DATA
233:           #define	CONST	far
234:           #else
235:           #define	CONST	const
236:           #endif
237:           
238:            /* we don't need plus signs, use minus signs only if we have floats or signed ints */
239:           
240:           #if	!defined(NEGSIGN) && defined(TEN)
241:           #define	NEGSIGN	0x03
242:           #endif
243:           
244:           #ifndef	RETVALUE
245:           #define	INCR_CNT	/*nix */
246:           #else
247:           #define	INCR_CNT	,(++ccnt)
248:           #endif
249:           
250:           #if	defined(EFMT) || defined(GFMT) || defined(FFMT) || defined(ALTERN) || defined(DEFPREC) || defined(POINTER)
251:           #define	FLAG_SIZE	unsigned short
252:           #else
253:           #define	FLAG_SIZE	unsigned char
254:           #endif
255:           
256:           
257:           #if	(sizeof(long) == sizeof(int) || defined(__FLOAT)) && !defined(__LONG)
258:           #define	__LONG	1
259:           #endif
260:           
261:           #if	sizeof(double) == sizeof(long) && DBL_MAX_EXP == 128
262:           #undef	frexp
263:           #define	frexp(val, ptr) (void)(*(ptr) = (unsigned char)((*(unsigned long *)&val >> 23) & 255) - 126)
264:           #elif	defined(_PSOC_)
265:           #undef	frexp
266:           #define	frexp(val, ptr) (void)(*(ptr) = ((unsigned char)(*(unsigned short long *)&val >> 15)) - 126)
267:           #elif	sizeof(double) == 3 && DBL_MAX_EXP == 128
268:           #undef	frexp
269:           #define	frexp(val, ptr) (void)(*(ptr) = ((*(unsigned long *)&val >> 15) & 255) - 126)
270:           #endif
271:           
272:           #if	defined(__FLOAT) && sizeof(double) == 8
273:           #define	DOUBLE	1
274:           
275:           extern double	_dto64i(double);
276:           extern double	_64itod(double);
277:           extern double	_div64(double, double);
278:           extern double	_divto64i(double, double);
279:           extern unsigned	_div64ir(double, double);
280:           extern unsigned	_mod64i10(double);
281:           
282:           #else
283:           #define	DOUBLE	0
284:           #endif
285:           
286:           #ifdef	__LONG
287:           #define	value	long
288:           #define	NDIG	12		/* max number of digits to be printed */
289:           #else
290:           #define	value	int
291:           #define	NDIG	6		/* max number of digits to be printed */
292:           #endif
293:           
294:           #if	DOUBLE
295:           union {
296:           	unsigned long	ul[40];
297:           	double		db[20];
298:           }	_fdp =
299:           {
300:           #if	!defined(BIG_ENDIAN) && !defined(LITTLE_ENDIAN)
301:           #error Neither BIG_ENDIAN or LITTLE_ENDIAN has been set
302:           #endif
303:           #if	BIG_ENDIAN
304:           	0x00000000,0x00000001,
305:           	0x00000000,0x0000000A,
306:           	0x00000000,0x00000064,
307:           	0x00000000,0x000003E8,
308:           	0x00000000,0x00002710,
309:           	0x00000000,0x000186A0,
310:           	0x00000000,0x000F4240,
311:           	0x00000000,0x00989680,
312:           	0x00000000,0x05F5E100,
313:           	0x00000000,0x3B9ACA00,
314:           	0x00000002,0x540BE400,
315:           	0x00000017,0x4876E800,
316:           	0x000000E8,0xD4A51000,
317:           	0x00000918,0x4E72A000,
318:           	0x00005AF3,0x107A4000,
319:           	0x00038D7E,0xA4C68000,
320:           	0x002386F2,0x6FC10000,
321:           	0x01634578,0x5D8A0000,
322:           	0x0DE0B6B3,0xA7640000,
323:           	0x8AC72304,0x89E80000,
324:           #else
325:           	0x00000001,0x00000000,
326:           	0x0000000A,0x00000000,
327:           	0x00000064,0x00000000,
328:           	0x000003E8,0x00000000,
329:           	0x00002710,0x00000000,
330:           	0x000186A0,0x00000000,
331:           	0x000F4240,0x00000000,
332:           	0x00989680,0x00000000,
333:           	0x05F5E100,0x00000000,
334:           	0x3B9ACA00,0x00000000,
335:           	0x540BE400,0x00000002,
336:           	0x4876E800,0x00000017,
337:           	0xD4A51000,0x000000E8,
338:           	0x4E72A000,0x00000918,
339:           	0x107A4000,0x00005AF3,
340:           	0xA4C68000,0x00038D7E,
341:           	0x6FC10000,0x002386F2,
342:           	0x5D8A0000,0x01634578,
343:           	0xA7640000,0x0DE0B6B3,
344:           	0x89E80000,0x8AC72304,
345:           #endif
346:           };
347:           
348:           #define	fdpowers	_fdp.db
349:           
350:           #else
351:           #define	fdpowers	dpowers
352:           #endif
353:           #if defined(TEN) || defined(__FLOAT) || defined (UNSIGN)
354:           const static unsigned value	dpowers[] =	{1, 10, 100, 1000, 10000,
355:           #ifdef	__LONG
356:           						 100000, 1000000, 10000000, 100000000,
357:           						 1000000000
358:           #endif
359:           							 };
360:           #endif
361:           #ifdef	SIXTEEN
362:           const static unsigned value	hexpowers[] =	{1, 0x10, 0x100, 0x1000,
363:           #if	__LONG
364:           						 0x10000, 0x100000, 0x1000000, 0x10000000
365:           #endif
366:           							};
367:           #endif
368:           #ifdef	EIGHT
369:           const static unsigned value	octpowers[] =	{1, 010, 0100, 01000, 010000, 0100000,
370:           #ifdef	__LONG
371:           						01000000,
372:           						 010000000, 0100000000, 01000000000, 010000000000,
373:           						 0100000000000
374:           #endif
375:           							};
376:           #endif
377:           
378:           #ifdef	__FLOAT
379:           
380:           #define	NDDIG	(sizeof fdpowers/sizeof fdpowers[0])
381:           
382:           #if	DBL_MAX_10_EXP > 120
383:           #define	expon	int
384:           #else
385:           #define	expon	signed char
386:           #endif
387:           
388:           extern const double	_powers_[], _npowers_[];
389:           #ifdef	z80
390:           #define	_div_to_l_(a, b)	((unsigned long)((a)/(b)))
391:           #else
392:           extern unsigned long	_div_to_l_(double, double);
393:           #ifdef	_OMNI_CODE_
394:           extern unsigned long	_tdiv_to_l_(float, float);
395:           #ifdef	_HTKC_
396:           #pragma callname _div_to_l_ double
397:           #pragma callname _tdiv_to_l_ float
398:           #endif
399:           #define	div_to_l_(a,b)	((sizeof(double)== 3) ? _tdiv_to_l_(a,b) : _div_to_l_(a,b))
400:           #else
401:           #define	div_to_l_	_div_to_l_
402:           #endif
403:           #endif
404:           
405:           /* this routine returns a value to round to the number of decimal
406:           	places specified */
407:           #if __FLOAT
408:           static double
409:           fround(unsigned char prec)
410:           {
411:           	/* prec is guaranteed to be less than NDIG */
412:           
413:           	if(prec>=110)
414:           		return 0.5 * _npowers_[prec/100+18] * _npowers_[(prec%100)/10+9] * _npowers_[prec%10];
415:           	else if(prec > 10)
416:           		return 0.5 * _npowers_[prec/10+9] * _npowers_[prec%10];
417:           	return 0.5 * _npowers_[prec];
418:           }
419:           #endif
420:           
421:           /* this routine returns a scaling factor equal to 1 to the decimal
422:              power supplied */
423:           
424:           static double
425:           scale(expon scl)
426:           {
427:           
428:           	if(scl < 0) {
429:           		scl = -scl;
430:           		if(scl>=110)
431:           			return _npowers_[scl/100+18] * _npowers_[(scl%100)/10+9] * _npowers_[scl%10];
432:           		else if(scl > 10)
433:           			return _npowers_[scl/10+9] * _npowers_[scl%10];
434:           		return _npowers_[scl];
435:           	}
436:           	if(scl>=110)
437:           		return _powers_[scl/100+18] * _powers_[(scl%100)/10+9] * _powers_[scl%10];
438:           	else if(scl > 10)
439:           		return _powers_[scl/10+9] * _powers_[scl%10];
440:           	return _powers_[scl];
441:           }
442:           
443:           
444:           #endif	/* __FLOAT */
445:           
446:           
447:           
448:           #ifdef	_HOSTED
449:           #define	pputc(c)	(putc(c, fp) != EOF && ++ccnt)
450:           int
451:           vfprintf(FILE * fp, register const  char * f, register va_list ap)
452:           {
453:           	char		cbuf[2];
454:           #else	/* _HOSTED */
455:           int
456:           #if	defined(VPRINTF) || (defined(PRINTF) && (defined(SPRINTF) || defined(VSPRINTF)))
457:           #define	pputc(c)	if(pb->func) (pb->func(c))INCR_CNT; else ((*pb->ptr++ = c)INCR_CNT)
458:           _doprnt(struct __prbuf * pb, register const  char * f, register va_list ap)
459:           {
460:           #endif
461:           
462:           #if	defined(PRINTF) && !(defined(SPRINTF) || defined(VSPRINTF))
463:           #define	pputc(c)	(putch(c) INCR_CNT)
464:           printf(const char * f, ...)
465:           {
466:           	va_list	ap;
467:           #define	NEED_START
468:           #endif
469:           
470:           #if	!defined(PRINTF) && defined(VSPRINTF)
471:           
472:           #ifdef	SPRINTF
473:           sprintf(char * sp, const char * f, ...)
474:           {
475:           	va_list	ap;
476:           
477:           	va_start(ap, f);
478:           	vsprintf(sp, f, ap);
479:           	va_end(ap);
480:           }
481:           int
482:           #endif	// SPRINTF
483:           
484:           #define	pputc(c)	((*sp++ = (c))INCR_CNT)
485:           vsprintf(char * sp, register const  char * f, register va_list ap)
486:           {
487:           #define NEED_START
488:           #endif	// VSPRINTF
489:           
490:           #if	!defined(PRINTF) && defined(SPRINTF) && !defined(VSPRINTF)
491:           #define	pputc(c)	((*sp++ = (c))INCR_CNT)
492:           sprintf(char * sp, const  char * f, ...)
05BE  00DB     MOVWF sp
493:           {
494:           	va_list	ap;
495:           #define	NEED_START
496:           #endif
497:           #endif	// HOSTED
498:           
499:           	signed char		c;
500:           #if	defined(WIDTH) || defined(__FLOAT)
501:           	int		width;
502:           #endif
503:           #ifdef	__LONG
504:           	int		prec;
505:           #else
506:           	signed char	prec;
507:           #endif
508:           	FLAG_SIZE	flag;
509:           #ifdef	RETVALUE
510:           	int		ccnt = 0;
511:           #else
512:           #define	ccnt	0
513:           #endif
514:           #ifdef	__FLOAT
515:           	char	d;
516:           	double	fval, integ;
517:           	int		exp;
518:           	double		ival;
519:           	union {
520:           		unsigned value	_val;
521:           		struct {
522:           		    CONST char *	_cp;
523:           		    unsigned	_len;
524:           		}		_str;
525:           	}		_val;
526:           #else	// __FLOAT
527:           	union {
528:           		unsigned value	_val;
529:           		struct {
530:           		    CONST char *	_cp;
531:           		    unsigned	_len;
532:           		}		_str;
533:           	}		_val;
534:           #endif	// __FLOAT
535:           
536:           #define	val	_val._val
537:           #define	cp	_val._str._cp
538:           #define	len	_val._str._len
539:           
540:           	
541:           #ifdef	NEED_START
542:           	va_start(ap, f);
05BF  3049     MOVLW 0x49
05C0  00D3     MOVWF ap
543:           #endif
544:           
545:           	while(c = *f++) {
05C1  0848     MOVF 0x48, W
05C2  00D0     MOVWF 0x50
05C3  0847     MOVF f, W
05C4  00CF     MOVWF f1
05C5  0AC7     INCF f, F
05C6  1903     BTFSC STATUS, 0x2
05C7  0AC8     INCF 0x48, F
05C8  0850     MOVF 0x50, W
05C9  00FF     MOVWF 0x7F
05CA  084F     MOVF f1, W
05CB  0084     MOVWF FSR
05CC  160A     BSF PCLATH, 0x4
05CD  158A     BSF PCLATH, 0x3
05CE  2000     CALL 0x0
05CF  120A     BCF PCLATH, 0x4
05D0  118A     BCF PCLATH, 0x3
05D1  00DA     MOVWF c
05D2  08DA     MOVF c, F
05D3  1903     BTFSC STATUS, 0x2
05D4  2F71     GOTO 0x771
0770  2DC1     GOTO 0x5C1
546:           #ifdef	ANYFORMAT
547:           		if(c != '%')
05D5  085A     MOVF c, W
05D6  3A25     XORLW 0x25
05D7  1903     BTFSC STATUS, 0x2
05D8  2DE0     GOTO 0x5E0
548:           #endif	//ANYFORMAT
549:           		{
550:           			pputc(c);
05D9  085B     MOVF sp, W
05DA  0084     MOVWF FSR
05DB  085A     MOVF c, W
05DC  1383     BCF STATUS, 0x7
05DD  0080     MOVWF INDF
05DE  0ADB     INCF sp, F
551:           			continue;
05DF  2DC1     GOTO 0x5C1
552:           		}
553:           #ifdef	ANYFORMAT
554:           #ifdef	WIDTH
555:           		width = 0;
05E0  01D5     CLRF width
05E1  01D6     CLRF f3
556:           #endif
557:           		flag = 0;
05E2  01D4     CLRF flag
05E3  2DE8     GOTO 0x5E8
558:           #if	defined(LEFT) || defined(SPCSIGN) || defined(MANSIGN) || defined(ALTERN) || defined(FILL)
559:           		for(;;) {
560:           			switch(*f) {
05E8  0848     MOVF 0x48, W
05E9  00FF     MOVWF 0x7F
05EA  0847     MOVF f, W
05EB  0084     MOVWF FSR
05EC  160A     BSF PCLATH, 0x4
05ED  158A     BSF PCLATH, 0x3
05EE  2000     CALL 0x0
05EF  120A     BCF PCLATH, 0x4
05F0  118A     BCF PCLATH, 0x3
05F1  3A30     XORLW 0x30
05F2  1903     BTFSC STATUS, 0x2
05F3  2DE4     GOTO 0x5E4
05F4  2DF5     GOTO 0x5F5
561:           #ifdef	LEFT
562:           			case '-':
563:           				flag |= LEFT;
564:           				f++;
565:           				continue;
566:           #endif
567:           
568:           #ifdef	SPCSIGN
569:           			case ' ':
570:           				flag |= SPCSIGN;
571:           				f++;
572:           				continue;
573:           #endif
574:           
575:           #ifdef	MANSIGN
576:           			case '+':
577:           				flag |= MANSIGN;
578:           				f++;
579:           				continue;
580:           #endif
581:           #ifdef	ALTERN
582:           			case '#':
583:           				flag |= ALTERN;
584:           				f++;
585:           				continue;
586:           #endif
587:           #ifdef	FILL
588:           			case '0':
589:           				flag |= FILL;
05E4  1554     BSF flag, 0x2
590:           				f++;
05E5  0AC7     INCF f, F
05E6  1903     BTFSC STATUS, 0x2
05E7  0AC8     INCF 0x48, F
591:           				continue;
592:           #endif
593:           			}
594:           			break;
595:           		}
596:           #endif
597:           #if	defined(MANSIGN) && defined(SPCSIGN)
598:           		if(flag & MANSIGN)
599:           			flag &= ~SPCSIGN;
600:           #endif
601:           #if	defined(LEFT) && defined(FILL)
602:           		if(flag & LEFT)
603:           			flag &= ~FILL;
604:           #endif
605:           #ifdef	WIDTH
606:           		if(isdigit((unsigned)*f)) {
05F5  0848     MOVF 0x48, W
05F6  00FF     MOVWF 0x7F
05F7  0847     MOVF f, W
05F8  0084     MOVWF FSR
05F9  160A     BSF PCLATH, 0x4
05FA  158A     BSF PCLATH, 0x3
05FB  2000     CALL 0x0
05FC  120A     BCF PCLATH, 0x4
05FD  118A     BCF PCLATH, 0x3
05FE  2776     CALL 0x776
05FF  120A     BCF PCLATH, 0x4
0600  118A     BCF PCLATH, 0x3
0601  1C03     BTFSS STATUS, 0x0
0602  2E78     GOTO 0x678
607:           			width = 0;
0603  01D5     CLRF width
0604  01D6     CLRF f3
608:           			do {
609:           				width *= 10;
0605  300A     MOVLW 0xA
0606  00A3     MOVWF x
0607  01A4     CLRF dato
0608  0856     MOVF f3, W
0609  00A6     MOVWF x
060A  0855     MOVF width, W
060B  00A5     MOVWF y
060C  2784     CALL 0x784
060D  0824     MOVF dato, W
060E  00D6     MOVWF f3
060F  0823     MOVF x, W
0610  00D5     MOVWF width
610:           			   	width += *f++ - '0';
0611  0848     MOVF 0x48, W
0612  00FF     MOVWF 0x7F
0613  0847     MOVF f, W
0614  0084     MOVWF FSR
0615  160A     BSF PCLATH, 0x4
0616  158A     BSF PCLATH, 0x3
0617  2000     CALL 0x0
0618  120A     BCF PCLATH, 0x4
0619  118A     BCF PCLATH, 0x3
061A  3ED0     ADDLW 0xD0
061B  00CF     MOVWF f1
061C  30FF     MOVLW 0xFF
061D  1803     BTFSC STATUS, 0x0
061E  3000     MOVLW 0x0
061F  00D0     MOVWF 0x50
0620  084F     MOVF f1, W
0621  07D5     ADDWF width, F
0622  1803     BTFSC STATUS, 0x0
0623  0AD6     INCF f3, F
0624  0850     MOVF 0x50, W
0625  07D6     ADDWF f3, F
0626  0AC7     INCF f, F
0627  1903     BTFSC STATUS, 0x2
0628  0AC8     INCF 0x48, F
611:           			} while(isdigit((unsigned)*f));
0629  0848     MOVF 0x48, W
062A  00FF     MOVWF 0x7F
062B  0847     MOVF f, W
062C  0084     MOVWF FSR
062D  160A     BSF PCLATH, 0x4
062E  158A     BSF PCLATH, 0x3
062F  2000     CALL 0x0
0630  120A     BCF PCLATH, 0x4
0631  118A     BCF PCLATH, 0x3
0632  2776     CALL 0x776
0633  120A     BCF PCLATH, 0x4
0634  118A     BCF PCLATH, 0x3
0635  1C03     BTFSS STATUS, 0x0
0636  2E78     GOTO 0x678
0637  2E05     GOTO 0x605
612:           #ifdef	STAR
613:           		} else if(*f == '*') {
614:           			width = va_arg(ap, int);
615:           			f++;
616:           #endif
617:           		}
618:           #endif
619:           #ifdef	PRECISION
620:           		if(*f == '.') {
621:           			flag |= PRECISION;
622:           			f++;
623:           #ifdef	STAR
624:           			if(*f == '*') {
625:           				prec = va_arg(ap, int);
626:           				f++;
627:           			} else
628:           #endif
629:           			{
630:           				prec = 0;
631:           				while(isdigit((unsigned)*f))
632:           					prec = prec*10 + *f++ - '0';
633:           			}
634:           		} else {
635:           			prec = 0;
636:           #ifdef	DEFPREC
637:           			flag |= DEFPREC;
638:           #endif	// DEFPREC
639:           		}
640:           #endif	// PRECISION
641:           #if	defined(__LONG) && defined(LONG)
642:           loop:
643:           #endif
644:           		switch(c = *f++) {
0678  0848     MOVF 0x48, W
0679  00D0     MOVWF 0x50
067A  0847     MOVF f, W
067B  00CF     MOVWF f1
067C  0AC7     INCF f, F
067D  1903     BTFSC STATUS, 0x2
067E  0AC8     INCF 0x48, F
067F  0850     MOVF 0x50, W
0680  00FF     MOVWF 0x7F
0681  084F     MOVF f1, W
0682  0084     MOVWF FSR
0683  160A     BSF PCLATH, 0x4
0684  158A     BSF PCLATH, 0x3
0685  2000     CALL 0x0
0686  120A     BCF PCLATH, 0x4
0687  118A     BCF PCLATH, 0x3
0688  00DA     MOVWF c
0689  3A00     XORLW 0x0
068A  1903     BTFSC STATUS, 0x2
068B  2F71     GOTO 0x771
068C  3A64     XORLW 0x64
068D  1903     BTFSC STATUS, 0x2
068E  2E96     GOTO 0x696
068F  3A0D     XORLW 0xD
0690  1903     BTFSC STATUS, 0x2
0691  2E96     GOTO 0x696
0692  3A1C     XORLW 0x1C
0693  1903     BTFSC STATUS, 0x2
0694  2E76     GOTO 0x676
0695  2E70     GOTO 0x670
645:           
646:           		case 0:
647:           			goto alldone;
648:           
649:           #ifdef	LONG
650:           		case 'l':
651:           #ifdef	__LONG
652:           			flag |= LONG;
653:           			goto loop;
654:           #else
655:           			cp = "(non-long printf)";
656:           			goto strings;
657:           #endif
658:           #endif
659:           
660:           #ifdef	FLOATFORMAT
661:           #ifndef	__FLOAT
662:           		case 'E':
663:           		case 'f':
664:           		case 'e':
665:           		case 'G':
666:           		case 'g':
667:           			cp = "(non-float printf)";
668:           			goto strings;
669:           #else
670:           #ifdef	FFMT
671:           		case 'f':
672:           			flag |= FFMT;
673:           			break;
674:           #endif
675:           
676:           #ifdef	EFMT
677:           #ifdef	UPCASE
678:           		case 'E':
679:           			flag |= UPCASE;
680:           #endif
681:           		case 'e':
682:           			flag |= EFMT;
683:           			break;
684:           #endif
685:           
686:           #ifdef	GFMT
687:           #ifdef	UPCASE
688:           		case 'G':
689:           			flag |= UPCASE;
690:           #endif
691:           		case 'g':
692:           			flag |= GFMT;
693:           			break;
694:           #endif	// GFMT
695:           #endif
696:           #endif	// FLOATFORMAT
697:           #ifdef	EIGHT
698:           		case 'o':
699:           #ifdef	MULTRAD
700:           			flag |= EIGHT;
701:           #endif
702:           			break;
703:           #endif
704:           
705:           #ifdef	TEN
706:           		case 'd':
707:           		case 'i':
708:           			break;
709:           #endif
710:           
711:           #ifdef	POINTER
712:           		case 'p':
713:           #if	i8086 && LARGE_DATA
714:           			flag |= LONG;
715:           #elif	_PIC18 && LARGE_DATA
716:           			flag |= POINTER;
717:           #endif
718:           #endif	// POINTER
719:           #ifdef	SIXTEEN
720:           #ifdef	HEXUPCASE
721:           		case 'X':
722:           #ifdef	UPCASE
723:           			flag |= UPCASE;
724:           #endif
725:           #endif
726:           #if	defined(HEXLOWCASE) || !defined(UPCASE)
727:           		case 'x':
728:           #endif
729:           #ifdef	MULTRAD
730:           			flag |= SIXTEEN;
731:           #endif
732:           			break;
733:           #endif	// SIXTEEN
734:           
735:           #if	defined(STRING) || defined(PERCPERC)
736:           #ifdef	STRING
737:           		case 's':
738:           #if	i8086 && SMALL_DATA
739:           			if(flag & LONG)
740:           				cp = va_arg(ap, far char *);
741:           			else
742:           #endif
743:           				cp = va_arg(ap, const char *);
744:           #endif	// STRING
745:           #if	!defined(__FLOAT) && !defined(CUSTOM_PRINTF)
746:           strings:
747:           #endif
748:           #ifdef	STRING
749:           			if(!cp)
750:           				cp = "(null)";
751:           #endif
752:           #if	defined(WIDTH) || defined(PRECISION)
753:           #if	defined(STRING)
754:           			len = 0;
755:           			while(cp[len])
756:           				len++;
757:           #endif
758:           #ifdef	PERCPERC
759:           dostring:
760:           #endif
761:           #ifdef	PRECISION
762:           			if(prec && prec < len)
763:           				len = prec;
764:           #endif	// PRECISION
765:           #ifdef	WIDTH
766:           			if(width > len)
0638  0856     MOVF f3, W
0639  0259     SUBWF exp, W
063A  1D03     BTFSS STATUS, 0x2
063B  2E3E     GOTO 0x63E
063C  0855     MOVF width, W
063D  0258     SUBWF 0x58, W
063E  1803     BTFSC STATUS, 0x0
063F  2E47     GOTO 0x647
767:           				width -= len;
0640  0858     MOVF 0x58, W
0641  02D5     SUBWF width, F
0642  0859     MOVF exp, W
0643  1C03     BTFSS STATUS, 0x0
0644  03D6     DECF f3, F
0645  02D6     SUBWF f3, F
0646  2E49     GOTO 0x649
768:           			else
769:           				width = 0;
0647  01D5     CLRF width
0648  01D6     CLRF f3
770:           #ifdef	LEFT
771:           			if(!(flag & LEFT))
772:           #endif	// LEFT
773:           				while(width--)
0649  30FF     MOVLW 0xFF
064A  07D5     ADDWF width, F
064B  1C03     BTFSS STATUS, 0x0
064C  03D6     DECF f3, F
064D  0A55     INCF width, W
064E  1903     BTFSC STATUS, 0x2
064F  0A56     INCF f3, W
0650  1903     BTFSC STATUS, 0x2
0651  2E64     GOTO 0x664
0658  2E49     GOTO 0x649
774:           					pputc(' ');
0652  085B     MOVF sp, W
0653  0084     MOVWF FSR
0654  3020     MOVLW 0x20
0655  1383     BCF STATUS, 0x7
0656  0080     MOVWF INDF
0657  0ADB     INCF sp, F
775:           #endif	// WIDTH
776:           			while(len--)
0664  3001     MOVLW 0x1
0665  02D8     SUBWF 0x58, F
0666  3000     MOVLW 0x0
0667  1C03     BTFSS STATUS, 0x0
0668  03D9     DECF exp, F
0669  02D9     SUBWF exp, F
066A  0A58     INCF 0x58, W
066B  1903     BTFSC STATUS, 0x2
066C  0A59     INCF exp, W
066D  1903     BTFSC STATUS, 0x2
066E  2DC1     GOTO 0x5C1
066F  2E59     GOTO 0x659
777:           				pputc(*cp++);
0659  0857     MOVF _val, W
065A  0084     MOVWF FSR
065B  1383     BCF STATUS, 0x7
065C  0800     MOVF INDF, W
065D  00CF     MOVWF f1
065E  085B     MOVF sp, W
065F  0084     MOVWF FSR
0660  084F     MOVF f1, W
0661  0080     MOVWF INDF
0662  0AD7     INCF _val, F
0663  0ADB     INCF sp, F
778:           #ifdef	LEFT
779:           			if(flag & LEFT)
780:           				while(width--)
781:           					pputc(' ');
782:           #endif	// LEFT
783:           			continue;
784:           #else	// WIDTH || PRECISION
785:           #if	defined(STRING)
786:           			while(*cp)
787:           				pputc(*cp++);
788:           			continue;
789:           #endif
790:           #endif	// WIDTH || PRECISION
791:           #endif	// defined(STRING) || defined(PERCPERC)
792:           #ifdef	CHAR
793:           		case 'c':
794:           #if	_HOSTED
795:           			val = va_arg(ap, int);
796:           			c = val >> 8;
797:           			if(flag & LONG && c && (unsigned char)c != 0xFF) {
798:           				cbuf[0] = c;
799:           				cbuf[1] = val;
800:           				len = 2;
801:           			} else {
802:           				cbuf[0] = val;
803:           				len = 1;
804:           			}
805:           			cp = cbuf;
806:           			goto dostring;
807:           #else
808:           			c = va_arg(ap, int);
809:           #endif	// _HOSTED
810:           #endif	// CHAR
811:           		default:
812:           #ifdef	PERCPERC
813:           #if	defined(WIDTH) || defined(PRECISION)
814:           			cp = (char *)&c;
0670  305A     MOVLW 0x5A
0671  00D7     MOVWF _val
815:           			len = 1;
0672  01D8     CLRF 0x58
0673  0AD8     INCF 0x58, F
0674  01D9     CLRF exp
816:           			goto dostring;
0675  2E38     GOTO 0x638
817:           #else
818:           			pputc(c);
819:           			continue;
820:           #endif
821:           #else	// PERCPERC
822:           			continue;
823:           #endif
824:           
825:           #ifdef	UNSIGN
826:           		case 'u':
827:           			flag |= UNSIGN;
0676  1754     BSF flag, 0x6
828:           			break;
0677  2E96     GOTO 0x696
829:           #endif
830:           
831:           		}
832:           #endif	// ANYFORMAT
833:           #ifdef	__FLOAT
834:           		if(flag & (FLOATFORMAT)) {
835:           #ifdef	DEFPREC
836:           			if(flag & DEFPREC)
837:           #endif
838:           				prec = 6;
839:           			fval = va_arg(ap, double);	// source the floating point value
840:           			if(fval < 0.0) {
841:           				fval = -fval;		// get the absolute value
842:           				flag |= NEGSIGN;
843:           			}
844:           			exp = 0;		/* If the number is zero, the exponent is zero. */
845:           			if( fval!=0) {		/* If the number is non-zero, find the exponent. */
846:           				frexp(fval, &exp);		/* get binary exponent */
847:           				exp--;				/* adjust 0.5 -> 1.0 */
848:           				exp *= 3;
849:           				exp /= 10;			/* estimate decimal exponent */
850:           				if(exp < 0)
851:           					exp--;
852:           				// the following line can cause "recursive call" errors because scale calls
853:           				// ftmul, and is used when evaluating an argument to ftmul
854:           				//integ = fval * scale(-exp);
855:           				integ = scale(-exp);		// replaced with this
856:           				integ *= fval;
857:           				if(integ < 1.0)
858:           					exp--;
859:           				else if(integ >= 10.0)
860:           					exp++;
861:           			}
862:           #if	defined(EFMT) || defined(GFMT)
863:           			if(exp <= 0)	// value is 0.??? (neg expnt) whole characters = 1 (allow zero)
864:           				c = 1;
865:           			else
866:           				c = exp;
867:           			if(
868:           #ifdef	EFMT
869:           					flag & EFMT
870:           #ifdef	GFMT
871:           					||
872:           #endif
873:           #endif
874:           #ifdef	GFMT
875:           					flag & GFMT && (exp < -4 || exp >= (int)prec)
876:           #endif
877:           				) {	/* use e format */
878:           #ifdef	GFMT
879:           				if(prec && flag & GFMT)
880:           					prec--;		/* g format precision includes integer digit */
881:           #endif
882:           				if((unsigned)prec > NDDIG - 2)
883:           					c = NDDIG - 2;
884:           				else
885:           					c = prec;
886:           				if( fval!=0) {	/* Normalise only if the number is non-zero. */
887:           					fval /= scale(exp-c);
888:           #if	DOUBLE
889:           					ival = _dto64i(fval);
890:           					if(fval - _64itod(ival) >= 0.5) {
891:           						fval += 0.5;
892:           						ival = _dto64i(fval);
893:           					}
894:           					if(ival >= fdpowers[c+1]) {
895:           						fval *= 1e-1;
896:           						exp++;
897:           					} else if(ival < fdpowers[c]) {
898:           						fval *= 10.0;
899:           						exp--;
900:           					}
901:           #else	
902:           					if(fval - (double)(unsigned long)fval >= 0.5)
903:           						fval += 0.5;
904:           					if((unsigned long)fval >= fdpowers[c+1]) {
905:           						fval *= 1e-1;
906:           						exp++;
907:           					} else if((unsigned long)fval < fdpowers[c]) {
908:           						fval *= 10.0;
909:           						exp--;
910:           					}
911:           #endif
912:           				}
913:           #if defined(GFMT) && defined(ALTERN)
914:           				if(flag & GFMT && !(flag & ALTERN)) {		/* g format, precision means something different */
915:           					if(prec > (int)(NDDIG))
916:           						prec = NDDIG;
917:           #if	DOUBLE
918:           					ival = _dto64i(fval);
919:           					while(ival != 0.0 && _mod64i10(ival) == 0) {
920:           						prec--;
921:           						ival = _div64(ival, fdpowers[1]);
922:           					}
923:           #else
924:           					val = (unsigned long)fval;
925:           					while(val && val % 10 == 0) {
926:           						prec--;
927:           						val /= 10;
928:           					}
929:           #endif
930:           					if(prec < c) {
931:           						fval /= scale(c-prec);
932:           						c = prec;
933:           					}
934:           
935:           				}
936:           #endif
937:           #ifdef	WIDTH
938:           				width -=  prec + 5;
939:           #ifdef	ALTERN
940:           				if(prec || flag & ALTERN)
941:           					width--;
942:           #endif
943:           				if(flag & NEGSIGN)
944:           					width--;
945:           #if	DBL_MAX_10_EXP >= 100
946:           #if	DBL_MAX_10_EXP >= 1000
947:           				if(exp >= 1000 || exp <= -1000)	/* 4 digit exponent */
948:           					width--;
949:           #endif
950:           				if(exp >= 100 || exp <= -100)	/* 3 digit exponent */
951:           					width--;
952:           #endif
953:           #endif	// WIDTH
954:           #ifdef	FILL
955:           				if(flag & FILL) {
956:           #if defined(MANSIGN) && defined(SPCSIGN)
957:           					if(flag & MANSIGN)
958:           						pputc(flag & SPCSIGN ? '-' : '+');
959:           					else if(flag & SPCSIGN)
960:           						pputc(' ');
961:           #endif
962:           					while(width > 0) {
963:           						pputc('0');
964:           						width--;
965:           					}
966:           				} else
967:           #endif	// FILL
968:           				{
969:           #ifdef	WIDTH
970:           #ifdef	LEFT
971:           					if(!(flag & LEFT))
972:           #endif
973:           						while(width > 0) {
974:           							pputc(' ');
975:           							width--;
976:           						}
977:           #endif	// WIDTH
978:           #ifdef	MANSIGN
979:           					if(flag & MANSIGN)
980:           						putsign();
981:           #else
982:           					if(flag & NEGSIGN)
983:           						pputc('-');
984:           #endif	// MANSIGN
985:           #ifdef	SPCSIGN
986:           					else if(flag & SPCSIGN)
987:           						pputc(' ');
988:           #endif	// SPCSIGN
989:           				}
990:           #if	DOUBLE
991:           				ival = _dto64i(fval);
992:           				pputc(_div64ir(ival, fdpowers[c]) + '0');
993:           #else
994:           				val = (unsigned long)fval;
995:           				pputc(val/dpowers[c] + '0');
996:           				val %= dpowers[c];
997:           #endif
998:           #ifdef	ALTERN
999:           				if(prec || flag & ALTERN)
1000:          #else
1001:          				if(prec)
1002:          #endif
1003:          				{
1004:          					pputc('.');
1005:          					prec -= c;
1006:          					while(c--) {
1007:          #if	DOUBLE
1008:          						pputc('0' + _mod64i10(_div64(ival, fdpowers[c])));
1009:          #else
1010:          #ifdef	GFMT
1011:          						if(flag & GFMT && val == 0) {
1012:          							prec = c = 0;
1013:          							break;
1014:          						}
1015:          #endif
1016:          						pputc('0' + (val/dpowers[c]));
1017:          						val %= dpowers[c];
1018:          #endif
1019:          					}
1020:          					while(prec) {
1021:          						pputc('0');
1022:          						prec--;
1023:          					}
1024:          				}
1025:          #ifdef	UPCASE
1026:          				if(flag & UPCASE)
1027:          					pputc('E');
1028:          				else
1029:          #endif
1030:          					pputc('e');
1031:          				if(exp < 0) {
1032:          					exp = -exp;
1033:          					pputc('-');
1034:          				} else
1035:          					pputc('+');
1036:          #if	DBL_MAX_10_EXP >= 100
1037:          #if	DBL_MAX_10_EXP >= 1000
1038:          				if(exp >= 1000) {
1039:          					pputc(exp / 1000 + '0');
1040:          					exp %= 1000;
1041:          				}
1042:          #endif
1043:          				if(exp >= 100) {
1044:          					pputc(exp / 100 + '0');
1045:          					exp %= 100;
1046:          				}
1047:          #endif
1048:          				pputc(exp / 10 + '0');
1049:          				pputc(exp % 10 + '0');
1050:          #ifdef	LEFT
1051:          				if((flag & LEFT) && width > 0)
1052:          					do
1053:          						pputc(' ');
1054:          					while(--width);
1055:          #endif	// LEFT
1056:          					continue;
1057:          				}
1058:          #endif	// EFMT || GFMT
1059:          				/* here for f format */
1060:          #if	DOUBLE
1061:          #ifdef	GFMT
1062:          				if(flag & GFMT) {
1063:          					if(exp < 0)	// fractional part only
1064:          						prec -= exp-1;
1065:          					ival = _dto64i(fval);
1066:          					for(c = 1 ; c != NDDIG ; c++)
1067:          						if(ival < fdpowers[c])
1068:          							break;
1069:          					if(prec > NDDIG)
1070:          						prec = NDDIG;
1071:          					prec -= c;
1072:          					ival = _dto64i((fval - _64itod(ival)) * scale(prec)+0.5);
1073:          					// see how many zeros are at the end of the fractional part
1074:          					while(prec && _mod64i10(ival) == 0) {
1075:          						prec--;
1076:          						ival = _div64(ival, fdpowers[1]);
1077:          					}
1078:          				}
1079:          #endif	// GFMT
1080:          				if(prec <= (int)NDDIG)
1081:          					fval += fround(prec);
1082:          				if(exp > (int)(NDDIG)-2) {
1083:          					exp -= NDDIG-2;
1084:          					ival = _divto64i(fval, scale(exp));
1085:          					fval = 0.0;
1086:          				} else {
1087:          					ival = _dto64i(fval);
1088:          					fval -= _64itod(ival);
1089:          					exp = 0;
1090:          				}
1091:          				for(c = 1 ; c != NDDIG ; c++)
1092:          					if(ival < fdpowers[c])
1093:          						break;
1094:          #else	// DOUBLE
1095:          #ifdef	GFMT
1096:          				if(flag & GFMT) {
1097:          					if(exp < 0)	// fractional part only
1098:          						prec -= (exp+1);
1099:          					// count number of digits in the integral part (this is for %g)
1100:          					val = (unsigned long)fval;
1101:          					for(c = 0 ; c != NDDIG ; c++)
1102:          						if(val < fdpowers[c])
1103:          							break;
1104:          					prec -= c;		// reduce precision by this
1105:          					if(prec <= NDIG)
1106:          						fval += fround(prec);
1107:          					// get fractional part and count trailing zeros - reduce
1108:          					// prec as required
1109:          					{
1110:          						double	temp;
1111:          						temp = scale(prec);
1112:          						temp *= fval - (double)val;
1113:          						val = (unsigned long)temp;
1114:          					}
1115:          					while(prec && val % 10 == 0) {
1116:          						val /= 10;
1117:          						prec--;
1118:          					}
1119:          				} else
1120:          #endif	//GFMT
1121:          					if(prec <= NDIG)
1122:          						fval += fround(prec);
1123:          
1124:          				/* ~4.2e9 is the largest float that will fit into a 32-bit long */
1125:          				if((exp > 9)||(fval != 0 && (unsigned long)fval == 0 && exp > 1)) {
1126:          					// fval is > 4.2e9
1127:          					// new exp must be such that div_to_l() is < 4.2e9
1128:          					// OLD CODE:	if(fval / scale(exp) < 4.294967296){
1129:          					if(integ < 4.294967296){
1130:          						exp -= NDDIG-1;
1131:          					}else{
1132:          						exp -= NDDIG-2;
1133:          					}
1134:          					integ = scale(exp);
1135:          					val = div_to_l_(fval, integ);
1136:           					//val = _div_to_l_(integ, fval);
1137:          					//val = (long)(integ * fval);	// fit as much signifigant data into the long as it can hold
1138:          					fval = 0.0;	// There will be no fractional component
1139:          				} else {
1140:          					val = (unsigned long)fval;
1141:          					fval -= (double)val;
1142:          					exp = 0;
1143:          				}
1144:          				// count digits in integral part
1145:          				for(c = 1 ; c != NDDIG ; c++)
1146:          					if(val < fdpowers[c])
1147:          						break;
1148:          #endif	// DOUBLE
1149:          #ifdef	WIDTH
1150:          				// at this point, c contains the number of whole-number digits to print
1151:          				width -= prec + c + exp;
1152:          				if(
1153:          #ifdef	ALTERN
1154:          						flag & ALTERN ||
1155:          #endif
1156:          						prec)
1157:          					width--;		// allow for decimal point
1158:          				if(flag & NEGSIGN)
1159:          					width--;
1160:          #endif	// WIDTH
1161:          #ifdef	FILL
1162:          				if(flag & FILL) {
1163:          #ifdef	MANSIGN
1164:          					if(flag & MANSIGN)
1165:          #else
1166:          					if(flag & NEGSIGN)
1167:          #endif	// MANSIGN
1168:          						putsign();
1169:          #if defined(MANSIGN) && defined(SPCSIGN)
1170:          					else
1171:          #endif
1172:          #ifdef	SPCSIGN
1173:          					if(flag & SPCSIGN)
1174:          						pputc(' ');
1175:          #endif	// SPCSIGN
1176:          #ifdef	WIDTH
1177:          					while(width > 0) {
1178:          						pputc('0');
1179:          						width--;
1180:          					}
1181:          #endif	// WIDTH
1182:          				} else
1183:          #endif	// FILL
1184:          				{
1185:          #ifdef	LEFT
1186:          					if(!(flag & LEFT))
1187:          #endif
1188:          #ifdef	WIDTH
1189:          					while(width > 0) {
1190:          						pputc(' ');
1191:          						width--;
1192:          					}
1193:          #endif	// WIDTH
1194:          #ifdef	MANSIGN
1195:          				if(flag & MANSIGN)
1196:          #else
1197:          				if(flag & NEGSIGN)
1198:          #endif	// MANSIGN
1199:          					putsign();
1200:          #ifdef	SPCSIGN
1201:          				else if(flag & SPCSIGN)
1202:          					pputc(' ');
1203:          #endif	// SPCSIGN
1204:          			}
1205:          			while(c--) {
1206:          #if	DOUBLE
1207:          				pputc('0' + _mod64i10(_div64(ival, fdpowers[c])));
1208:          #else
1209:          				{
1210:          					unsigned long vd = val/dpowers[c];
1211:          					vd %= 10;
1212:          					pputc('0' + vd);
1213:          				}
1214:          #endif	// DOUBLE
1215:          			}
1216:          			while(exp > 0) {
1217:          				pputc('0');
1218:          				exp--;
1219:          			}
1220:          			if(prec > (int)(NDDIG-2))
1221:          				c = NDDIG-2;
1222:          			else
1223:          				c = prec;
1224:          			prec -= c;
1225:          #ifdef	ALTERN
1226:          			if(c || flag & ALTERN)
1227:          #else
1228:          			if(c)
1229:          #endif
1230:          				pputc('.');
1231:          #if	DOUBLE
1232:          			ival = _dto64i(fval * scale(c));
1233:          			while(c)
1234:          				pputc('0' + _mod64i10(_div64(ival, fdpowers[--c])));
1235:          #else	// DOUBLE
1236:          			val = (long)(fval * scale(c));
1237:          			while(c--) {
1238:          				unsigned long vd = val/dpowers[c];
1239:          				vd %= 10;
1240:          				pputc('0' + vd);
1241:          				val %= dpowers[c];
1242:          			}
1243:          #endif	// DOUBLE
1244:          			while(prec) {
1245:          				pputc('0');
1246:          				prec--;
1247:          			}
1248:          #ifdef	LEFT
1249:          			if((flag & LEFT) && width > 0)
1250:          				do
1251:          					pputc(' ');
1252:          				while(--width);
1253:          #endif
1254:          			continue;
1255:          		}
1256:          #endif	/* __FLOAT */
1257:          
1258:          #if	defined(TEN)
1259:          #ifdef	BASEM
1260:          		if((flag & BASEM) == TEN)
0696  1B54     BTFSC flag, 0x6
0697  2EAC     GOTO 0x6AC
1261:          #endif	//BASEM
1262:          		{
1263:          #ifdef	LONG
1264:          			if(flag & LONG)
1265:          				val = va_arg(ap, long);
1266:          			else
1267:          #endif	// LONG
1268:          				val = (value)va_arg(ap, int);
0698  0853     MOVF ap, W
0699  0084     MOVWF FSR
069A  1383     BCF STATUS, 0x7
069B  0800     MOVF INDF, W
069C  00D7     MOVWF _val
069D  0A84     INCF FSR, F
069E  0800     MOVF INDF, W
069F  00D8     MOVWF 0x58
06A0  0AD3     INCF ap, F
06A1  0AD3     INCF ap, F
1269:          #ifdef	NEGSIGN
1270:          			if((value)val < 0) {
06A2  1FD8     BTFSS 0x58, 0x7
06A3  2EB6     GOTO 0x6B6
1271:          				flag |= NEGSIGN;
06A4  3003     MOVLW 0x3
06A5  04D4     IORWF flag, F
1272:          				val = -val;
06A6  09D7     COMF _val, F
06A7  09D8     COMF 0x58, F
06A8  0AD7     INCF _val, F
06A9  1903     BTFSC STATUS, 0x2
06AA  0AD8     INCF 0x58, F
06AB  2EB6     GOTO 0x6B6
1273:          			}
1274:          #endif
1275:          		}
1276:          #ifdef	BASEM
1277:          		else
1278:          #endif
1279:          #endif	// TEN
1280:          
1281:          #if	defined(EIGHT) || defined(SIXTEEN) || defined(UNSIGN)
1282:          		{
1283:          #ifdef	__LONG
1284:          #if	defined(_PIC18) && defined(LARGE_DATA) && defined(POINTER)
1285:          			if(flag & POINTER)
1286:          				val = (unsigned long)va_arg(ap, far char *);
1287:          			else
1288:          #endif
1289:          #ifdef	LONG
1290:          				if(flag & LONG)
1291:          				val = va_arg(ap, unsigned long);
1292:          			else
1293:          #endif	// LONG
1294:          #endif	// __LONG
1295:          				val = va_arg(ap, unsigned);
06AC  0853     MOVF ap, W
06AD  0084     MOVWF FSR
06AE  1383     BCF STATUS, 0x7
06AF  0800     MOVF INDF, W
06B0  00D7     MOVWF _val
06B1  0A84     INCF FSR, F
06B2  0800     MOVF INDF, W
06B3  00D8     MOVWF 0x58
06B4  0AD3     INCF ap, F
06B5  0AD3     INCF ap, F
1296:          		}
1297:          #endif	// EIGHT or SIXTEEN or UNSIGN
1298:          #ifdef	PRECISION
1299:          		if(prec == 0 && val == 0)
1300:          			prec++;
1301:          #endif
1302:          #ifdef	MULTRAD
1303:          		switch((unsigned char)(flag & BASEM)) {
1304:          #endif
1305:          #if	defined(TEN) || defined(UNSIGN)
1306:          #ifdef	MULTRAD
1307:          #ifdef	TEN
1308:          		case TEN:
1309:          #endif
1310:          #ifdef	UNSIGN
1311:          		case UNSIGN:
1312:          #endif
1313:          #endif	// MULTRAD
1314:          			for(c = 1 ; c != sizeof dpowers/sizeof dpowers[0] ; c++)
06B6  01DA     CLRF c
06B7  0ADA     INCF c, F
06B8  085A     MOVF c, W
06B9  3A05     XORLW 0x5
06BA  1903     BTFSC STATUS, 0x2
06BB  2ED7     GOTO 0x6D7
1315:          				if(val < dpowers[c])
06BC  1003     BCF STATUS, 0x0
06BD  0D5A     RLF c, W
06BE  3E12     ADDLW 0x12
06BF  0084     MOVWF FSR
06C0  3098     MOVLW 0x98
06C1  1803     BTFSC STATUS, 0x0
06C2  3E01     ADDLW 0x1
06C3  00FF     MOVWF 0x7F
06C4  160A     BSF PCLATH, 0x4
06C5  158A     BSF PCLATH, 0x3
06C6  2000     CALL 0x0
06C7  120A     BCF PCLATH, 0x4
06C8  118A     BCF PCLATH, 0x3
06C9  00CF     MOVWF f1
06CA  160A     BSF PCLATH, 0x4
06CB  158A     BSF PCLATH, 0x3
06CC  2000     CALL 0x0
06CD  120A     BCF PCLATH, 0x4
06CE  118A     BCF PCLATH, 0x3
06CF  00D0     MOVWF 0x50
06D0  0258     SUBWF 0x58, W
06D1  1D03     BTFSS STATUS, 0x2
06D2  2ED5     GOTO 0x6D5
06D3  084F     MOVF f1, W
06D4  0257     SUBWF _val, W
06D5  1803     BTFSC STATUS, 0x0
06D6  2EB7     GOTO 0x6B7
1316:          					break;
1317:          #ifdef	MULTRAD
1318:          			break;
1319:          #endif
1320:          #endif	// TEN || UNSIGN
1321:          #ifdef	SIXTEEN
1322:          #ifdef	MULTRAD
1323:          		case SIXTEEN:
1324:          #endif	// MULTRAD
1325:          			for(c = 1 ; c != sizeof hexpowers/sizeof hexpowers[0] ; c++)
1326:          				if(val < hexpowers[c])
1327:          					break;
1328:          #ifdef	MULTRAD
1329:          			break;
1330:          #endif
1331:          #endif
1332:          
1333:          #ifdef	EIGHT
1334:          #ifdef	MULTRAD
1335:          		case EIGHT:
1336:          #endif	// MULTRAD
1337:          			for(c = 1 ; c != sizeof octpowers/sizeof octpowers[0] ; c++)
1338:          				if(val < octpowers[c])
1339:          					break;
1340:          #ifdef	MULTRAD
1341:          			break;
1342:          #endif
1343:          #endif
1344:          #ifdef	MULTRAD
1345:          		}
1346:          #endif
1347:          #ifdef	PRECISION
1348:          		if(c < prec)
1349:          			c = prec;
1350:          		else if(prec < c)
1351:          			prec = c;
1352:          #endif
1353:          #if	defined(WIDTH) && defined(NEGSIGN)
1354:          		if(width && flag & NEGSIGN)
06D7  0856     MOVF f3, W
06D8  0455     IORWF width, W
06D9  1903     BTFSC STATUS, 0x2
06DA  2EE3     GOTO 0x6E3
06DB  0854     MOVF flag, W
06DC  3903     ANDLW 0x3
06DD  1903     BTFSC STATUS, 0x2
06DE  2EE3     GOTO 0x6E3
1355:          			width--;
06DF  30FF     MOVLW 0xFF
06E0  07D5     ADDWF width, F
06E1  1C03     BTFSS STATUS, 0x0
06E2  03D6     DECF f3, F
1356:          #ifdef	PRECISION
1357:          		if(flag & PRECISION) {
1358:          			if(width > prec)
1359:          				width -= prec;
1360:          			else
1361:          				width = 0;
1362:          		}
1363:          #endif
1364:          #ifdef	ALTERN
1365:          #ifdef	EIGHT
1366:          		if((flag & (
1367:          #ifdef	FILL
1368:          						FILL|
1369:          #endif
1370:          							BASEM|ALTERN)) == (EIGHT|ALTERN)) {
1371:          			if(width)
1372:          				width--;
1373:          		} else
1374:          #endif	// EIGHT
1375:          #if	defined(SIXTEEN)
1376:          #ifdef	BASEM
1377:          		if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1378:          #else
1379:          		if(flag & ALTERN) {
1380:          #endif
1381:          			if(width > 2)
1382:          				width -= 2;
1383:          			else
1384:          				width = 0;
1385:          		}
1386:          #endif	// SIXTEEN
1387:          #endif	// ALTERN
1388:          #endif	// WIDTH
1389:          #ifdef	WIDTH
1390:          		if(width > c)
06E3  085A     MOVF c, W
06E4  00CF     MOVWF f1
06E5  01D0     CLRF 0x50
06E6  1BCF     BTFSC f1, 0x7
06E7  03D0     DECF 0x50, F
06E8  0850     MOVF 0x50, W
06E9  3A80     XORLW 0x80
06EA  00D1     MOVWF 0x51
06EB  0856     MOVF f3, W
06EC  3A80     XORLW 0x80
06ED  0251     SUBWF 0x51, W
06EE  1D03     BTFSS STATUS, 0x2
06EF  2EF2     GOTO 0x6F2
06F0  0855     MOVF width, W
06F1  024F     SUBWF f1, W
06F2  1803     BTFSC STATUS, 0x0
06F3  2F01     GOTO 0x701
1391:          			width -= c;
06F4  1283     BCF STATUS, 0x5
06F5  1303     BCF STATUS, 0x6
06F6  085A     MOVF c, W
06F7  00CF     MOVWF f1
06F8  01D0     CLRF 0x50
06F9  1BCF     BTFSC f1, 0x7
06FA  03D0     DECF 0x50, F
06FB  02D5     SUBWF width, F
06FC  0850     MOVF 0x50, W
06FD  1C03     BTFSS STATUS, 0x0
06FE  03D6     DECF f3, F
06FF  02D6     SUBWF f3, F
0700  2F05     GOTO 0x705
1392:          		else
1393:          			width = 0;
0701  1283     BCF STATUS, 0x5
0702  1303     BCF STATUS, 0x6
0703  01D5     CLRF width
0704  01D6     CLRF f3
1394:          #endif
1395:          #ifdef	FILL
1396:          		if(flag & FILL) {
0705  1D54     BTFSS flag, 0x2
0706  2F20     GOTO 0x720
1397:          #ifdef	MANSIGN
1398:          			if(flag & MANSIGN)
1399:          				putsign();
1400:          #elif defined(NEGSIGN)
1401:          			if(flag & NEGSIGN)
0707  0854     MOVF flag, W
0708  3903     ANDLW 0x3
0709  1903     BTFSC STATUS, 0x2
070A  2F11     GOTO 0x711
1402:          				pputc('-');
070B  085B     MOVF sp, W
070C  0084     MOVWF FSR
070D  302D     MOVLW 0x2D
070E  1383     BCF STATUS, 0x7
070F  0080     MOVWF INDF
0710  0ADB     INCF sp, F
1403:          #endif
1404:          #if defined(MANSIGN) || defined(NEGSIGN) && defined(SPCSIGN)
1405:          			else
1406:          #endif	// MANSIGN
1407:          #ifdef	SPCSIGN
1408:          			if(flag & SPCSIGN)
1409:          				pputc(' ');
1410:          #endif
1411:          #if defined(ALTERN) && defined(SIXTEEN)
1412:          			else if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1413:          				pputc('0');
1414:          #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
1415:          				pputc(flag & UPCASE ? 'X' : 'x');
1416:          #elif defined(HEXUPCASE)
1417:          				pputc('X');
1418:          #else
1419:          				pputc('x');
1420:          #endif	// HEXUPCASE
1421:          			}
1422:          #endif	// ALTERN
1423:          #ifdef	WIDTH
1424:          			if(width)
0711  0856     MOVF f3, W
0712  0455     IORWF width, W
0713  1903     BTFSC STATUS, 0x2
0714  2F3C     GOTO 0x73C
1425:          				do
1426:          					pputc('0');
0715  085B     MOVF sp, W
0716  0084     MOVWF FSR
0717  3030     MOVLW 0x30
0718  1383     BCF STATUS, 0x7
0719  0080     MOVWF INDF
071B  0ADB     INCF sp, F
1427:          				while(--width);
071A  30FF     MOVLW 0xFF
071C  07D5     ADDWF width, F
071D  1C03     BTFSS STATUS, 0x0
071E  03D6     DECF f3, F
071F  2F11     GOTO 0x711
1428:          #endif	// WIDTH
1429:          		} else
1430:          #endif	//FILL
1431:          		{
1432:          #ifdef	WIDTH
1433:          			if(width
1434:          #ifdef	LEFT
1435:          					&& !(flag & LEFT)
1436:          #endif
1437:          					)
0720  0856     MOVF f3, W
0721  0455     IORWF width, W
0722  1903     BTFSC STATUS, 0x2
0723  2F32     GOTO 0x732
1438:          				do
1439:          					pputc(' ');
0724  085B     MOVF sp, W
0725  0084     MOVWF FSR
0726  3020     MOVLW 0x20
0727  1383     BCF STATUS, 0x7
0728  0080     MOVWF INDF
072A  0ADB     INCF sp, F
1440:          				while(--width);
0729  30FF     MOVLW 0xFF
072B  07D5     ADDWF width, F
072C  1C03     BTFSS STATUS, 0x0
072D  03D6     DECF f3, F
072E  0856     MOVF f3, W
072F  0455     IORWF width, W
0730  1D03     BTFSS STATUS, 0x2
0731  2F24     GOTO 0x724
1441:          #endif	// WIDTH
1442:          #ifdef	MANSIGN
1443:          			if(flag & MANSIGN)
1444:          				putsign();
1445:          #else
1446:          #ifdef	NEGSIGN
1447:          			if(flag & NEGSIGN)
0732  0854     MOVF flag, W
0733  3903     ANDLW 0x3
0734  1903     BTFSC STATUS, 0x2
0735  2F3C     GOTO 0x73C
1448:          				pputc('-');
0736  085B     MOVF sp, W
0737  0084     MOVWF FSR
0738  302D     MOVLW 0x2D
0739  1383     BCF STATUS, 0x7
073A  0080     MOVWF INDF
073B  0ADB     INCF sp, F
1449:          #endif
1450:          #endif	// MANSIGN
1451:          #ifdef	SPCSIGN
1452:          			else if(flag & SPCSIGN)
1453:          				pputc(' ');
1454:          #endif
1455:          #ifdef	ALTERN
1456:          #ifdef	EIGHT
1457:          			if((flag & (BASEM|ALTERN)) == (EIGHT|ALTERN))
1458:          				pputc('0');
1459:          			else
1460:          #endif	// EIGHT
1461:          #ifdef	SIXTEEN
1462:          #ifdef	BASEM
1463:          			if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1464:          #else
1465:          			if(flag & ALTERN) {
1466:          #endif
1467:          				pputc('0');
1468:          #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
1469:          				pputc(flag & UPCASE ? 'X' : 'x');
1470:          #elif defined(HEXUPCASE)
1471:          				pputc('X');
1472:          #else
1473:          				pputc('x');
1474:          #endif
1475:          			}
1476:          #endif	// SIXTEEN
1477:          #endif	// ALTERN
1478:          		}
1479:          #if	defined(SIXTEEN) || defined(TEN) || defined(EIGHT) || defined(UNSIGN)
1480:          #ifndef	PRECISION
1481:          		prec = c;
073C  085A     MOVF c, W
073D  00D2     MOVWF prec
1482:          #endif
1483:          		while(prec--) {
073E  2F6D     GOTO 0x76D
076D  03D2     DECF prec, F
076E  0F52     INCFSZ prec, W
076F  2F3F     GOTO 0x73F
1484:          #ifdef	MULTRAD
1485:          			switch((unsigned char)(flag & BASEM))
1486:          #endif
1487:          			{
1488:          
1489:          #if	defined(TEN) || defined(UNSIGN)
1490:          #ifdef	MULTRAD
1491:          #ifdef	TEN
1492:          		case TEN:
1493:          #endif
1494:          #ifdef	UNSIGN
1495:          		case UNSIGN:
1496:          #endif
1497:          #endif	// MULTRAD
1498:          				c = (val / dpowers[prec]) % 10 + '0';
073F  300A     MOVLW 0xA
0740  00AA     MOVWF Data
0741  01AB     CLRF sec
0742  1003     BCF STATUS, 0x0
0743  0D52     RLF prec, W
0744  3E12     ADDLW 0x12
0745  0084     MOVWF FSR
0746  3098     MOVLW 0x98
0747  1803     BTFSC STATUS, 0x0
0748  3E01     ADDLW 0x1
0749  00FF     MOVWF 0x7F
074A  160A     BSF PCLATH, 0x4
074B  158A     BSF PCLATH, 0x3
074C  2000     CALL 0x0
074D  120A     BCF PCLATH, 0x4
074E  118A     BCF PCLATH, 0x3
074F  00A3     MOVWF x
0750  160A     BSF PCLATH, 0x4
0751  158A     BSF PCLATH, 0x3
0752  2000     CALL 0x0
0753  120A     BCF PCLATH, 0x4
0754  118A     BCF PCLATH, 0x3
0755  00A4     MOVWF dato
0756  0858     MOVF 0x58, W
0757  00A6     MOVWF x
0758  0857     MOVF _val, W
0759  00A5     MOVWF y
075A  279D     CALL 0x79D
075B  120A     BCF PCLATH, 0x4
075C  118A     BCF PCLATH, 0x3
075D  0824     MOVF dato, W
075E  00AD     MOVWF day
075F  0823     MOVF x, W
0760  00AC     MOVWF hr
0761  27C7     CALL 0x7C7
0762  120A     BCF PCLATH, 0x4
0763  118A     BCF PCLATH, 0x3
0764  082A     MOVF Data, W
0765  3E30     ADDLW 0x30
0766  00DA     MOVWF c
1499:          #ifdef	MULTRAD
1500:          				break;
1501:          #endif
1502:          #endif	// TEN || UNSIGN
1503:          
1504:          #ifdef	SIXTEEN
1505:          #ifdef	MULTRAD
1506:          			case SIXTEEN:
1507:          #endif
1508:          			{
1509:          				unsigned char idx = (val / hexpowers[prec]) & 0xF;
1510:          #if	defined(HEXLOWCASE) && defined(HEXUPCASE)
1511:          				c = (flag & UPCASE ? "0123456789ABCDEF" : "0123456789abcdef")[idx];
1512:          #elif	defined(HEXUPCASE)
1513:          				c = "0123456789ABCDEF"[idx];
1514:          #else
1515:          				c = "0123456789abcdef"[idx];
1516:          #endif	//HEXCASE
1517:          			}
1518:          #ifdef	MULTRAD
1519:          				break;
1520:          #endif
1521:          #endif
1522:          
1523:          #ifdef	EIGHT
1524:          #ifdef	MULTRAD
1525:          			case EIGHT:
1526:          #endif	// MULTRAD
1527:          				c = ((val / octpowers[prec]) & 07) + '0';
1528:          #ifdef	MULTRAD
1529:          				break;
1530:          #endif	// MULTRAD
1531:          #endif	// EIGHT
1532:          			}
1533:          			pputc(c);
0767  085B     MOVF sp, W
0768  0084     MOVWF FSR
0769  085A     MOVF c, W
076A  1383     BCF STATUS, 0x7
076B  0080     MOVWF INDF
076C  0ADB     INCF sp, F
1534:          		}
1535:          #endif	// 16 or 10 or 8
1536:          #ifdef	LEFT
1537:          		if((flag & LEFT) && width > 0)
1538:          			do
1539:          				pputc(' ');
1540:          			while(--width);
1541:          #endif	// LEFT
1542:          	}
1543:          #ifdef	ANYFORMAT
1544:          alldone:
1545:          #endif	// ANYFORMAT
1546:          #if	!defined(PRINTF) && (defined(SPRINTF) || defined(VSPRINTF))
1547:          	*sp = 0;
0771  085B     MOVF sp, W
0772  0084     MOVWF FSR
0773  1383     BCF STATUS, 0x7
0774  0180     CLRF INDF
1548:          #endif
1549:          	return ccnt;
1550:          }
0775  0008     RETURN
1551:          
---  /opt/microchip/xc8/v1.31/sources/common/bmul.c  ----------------------------------------------------
1:             // 8 x 8 bit multiplication with 8 bit result
2:             
3:             unsigned char
4:             __bmul(unsigned char multiplier, unsigned char multiplicand)
0BAB  00A5     MOVWF y
5:             {
6:             	unsigned char product;
7:             
8:             	product = 0;
0BAC  01A4     CLRF dato
9:             	do {
10:            		if(multiplier & 1)
0BAD  0823     MOVF x, W
0BAE  1825     BTFSC y, 0x0
11:            			product += multiplicand;
0BAD  0823     MOVF x, W
0BAF  07A4     ADDWF dato, F
12:            		multiplicand <<= 1;
0BB0  1003     BCF STATUS, 0x0
0BB1  0DA3     RLF x, F
13:            		multiplier >>= 1;
0BB2  1003     BCF STATUS, 0x0
0BB3  0CA5     RRF y, F
14:            	} while(multiplier != 0);
0BB4  08A5     MOVF y, F
0BB5  1D03     BTFSS STATUS, 0x2
0BB6  2BAD     GOTO 0x3AD
15:            	return product;
0BB7  0824     MOVF dato, W
16:            }
0BB8  0008     RETURN
17:            
---  /opt/microchip/xc8/v1.31/sources/common/awmod.c  ---------------------------------------------------
1:             // integer signed unsigned modulus
2:             
3:             signed int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __awmod(signed int divisor, signed int dividend)
0BB9  01B6     CLRF sign
1459  01F5     CLRF Pin
7:             #else
8:             __awmod(signed int dividend, signed int divisor)
9:             #endif
10:            {
11:            	unsigned char	counter, sign;
12:            
13:            	sign = 0;
0BB9  01B6     CLRF sign
1459  01F5     CLRF Pin
14:            	if(dividend < 0) {
0BBA  1FB4     BTFSS sign, 0x7
0BBB  2BC3     GOTO 0x3C3
145A  1FF3     BTFSS counter, 0x7
145B  2C63     GOTO 0x463
15:            		dividend = -dividend;
0BBC  09B3     COMF dividend, F
0BBD  09B4     COMF sign, F
0BBE  0AB3     INCF dividend, F
0BBF  1903     BTFSC STATUS, 0x2
0BC0  0AB4     INCF sign, F
145C  09F2     COMF dividend, F
145D  09F3     COMF counter, F
145E  0AF2     INCF dividend, F
145F  1903     BTFSC STATUS, 0x2
1460  0AF3     INCF counter, F
16:            		sign = 1;
0BC1  01B6     CLRF sign
0BC2  0AB6     INCF sign, F
1461  01F5     CLRF Pin
1462  0AF5     INCF Pin, F
17:            	}
18:            	if(divisor < 0)
0BC3  1FB2     BTFSS 0x32, 0x7
0BC4  2BCA     GOTO 0x3CA
1463  1FF1     BTFSS canal, 0x7
1464  2C6A     GOTO 0x46A
19:            		divisor = -divisor;
0BC5  09B1     COMF divisor, F
0BC6  09B2     COMF 0x32, F
0BC7  0AB1     INCF divisor, F
0BC8  1903     BTFSC STATUS, 0x2
0BC9  0AB2     INCF 0x32, F
1465  09F0     COMF divisor, F
1466  09F1     COMF canal, F
1467  0AF0     INCF divisor, F
1468  1903     BTFSC STATUS, 0x2
1469  0AF1     INCF canal, F
20:            	if(divisor != 0) {
0BCA  0832     MOVF 0x32, W
0BCB  0431     IORWF divisor, W
0BCC  1903     BTFSC STATUS, 0x2
0BCD  2BE9     GOTO 0x3E9
146A  0871     MOVF canal, W
146B  0470     IORWF divisor, W
146C  1903     BTFSC STATUS, 0x2
146D  2C89     GOTO 0x489
21:            		counter = 1;
0BCE  01B5     CLRF counter
146E  01F4     CLRF counter
22:            		while(((unsigned int)divisor & 0x8000U) == 0) {
0BD0  1BB2     BTFSC 0x32, 0x7
0BD1  2BD6     GOTO 0x3D6
0BD5  2BCF     GOTO 0x3CF
1470  1BF1     BTFSC canal, 0x7
1471  2C76     GOTO 0x476
1475  2C6F     GOTO 0x46F
23:            			divisor <<= 1;
0BCF  0AB5     INCF counter, F
0BD2  1003     BCF STATUS, 0x0
0BD3  0DB1     RLF divisor, F
0BD4  0DB2     RLF 0x32, F
146F  0AF4     INCF counter, F
1472  1003     BCF STATUS, 0x0
1473  0DF0     RLF divisor, F
1474  0DF1     RLF canal, F
24:            			counter++;
0BCF  0AB5     INCF counter, F
146F  0AF4     INCF counter, F
25:            		}
26:            		do {
27:            			if((unsigned int)divisor <= (unsigned int)dividend)
0BD6  0832     MOVF 0x32, W
0BD7  0234     SUBWF sign, W
0BD8  1D03     BTFSS STATUS, 0x2
0BD9  2BDC     GOTO 0x3DC
0BDA  0831     MOVF divisor, W
0BDB  0233     SUBWF dividend, W
0BDC  1C03     BTFSS STATUS, 0x0
0BDD  2BE5     GOTO 0x3E5
1476  0871     MOVF canal, W
1477  0273     SUBWF counter, W
1478  1D03     BTFSS STATUS, 0x2
1479  2C7C     GOTO 0x47C
147A  0870     MOVF divisor, W
147B  0272     SUBWF dividend, W
147C  1C03     BTFSS STATUS, 0x0
147D  2C85     GOTO 0x485
28:            				dividend -= divisor;
0BDE  0831     MOVF divisor, W
0BDF  02B3     SUBWF dividend, F
0BE0  0832     MOVF 0x32, W
0BE1  1C03     BTFSS STATUS, 0x0
0BE2  03B4     DECF sign, F
0BE3  02B4     SUBWF sign, F
147E  0870     MOVF divisor, W
147F  02F2     SUBWF dividend, F
1480  0871     MOVF canal, W
1481  1C03     BTFSS STATUS, 0x0
1482  03F3     DECF counter, F
1483  02F3     SUBWF counter, F
29:            			*(unsigned int *)&divisor >>= 1;
0BE4  1003     BCF STATUS, 0x0
0BE5  0CB2     RRF 0x32, F
0BE6  0CB1     RRF divisor, F
1484  1003     BCF STATUS, 0x0
1485  0CF1     RRF canal, F
1486  0CF0     RRF divisor, F
30:            		} while(--counter != 0);
0BE7  0BB5     DECFSZ counter, F
0BE8  2BD6     GOTO 0x3D6
1487  0BF4     DECFSZ counter, F
1488  2C76     GOTO 0x476
31:            	}
32:            	if(sign)
0BE9  0836     MOVF sign, W
0BEA  1903     BTFSC STATUS, 0x2
0BEB  2BF1     GOTO 0x3F1
1489  0875     MOVF Pin, W
148A  1903     BTFSC STATUS, 0x2
148B  2C91     GOTO 0x491
33:            		dividend = -dividend;
0BEC  09B3     COMF dividend, F
0BED  09B4     COMF sign, F
0BEE  0AB3     INCF dividend, F
0BEF  1903     BTFSC STATUS, 0x2
0BF0  0AB4     INCF sign, F
148C  09F2     COMF dividend, F
148D  09F3     COMF counter, F
148E  0AF2     INCF dividend, F
148F  1903     BTFSC STATUS, 0x2
1490  0AF3     INCF counter, F
34:            	return dividend;
0BF1  0834     MOVF sign, W
0BF2  00B2     MOVWF 0x32
0BF3  0833     MOVF dividend, W
0BF4  00B1     MOVWF divisor
1491  0873     MOVF counter, W
1492  00F1     MOVWF canal
1493  0872     MOVF dividend, W
1494  00F0     MOVWF divisor
35:            }
0BF5  0008     RETURN
1495  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/awdiv.c  ---------------------------------------------------
1:             // integer signed division
2:             
3:             signed int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __awdiv(signed int divisor, signed int dividend)
7:             #else
8:             __awdiv(signed int dividend, signed int divisor)
9:             #endif
10:            {
11:            	signed int	quotient;
12:            	unsigned char	counter, sign;
13:            
14:            	sign = 0;
0904  01AE     CLRF sign
15:            	if(divisor < 0) {
0905  1FAA     BTFSS Data, 0x7
0906  290E     GOTO 0x10E
16:            		divisor = -divisor;
0907  09A9     COMF year, F
0908  09AA     COMF Data, F
0909  0AA9     INCF year, F
090A  1903     BTFSC STATUS, 0x2
090B  0AAA     INCF Data, F
17:            		sign = 1;
090C  01AE     CLRF sign
090D  0AAE     INCF sign, F
18:            	}
19:            	if(dividend < 0) {
090E  1FAC     BTFSS hr, 0x7
090F  2917     GOTO 0x117
20:            		dividend = -dividend;
0910  09AB     COMF sec, F
0911  09AC     COMF hr, F
0912  0AAB     INCF sec, F
0913  1903     BTFSC STATUS, 0x2
0914  0AAC     INCF hr, F
21:            		sign ^= 1;
0915  3001     MOVLW 0x1
0916  06AE     XORWF sign, F
22:            	}
23:            	quotient = 0;
0917  01AF     CLRF quotient
0918  01B0     CLRF c
24:            	if(divisor != 0) {
0919  082A     MOVF Data, W
091A  0429     IORWF year, W
091B  1903     BTFSC STATUS, 0x2
091C  293C     GOTO 0x13C
25:            		counter = 1;
091D  01AD     CLRF day
26:            		while((divisor & 0x8000U) == 0) {
091F  1BAA     BTFSC Data, 0x7
0920  2925     GOTO 0x125
0924  291E     GOTO 0x11E
27:            			divisor <<= 1;
091E  0AAD     INCF day, F
0921  1003     BCF STATUS, 0x0
0922  0DA9     RLF year, F
0923  0DAA     RLF Data, F
28:            			counter++;
091E  0AAD     INCF day, F
29:            		}
30:            		do {
31:            			quotient <<= 1;
0925  1003     BCF STATUS, 0x0
0926  0DAF     RLF quotient, F
0927  0DB0     RLF c, F
32:            			if((unsigned int)divisor <= (unsigned int)dividend) {
0928  082A     MOVF Data, W
0929  022C     SUBWF hr, W
092A  1D03     BTFSS STATUS, 0x2
092B  292E     GOTO 0x12E
092C  0829     MOVF year, W
092D  022B     SUBWF sec, W
092E  1C03     BTFSS STATUS, 0x0
092F  2938     GOTO 0x138
33:            				dividend -= divisor;
0930  0829     MOVF year, W
0931  02AB     SUBWF sec, F
0932  082A     MOVF Data, W
0933  1C03     BTFSS STATUS, 0x0
0934  03AC     DECF hr, F
0935  02AC     SUBWF hr, F
34:            				quotient |= 1;
0936  142F     BSF quotient, 0x0
35:            			}
36:            			*(unsigned int *)&divisor >>= 1;
0937  1003     BCF STATUS, 0x0
0938  0CAA     RRF Data, F
0939  0CA9     RRF year, F
37:            		} while(--counter != 0);
093A  0BAD     DECFSZ day, F
093B  2925     GOTO 0x125
38:            	}
39:            	if(sign)
093C  082E     MOVF sign, W
093D  1903     BTFSC STATUS, 0x2
093E  2944     GOTO 0x144
40:            		quotient = -quotient;
093F  09AF     COMF quotient, F
0940  09B0     COMF c, F
0941  0AAF     INCF quotient, F
0942  1903     BTFSC STATUS, 0x2
0943  0AB0     INCF c, F
41:            	return quotient;
0944  0830     MOVF c, W
0945  00AA     MOVWF Data
0946  082F     MOVF quotient, W
0947  00A9     MOVWF year
42:            }
0948  0008     RETURN
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/pwm.c  --------------------------------
1:             #include <xc.h>
2:             #include <stdint.h>         /* For uint8_t definition */
3:             #include <stdbool.h>        /* For true/false definition */
4:             #include "system.h"
5:             #include "pwm.h"
6:             #include "user.h"
7:             /*The following steps should be taken when configuring
8:             the CCP module for PWM operation:
9:             1. Set the PWM period by writing to the PR2 register.
10:            2. Set the PWM duty cycle by writing to the
11:            CCPR1L register and CCP1CON<5:4> bits.
12:            3. Make the CCP1 pin an output by clearing the
13:            TRISC<2> bit.
14:            4. Set the TMR2 prescale value and enable Timer2
15:            by writing to T2CON.
16:            5. Configure the CCP1 module for PWM operation.*/
17:            #define FrecuenciaPWM 4880UL
18:            #define PeriodoPWM 1/FrecuenciaPWM
19:            #define PRESCALERTIMER2 4
20:            #define asignaPR2 _XTAL_FREQ/PRESCALERTIMER2/4*PeriodoPWM-1
21:            
22:            void set_periodo_buzzer(void) {
23:                //PWM Period = [(PR2) + 1] * 4 * TOSC *(TMR2 Prescale Value)
24:                //PR2=PWM PERIOD/(4*TOSC*TMR2 Prescale Value)-1
25:                //para una frecuencia de __XTAL_FREQ/4=5Mhz
26:                PR2 = asignaPR2; //periodo;;//periodo; //asigno el periodo
1431  30FF     MOVLW 0xFF
1432  0092     MOVWF T2CON
27:                T2CONbits.TMR2ON = 1; //Habilito el timer2
1433  1283     BCF STATUS, 0x5
1434  1512     BSF T2CON, 0x2
28:                T2CONbits.T2CKPS = 1; //prescaler en 4
1435  0812     MOVF T2CON, W
1436  39FC     ANDLW 0xFC
1437  3801     IORLW 0x1
1438  0092     MOVWF T2CON
29:                // CCP1CONbits.CCP1M=0b1100; //Configuro el CCp1 como PWM
30:                RB2 = 0;
1439  1106     BCF PORTB, 0x2
31:                TRISC2 = 0; //pongo el pin RC2/PWM1 como salida
143A  1683     BSF STATUS, 0x5
143B  1107     BCF PORTC, 0x2
32:            #warning No olvidar que si el PWM_duty > PWM_period no queda bien definida la frecuencia
33:                set_duty(512);
143C  1283     BCF STATUS, 0x5
34:            }
35:            
36:            /*/PWM Duty Cycle =(CCPR1L:CCP1CON<5:4>)*TOSC*(TMR2 Prescale Value)*/
37:            void set_duty(unsigned int duty) {
38:            
39:            #define PWM10Bits
40:                //pwm modo 10bits
41:            #ifdef PWM10Bits
42:                CCPR1L = duty >> 2;
1441  0824     MOVF dato, W
1442  00A6     MOVWF x
1443  0823     MOVF x, W
1444  00A5     MOVWF y
1445  1003     BCF STATUS, 0x0
1446  0CA6     RRF x, F
1447  0CA5     RRF y, F
1448  1003     BCF STATUS, 0x0
1449  0CA6     RRF x, F
144A  0CA5     RRF y, F
144B  0825     MOVF y, W
144C  0095     MOVWF CCPR1
43:            #endif
44:                CCP1CON = (CCP1CON & 0xCF) | ((duty << 4) & 0x30);
144D  0823     MOVF x, W
144E  00A5     MOVWF y
144F  0E25     SWAPF y, W
1450  39F0     ANDLW 0xF0
1451  00A5     MOVWF y
1452  3930     ANDLW 0x30
1453  00A6     MOVWF x
1454  0817     MOVF CCP1CON, W
1455  39CF     ANDLW 0xCF
1456  0426     IORWF x, W
1457  0097     MOVWF CCP1CON
45:            
46:            
47:            
48:            }
1458  0008     RETURN
49:            
50:            void buzzer_off(void) {
0800  30F0     MOVLW 0xF0
0FE5  30F0     MOVLW 0xF0
51:                //activapor=0;
52:                CCP1CONbits.CCP1M = 0; //desactiva pwm
0800  30F0     MOVLW 0xF0
0801  1283     BCF STATUS, 0x5
0802  1303     BCF STATUS, 0x6
0803  0597     ANDWF CCP1CON, F
0FE5  30F0     MOVLW 0xF0
0FE6  1283     BCF STATUS, 0x5
0FE7  0597     ANDWF CCP1CON, F
53:                PORTCbits.RC2 = 0; //pongo el pin de reloj en bajo
0804  1107     BCF PORTC, 0x2
0FE8  1107     BCF PORTC, 0x2
54:            
55:            }
0805  0008     RETURN
0FE9  0008     RETURN
56:            
57:            void buzzer_on(void) {
0FEA  3003     MOVLW 0x3
141B  3003     MOVLW 0x3
58:                activapwmpor = 3;
0FEA  3003     MOVLW 0x3
0FEB  1683     BSF STATUS, 0x5
0FEC  1303     BCF STATUS, 0x6
0FED  00B3     MOVWF dividend
141B  3003     MOVLW 0x3
141C  1683     BSF STATUS, 0x5
141D  1303     BCF STATUS, 0x6
141E  00B3     MOVWF dividend
59:                CCP1CONbits.CCP1M = 0b1100; //activa pwm
0FEE  1283     BCF STATUS, 0x5
0FEF  0817     MOVF CCP1CON, W
0FF0  39F0     ANDLW 0xF0
0FF1  380C     IORLW 0xC
0FF2  0097     MOVWF CCP1CON
141F  1283     BCF STATUS, 0x5
1420  0817     MOVF CCP1CON, W
1421  39F0     ANDLW 0xF0
1422  380C     IORLW 0xC
1423  0097     MOVWF CCP1CON
60:            }
0FF3  0008     RETURN
1424  0008     RETURN
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/main.c  -------------------------------
1:             /******************************************************************************/
2:             /* Files to Include                                                           */
3:             /******************************************************************************/
4:             // Real Time Clock & NVRAM
5:             // Hardware isl1208 of Dallas Maxim
6:             // With interface I2C
7:             #ifndef __PICCPRO__
8:             #define __PICCPRO__
9:             #endif
10:            #if defined(__XC)
11:            #include <xc.h>         /* XC8 General Include File */
12:            #elif defined(HI_TECH_C)
13:            #include <htc.h>        /* HiTech General Include File */
14:            #endif
15:            
16:            #include <stdint.h>        /* For uint8_t definition */
17:            #include <stdbool.h>       /* For true/false definition */
18:            #include <stdio.h>
19:            #include "system.h"        /* System funct/params, like osc/peripheral config */
20:            #include "user.h"          /* User funct/params, such as InitApp */
21:            #include "Pulsadores.h"
22:            #include "pwm.h"
23:            #include "adcPic16.h"
24:            /******************************************************************************/
25:            /* User Global Variable Declaration                                           */
26:            /******************************************************************************/
27:            
28:            /* i.e. uint8_t <variable_name>; */
29:            
30:            /******************************************************************************/
31:            /* Main Program                                                               */
32:            /******************************************************************************/
33:            
34:            //#fuses HS,MCLR,NOWDT,NOPROTECT,NOPUT,NOBROWNOUT,NOPBADEN,NOLVP,NOCPD,NODEBUG,NOWRT,NOVREGEN
35:            //#use delay(clock=20000000)
36:            //#use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7)
37:            
38:            
39:            #define USE_INTERRUPTS 1
40:            
41:            #include "_isl1208.h"
42:            #include "HardI2C.h"
43:            #include "usart1.h"
44:            #include "LCDGeneric.h"
45:            ///////////////////////////////////////////////////////////////////////////////
46:            
47:            void lee_y_transmite_date_and_time(void) {
48:                isl1208_get_date(&fecha.day, &fecha.month, &fecha.yr, &fecha.dow);
0878  306D     MOVLW 0x6D
0879  1283     BCF STATUS, 0x5
087A  00A8     MOVWF mth
087B  306E     MOVLW 0x6E
087C  00A9     MOVWF year
087D  306F     MOVLW 0x6F
087E  00AA     MOVWF Data
087F  306C     MOVLW 0x6C
0880  2208     CALL 0x208
0881  120A     BCF PCLATH, 0x4
0882  158A     BSF PCLATH, 0x3
49:                isl1208_get_time(&horarioactual.hrs, &horarioactual.min, &horarioactual.sec);
0883  30DF     MOVLW 0xDF
50:            }
51:            
52:            void main() {
53:                TMR1IE = 0; //   disable_interrupts(int_timer1);
0029  1683     BSF STATUS, 0x5
002A  100C     BCF PIR1, 0x0
54:                RCIE = 0; //    disable_interrupts(int_rda);
002B  128C     BCF PIR1, 0x5
55:                RBIE = 0;
002C  118B     BCF INTCON, 0x3
56:                INTE = 0; //disable_interrupts(int_ext);
002D  120B     BCF INTCON, 0x4
57:                ADCON1 = 0x06; //todos puertos digitales
002E  3006     MOVLW 0x6
002F  009F     MOVWF ADCON0
58:                //setup_counters(RTCC_INTERNAL,RTCC_DIV_2);
59:                T0CS = 0; // TMR0 Clock Source Select bit: internal
0030  1281     BCF TMR0, 0x5
60:                PSA = 0; //Prescaler is assigned to the Timer0 module
0031  1181     BCF TMR0, 0x3
61:                OPTION_REGbits.PS = 0b101; //: Prescaler Rate Select bits 1/64
0032  0801     MOVF TMR0, W
0033  39F8     ANDLW 0xF8
0034  3805     IORLW 0x5
0035  0081     MOVWF TMR0
62:                //setup_timer_1(T1_INTERNAL | T1_DIV_BY_1);
63:                T1CON = 1;
0036  3001     MOVLW 0x1
0037  1283     BCF STATUS, 0x5
0038  0090     MOVWF T1CON
64:                CCP1CONbits.CCP1M = 0;
0039  30F0     MOVLW 0xF0
003A  0597     ANDWF CCP1CON, F
65:                //configura_USART();
66:                setup_i2c(I2C_MASTER);
003B  3038     MOVLW 0x38
003C  120A     BCF PCLATH, 0x4
003D  158A     BSF PCLATH, 0x3
003E  2006     CALL 0x6
003F  120A     BCF PCLATH, 0x4
0040  118A     BCF PCLATH, 0x3
67:            
68:            
69:                TRISB = 0b00111111; //Configuro las entradas de las teclas y la entrada del reloj
0041  303F     MOVLW 0x3F
0042  1683     BSF STATUS, 0x5
0043  0086     MOVWF PORTB
70:                PORTB = 0;
0044  1283     BCF STATUS, 0x5
0045  0186     CLRF PORTB
71:                TRISC0 = 0; //Configuro el pin de activacion de la bomba como salida
0046  1683     BSF STATUS, 0x5
0047  1007     BCF PORTC, 0x0
72:                TRISD = 0x00;
0048  0188     CLRF PORTD
73:                PORTD = 0;
0049  1283     BCF STATUS, 0x5
004A  0188     CLRF PORTD
74:                TRISE = 0b00000000;
004B  1683     BSF STATUS, 0x5
004C  0189     CLRF PORTE
75:                PORTE = 0;
004D  1283     BCF STATUS, 0x5
004E  0189     CLRF PORTE
76:            
77:                vInitLCD();
004F  160A     BSF PCLATH, 0x4
0050  118A     BCF PCLATH, 0x3
0051  24E1     CALL 0x4E1
0052  120A     BCF PCLATH, 0x4
0053  118A     BCF PCLATH, 0x3
78:                static char * cadena;
79:                sprintf(cadenaamostrar, cadena_esp);
0054  3031     MOVLW 0x31
0055  00C7     MOVWF f
0056  3098     MOVLW 0x98
0057  00C8     MOVWF 0x48
0058  30CA     MOVLW 0xCA
0059  120A     BCF PCLATH, 0x4
005A  118A     BCF PCLATH, 0x3
005B  25BE     CALL 0x5BE
005C  120A     BCF PCLATH, 0x4
005D  118A     BCF PCLATH, 0x3
80:                sprintf(cadenaamostrar2, cadena_esp);
005E  3031     MOVLW 0x31
005F  00C7     MOVWF f
0060  3098     MOVLW 0x98
0061  00C8     MOVWF 0x48
0062  30D2     MOVLW 0xD2
0063  120A     BCF PCLATH, 0x4
0064  118A     BCF PCLATH, 0x3
0065  25BE     CALL 0x5BE
0066  120A     BCF PCLATH, 0x4
0067  118A     BCF PCLATH, 0x3
81:                vGotoxyLCD(1, 1);
0068  3001     MOVLW 0x1
0069  01A5     CLRF y
006A  0AA5     INCF y, F
006B  160A     BSF PCLATH, 0x4
006C  118A     BCF PCLATH, 0x3
006D  2496     CALL 0x496
006E  120A     BCF PCLATH, 0x4
006F  118A     BCF PCLATH, 0x3
82:                cadena = cadenaamostrar;
0070  30CA     MOVLW 0xCA
0071  1683     BSF STATUS, 0x5
0072  00C9     MOVWF 0x49
83:                while (*cadena != '\0')
0073  0849     MOVF 0x49, W
0074  0084     MOVWF FSR
0075  1383     BCF STATUS, 0x7
0076  0880     MOVF INDF, F
0077  1903     BTFSC STATUS, 0x2
0078  2885     GOTO 0x85
0084  2873     GOTO 0x73
84:                    vLCD_Putc(*cadena++);
0079  0849     MOVF 0x49, W
007A  0084     MOVWF FSR
007B  0800     MOVF INDF, W
007C  160A     BSF PCLATH, 0x4
007D  118A     BCF PCLATH, 0x3
007E  24B9     CALL 0x4B9
007F  120A     BCF PCLATH, 0x4
0080  118A     BCF PCLATH, 0x3
0081  1683     BSF STATUS, 0x5
0082  1303     BCF STATUS, 0x6
0083  0AC9     INCF 0x49, F
85:                vGotoxyLCD(1, 2);
0085  3002     MOVLW 0x2
0086  1283     BCF STATUS, 0x5
0087  00A5     MOVWF y
0088  3001     MOVLW 0x1
0089  160A     BSF PCLATH, 0x4
008A  118A     BCF PCLATH, 0x3
008B  2496     CALL 0x496
008C  120A     BCF PCLATH, 0x4
008D  118A     BCF PCLATH, 0x3
86:                cadena = cadenaamostrar2;
008E  30D2     MOVLW 0xD2
008F  1683     BSF STATUS, 0x5
0090  00C9     MOVWF 0x49
87:                while (*cadena != '\0')
0091  0849     MOVF 0x49, W
0092  0084     MOVWF FSR
0093  1383     BCF STATUS, 0x7
0094  0880     MOVF INDF, F
0095  1903     BTFSC STATUS, 0x2
0096  28A3     GOTO 0xA3
00A2  2891     GOTO 0x91
88:                    vLCD_Putc(*cadena++);
0097  0849     MOVF 0x49, W
0098  0084     MOVWF FSR
0099  0800     MOVF INDF, W
009A  160A     BSF PCLATH, 0x4
009B  118A     BCF PCLATH, 0x3
009C  24B9     CALL 0x4B9
009D  120A     BCF PCLATH, 0x4
009E  118A     BCF PCLATH, 0x3
009F  1683     BSF STATUS, 0x5
00A0  1303     BCF STATUS, 0x6
00A1  0AC9     INCF 0x49, F
89:                refrescadisplay = 0;
00A3  300D     MOVLW 0xD
00A4  01C5     CLRF dia
90:                __delay_ms(500);
00A3  300D     MOVLW 0xD
00A5  1283     BCF STATUS, 0x5
00A6  00DE     MOVWF 0x5E
00A7  30AF     MOVLW 0xAF
00A8  00DD     MOVWF 0x5D
00A9  30C1     MOVLW 0xC1
00AA  00DC     MOVWF 0x5C
00AB  0BDC     DECFSZ 0x5C, F
00AC  28AB     GOTO 0xAB
00AD  0BDD     DECFSZ 0x5D, F
00AE  28AB     GOTO 0xAB
00AF  0BDE     DECFSZ 0x5E, F
00B0  28AB     GOTO 0xAB
00B1  0000     NOP
91:                sprintf(cadenaamostrar, "Ini...");
00B2  303C     MOVLW 0x3C
00B3  1283     BCF STATUS, 0x5
00B4  1303     BCF STATUS, 0x6
00B5  00C7     MOVWF f
00B6  3099     MOVLW 0x99
00B7  00C8     MOVWF 0x48
00B8  30CA     MOVLW 0xCA
00B9  120A     BCF PCLATH, 0x4
00BA  118A     BCF PCLATH, 0x3
00BB  25BE     CALL 0x5BE
00BC  120A     BCF PCLATH, 0x4
00BD  118A     BCF PCLATH, 0x3
92:                vGotoxyLCD(1, 1);
00BE  3001     MOVLW 0x1
00BF  01A5     CLRF y
00C0  0AA5     INCF y, F
00C1  160A     BSF PCLATH, 0x4
00C2  118A     BCF PCLATH, 0x3
00C3  2496     CALL 0x496
00C4  120A     BCF PCLATH, 0x4
00C5  118A     BCF PCLATH, 0x3
93:                cadena = cadenaamostrar;
00C6  30CA     MOVLW 0xCA
00C7  1683     BSF STATUS, 0x5
00C8  00C9     MOVWF 0x49
94:                while (*cadena != '\0')
00C9  0849     MOVF 0x49, W
00CA  0084     MOVWF FSR
00CB  1383     BCF STATUS, 0x7
00CC  0880     MOVF INDF, F
00CD  1903     BTFSC STATUS, 0x2
00CE  28DB     GOTO 0xDB
00DA  28C9     GOTO 0xC9
95:                    vLCD_Putc(*cadena++);
00CF  0849     MOVF 0x49, W
00D0  0084     MOVWF FSR
00D1  0800     MOVF INDF, W
00D2  160A     BSF PCLATH, 0x4
00D3  118A     BCF PCLATH, 0x3
00D4  24B9     CALL 0x4B9
00D5  120A     BCF PCLATH, 0x4
00D6  118A     BCF PCLATH, 0x3
00D7  1683     BSF STATUS, 0x5
00D8  1303     BCF STATUS, 0x6
00D9  0AC9     INCF 0x49, F
96:                vGotoxyLCD(1, 2);
00DB  3002     MOVLW 0x2
00DC  1283     BCF STATUS, 0x5
00DD  00A5     MOVWF y
00DE  3001     MOVLW 0x1
00DF  160A     BSF PCLATH, 0x4
00E0  118A     BCF PCLATH, 0x3
00E1  2496     CALL 0x496
00E2  120A     BCF PCLATH, 0x4
00E3  118A     BCF PCLATH, 0x3
97:                cadena = cadenaamostrar2;
00E4  30D2     MOVLW 0xD2
00E5  1683     BSF STATUS, 0x5
00E6  00C9     MOVWF 0x49
98:                while (*cadena != '\0')
00E7  0849     MOVF 0x49, W
00E8  0084     MOVWF FSR
00E9  1383     BCF STATUS, 0x7
00EA  0880     MOVF INDF, F
00EB  1903     BTFSC STATUS, 0x2
00EC  28F9     GOTO 0xF9
00F8  28E7     GOTO 0xE7
99:                    vLCD_Putc(*cadena++);
00ED  0849     MOVF 0x49, W
00EE  0084     MOVWF FSR
00EF  0800     MOVF INDF, W
00F0  160A     BSF PCLATH, 0x4
00F1  118A     BCF PCLATH, 0x3
00F2  24B9     CALL 0x4B9
00F3  120A     BCF PCLATH, 0x4
00F4  118A     BCF PCLATH, 0x3
00F5  1683     BSF STATUS, 0x5
00F6  1303     BCF STATUS, 0x6
00F7  0AC9     INCF 0x49, F
100:               refrescadisplay = 0;
00F9  01C5     CLRF dia
101:           
102:           
103:               set_periodo_buzzer(); //configuro el pwm para una frecuencia de 3khz
00FA  160A     BSF PCLATH, 0x4
00FB  118A     BCF PCLATH, 0x3
00FC  2431     CALL 0x431
00FD  120A     BCF PCLATH, 0x4
00FE  118A     BCF PCLATH, 0x3
104:               buzzer_on();
00FF  160A     BSF PCLATH, 0x4
0100  118A     BCF PCLATH, 0x3
0101  241B     CALL 0x41B
0102  120A     BCF PCLATH, 0x4
0103  118A     BCF PCLATH, 0x3
105:               __delay_ms(200);
0104  3006     MOVLW 0x6
0105  00DE     MOVWF 0x5E
0106  3013     MOVLW 0x13
0107  00DD     MOVWF 0x5D
0108  30B1     MOVLW 0xB1
0109  00DC     MOVWF 0x5C
010A  0BDC     DECFSZ 0x5C, F
010B  290A     GOTO 0x10A
010C  0BDD     DECFSZ 0x5D, F
010D  290A     GOTO 0x10A
010E  0BDE     DECFSZ 0x5E, F
010F  290A     GOTO 0x10A
0110  2911     GOTO 0x111
106:               buzzer_off();
0111  120A     BCF PCLATH, 0x4
0112  158A     BSF PCLATH, 0x3
0113  2000     CALL 0x0
0114  120A     BCF PCLATH, 0x4
0115  118A     BCF PCLATH, 0x3
107:               __delay_ms(200);
0116  3006     MOVLW 0x6
0117  00DE     MOVWF 0x5E
0118  3013     MOVLW 0x13
0119  00DD     MOVWF 0x5D
011A  30B1     MOVLW 0xB1
011B  00DC     MOVWF 0x5C
011C  0BDC     DECFSZ 0x5C, F
011D  291C     GOTO 0x11C
011E  0BDD     DECFSZ 0x5D, F
011F  291C     GOTO 0x11C
0120  0BDE     DECFSZ 0x5E, F
0121  291C     GOTO 0x11C
0122  2923     GOTO 0x123
108:               buzzer_on();
0123  160A     BSF PCLATH, 0x4
0124  118A     BCF PCLATH, 0x3
0125  241B     CALL 0x41B
0126  120A     BCF PCLATH, 0x4
0127  118A     BCF PCLATH, 0x3
109:               __delay_ms(200);
0128  3006     MOVLW 0x6
0129  00DE     MOVWF 0x5E
012A  3013     MOVLW 0x13
012B  00DD     MOVWF 0x5D
012C  30B1     MOVLW 0xB1
012D  00DC     MOVWF 0x5C
012E  0BDC     DECFSZ 0x5C, F
012F  292E     GOTO 0x12E
0130  0BDD     DECFSZ 0x5D, F
0131  292E     GOTO 0x12E
0132  0BDE     DECFSZ 0x5E, F
0133  292E     GOTO 0x12E
0134  2935     GOTO 0x135
110:               buzzer_off();
0135  120A     BCF PCLATH, 0x4
0136  158A     BSF PCLATH, 0x3
0137  2000     CALL 0x0
0138  120A     BCF PCLATH, 0x4
0139  118A     BCF PCLATH, 0x3
111:               //ext_int_edge(2,H_TO_L);
112:               INTEDG = 0;
013A  1683     BSF STATUS, 0x5
013B  1301     BCF TMR0, 0x6
113:               INTE = 1; // enable_interrupts(int_ext2);
013C  160B     BSF INTCON, 0x4
114:               TMR0IE = 1;
013D  168B     BSF INTCON, 0x5
115:               setADCChannel(MIDECORRIENTE);
013E  3000     MOVLW 0x0
013F  160A     BSF PCLATH, 0x4
0140  118A     BCF PCLATH, 0x3
0141  2425     CALL 0x425
0142  120A     BCF PCLATH, 0x4
0143  118A     BCF PCLATH, 0x3
116:               __delay_us(20);
0144  3021     MOVLW 0x21
0145  00DC     MOVWF 0x5C
0146  0BDC     DECFSZ 0x5C, F
0147  2946     GOTO 0x146
117:               openADC();
0148  120A     BCF PCLATH, 0x4
0149  118A     BCF PCLATH, 0x3
014A  27EB     CALL 0x7EB
014B  120A     BCF PCLATH, 0x4
014C  118A     BCF PCLATH, 0x3
118:               __delay_us(20);
014D  3021     MOVLW 0x21
014E  00DC     MOVWF 0x5C
014F  0BDC     DECFSZ 0x5C, F
0150  294F     GOTO 0x14F
119:               interruptADC_on();
0151  160A     BSF PCLATH, 0x4
0152  118A     BCF PCLATH, 0x3
0153  240F     CALL 0x40F
0154  120A     BCF PCLATH, 0x4
0155  118A     BCF PCLATH, 0x3
120:               __delay_ms(500);
0156  300D     MOVLW 0xD
0157  1283     BCF STATUS, 0x5
0158  00DE     MOVWF 0x5E
0159  30AF     MOVLW 0xAF
015A  00DD     MOVWF 0x5D
015B  30C1     MOVLW 0xC1
015C  00DC     MOVWF 0x5C
015D  0BDC     DECFSZ 0x5C, F
015E  295D     GOTO 0x15D
015F  0BDD     DECFSZ 0x5D, F
0160  295D     GOTO 0x15D
0161  0BDE     DECFSZ 0x5E, F
0162  295D     GOTO 0x15D
0163  0000     NOP
121:           
122:           
123:               ADIF = 0;
0164  1283     BCF STATUS, 0x5
0165  1303     BCF STATUS, 0x6
0166  130C     BCF PIR1, 0x6
124:               INTF = 0; // borro las banderas de interrupcion
0167  108B     BCF INTCON, 0x1
125:               TMR0IF = 0;
0168  110B     BCF INTCON, 0x2
126:           
127:               if (ISL1208_ready()) {
0169  120A     BCF PCLATH, 0x4
016A  158A     BSF PCLATH, 0x3
016B  2149     CALL 0x149
016C  120A     BCF PCLATH, 0x4
016D  118A     BCF PCLATH, 0x3
016E  3A00     XORLW 0x0
016F  1903     BTFSC STATUS, 0x2
0170  29C5     GOTO 0x1C5
128:                   sprintf(cadenaamostrar, "RTC OK");
0171  3043     MOVLW 0x43
0172  00C7     MOVWF f
0173  3099     MOVLW 0x99
0174  00C8     MOVWF 0x48
0175  30CA     MOVLW 0xCA
0176  120A     BCF PCLATH, 0x4
0177  118A     BCF PCLATH, 0x3
0178  25BE     CALL 0x5BE
0179  120A     BCF PCLATH, 0x4
017A  118A     BCF PCLATH, 0x3
129:                   vGotoxyLCD(1, 1);
017B  3001     MOVLW 0x1
017C  01A5     CLRF y
017D  0AA5     INCF y, F
017E  160A     BSF PCLATH, 0x4
017F  118A     BCF PCLATH, 0x3
0180  2496     CALL 0x496
0181  120A     BCF PCLATH, 0x4
0182  118A     BCF PCLATH, 0x3
130:                   cadena = cadenaamostrar;
0183  30CA     MOVLW 0xCA
0184  1683     BSF STATUS, 0x5
0185  00C9     MOVWF 0x49
131:                   while (*cadena != '\0')
0186  0849     MOVF 0x49, W
0187  0084     MOVWF FSR
0188  1383     BCF STATUS, 0x7
0189  0880     MOVF INDF, F
018A  1903     BTFSC STATUS, 0x2
018B  2998     GOTO 0x198
0197  2986     GOTO 0x186
132:                       vLCD_Putc(*cadena++);
018C  0849     MOVF 0x49, W
018D  0084     MOVWF FSR
018E  0800     MOVF INDF, W
018F  160A     BSF PCLATH, 0x4
0190  118A     BCF PCLATH, 0x3
0191  24B9     CALL 0x4B9
0192  120A     BCF PCLATH, 0x4
0193  118A     BCF PCLATH, 0x3
0194  1683     BSF STATUS, 0x5
0195  1303     BCF STATUS, 0x6
0196  0AC9     INCF 0x49, F
133:           
134:                   __delay_ms(500);
0198  300D     MOVLW 0xD
0199  1283     BCF STATUS, 0x5
019A  00DE     MOVWF 0x5E
019B  30AF     MOVLW 0xAF
019C  00DD     MOVWF 0x5D
019D  30C1     MOVLW 0xC1
019E  00DC     MOVWF 0x5C
019F  0BDC     DECFSZ 0x5C, F
01A0  299F     GOTO 0x19F
01A1  0BDD     DECFSZ 0x5D, F
01A2  299F     GOTO 0x19F
01A3  0BDE     DECFSZ 0x5E, F
01A4  299F     GOTO 0x19F
01A5  0000     NOP
135:                   __delay_ms(500);
01A6  300D     MOVLW 0xD
01A7  1283     BCF STATUS, 0x5
01A8  1303     BCF STATUS, 0x6
01A9  00DE     MOVWF 0x5E
01AA  30AF     MOVLW 0xAF
01AB  00DD     MOVWF 0x5D
01AC  30C1     MOVLW 0xC1
01AD  00DC     MOVWF 0x5C
01AE  0BDC     DECFSZ 0x5C, F
01AF  29AE     GOTO 0x1AE
01B0  0BDD     DECFSZ 0x5D, F
01B1  29AE     GOTO 0x1AE
01B2  0BDE     DECFSZ 0x5E, F
01B3  29AE     GOTO 0x1AE
01B4  0000     NOP
136:                   __delay_ms(500);
01B5  300D     MOVLW 0xD
01B6  1283     BCF STATUS, 0x5
01B7  1303     BCF STATUS, 0x6
01B8  00DE     MOVWF 0x5E
01B9  30AF     MOVLW 0xAF
01BA  00DD     MOVWF 0x5D
01BB  30C1     MOVLW 0xC1
01BC  00DC     MOVWF 0x5C
01BD  0BDC     DECFSZ 0x5C, F
01BE  29BD     GOTO 0x1BD
01BF  0BDD     DECFSZ 0x5D, F
01C0  29BD     GOTO 0x1BD
01C1  0BDE     DECFSZ 0x5E, F
01C2  29BD     GOTO 0x1BD
01C3  0000     NOP
137:               } else {
01C4  29EC     GOTO 0x1EC
138:                   sprintf(cadenaamostrar, "RTC ERRO");
01C5  302A     MOVLW 0x2A
01C6  00C7     MOVWF f
01C7  3099     MOVLW 0x99
01C8  00C8     MOVWF 0x48
01C9  30CA     MOVLW 0xCA
01CA  120A     BCF PCLATH, 0x4
01CB  118A     BCF PCLATH, 0x3
01CC  25BE     CALL 0x5BE
01CD  120A     BCF PCLATH, 0x4
01CE  118A     BCF PCLATH, 0x3
139:                   vGotoxyLCD(1, 1);
01CF  3001     MOVLW 0x1
01D0  01A5     CLRF y
01D1  0AA5     INCF y, F
01D2  160A     BSF PCLATH, 0x4
01D3  118A     BCF PCLATH, 0x3
01D4  2496     CALL 0x496
01D5  120A     BCF PCLATH, 0x4
01D6  118A     BCF PCLATH, 0x3
140:                   cadena = cadenaamostrar;
01D7  30CA     MOVLW 0xCA
01D8  1683     BSF STATUS, 0x5
01D9  00C9     MOVWF 0x49
141:                   while (*cadena != '\0')
01DA  0849     MOVF 0x49, W
01DB  0084     MOVWF FSR
01DC  1383     BCF STATUS, 0x7
01DD  0880     MOVF INDF, F
01DE  1903     BTFSC STATUS, 0x2
01DF  2998     GOTO 0x198
01EB  29DA     GOTO 0x1DA
142:                       vLCD_Putc(*cadena++);
01E0  0849     MOVF 0x49, W
01E1  0084     MOVWF FSR
01E2  0800     MOVF INDF, W
01E3  160A     BSF PCLATH, 0x4
01E4  118A     BCF PCLATH, 0x3
01E5  24B9     CALL 0x4B9
01E6  120A     BCF PCLATH, 0x4
01E7  118A     BCF PCLATH, 0x3
01E8  1683     BSF STATUS, 0x5
01E9  1303     BCF STATUS, 0x6
01EA  0AC9     INCF 0x49, F
143:           
144:                   __delay_ms(500);
145:                   __delay_ms(500);
146:                   __delay_ms(500);
147:           
148:               };
149:               fecha.day = 1;
01EC  1283     BCF STATUS, 0x5
01ED  1303     BCF STATUS, 0x6
01EF  01EC     CLRF fecha
01F0  0AEC     INCF fecha, F
150:               fecha.month = 1;
01F1  01ED     CLRF 0x6D
01F2  0AED     INCF 0x6D, F
151:               fecha.yr = 15;
01EE  300F     MOVLW 0xF
01F3  00EE     MOVWF 0x6E
152:               fecha.dow = 4;
01F4  3004     MOVLW 0x4
01F5  00EF     MOVWF 0x6F
153:               isl1208SR.Valor = 0x00;
01F6  1683     BSF STATUS, 0x5
01F7  01C3     CLRF dow
154:               isl1208SR.Valor = ISL1208_Read_status();
01F8  120A     BCF PCLATH, 0x4
01F9  158A     BSF PCLATH, 0x3
01FA  2159     CALL 0x159
01FB  120A     BCF PCLATH, 0x4
01FC  118A     BCF PCLATH, 0x3
01FD  1683     BSF STATUS, 0x5
01FE  00C3     MOVWF dow
155:               if (isl1208SR.RTCF) {//Si se reseteo el RTC, envio directamente a configurar la hora
01FF  1C43     BTFSS dow, 0x0
0200  2A04     GOTO 0x204
156:                   menuactual = MENU_CONFIGURAHORARIO;
0201  3003     MOVLW 0x3
0202  00C4     MOVWF a
157:           
158:               } else {
0203  2A1A     GOTO 0x21A
159:                   lee_y_transmite_date_and_time();
0204  120A     BCF PCLATH, 0x4
0205  158A     BSF PCLATH, 0x3
0206  2078     CALL 0x78
0207  120A     BCF PCLATH, 0x4
0208  118A     BCF PCLATH, 0x3
160:           
161:                   /*TODO leer el valor de la alarma de encendido en algun lado cuando se cambia el
162:                    valor de horarioenc pero no se guarda
163:                    */
164:                   isl1208_get_time_enc(&horarioenc.hrs, &horarioenc.min, &horarioenc.sec);
0209  30E2     MOVLW 0xE2
020A  1283     BCF STATUS, 0x5
020B  00A8     MOVWF mth
020C  30E1     MOVLW 0xE1
020D  00A9     MOVWF year
020E  30E3     MOVLW 0xE3
020F  120A     BCF PCLATH, 0x4
0210  158A     BSF PCLATH, 0x3
0211  21CF     CALL 0x1CF
0212  120A     BCF PCLATH, 0x4
0213  118A     BCF PCLATH, 0x3
165:                   isl1208_get_dow_enc(&fechaenc.dow);
0214  30DD     MOVLW 0xDD
0215  120A     BCF PCLATH, 0x4
0216  158A     BSF PCLATH, 0x3
0217  2174     CALL 0x174
0218  120A     BCF PCLATH, 0x4
0219  118A     BCF PCLATH, 0x3
166:                   //TODO tengo que detectar si la alarma se activo cunado el sistema estaba apagado y procesarla
167:               }
168:               ei(); //enable_interrupts(global);
021A  178B     BSF INTCON, 0x7
021B  2CF5     GOTO 0x4F5
169:               // Inicializa isl1208
170:               //TODO   isl1208_init(isl1208_OUT_ENABLED | isl1208_OUT_1_HZ);
171:           
172:               while (1) {//
173:                   // di(); //
174:                   //Inicia Procesa los men
175:                   ////////////////////////////////////////
176:                   switch (menuactual) {
04F5  1683     BSF STATUS, 0x5
04F6  1303     BCF STATUS, 0x6
04F7  0844     MOVF a, W
04F8  0084     MOVWF FSR
04F9  3012     MOVLW 0x12
04FA  0204     SUBWF FSR, W
04FB  1803     BTFSC STATUS, 0x0
04FC  2D04     GOTO 0x504
04FD  3010     MOVLW 0x10
04FE  008A     MOVWF PCLATH
04FF  1003     BCF STATUS, 0x0
0500  0D04     RLF FSR, W
0501  0704     ADDWF FSR, W
0502  3E00     ADDLW 0x0
0503  0082     MOVWF PCL
1000  120A     BCF PCLATH, 0x4
1001  118A     BCF PCLATH, 0x3
1002  2A1C     GOTO 0x21C
1003  120A     BCF PCLATH, 0x4
1004  118A     BCF PCLATH, 0x3
1005  2A66     GOTO 0x266
1006  120A     BCF PCLATH, 0x4
1007  118A     BCF PCLATH, 0x3
1008  2BEC     GOTO 0x3EC
1009  120A     BCF PCLATH, 0x4
100A  118A     BCF PCLATH, 0x3
100B  2A9B     GOTO 0x29B
100C  120A     BCF PCLATH, 0x4
100D  118A     BCF PCLATH, 0x3
100E  2AA3     GOTO 0x2A3
100F  120A     BCF PCLATH, 0x4
1010  118A     BCF PCLATH, 0x3
1011  2AD5     GOTO 0x2D5
1012  120A     BCF PCLATH, 0x4
1013  118A     BCF PCLATH, 0x3
1014  2AE7     GOTO 0x2E7
1015  120A     BCF PCLATH, 0x4
1016  118A     BCF PCLATH, 0x3
1017  2AEF     GOTO 0x2EF
1018  120A     BCF PCLATH, 0x4
1019  118A     BCF PCLATH, 0x3
101A  2AFD     GOTO 0x2FD
101B  120A     BCF PCLATH, 0x4
101C  118A     BCF PCLATH, 0x3
101D  2B0E     GOTO 0x30E
101E  120A     BCF PCLATH, 0x4
101F  118A     BCF PCLATH, 0x3
1020  2B4F     GOTO 0x34F
1021  120A     BCF PCLATH, 0x4
1022  118A     BCF PCLATH, 0x3
1023  2B57     GOTO 0x357
1024  120A     BCF PCLATH, 0x4
1025  118A     BCF PCLATH, 0x3
1026  2B67     GOTO 0x367
1027  120A     BCF PCLATH, 0x4
1028  118A     BCF PCLATH, 0x3
1029  2B89     GOTO 0x389
102A  120A     BCF PCLATH, 0x4
102B  118A     BCF PCLATH, 0x3
102C  2B9D     GOTO 0x39D
102D  120A     BCF PCLATH, 0x4
102E  118A     BCF PCLATH, 0x3
102F  2BB1     GOTO 0x3B1
1030  120A     BCF PCLATH, 0x4
1031  118A     BCF PCLATH, 0x3
1032  2BB2     GOTO 0x3B2
1033  120A     BCF PCLATH, 0x4
1034  118A     BCF PCLATH, 0x3
1035  2BCA     GOTO 0x3CA
177:                       case MENU_MUESTRAHORA:
178:                       {
179:                           horario = &horarioactual;
021C  30DE     MOVLW 0xDE
021D  00FD     MOVWF horario
180:                           //Se actualiza lo que se muestra en el display, solamente cuando hay cambios en lo que mostrar
181:           
182:                           if (flanco) {
021E  087C     MOVF flanco, W
021F  1903     BTFSC STATUS, 0x2
0220  2A46     GOTO 0x246
183:                               lee_y_transmite_date_and_time();
0221  120A     BCF PCLATH, 0x4
0222  158A     BSF PCLATH, 0x3
0223  2078     CALL 0x78
0224  120A     BCF PCLATH, 0x4
0225  118A     BCF PCLATH, 0x3
184:                               sprintf(cadenaamostrar, "%02d:%02d    ", horarioactual.hrs, horarioactual.min);
0226  3058     MOVLW 0x58
0227  1283     BCF STATUS, 0x5
0228  00C7     MOVWF f
0229  3098     MOVLW 0x98
022A  00C8     MOVWF 0x48
022B  1683     BSF STATUS, 0x5
022C  0860     MOVF 0x60, W
022D  1283     BCF STATUS, 0x5
022E  00C9     MOVWF 0x49
022F  01CA     CLRF cntr
0230  1683     BSF STATUS, 0x5
0231  085F     MOVF mediciondevoltaje, W
0232  1283     BCF STATUS, 0x5
0233  00CB     MOVWF sign
0234  30CA     MOVLW 0xCA
0235  01CC     CLRF f2
0236  120A     BCF PCLATH, 0x4
0237  118A     BCF PCLATH, 0x3
0238  25BE     CALL 0x5BE
0239  120A     BCF PCLATH, 0x4
023A  118A     BCF PCLATH, 0x3
185:                               sprintf(cadenaamostrar2, cadena_esp);
023B  3031     MOVLW 0x31
023C  00C7     MOVWF f
023D  3098     MOVLW 0x98
023E  00C8     MOVWF 0x48
023F  30D2     MOVLW 0xD2
0240  120A     BCF PCLATH, 0x4
0241  118A     BCF PCLATH, 0x3
0242  25BE     CALL 0x5BE
0243  120A     BCF PCLATH, 0x4
0244  118A     BCF PCLATH, 0x3
186:                           } else {
0245  2D04     GOTO 0x504
187:                               sprintf(cadenaamostrar, "%02d %02d    ", horarioactual.hrs, horarioactual.min);
0246  304A     MOVLW 0x4A
0247  1283     BCF STATUS, 0x5
0248  00C7     MOVWF f
0249  3098     MOVLW 0x98
024A  00C8     MOVWF 0x48
024B  1683     BSF STATUS, 0x5
024C  0860     MOVF 0x60, W
024D  1283     BCF STATUS, 0x5
024E  00C9     MOVWF 0x49
024F  01CA     CLRF cntr
0250  1683     BSF STATUS, 0x5
0251  085F     MOVF mediciondevoltaje, W
0252  1283     BCF STATUS, 0x5
0253  00CB     MOVWF sign
0254  30CA     MOVLW 0xCA
0255  01CC     CLRF f2
0256  120A     BCF PCLATH, 0x4
0257  118A     BCF PCLATH, 0x3
0258  25BE     CALL 0x5BE
0259  120A     BCF PCLATH, 0x4
025A  118A     BCF PCLATH, 0x3
188:                               sprintf(cadenaamostrar2, cadena_esp);
025B  3031     MOVLW 0x31
025C  00C7     MOVWF f
025D  3098     MOVLW 0x98
025E  00C8     MOVWF 0x48
025F  30D2     MOVLW 0xD2
0260  120A     BCF PCLATH, 0x4
0261  118A     BCF PCLATH, 0x3
0262  25BE     CALL 0x5BE
0263  120A     BCF PCLATH, 0x4
0264  118A     BCF PCLATH, 0x3
0265  2D04     GOTO 0x504
189:                           }
190:                           break;
191:                       }
192:                       case MENU_MUESTRAFECHA:
193:                       {
194:           
195:                           if (flanco) {
0266  087C     MOVF flanco, W
0267  1903     BTFSC STATUS, 0x2
0268  2D04     GOTO 0x504
196:                               lee_y_transmite_date_and_time();
0269  120A     BCF PCLATH, 0x4
026A  158A     BSF PCLATH, 0x3
026B  2078     CALL 0x78
026C  120A     BCF PCLATH, 0x4
026D  118A     BCF PCLATH, 0x3
197:                               sprintf(cadenaamostrar, "%02d/%02d/%02d ", fecha.day, fecha.month, fecha.yr);
026E  303A     MOVLW 0x3A
026F  1283     BCF STATUS, 0x5
0270  00C7     MOVWF f
0271  3098     MOVLW 0x98
0272  00C8     MOVWF 0x48
0273  086C     MOVF fecha, W
0274  00C9     MOVWF 0x49
0275  01CA     CLRF cntr
0276  086D     MOVF 0x6D, W
0277  00CB     MOVWF sign
0278  01CC     CLRF f2
0279  086E     MOVF 0x6E, W
027A  00CD     MOVWF 0x4D
027B  30CA     MOVLW 0xCA
027C  01CE     CLRF 0x4E
027D  120A     BCF PCLATH, 0x4
027E  118A     BCF PCLATH, 0x3
027F  25BE     CALL 0x5BE
0280  120A     BCF PCLATH, 0x4
0281  118A     BCF PCLATH, 0x3
198:                               sprintf(cadenaamostrar2, days_of_week[dia_de_la_semana(&fecha.day, &fecha.month, &fecha.yr)]);
0282  306E     MOVLW 0x6E
0283  00B8     MOVWF anio
0284  306D     MOVLW 0x6D
0285  00B7     MOVWF mes
0286  306C     MOVLW 0x6C
0287  120A     BCF PCLATH, 0x4
0288  158A     BSF PCLATH, 0x3
0289  208A     CALL 0x8A
028A  120A     BCF PCLATH, 0x4
028B  118A     BCF PCLATH, 0x3
028C  00EB     MOVWF 0x6B
028D  3003     MOVLW 0x3
028E  00A3     MOVWF x
028F  086B     MOVF 0x6B, W
0290  120A     BCF PCLATH, 0x4
0291  158A     BSF PCLATH, 0x3
0292  23AB     CALL 0x3AB
0293  120A     BCF PCLATH, 0x4
0294  118A     BCF PCLATH, 0x3
0295  3E1C     ADDLW 0x1C
0296  00C7     MOVWF f
0297  3098     MOVLW 0x98
0298  1803     BTFSC STATUS, 0x0
0299  3E01     ADDLW 0x1
029A  2BEA     GOTO 0x3EA
199:                           }
200:           
201:           
202:                           break;
203:                       }
204:                       case MENU_CONFIGURAHORARIO:
205:                       {
206:           
207:                           if (flanco) {
029B  087C     MOVF flanco, W
029C  1903     BTFSC STATUS, 0x2
029D  2D04     GOTO 0x504
208:                               sprintf(cadenaamostrar, "SET HORA ");
029E  30E7     MOVLW 0xE7
029F  1283     BCF STATUS, 0x5
02A0  00C7     MOVWF f
02A1  3098     MOVLW 0x98
02A2  2BE0     GOTO 0x3E0
209:                               sprintf(cadenaamostrar2, cadena_esp);
210:                           }
211:           
212:                           break;
213:                       }
214:                       case SUBMENU_CONFIGURAHORA:
215:                       {
216:                           modificafecha = HORA;
02A3  30DE     MOVLW 0xDE
02A4  01E4     CLRF 0x64
217:                           horario = &horarioactual;
02A3  30DE     MOVLW 0xDE
02A5  00FD     MOVWF horario
218:                           if (flanco || haycambio) {
02A6  08FC     MOVF flanco, F
02A7  1903     BTFSC STATUS, 0x2
02A8  0842     MOVF m, W
02A9  1903     BTFSC STATUS, 0x2
02AA  2ACD     GOTO 0x2CD
219:                               sprintf(cadenaamostrar, "%02d:%02d    ", horarioactual.hrs, horarioactual.min);
02AB  3058     MOVLW 0x58
02AC  1283     BCF STATUS, 0x5
02AD  00C7     MOVWF f
02AE  3098     MOVLW 0x98
02AF  00C8     MOVWF 0x48
02B0  1683     BSF STATUS, 0x5
02B1  0860     MOVF 0x60, W
02B2  1283     BCF STATUS, 0x5
02B3  00C9     MOVWF 0x49
02B4  01CA     CLRF cntr
02B5  1683     BSF STATUS, 0x5
02B6  085F     MOVF mediciondevoltaje, W
02B7  1283     BCF STATUS, 0x5
02B8  00CB     MOVWF sign
02B9  30CA     MOVLW 0xCA
02BA  01CC     CLRF f2
02BB  120A     BCF PCLATH, 0x4
02BC  118A     BCF PCLATH, 0x3
02BD  25BE     CALL 0x5BE
02BE  120A     BCF PCLATH, 0x4
02BF  118A     BCF PCLATH, 0x3
220:                               sprintf(cadenaamostrar2, cadena_esp);
02C0  3031     MOVLW 0x31
02C1  00C7     MOVWF f
02C2  3098     MOVLW 0x98
02C3  00C8     MOVWF 0x48
02C4  30D2     MOVLW 0xD2
02C5  120A     BCF PCLATH, 0x4
02C6  118A     BCF PCLATH, 0x3
02C7  25BE     CALL 0x5BE
02C8  120A     BCF PCLATH, 0x4
02C9  118A     BCF PCLATH, 0x3
221:                               haycambio = 0;
02CA  1683     BSF STATUS, 0x5
02CB  01C2     CLRF m
222:                           } else {
02CC  2D04     GOTO 0x504
223:                               sprintf(cadenaamostrar, "  :%02d    ", horarioactual.min);
02CD  309C     MOVLW 0x9C
02CE  1283     BCF STATUS, 0x5
02CF  00C7     MOVWF f
02D0  3098     MOVLW 0x98
02D1  00C8     MOVWF 0x48
02D2  1683     BSF STATUS, 0x5
02D3  085F     MOVF mediciondevoltaje, W
02D4  2B84     GOTO 0x384
224:                               sprintf(cadenaamostrar2, cadena_esp);
225:                           }
226:                           break;
227:                       }
228:                       case SUBMENU_CONFIGURAMINUTOS:
02D5  30DE     MOVLW 0xDE
229:                       {
230:                           modificafecha = MINUTOS;
02D6  01E4     CLRF 0x64
02D7  0AE4     INCF 0x64, F
231:                           horario = &horarioactual;
02D5  30DE     MOVLW 0xDE
02D8  00FD     MOVWF horario
232:                           if (flanco || haycambio) {
02D9  08FC     MOVF flanco, F
02DA  1D03     BTFSS STATUS, 0x2
02DB  2AAB     GOTO 0x2AB
02DC  0842     MOVF m, W
02DD  1D03     BTFSS STATUS, 0x2
233:                               sprintf(cadenaamostrar, "%02d:%02d    ", horarioactual.hrs, horarioactual.min);
02DE  2AAB     GOTO 0x2AB
234:                               sprintf(cadenaamostrar2, cadena_esp);
235:                               haycambio = 0;
236:                           } else {
237:                               sprintf(cadenaamostrar, "%02d:      ", horarioactual.hrs);
02DF  3090     MOVLW 0x90
02E0  1283     BCF STATUS, 0x5
02E1  00C7     MOVWF f
02E2  3098     MOVLW 0x98
02E3  00C8     MOVWF 0x48
02E4  1683     BSF STATUS, 0x5
02E5  0860     MOVF 0x60, W
02E6  2B84     GOTO 0x384
238:                               sprintf(cadenaamostrar2, cadena_esp);
239:                           }
240:                           break;
241:                       }
242:                       case MENU_CONFIGURAFECHA:
243:                       {
244:           
245:                           if (flanco) {
02E7  087C     MOVF flanco, W
02E8  1903     BTFSC STATUS, 0x2
02E9  2D04     GOTO 0x504
246:                               sprintf(cadenaamostrar, "SET FECHA");
02EA  30FB     MOVLW 0xFB
02EB  1283     BCF STATUS, 0x5
02EC  00C7     MOVWF f
02ED  3098     MOVLW 0x98
02EE  2BE0     GOTO 0x3E0
247:                               sprintf(cadenaamostrar2, cadena_esp);
248:                           }
249:                           break;
250:                       }
251:                       case SUBMENU_CONFIGURADIA:
252:                       {
253:                           modificafecha = DIA;
02EF  3002     MOVLW 0x2
02F0  00E4     MOVWF 0x64
254:           
255:                           if (flanco || haycambio) {
02F1  08FC     MOVF flanco, F
02F2  1903     BTFSC STATUS, 0x2
02F3  0842     MOVF m, W
02F4  1D03     BTFSS STATUS, 0x2
02F5  2B15     GOTO 0x315
256:                               sprintf(cadenaamostrar, "%02d/%02d/%02d ", fecha.day, fecha.month, fecha.yr);
257:                               sprintf(cadenaamostrar2, days_of_week[dia_de_la_semana(&fecha.day, &fecha.month, &fecha.yr)]);
258:                               //sprintf(cadenaamostrar2, "             ");
259:                               haycambio = 0;
260:                           } else {
261:                               sprintf(cadenaamostrar, "  /%02d/%02d ", fecha.month, fecha.yr);
02F6  3082     MOVLW 0x82
02F7  1283     BCF STATUS, 0x5
02F8  00C7     MOVWF f
02F9  3098     MOVLW 0x98
02FA  00C8     MOVWF 0x48
02FB  086D     MOVF 0x6D, W
02FC  2B0A     GOTO 0x30A
262:                               sprintf(cadenaamostrar2, cadena_esp);
263:                           }
264:                           break;
265:                       }
266:                       case SUBMENU_CONFIGURAMES:
267:                       {
268:                           modificafecha = MES;
02FD  3003     MOVLW 0x3
02FE  00E4     MOVWF 0x64
269:           
270:                           if (flanco || haycambio) {
02FF  08FC     MOVF flanco, F
0300  1903     BTFSC STATUS, 0x2
0301  0842     MOVF m, W
0302  1D03     BTFSS STATUS, 0x2
0303  2B15     GOTO 0x315
271:                               sprintf(cadenaamostrar, "%02d/%02d/%02d ", fecha.day, fecha.month, fecha.yr);
272:                               sprintf(cadenaamostrar2, days_of_week[dia_de_la_semana(&fecha.day, &fecha.month, &fecha.yr)]);
273:                               haycambio = 0;
274:                           } else {
275:                               sprintf(cadenaamostrar, "%02d/  /%02d ", fecha.day, fecha.yr);
0304  3074     MOVLW 0x74
0305  1283     BCF STATUS, 0x5
0306  00C7     MOVWF f
0307  3098     MOVLW 0x98
0308  00C8     MOVWF 0x48
0309  086C     MOVF fecha, W
030A  00C9     MOVWF 0x49
030B  01CA     CLRF cntr
030C  086E     MOVF 0x6E, W
030D  2B4B     GOTO 0x34B
276:                               sprintf(cadenaamostrar2, cadena_esp);
277:                           }
278:                           break;
279:                       }
280:                       case SUBMENU_CONFIGURAANIO:
281:                       {
282:                           modificafecha = ANIO;
030E  3004     MOVLW 0x4
030F  00E4     MOVWF 0x64
283:           
284:                           if (flanco || haycambio) {
0310  08FC     MOVF flanco, F
0311  1903     BTFSC STATUS, 0x2
0312  0842     MOVF m, W
0313  1903     BTFSC STATUS, 0x2
0314  2B42     GOTO 0x342
285:                               sprintf(cadenaamostrar, "%02d/%02d/%02d ", fecha.day, fecha.month, fecha.yr);
0315  303A     MOVLW 0x3A
0316  1283     BCF STATUS, 0x5
0317  00C7     MOVWF f
0318  3098     MOVLW 0x98
0319  00C8     MOVWF 0x48
031A  086C     MOVF fecha, W
031B  00C9     MOVWF 0x49
031C  01CA     CLRF cntr
031D  086D     MOVF 0x6D, W
031E  00CB     MOVWF sign
031F  01CC     CLRF f2
0320  086E     MOVF 0x6E, W
0321  00CD     MOVWF 0x4D
0322  30CA     MOVLW 0xCA
0323  01CE     CLRF 0x4E
0324  120A     BCF PCLATH, 0x4
0325  118A     BCF PCLATH, 0x3
0326  25BE     CALL 0x5BE
0327  120A     BCF PCLATH, 0x4
0328  118A     BCF PCLATH, 0x3
286:                               sprintf(cadenaamostrar2, days_of_week[dia_de_la_semana(&fecha.day, &fecha.month, &fecha.yr)]);
0329  306E     MOVLW 0x6E
032A  00B8     MOVWF anio
032B  306D     MOVLW 0x6D
032C  00B7     MOVWF mes
032D  306C     MOVLW 0x6C
032E  120A     BCF PCLATH, 0x4
032F  158A     BSF PCLATH, 0x3
0330  208A     CALL 0x8A
0331  120A     BCF PCLATH, 0x4
0332  118A     BCF PCLATH, 0x3
0333  00EB     MOVWF 0x6B
0334  3003     MOVLW 0x3
0335  00A3     MOVWF x
0336  086B     MOVF 0x6B, W
0337  120A     BCF PCLATH, 0x4
0338  158A     BSF PCLATH, 0x3
0339  23AB     CALL 0x3AB
033A  120A     BCF PCLATH, 0x4
033B  118A     BCF PCLATH, 0x3
033C  3E1C     ADDLW 0x1C
033D  00C7     MOVWF f
033E  3098     MOVLW 0x98
033F  1803     BTFSC STATUS, 0x0
0340  3E01     ADDLW 0x1
0341  2AC3     GOTO 0x2C3
287:                               haycambio = 0;
288:                           } else {
289:                               sprintf(cadenaamostrar, "%02d/%02d/   ", fecha.day, fecha.month);
0342  3066     MOVLW 0x66
0343  1283     BCF STATUS, 0x5
0344  00C7     MOVWF f
0345  3098     MOVLW 0x98
0346  00C8     MOVWF 0x48
0347  086C     MOVF fecha, W
0348  00C9     MOVWF 0x49
0349  01CA     CLRF cntr
034A  086D     MOVF 0x6D, W
034B  00CB     MOVWF sign
034C  30CA     MOVLW 0xCA
034D  01CC     CLRF f2
034E  2BE2     GOTO 0x3E2
290:                               sprintf(cadenaamostrar2, cadena_esp);
291:                           }
292:                           break;
293:                       }
294:                       case MENU_CONFIGURAENCENDIDO:
295:                       {
296:           
297:                           if (flanco) {
034F  087C     MOVF flanco, W
0350  1903     BTFSC STATUS, 0x2
0351  2D04     GOTO 0x504
298:                               sprintf(cadenaamostrar, "SET ENC  ");
0352  30D3     MOVLW 0xD3
0353  1283     BCF STATUS, 0x5
0354  00C7     MOVWF f
0355  3098     MOVLW 0x98
0356  2BE0     GOTO 0x3E0
299:                               sprintf(cadenaamostrar2, cadena_esp);
300:                           }
301:           
302:                           break;
303:                       }
304:                       case SUBMENU_CONFIGURAHORAENCENDIDO:
305:                       {
306:                           modificafecha = HORA;
0357  30E1     MOVLW 0xE1
0358  01E4     CLRF 0x64
307:                           horario = &horarioenc;
0357  30E1     MOVLW 0xE1
0359  00FD     MOVWF horario
308:                           if (flanco || haycambio) {
035A  08FC     MOVF flanco, F
035B  1903     BTFSC STATUS, 0x2
035C  0842     MOVF m, W
035D  1D03     BTFSS STATUS, 0x2
035E  2B70     GOTO 0x370
309:                               sprintf(cadenaamostrar, "%02d:%02d    ", horarioenc.hrs, horarioenc.min);
310:                               sprintf(cadenaamostrar2, cadena_esp);
311:                               haycambio = 0;
312:                           } else {
313:                               sprintf(cadenaamostrar, "  :%02d    ", horarioenc.min);
035F  309C     MOVLW 0x9C
0360  1283     BCF STATUS, 0x5
0361  00C7     MOVWF f
0362  3098     MOVLW 0x98
0363  00C8     MOVWF 0x48
0364  1683     BSF STATUS, 0x5
0365  0862     MOVF 0x62, W
0366  2B84     GOTO 0x384
314:                               sprintf(cadenaamostrar2, cadena_esp);
315:                           }
316:           
317:                           break;
318:                       }
319:                       case SUBMENU_CONFIGURAMINUTOSENCENDIDO:
0367  30E1     MOVLW 0xE1
320:                       {
321:                           modificafecha = MINUTOS;
0368  01E4     CLRF 0x64
0369  0AE4     INCF 0x64, F
322:                           horario = &horarioenc;
0367  30E1     MOVLW 0xE1
036A  00FD     MOVWF horario
323:                           if (flanco || haycambio) {
036B  08FC     MOVF flanco, F
036C  1903     BTFSC STATUS, 0x2
036D  0842     MOVF m, W
036E  1903     BTFSC STATUS, 0x2
036F  2B7D     GOTO 0x37D
324:                               sprintf(cadenaamostrar, "%02d:%02d    ", horarioenc.hrs, horarioenc.min);
0370  3058     MOVLW 0x58
0371  1283     BCF STATUS, 0x5
0372  00C7     MOVWF f
0373  3098     MOVLW 0x98
0374  00C8     MOVWF 0x48
0375  1683     BSF STATUS, 0x5
0376  0863     MOVF 0x63, W
0377  1283     BCF STATUS, 0x5
0378  00C9     MOVWF 0x49
0379  01CA     CLRF cntr
037A  1683     BSF STATUS, 0x5
037B  0862     MOVF 0x62, W
037C  2AB7     GOTO 0x2B7
325:                               sprintf(cadenaamostrar2, cadena_esp);
326:                               haycambio = 0;
327:                           } else {
328:                               sprintf(cadenaamostrar, "%02d:      ", horarioenc.hrs);
037D  3090     MOVLW 0x90
037E  1283     BCF STATUS, 0x5
037F  00C7     MOVWF f
0380  3098     MOVLW 0x98
0381  00C8     MOVWF 0x48
0382  1683     BSF STATUS, 0x5
0383  0863     MOVF 0x63, W
0384  1283     BCF STATUS, 0x5
0385  00C9     MOVWF 0x49
0386  30CA     MOVLW 0xCA
0387  01CA     CLRF cntr
0388  2BE2     GOTO 0x3E2
329:                               sprintf(cadenaamostrar2, cadena_esp);
330:                           }
331:                           break;
332:                       }
333:           
334:           
335:                       case SUBMENU_CONFIGURAPERIODOENCENDIDO:
336:                       {
337:                           modificafecha = PERIODOENCENDIDO;
0389  3009     MOVLW 0x9
038A  00E4     MOVWF 0x64
338:           
339:                           if (flanco || haycambio) {
038B  08FC     MOVF flanco, F
038C  1903     BTFSC STATUS, 0x2
038D  0842     MOVF m, W
038E  1903     BTFSC STATUS, 0x2
038F  2B98     GOTO 0x398
340:                               sprintf(cadenaamostrar, "c/%u dias", periodoencendido);
0390  3005     MOVLW 0x5
0391  1283     BCF STATUS, 0x5
0392  00C7     MOVWF f
0393  3099     MOVLW 0x99
0394  00C8     MOVWF 0x48
0395  1683     BSF STATUS, 0x5
0396  0865     MOVF adcenteroI, W
0397  2BC0     GOTO 0x3C0
341:                               sprintf(cadenaamostrar2, cadena_esp);
342:                               haycambio = 0;
343:                           } else {
344:                               sprintf(cadenaamostrar, "c/  dias");
0398  3033     MOVLW 0x33
0399  1283     BCF STATUS, 0x5
039A  00C7     MOVWF f
039B  3099     MOVLW 0x99
039C  2BE0     GOTO 0x3E0
345:                               sprintf(cadenaamostrar2, cadena_esp);
346:                           }
347:                           break;
348:                       }
349:           
350:                       case SUBMENU_CONFIGURATIEMPOENCENDIDO:
351:                       {
352:                           modificafecha = TIEMPOENCENDIDO;
039D  3007     MOVLW 0x7
039E  00E4     MOVWF 0x64
353:           
354:                           if (flanco || haycambio) {
039F  08FC     MOVF flanco, F
03A0  1903     BTFSC STATUS, 0x2
03A1  0842     MOVF m, W
03A2  1903     BTFSC STATUS, 0x2
03A3  2BAC     GOTO 0x3AC
355:                               sprintf(cadenaamostrar, "ENCEN:%02d", tiempoencendido);
03A4  30BE     MOVLW 0xBE
03A5  1283     BCF STATUS, 0x5
03A6  00C7     MOVWF f
03A7  3098     MOVLW 0x98
03A8  00C8     MOVWF 0x48
03A9  1683     BSF STATUS, 0x5
03AA  0846     MOVF y, W
03AB  2BC0     GOTO 0x3C0
356:                               sprintf(cadenaamostrar2, cadena_esp);
357:                               haycambio = 0;
358:                           } else {
359:                               sprintf(cadenaamostrar, "ENCEN:  ");
03AC  3021     MOVLW 0x21
03AD  1283     BCF STATUS, 0x5
03AE  00C7     MOVWF f
03AF  3099     MOVLW 0x99
03B0  2BE0     GOTO 0x3E0
360:                               sprintf(cadenaamostrar2, cadena_esp);
361:                           }
362:                           break;
363:                       }
364:                       case MENU_CONFIGURAFALLACORRIENTE:
365:                       {
366:                           modificafecha = SINO;
03B1  2BCA     GOTO 0x3CA
367:           
368:                           if (flanco)
369:                               if (banderasino) {
370:                                   sprintf(cadenaamostrar, "NORMAL A ");
371:                                   sprintf(cadenaamostrar2, cadena_esp);
372:                               } else {
373:                                   sprintf(cadenaamostrar, "NORMAL C ");
374:                                   sprintf(cadenaamostrar2, cadena_esp);
375:                               } else {
376:                               sprintf(cadenaamostrar, "NORMAL   ");
377:                               sprintf(cadenaamostrar2, cadena_esp);
378:                           }
379:                           break;
380:                       }
381:                       case MENU_CONFIGURATIEMPOFALLACORRIENTE:
382:                       {
383:                           modificafecha = TIEMPOFALLA;
03B2  3008     MOVLW 0x8
03B3  00E4     MOVWF 0x64
384:           
385:                           if (flanco || haycambio) {
03B4  08FC     MOVF flanco, F
03B5  1903     BTFSC STATUS, 0x2
03B6  0842     MOVF m, W
03B7  1903     BTFSC STATUS, 0x2
03B8  2BC5     GOTO 0x3C5
386:                               sprintf(cadenaamostrar, "FALLA:%02d", tiempofalla);
03B9  30B3     MOVLW 0xB3
03BA  1283     BCF STATUS, 0x5
03BB  00C7     MOVWF f
03BC  3098     MOVLW 0x98
03BD  00C8     MOVWF 0x48
03BE  1683     BSF STATUS, 0x5
03BF  0847     MOVF f, W
03C0  1283     BCF STATUS, 0x5
03C1  00C9     MOVWF 0x49
03C2  30CA     MOVLW 0xCA
03C3  01CA     CLRF cntr
03C4  2ABB     GOTO 0x2BB
387:                               sprintf(cadenaamostrar2, cadena_esp);
388:                               haycambio = 0;
389:                           } else {
390:                               sprintf(cadenaamostrar, "FALLA:  ");
03C5  3018     MOVLW 0x18
03C6  1283     BCF STATUS, 0x5
03C7  00C7     MOVWF f
03C8  3099     MOVLW 0x99
03C9  2BE0     GOTO 0x3E0
391:                               sprintf(cadenaamostrar2, cadena_esp);
392:                           }
393:                           break;
394:                       }
395:                       case MENU_CONFIGURAINDICACIONDENIVEL:
396:                       {
397:                           modificafecha = SINO;
03CA  3006     MOVLW 0x6
03CB  00E4     MOVWF 0x64
398:           
399:           
400:                           if (flanco)
03CC  087C     MOVF flanco, W
03CD  1903     BTFSC STATUS, 0x2
03CE  2BDC     GOTO 0x3DC
401:                               if (banderasino) {
03CF  0836     MOVF sign, W
03D0  1903     BTFSC STATUS, 0x2
03D1  2BD7     GOTO 0x3D7
402:                                   sprintf(cadenaamostrar, "NORMAL A ");
03D2  30DD     MOVLW 0xDD
03D3  1283     BCF STATUS, 0x5
03D4  00C7     MOVWF f
03D5  3098     MOVLW 0x98
03D6  2BE0     GOTO 0x3E0
403:                                   sprintf(cadenaamostrar2, cadena_esp);
404:                               } else {
405:                                   sprintf(cadenaamostrar, "NORMAL C ");
03D7  30F1     MOVLW 0xF1
03D8  1283     BCF STATUS, 0x5
03D9  00C7     MOVWF f
03DA  3098     MOVLW 0x98
03DB  2BE0     GOTO 0x3E0
406:                                   sprintf(cadenaamostrar2, cadena_esp);
407:                               } else {
408:                               sprintf(cadenaamostrar, "NORMAL   ");
03DC  30C9     MOVLW 0xC9
03DD  1283     BCF STATUS, 0x5
03DE  00C7     MOVWF f
03DF  3098     MOVLW 0x98
03E0  00C8     MOVWF 0x48
03E1  30CA     MOVLW 0xCA
03E2  120A     BCF PCLATH, 0x4
03E3  118A     BCF PCLATH, 0x3
03E4  25BE     CALL 0x5BE
03E5  120A     BCF PCLATH, 0x4
03E6  118A     BCF PCLATH, 0x3
409:                               sprintf(cadenaamostrar2, cadena_esp);
03E7  3031     MOVLW 0x31
03E8  00C7     MOVWF f
03E9  3098     MOVLW 0x98
03EA  00C8     MOVWF 0x48
03EB  2CED     GOTO 0x4ED
410:                           }
411:           
412:                           break;
413:                       }
414:                       case MENU_MUESTRAMEDICIONES:
415:                       {
416:                           unsigned int adcenteroI;
417:                           unsigned int adcdecimalI;
418:                           unsigned int adcenteroV;
419:                           mediciondecorriente = (float) medidaI_adc * 50 / 1024;
03EC  1283     BCF STATUS, 0x5
03ED  3080     MOVLW 0x80
03EE  01CC     CLRF f2
03EF  00CD     MOVWF 0x4D
03F0  3044     MOVLW 0x44
03F1  00CE     MOVWF 0x4E
03F2  3048     MOVLW 0x48
03F3  01BD     CLRF f1
03F4  00BE     MOVWF 0x3E
03F5  3042     MOVLW 0x42
03F6  00BF     MOVWF 0x3F
03F7  1683     BSF STATUS, 0x5
03F8  082E     MOVF sign, W
03F9  1283     BCF STATUS, 0x5
03FA  00B1     MOVWF divisor
03FB  1683     BSF STATUS, 0x5
03FC  082D     MOVF day, W
03FD  1283     BCF STATUS, 0x5
03FE  00B0     MOVWF c
03FF  160A     BSF PCLATH, 0x4
0400  118A     BCF PCLATH, 0x3
0401  25F9     CALL 0x5F9
0402  120A     BCF PCLATH, 0x4
0403  118A     BCF PCLATH, 0x3
0404  0830     MOVF c, W
0405  00C0     MOVWF f2
0406  0831     MOVF divisor, W
0407  00C1     MOVWF 0x41
0408  0832     MOVF 0x32, W
0409  00C2     MOVWF m
040A  160A     BSF PCLATH, 0x4
040B  118A     BCF PCLATH, 0x3
040C  2687     CALL 0x687
040D  120A     BCF PCLATH, 0x4
040E  118A     BCF PCLATH, 0x3
040F  083D     MOVF f1, W
0410  00CF     MOVWF f1
0411  083E     MOVF 0x3E, W
0412  00D0     MOVWF 0x50
0413  083F     MOVF 0x3F, W
0414  00D1     MOVWF 0x51
0415  160A     BSF PCLATH, 0x4
0416  118A     BCF PCLATH, 0x3
0417  261F     CALL 0x61F
0418  120A     BCF PCLATH, 0x4
0419  118A     BCF PCLATH, 0x3
041A  084C     MOVF f2, W
041B  1683     BSF STATUS, 0x5
041C  00AA     MOVWF Data
041D  1283     BCF STATUS, 0x5
041E  084D     MOVF 0x4D, W
041F  1683     BSF STATUS, 0x5
0420  00AB     MOVWF sec
0421  1283     BCF STATUS, 0x5
0422  084E     MOVF 0x4E, W
0423  1683     BSF STATUS, 0x5
0424  00AC     MOVWF hr
420:                           //convierto el valor decimal a float
421:                           //para una entrada de 3.3V la lectura es 1023
422:                           //para 0 V la lectura es 0
423:                           //para una maxima lectura quiero que en el display se observe 50A
424:                           //Deseo que tambien me muestre 1 decimal, separo la parte entera y la decimal
425:                           //como la resolucion es 1024, cada bit corresponde a 50A/1024=0.048828125A
426:                           //cada 20 muestras tengo aproximdamente 1A
427:                           float mediciondevoltaje = (float) medidaV_adc * 440 / 1024;
0425  1283     BCF STATUS, 0x5
0426  3080     MOVLW 0x80
0427  01CC     CLRF f2
0428  00CD     MOVWF 0x4D
0429  3044     MOVLW 0x44
042A  00CE     MOVWF 0x4E
042B  30DC     MOVLW 0xDC
042C  01BD     CLRF f1
042D  00BE     MOVWF 0x3E
042E  3043     MOVLW 0x43
042F  00BF     MOVWF 0x3F
0430  1683     BSF STATUS, 0x5
0431  0830     MOVF c, W
0432  1283     BCF STATUS, 0x5
0433  00B1     MOVWF divisor
0434  1683     BSF STATUS, 0x5
0435  082F     MOVF quotient, W
0436  1283     BCF STATUS, 0x5
0437  00B0     MOVWF c
0438  160A     BSF PCLATH, 0x4
0439  118A     BCF PCLATH, 0x3
043A  25F9     CALL 0x5F9
043B  120A     BCF PCLATH, 0x4
043C  118A     BCF PCLATH, 0x3
043D  0830     MOVF c, W
043E  00C0     MOVWF f2
043F  0831     MOVF divisor, W
0440  00C1     MOVWF 0x41
0441  0832     MOVF 0x32, W
0442  00C2     MOVWF m
0443  160A     BSF PCLATH, 0x4
0444  118A     BCF PCLATH, 0x3
0445  2687     CALL 0x687
0446  120A     BCF PCLATH, 0x4
0447  118A     BCF PCLATH, 0x3
0448  083D     MOVF f1, W
0449  00CF     MOVWF f1
044A  083E     MOVF 0x3E, W
044B  00D0     MOVWF 0x50
044C  083F     MOVF 0x3F, W
044D  00D1     MOVWF 0x51
044E  160A     BSF PCLATH, 0x4
044F  118A     BCF PCLATH, 0x3
0450  261F     CALL 0x61F
0451  120A     BCF PCLATH, 0x4
0452  118A     BCF PCLATH, 0x3
0453  084C     MOVF f2, W
0454  00DF     MOVWF mediciondevoltaje
0455  084D     MOVF 0x4D, W
0456  00E0     MOVWF 0x60
0457  084E     MOVF 0x4E, W
0458  00E1     MOVWF 0x61
428:                           adcenteroI = (unsigned int) mediciondecorriente;
0459  1683     BSF STATUS, 0x5
045A  082A     MOVF Data, W
045B  1283     BCF STATUS, 0x5
045C  00A3     MOVWF x
045D  1683     BSF STATUS, 0x5
045E  082B     MOVF sec, W
045F  1283     BCF STATUS, 0x5
0460  00A4     MOVWF dato
0461  1683     BSF STATUS, 0x5
0462  082C     MOVF hr, W
0463  1283     BCF STATUS, 0x5
0464  00A5     MOVWF y
0465  120A     BCF PCLATH, 0x4
0466  158A     BSF PCLATH, 0x3
0467  2017     CALL 0x17
0468  120A     BCF PCLATH, 0x4
0469  118A     BCF PCLATH, 0x3
046A  0824     MOVF dato, W
046B  00E6     MOVWF 0x66
046C  0823     MOVF x, W
046D  00E5     MOVWF adcenteroI
429:                           adcdecimalI = (unsigned int) ((mediciondecorriente - (unsigned int) mediciondecorriente)*10);
046E  1683     BSF STATUS, 0x5
046F  082A     MOVF Data, W
0470  1283     BCF STATUS, 0x5
0471  00BA     MOVWF f1
0472  1683     BSF STATUS, 0x5
0473  082B     MOVF sec, W
0474  1283     BCF STATUS, 0x5
0475  00BB     MOVWF 0x3B
0476  1683     BSF STATUS, 0x5
0477  082C     MOVF hr, W
0478  1283     BCF STATUS, 0x5
0479  00BC     MOVWF 0x3C
047A  1683     BSF STATUS, 0x5
047B  082A     MOVF Data, W
047C  1283     BCF STATUS, 0x5
047D  00A3     MOVWF x
047E  1683     BSF STATUS, 0x5
047F  082B     MOVF sec, W
0480  1283     BCF STATUS, 0x5
0481  00A4     MOVWF dato
0482  1683     BSF STATUS, 0x5
0483  082C     MOVF hr, W
0484  1283     BCF STATUS, 0x5
0485  00A5     MOVWF y
0486  120A     BCF PCLATH, 0x4
0487  158A     BSF PCLATH, 0x3
0488  2017     CALL 0x17
0489  120A     BCF PCLATH, 0x4
048A  118A     BCF PCLATH, 0x3
048B  0824     MOVF dato, W
048C  00B1     MOVWF divisor
048D  0823     MOVF x, W
048E  00B0     MOVWF c
048F  160A     BSF PCLATH, 0x4
0490  118A     BCF PCLATH, 0x3
0491  25F9     CALL 0x5F9
0492  120A     BCF PCLATH, 0x4
0493  118A     BCF PCLATH, 0x3
0494  0830     MOVF c, W
0495  00B7     MOVWF mes
0496  0831     MOVF divisor, W
0497  00B8     MOVWF anio
0498  0832     MOVF 0x32, W
0499  00B9     MOVWF 0x39
049A  160A     BSF PCLATH, 0x4
049B  118A     BCF PCLATH, 0x3
049C  2609     CALL 0x609
049D  120A     BCF PCLATH, 0x4
049E  118A     BCF PCLATH, 0x3
049F  0837     MOVF mes, W
04A0  00C0     MOVWF f2
04A1  0838     MOVF anio, W
04A2  00C1     MOVWF 0x41
04A3  0839     MOVF 0x39, W
04A4  00C2     MOVWF m
04A5  3020     MOVLW 0x20
04A6  01BD     CLRF f1
04A7  00BE     MOVWF 0x3E
04A8  3041     MOVLW 0x41
04A9  00BF     MOVWF 0x3F
04AA  160A     BSF PCLATH, 0x4
04AB  118A     BCF PCLATH, 0x3
04AC  2687     CALL 0x687
04AD  120A     BCF PCLATH, 0x4
04AE  118A     BCF PCLATH, 0x3
04AF  083D     MOVF f1, W
04B0  00E2     MOVWF 0x62
04B1  083E     MOVF 0x3E, W
04B2  00E3     MOVWF 0x63
04B3  083F     MOVF 0x3F, W
04B4  00E4     MOVWF 0x64
04B5  0862     MOVF 0x62, W
04B6  00A3     MOVWF x
04B7  0863     MOVF 0x63, W
04B8  00A4     MOVWF dato
04B9  0864     MOVF 0x64, W
04BA  00A5     MOVWF y
04BB  120A     BCF PCLATH, 0x4
04BC  158A     BSF PCLATH, 0x3
04BD  2017     CALL 0x17
04BE  120A     BCF PCLATH, 0x4
04BF  118A     BCF PCLATH, 0x3
04C0  0824     MOVF dato, W
04C1  00E8     MOVWF 0x68
04C2  0823     MOVF x, W
04C3  00E7     MOVWF adcdecimalI
430:                           adcenteroV = (unsigned int) mediciondevoltaje;
04C4  085F     MOVF mediciondevoltaje, W
04C5  00A3     MOVWF x
04C6  0860     MOVF 0x60, W
04C7  00A4     MOVWF dato
04C8  0861     MOVF 0x61, W
04C9  00A5     MOVWF y
04CA  120A     BCF PCLATH, 0x4
04CB  158A     BSF PCLATH, 0x3
04CC  2017     CALL 0x17
04CD  120A     BCF PCLATH, 0x4
04CE  118A     BCF PCLATH, 0x3
04CF  0824     MOVF dato, W
04D0  00EA     MOVWF 0x6A
04D1  0823     MOVF x, W
04D2  00E9     MOVWF adcenteroV
431:                           sprintf(cadenaamostrar, "%2u.%uA   ", (unsigned int) adcenteroI, (unsigned int) adcdecimalI);
04D3  30A8     MOVLW 0xA8
04D4  00C7     MOVWF f
04D5  3098     MOVLW 0x98
04D6  00C8     MOVWF 0x48
04D7  0866     MOVF 0x66, W
04D8  00CA     MOVWF cntr
04D9  0865     MOVF adcenteroI, W
04DA  00C9     MOVWF 0x49
04DB  0868     MOVF 0x68, W
04DC  00CC     MOVWF f2
04DD  0867     MOVF adcdecimalI, W
04DE  00CB     MOVWF sign
04DF  30CA     MOVLW 0xCA
04E0  120A     BCF PCLATH, 0x4
04E1  118A     BCF PCLATH, 0x3
04E2  25BE     CALL 0x5BE
04E3  120A     BCF PCLATH, 0x4
04E4  118A     BCF PCLATH, 0x3
432:                           sprintf(cadenaamostrar2, "%3uV    ", (unsigned int) adcenteroV);
04E5  300F     MOVLW 0xF
04E6  00C7     MOVWF f
04E7  3099     MOVLW 0x99
04E8  00C8     MOVWF 0x48
04E9  086A     MOVF 0x6A, W
04EA  00CA     MOVWF cntr
04EB  0869     MOVF adcenteroV, W
04EC  00C9     MOVWF 0x49
04ED  30D2     MOVLW 0xD2
04EE  120A     BCF PCLATH, 0x4
04EF  118A     BCF PCLATH, 0x3
04F0  25BE     CALL 0x5BE
04F1  120A     BCF PCLATH, 0x4
04F2  118A     BCF PCLATH, 0x3
433:                           break;
04F3  1683     BSF STATUS, 0x5
04F4  2D04     GOTO 0x504
434:                       }
435:                       default:
436:                           break;
437:                   };
438:                   //////////////////////////////////////////////////////////
439:                   //Finaliza Procesa los men
440:           
441:                   //Verifica estados de falla
442:                   /////////////////////////////////////////////////////////
443:                   switch (estadobomba) {
0504  1683     BSF STATUS, 0x5
0505  083E     MOVF 0x3E, W
0506  3A00     XORLW 0x0
0507  1903     BTFSC STATUS, 0x2
0508  2D0D     GOTO 0x50D
0509  3A01     XORLW 0x1
050A  1903     BTFSC STATUS, 0x2
050B  2D0D     GOTO 0x50D
050C  2D0D     GOTO 0x50D
444:                       case BOMBAAPAGADA:
445:                       {
446:           
447:                           break;
448:                       }
449:                       case BOMBAENCENDIDA:
450:                       {
451:           
452:                           break;
453:                       }
454:                       default:
455:                           break;
456:                   }
457:                   switch (estadonivel) {
050D  0841     MOVF 0x41, W
050E  3A00     XORLW 0x0
050F  1903     BTFSC STATUS, 0x2
0510  2D15     GOTO 0x515
0511  3A01     XORLW 0x1
0512  1903     BTFSC STATUS, 0x2
0513  2D15     GOTO 0x515
0514  2D15     GOTO 0x515
458:                       case NIVELNORMAL:
459:                       {
460:           
461:                           break;
462:                       }
463:                       case NIVELBAJO:
464:                       {
465:           
466:                           break;
467:                       }
468:                       default:
469:                           break;
470:                   }
471:           
472:                   switch (estadofallacorriente) {
0515  083F     MOVF 0x3F, W
0516  3A00     XORLW 0x0
0517  1903     BTFSC STATUS, 0x2
0518  2D1D     GOTO 0x51D
0519  3A01     XORLW 0x1
051A  1903     BTFSC STATUS, 0x2
051B  2D1D     GOTO 0x51D
051C  2D1D     GOTO 0x51D
473:                       case CORRIENTENORMAL:
474:                       {
475:                           break;
476:                       }
477:                       case FALLACORRIENTE:
478:                       {
479:                           break;
480:                       }
481:                       default:
482:                           break;
483:                   }
484:                   switch (estadofallavoltaje) {
051D  0840     MOVF f2, W
051E  3A00     XORLW 0x0
051F  1903     BTFSC STATUS, 0x2
0520  2D2B     GOTO 0x52B
0521  3A01     XORLW 0x1
0522  1903     BTFSC STATUS, 0x2
0523  2D2B     GOTO 0x52B
0524  2D2B     GOTO 0x52B
485:                       case VOLTAJENORMAL:
486:                       {
487:                           break;
488:                       }
489:                       case FALLAVOLTAJE:
490:                       {
491:                           break;
492:                       }
493:                       default:
494:                           break;
495:                   }
496:                   //////////////////////////////////////////////////////
497:                   //Fin Verifica estados de falla
498:           
499:                   //Activa o desactiva la Bomba
500:                   ///////////////////////////////////////////////////////
501:                   switch (activabomba) {
052B  0832     MOVF 0x32, W
052C  3A00     XORLW 0x0
052D  1903     BTFSC STATUS, 0x2
052E  2D28     GOTO 0x528
052F  3A01     XORLW 0x1
0530  1903     BTFSC STATUS, 0x2
0531  2D25     GOTO 0x525
0532  2D33     GOTO 0x533
502:                       case ENCIENDEBOMBA:
503:                       {
504:                           salidabomba = 1;
0525  1283     BCF STATUS, 0x5
0526  1407     BSF PORTC, 0x0
505:                           break;
0527  2D33     GOTO 0x533
506:                       }
507:                       case APAGABOMBA:
508:                       {
509:                           salidabomba = 0;
0528  1283     BCF STATUS, 0x5
0529  1007     BCF PORTC, 0x0
510:                           break;
052A  2D33     GOTO 0x533
511:                       }
512:                       default:
513:                           break;
514:                   }
515:                   //////////////////////////////////////////////////////
516:                   //Fin Activa o desactiva la Bomba
517:           
518:                   //Actualiza Display
519:                   /////////////////////////////////////////////
520:                   if (refrescadisplay) {
0533  1683     BSF STATUS, 0x5
0534  0845     MOVF dia, W
0535  1903     BTFSC STATUS, 0x2
0536  2D74     GOTO 0x574
521:                       vGotoxyLCD(1, 1);
0537  1283     BCF STATUS, 0x5
0538  3001     MOVLW 0x1
0539  01A5     CLRF y
053A  0AA5     INCF y, F
053B  160A     BSF PCLATH, 0x4
053C  118A     BCF PCLATH, 0x3
053D  2496     CALL 0x496
053E  120A     BCF PCLATH, 0x4
053F  118A     BCF PCLATH, 0x3
522:                       cadena = cadenaamostrar;
0540  30CA     MOVLW 0xCA
0541  1683     BSF STATUS, 0x5
0542  00C9     MOVWF 0x49
523:                       while (*cadena != '\0')
0543  0849     MOVF 0x49, W
0544  0084     MOVWF FSR
0545  1383     BCF STATUS, 0x7
0546  0880     MOVF INDF, F
0547  1903     BTFSC STATUS, 0x2
0548  2D55     GOTO 0x555
0554  2D43     GOTO 0x543
524:                           vLCD_Putc(*cadena++);
0549  0849     MOVF 0x49, W
054A  0084     MOVWF FSR
054B  0800     MOVF INDF, W
054C  160A     BSF PCLATH, 0x4
054D  118A     BCF PCLATH, 0x3
054E  24B9     CALL 0x4B9
054F  120A     BCF PCLATH, 0x4
0550  118A     BCF PCLATH, 0x3
0551  1683     BSF STATUS, 0x5
0552  1303     BCF STATUS, 0x6
0553  0AC9     INCF 0x49, F
525:                       vGotoxyLCD(1, 2);
0555  3002     MOVLW 0x2
0556  1283     BCF STATUS, 0x5
0557  00A5     MOVWF y
0558  3001     MOVLW 0x1
0559  160A     BSF PCLATH, 0x4
055A  118A     BCF PCLATH, 0x3
055B  2496     CALL 0x496
055C  120A     BCF PCLATH, 0x4
055D  118A     BCF PCLATH, 0x3
526:                       cadena = cadenaamostrar2;
055E  30D2     MOVLW 0xD2
055F  1683     BSF STATUS, 0x5
0560  00C9     MOVWF 0x49
527:                       while (*cadena != '\0')
0561  0849     MOVF 0x49, W
0562  0084     MOVWF FSR
0563  1383     BCF STATUS, 0x7
0564  0880     MOVF INDF, F
0565  1903     BTFSC STATUS, 0x2
0566  2D73     GOTO 0x573
0572  2D61     GOTO 0x561
528:                           vLCD_Putc(*cadena++);
0567  0849     MOVF 0x49, W
0568  0084     MOVWF FSR
0569  0800     MOVF INDF, W
056A  160A     BSF PCLATH, 0x4
056B  118A     BCF PCLATH, 0x3
056C  24B9     CALL 0x4B9
056D  120A     BCF PCLATH, 0x4
056E  118A     BCF PCLATH, 0x3
056F  1683     BSF STATUS, 0x5
0570  1303     BCF STATUS, 0x6
0571  0AC9     INCF 0x49, F
529:           
530:                       refrescadisplay = 0;
0573  01C5     CLRF dia
531:                   }
532:                   ////////////////////////////////////////////////
533:                   //Fin Actualiza Display
534:           
535:                   //Graba Nuevos datos en el RC
536:                   /////////////////////////////////////////////////
537:                   if (bandera_startglobal) {
0574  0835     MOVF counter, W
0575  1903     BTFSC STATUS, 0x2
0576  2D79     GOTO 0x579
538:                       bandera_grabafechay_hora = 1;
0577  01B4     CLRF sign
0578  0AB4     INCF sign, F
539:           
540:                   }
541:                   if (!bandera_startglobal && bandera_grabafechay_hora) {
0579  08B5     MOVF counter, F
057A  1D03     BTFSS STATUS, 0x2
057B  2DBB     GOTO 0x5BB
057C  0834     MOVF sign, W
057D  1903     BTFSC STATUS, 0x2
057E  2DBB     GOTO 0x5BB
542:                       if (horario == &horarioactual) {
057F  087D     MOVF horario, W
0580  3ADE     XORLW 0xDE
0581  1D03     BTFSS STATUS, 0x2
0582  2DA0     GOTO 0x5A0
543:                           isl1208_set_time((*horario).hrs, (*horario).min, 00);
0583  0A7D     INCF horario, W
0584  0084     MOVWF FSR
0585  1383     BCF STATUS, 0x7
0586  0800     MOVF INDF, W
0587  1283     BCF STATUS, 0x5
0588  00AA     MOVWF Data
0589  01AB     CLRF sec
058A  087D     MOVF horario, W
058B  3E02     ADDLW 0x2
058C  0084     MOVWF FSR
058D  0800     MOVF INDF, W
058E  120A     BCF PCLATH, 0x4
058F  158A     BSF PCLATH, 0x3
0590  2293     CALL 0x293
0591  120A     BCF PCLATH, 0x4
0592  118A     BCF PCLATH, 0x3
544:                           isl1208_set_date(&fecha.day, &fecha.month, &fecha.yr, &fecha.dow);
0593  306D     MOVLW 0x6D
0594  1283     BCF STATUS, 0x5
0595  00AA     MOVWF Data
0596  306E     MOVLW 0x6E
0597  00AB     MOVWF sec
0598  306F     MOVLW 0x6F
0599  00AC     MOVWF hr
059A  306C     MOVLW 0x6C
059B  120A     BCF PCLATH, 0x4
059C  158A     BSF PCLATH, 0x3
059D  22CF     CALL 0x2CF
059E  120A     BCF PCLATH, 0x4
059F  118A     BCF PCLATH, 0x3
545:                       }
546:                       if (horario == &horarioenc) {
05A0  087D     MOVF horario, W
05A1  3AE1     XORLW 0xE1
05A2  1D03     BTFSS STATUS, 0x2
05A3  2DBA     GOTO 0x5BA
547:                           isl1208_set_time_enc((*horario).hrs, (*horario).min, 00);
05A4  0A7D     INCF horario, W
05A5  0084     MOVWF FSR
05A6  1383     BCF STATUS, 0x7
05A7  0800     MOVF INDF, W
05A8  1283     BCF STATUS, 0x5
05A9  00AA     MOVWF Data
05AA  01AB     CLRF sec
05AB  087D     MOVF horario, W
05AC  3E02     ADDLW 0x2
05AD  0084     MOVWF FSR
05AE  0800     MOVF INDF, W
05AF  120A     BCF PCLATH, 0x4
05B0  158A     BSF PCLATH, 0x3
05B1  226A     CALL 0x26A
05B2  120A     BCF PCLATH, 0x4
05B3  118A     BCF PCLATH, 0x3
548:                           //isl1208_set_date(&fecha.day, &fecha.month, &fecha.yr, &fecha.dow);
549:                           isl1208_set_dow_enc(&fechaenc.dow);
05B4  30DD     MOVLW 0xDD
05B5  120A     BCF PCLATH, 0x4
05B6  158A     BSF PCLATH, 0x3
05B7  224C     CALL 0x24C
05B8  120A     BCF PCLATH, 0x4
05B9  118A     BCF PCLATH, 0x3
550:                       }
551:                       bandera_grabafechay_hora = 0;
05BA  01B4     CLRF sign
552:                   }
553:                   //////////////////////////////////////////////////////////////////
554:                   //Finaliza Graba Nuevos datos en el RC
555:                   NOP();
05BB  0000     NOP
556:                   NOP();
05BC  0000     NOP
557:           
558:               }
559:           }
560:           
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/interrupts.c  -------------------------
1:             
2:             /******************************************************************************/
3:             /*Files to Include                                                            */
4:             /******************************************************************************/
5:             
6:             #if defined(__XC)
7:             #include <xc.h>         /* XC8 General Include File */
8:             #elif defined(HI_TECH_C)
9:             #include <htc.h>        /* HiTech General Include File */
10:            #endif
11:            #include <stdbool.h>        /* For true/false definition */
12:            #include <stdint.h>
13:            #include "user.h"
14:            #include "system.h"
15:            
16:            #include "Pulsadores.h"
17:            #include "pwm.h"
18:            #include "adcPic16.h"
19:            #include "_isl1208.h"
20:            /* Interrupt Routines                                                         */
21:            /******************************************************************************/
22:            
23:            /* Baseline devices don't have interrupts. Note that some PIC16's 
24:             * are baseline devices.  Unfortunately the baseline detection macro is 
25:             * _PIC12 */
26:            #ifndef _PIC18
27:            #ifndef _PIC12
28:            
29:            void interrupt isr(void) {
0004  00FE     MOVWF 0x7E
0005  0E03     SWAPF STATUS, W
0006  1283     BCF STATUS, 0x5
0007  1303     BCF STATUS, 0x6
0008  00A0     MOVWF 0x20
0009  0804     MOVF FSR, W
000A  00A1     MOVWF 0x21
000B  080A     MOVF PCLATH, W
000C  00A2     MOVWF 0x22
000D  120A     BCF PCLATH, 0x4
000E  158A     BSF PCLATH, 0x3
000F  2C12     GOTO 0x412
0010  120A     BCF PCLATH, 0x4
0011  118A     BCF PCLATH, 0x3
0012  2813     GOTO 0x13
30:                if (ADIF && ADIE) {
0C12  1F0C     BTFSS PIR1, 0x6
0C13  2C36     GOTO 0x436
0C14  1683     BSF STATUS, 0x5
0C15  1F0C     BTFSS PIR1, 0x6
0C16  2C36     GOTO 0x436
31:                    if (getADCChannel() == MIDECORRIENTE) {
0C17  27DB     CALL 0x7DB
0C18  120A     BCF PCLATH, 0x4
0C19  158A     BSF PCLATH, 0x3
0C1A  3800     IORLW 0x0
0C1B  1D03     BTFSS STATUS, 0x2
0C1C  2C26     GOTO 0x426
32:                        medidaI_adc = adcRead();
0C1D  2797     CALL 0x797
0C1E  120A     BCF PCLATH, 0x4
0C1F  158A     BSF PCLATH, 0x3
0C20  0871     MOVF canal, W
0C21  00AE     MOVWF sign
0C22  0870     MOVF divisor, W
0C23  00AD     MOVWF day
33:                        setADCChannel(MIDETENSION);
0C24  3001     MOVLW 0x1
0C25  2C2E     GOTO 0x42E
34:                    } else {
35:                        medidaV_adc = adcRead();
0C26  2797     CALL 0x797
0C27  120A     BCF PCLATH, 0x4
0C28  158A     BSF PCLATH, 0x3
0C29  0871     MOVF canal, W
0C2A  00B0     MOVWF c
0C2B  0870     MOVF divisor, W
0C2C  00AF     MOVWF quotient
36:                        /*TODO debo realizar un promedio en las mediciones para filtrar las
37:                        variaciones rpidas de tensin*/
38:                        setADCChannel(MIDECORRIENTE);
0C2D  3000     MOVLW 0x0
0C2E  27F4     CALL 0x7F4
0C2F  120A     BCF PCLATH, 0x4
0C30  158A     BSF PCLATH, 0x3
39:                    }
40:                    ADIF = 0;
0C31  130C     BCF PIR1, 0x6
41:                    cambio_de_canal = 1;
0C32  1683     BSF STATUS, 0x5
0C33  01B7     CLRF mes
0C34  0AB7     INCF mes, F
42:                } else if (INTF && INTE) { // INTERRUPCION por EXT2 Clock Out --------------------------------------------
0C35  2EC6     GOTO 0x6C6
0C36  188B     BTFSC INTCON, 0x1
0C37  1E0B     BTFSS INTCON, 0x4
0C38  2C46     GOTO 0x446
43:                    if (INTEDG == 1) {
0C39  1683     BSF STATUS, 0x5
0C3A  1F01     BTFSS TMR0, 0x6
0C3B  2C3F     GOTO 0x43F
44:                        //      ext_int_edge(2,H_TO_L);
45:                        INTEDG = 0;
0C3C  1301     BCF TMR0, 0x6
46:                        flanco = 0;
0C3D  01FC     CLRF flanco
47:                        //PORTEbits.RE0 = 1; //output_high(PIN_E0);
48:                    } else {
0C3E  2C42     GOTO 0x442
49:                        //   ext_int_edge(2,L_TO_H);
50:                        INTEDG = 1;
0C3F  1701     BSF TMR0, 0x6
51:                        flanco = 1;
0C40  01FC     CLRF flanco
0C41  0AFC     INCF flanco, F
52:                        // PORTEbits.RE0 = 0; //output_low(PIN_E0);
53:                        //      flanco=1;
54:            
55:                    }
56:                    refrescadisplay = 1;
0C42  01C5     CLRF dia
0C43  0AC5     INCF dia, F
57:                    INTF = 0;
0C44  108B     BCF INTCON, 0x1
58:                } else if (T0IF && T0IE) {
0C45  2EC6     GOTO 0x6C6
0C46  190B     BTFSC INTCON, 0x2
0C47  1E8B     BTFSS INTCON, 0x5
0C48  2EC6     GOTO 0x6C6
59:            
60:                    //Interrupcion por desborde del timer0. Tal como esta configurado, se el timer desborda cada
61:                    //0.003264seg o sea 3.264 ms, por lo tanto para que pase alrededor de 0.5segundo, se debe entrar 150 veces
62:                    //como con un unsigned int no funciona uso unsigned char y solo hasta 150
63:                    //cada 3ms realizamos una conversion analogica para obtener la medida de corriente
64:                    if (cambio_de_canal)
0C49  1683     BSF STATUS, 0x5
0C4A  0837     MOVF mes, W
0C4B  1903     BTFSC STATUS, 0x2
0C4C  2C4F     GOTO 0x44F
65:                        cambio_de_canal = 0;
0C4D  01B7     CLRF mes
0C4E  2C52     GOTO 0x452
66:                    else
67:                        startADC();
0C4F  27E2     CALL 0x7E2
0C50  120A     BCF PCLATH, 0x4
0C51  158A     BSF PCLATH, 0x3
68:                    if (cuenta40ms < 12) {
0C52  300C     MOVLW 0xC
0C53  1683     BSF STATUS, 0x5
0C54  0238     SUBWF anio, W
0C55  1803     BTFSC STATUS, 0x0
0C56  2C59     GOTO 0x459
69:                        cuenta40ms++;
0C57  0AB8     INCF anio, F
70:                    } else {
0C58  2C95     GOTO 0x495
71:                        cuenta40ms = 0;
0C59  01B8     CLRF anio
72:                        if (activapwmpor > 0) {
0C5A  0833     MOVF dividend, W
0C5B  1903     BTFSC STATUS, 0x2
0C5C  2C5F     GOTO 0x45F
73:                            activapwmpor--;
0C5D  03B3     DECF dividend, F
74:                        } else {
0C5E  2C64     GOTO 0x464
75:                            buzzer_off();
0C5F  27E5     CALL 0x7E5
0C60  120A     BCF PCLATH, 0x4
0C61  158A     BSF PCLATH, 0x3
76:                            activapwmpor = 0;
0C62  1683     BSF STATUS, 0x5
0C63  01B3     CLRF dividend
77:                        }
78:                        if (cuenta500ms < 11) {
0C64  300B     MOVLW 0xB
0C65  0239     SUBWF 0x39, W
0C66  1803     BTFSC STATUS, 0x0
0C67  2C6A     GOTO 0x46A
79:                            cuenta500ms++;
0C68  0AB9     INCF 0x39, F
80:            
81:            
82:                        } else {
0C69  2C95     GOTO 0x495
83:            
84:                            cuenta500ms = 0;
0C6A  3000     MOVLW 0x0
0C6B  01B9     CLRF 0x39
85:                            flanco = !flanco;
0C6A  3000     MOVLW 0x0
0C6C  08FC     MOVF flanco, F
0C6D  1903     BTFSC STATUS, 0x2
0C6E  3001     MOVLW 0x1
0C6F  00FC     MOVWF flanco
86:                            refrescadisplay = 1;
0C71  01C5     CLRF dia
0C72  0AC5     INCF dia, F
87:                            if (cuentasegundos < 60) {
0C70  303C     MOVLW 0x3C
0C73  023D     SUBWF f1, W
0C74  1803     BTFSC STATUS, 0x0
0C75  2C78     GOTO 0x478
88:            
89:                                cuentasegundos++;
0C76  0ABD     INCF f1, F
90:                            } else {
0C77  2C95     GOTO 0x495
91:                                //TODO quitar esto en la version final
92:                                TRISDbits.TRISD3 = 0;
0C78  1188     BCF PORTD, 0x3
93:                               RD3=!RD3;// PORTDbits.RD3 = !PORTDbits.RD3;
0C79  3008     MOVLW 0x8
0C7A  1283     BCF STATUS, 0x5
0C7B  0688     XORWF PORTD, F
94:                                //TODO quitar esto en la version final
95:                                salidabomba = !salidabomba;
0C7C  3001     MOVLW 0x1
0C7D  0687     XORWF PORTC, F
96:                                cuentasegundos = 0;
0C7E  1683     BSF STATUS, 0x5
0C80  01BD     CLRF f1
97:                                if (cuentaminutos < 60) {
0C7F  303C     MOVLW 0x3C
0C81  023C     SUBWF 0x3C, W
0C82  1803     BTFSC STATUS, 0x0
0C83  2C86     GOTO 0x486
98:                                    cuentaminutos++;
0C84  0ABC     INCF 0x3C, F
99:                                } else {
0C85  2C95     GOTO 0x495
100:                                   cuentaminutos = 0;
0C86  3018     MOVLW 0x18
0C87  01BC     CLRF 0x3C
101:                                   if (cuentahoras < 24) {
0C86  3018     MOVLW 0x18
0C88  023B     SUBWF 0x3B, W
0C89  1803     BTFSC STATUS, 0x0
0C8A  2C8D     GOTO 0x48D
102:                                       cuentahoras++;
0C8B  0ABB     INCF 0x3B, F
103:                                   } else
0C8C  2C8E     GOTO 0x48E
104:                                       cuentahoras = 0;
0C8D  01BB     CLRF 0x3B
105:                                   if (cuentadias < 30) {
0C8E  301E     MOVLW 0x1E
0C8F  023A     SUBWF f1, W
0C90  1803     BTFSC STATUS, 0x0
0C91  2C94     GOTO 0x494
106:                                       cuentadias++;
0C92  0ABA     INCF f1, F
107:                                   } else {
0C93  2C95     GOTO 0x495
108:                                       cuentadias = 0;
0C94  01BA     CLRF f1
109:                                   }
110:                               }
111:           
112:                           }
113:                       }
114:                   }
115:                   static char maximodia;
116:                   if (Pulsacion(0, BOTON_Subir, CON_REPETICION, LOGICA_INVERSA)) {
0C95  3000     MOVLW 0x0
0C96  1283     BCF STATUS, 0x5
0C97  1906     BTFSC PORTB, 0x2
0C98  3001     MOVLW 0x1
0C99  00F5     MOVWF Pin
0C9A  3000     MOVLW 0x0
0C9B  01F6     CLRF TipoPin
0C9C  0AF6     INCF TipoPin, F
0C9D  01F7     CLRF Logica
0C9E  0AF7     INCF Logica, F
0C9F  26D1     CALL 0x6D1
0CA0  120A     BCF PCLATH, 0x4
0CA1  158A     BSF PCLATH, 0x3
0CA2  3A00     XORLW 0x0
0CA3  1903     BTFSC STATUS, 0x2
0CA4  2D94     GOTO 0x594
117:           
118:                       refrescadisplay = 1;
0CA5  1683     BSF STATUS, 0x5
0CA6  1303     BCF STATUS, 0x6
0CA7  01C5     CLRF dia
0CA8  0AC5     INCF dia, F
119:                       switch (modificafecha) {
0CA9  2D31     GOTO 0x531
0D31  0864     MOVF 0x64, W
0D32  0084     MOVWF FSR
0D33  300A     MOVLW 0xA
0D34  0204     SUBWF FSR, W
0D35  1803     BTFSC STATUS, 0x0
0D36  2D3E     GOTO 0x53E
0D37  3010     MOVLW 0x10
0D38  008A     MOVWF PCLATH
0D39  1003     BCF STATUS, 0x0
0D3A  0D04     RLF FSR, W
0D3B  0704     ADDWF FSR, W
0D3C  3E36     ADDLW 0x36
0D3D  0082     MOVWF PCL
1036  120A     BCF PCLATH, 0x4
1037  158A     BSF PCLATH, 0x3
1038  2CBB     GOTO 0x4BB
1039  120A     BCF PCLATH, 0x4
103A  158A     BSF PCLATH, 0x3
103B  2CAA     GOTO 0x4AA
103C  120A     BCF PCLATH, 0x4
103D  158A     BSF PCLATH, 0x3
103E  2CD5     GOTO 0x4D5
103F  120A     BCF PCLATH, 0x4
1040  158A     BSF PCLATH, 0x3
1041  2CE5     GOTO 0x4E5
1042  120A     BCF PCLATH, 0x4
1043  158A     BSF PCLATH, 0x3
1044  2CF3     GOTO 0x4F3
1045  120A     BCF PCLATH, 0x4
1046  158A     BSF PCLATH, 0x3
1047  2D3E     GOTO 0x53E
1048  120A     BCF PCLATH, 0x4
1049  158A     BSF PCLATH, 0x3
104A  2D02     GOTO 0x502
104B  120A     BCF PCLATH, 0x4
104C  158A     BSF PCLATH, 0x3
104D  2D08     GOTO 0x508
104E  120A     BCF PCLATH, 0x4
104F  158A     BSF PCLATH, 0x3
1050  2D16     GOTO 0x516
1051  120A     BCF PCLATH, 0x4
1052  158A     BSF PCLATH, 0x3
1053  2D24     GOTO 0x524
120:                           case MINUTOS:
121:                               haycambio = 1;
0CAA  01C2     CLRF m
0CAB  0AC2     INCF m, F
122:                               if ((*horario).min < 59) (*horario).min++;
0CAC  0A7D     INCF horario, W
0CAD  0084     MOVWF FSR
0CAE  303B     MOVLW 0x3B
0CAF  1383     BCF STATUS, 0x7
0CB0  0200     SUBWF INDF, W
0CB1  0A7D     INCF horario, W
0CB3  1C03     BTFSS STATUS, 0x0
0CB4  2CC8     GOTO 0x4C8
123:                               else
124:                                   if ((*horario).min == 59) (*horario).min = 0;
0CB2  0084     MOVWF FSR
0CB5  0800     MOVF INDF, W
0CB6  3A3B     XORLW 0x3B
0CB7  1D03     BTFSS STATUS, 0x2
0CB8  2D3E     GOTO 0x53E
0CB9  0A7D     INCF horario, W
0CBA  2CD2     GOTO 0x4D2
125:                               break;
126:                           case HORA:
127:                               haycambio = 1;
0CBB  01C2     CLRF m
0CBC  0AC2     INCF m, F
128:                               if ((*horario).hrs < 23) (*horario).hrs++;
0CBD  087D     MOVF horario, W
0CBE  3E02     ADDLW 0x2
0CBF  0084     MOVWF FSR
0CC0  3017     MOVLW 0x17
0CC1  1383     BCF STATUS, 0x7
0CC2  0200     SUBWF INDF, W
0CC3  087D     MOVF horario, W
0CC4  1803     BTFSC STATUS, 0x0
0CC5  2CCA     GOTO 0x4CA
0CC6  3E02     ADDLW 0x2
0CC7  0084     MOVWF FSR
0CC8  0A80     INCF INDF, F
0CC9  2D3E     GOTO 0x53E
129:                               else
130:                                   if ((*horario).hrs == 23) (*horario).hrs = 0;
0CCA  3E02     ADDLW 0x2
0CCB  0084     MOVWF FSR
0CCC  0800     MOVF INDF, W
0CCD  3A17     XORLW 0x17
0CCE  1D03     BTFSS STATUS, 0x2
0CCF  2D3E     GOTO 0x53E
0CD0  087D     MOVF horario, W
0CD1  3E02     ADDLW 0x2
0CD2  0084     MOVWF FSR
0CD3  0180     CLRF INDF
0CD4  2D3E     GOTO 0x53E
131:                               break;
132:                           case DIA:
133:                               haycambio = 1;
0CD5  01C2     CLRF m
0CD6  0AC2     INCF m, F
134:                               if (fecha.day < maximodia) fecha.day++;
0CD7  0848     MOVF 0x48, W
0CD8  1283     BCF STATUS, 0x5
0CD9  026C     SUBWF fecha, W
0CDA  1C03     BTFSS STATUS, 0x0
0CDB  2CE3     GOTO 0x4E3
135:                               else
136:                                   if (fecha.day == maximodia) fecha.day = 1;
0CDC  086C     MOVF fecha, W
0CDD  1683     BSF STATUS, 0x5
0CDE  0648     XORWF 0x48, W
0CDF  1D03     BTFSS STATUS, 0x2
0CE0  2D3E     GOTO 0x53E
0CE1  1283     BCF STATUS, 0x5
0CE2  01EC     CLRF fecha
0CE3  0AEC     INCF fecha, F
0CE4  2D3E     GOTO 0x53E
137:                               break;
138:                           case MES:
0CE5  300C     MOVLW 0xC
139:                               haycambio = 1;
0CE6  01C2     CLRF m
0CE7  0AC2     INCF m, F
140:                               if (fecha.month < 12) fecha.month++;
0CE5  300C     MOVLW 0xC
0CE8  1283     BCF STATUS, 0x5
0CE9  026D     SUBWF 0x6D, W
0CEA  1C03     BTFSS STATUS, 0x0
0CEB  2CF1     GOTO 0x4F1
141:                               else
142:                                   if (fecha.month == 12) fecha.month = 1;
0CEC  086D     MOVF 0x6D, W
0CED  3A0C     XORLW 0xC
0CEE  1D03     BTFSS STATUS, 0x2
0CEF  2D3E     GOTO 0x53E
0CF0  01ED     CLRF 0x6D
0CF1  0AED     INCF 0x6D, F
0CF2  2D3E     GOTO 0x53E
143:                               break;
144:                           case ANIO:
0CF3  3063     MOVLW 0x63
145:                               haycambio = 1;
0CF4  01C2     CLRF m
0CF5  0AC2     INCF m, F
146:                               if (fecha.yr < 99) fecha.yr++; //solamente vamos hasta el ao 00
0CF3  3063     MOVLW 0x63
0CF6  1283     BCF STATUS, 0x5
0CF7  026E     SUBWF 0x6E, W
0CF8  1803     BTFSC STATUS, 0x0
0CF9  2CFC     GOTO 0x4FC
0CFA  0AEE     INCF 0x6E, F
0CFB  2D3E     GOTO 0x53E
147:                               else
148:                                   if (fecha.yr == 99) fecha.yr = 0; //solamente contamos desde el ao 99
0CFC  086E     MOVF 0x6E, W
0CFD  3A63     XORLW 0x63
0CFE  1D03     BTFSS STATUS, 0x2
0CFF  2D3E     GOTO 0x53E
0D00  01EE     CLRF 0x6E
0D01  2D3E     GOTO 0x53E
149:                               break;
150:                           case SINO:
151:                               banderasino = !banderasino;
0D02  3000     MOVLW 0x0
0D03  08B6     MOVF sign, F
0D04  1903     BTFSC STATUS, 0x2
0D05  3001     MOVLW 0x1
0D06  00B6     MOVWF sign
152:                               break;
0D07  2D3E     GOTO 0x53E
153:                           case TIEMPOENCENDIDO:
0D08  303C     MOVLW 0x3C
154:                               haycambio = 1;
0D09  01C2     CLRF m
0D0A  0AC2     INCF m, F
155:                               if (tiempoencendido < TIEMPOMAXIMOENCENDIDO) tiempoencendido++; //
0D08  303C     MOVLW 0x3C
0D0B  0246     SUBWF y, W
0D0C  1803     BTFSC STATUS, 0x0
0D0D  2D10     GOTO 0x510
0D0E  0AC6     INCF y, F
0D0F  2D3E     GOTO 0x53E
156:                               else
157:                                   if (tiempoencendido == TIEMPOMAXIMOENCENDIDO) tiempoencendido = 0;
0D10  0846     MOVF y, W
0D11  3A3C     XORLW 0x3C
0D12  1D03     BTFSS STATUS, 0x2
0D13  2D3E     GOTO 0x53E
0D14  01C6     CLRF y
0D15  2D3E     GOTO 0x53E
158:                               break;
159:                           case TIEMPOFALLA:
0D16  301E     MOVLW 0x1E
160:                               haycambio = 1;
0D17  01C2     CLRF m
0D18  0AC2     INCF m, F
161:                               if (tiempofalla < TIEMPOMAXIMOFALLA) tiempofalla++; //
0D16  301E     MOVLW 0x1E
0D19  0247     SUBWF f, W
0D1A  1803     BTFSC STATUS, 0x0
0D1B  2D1E     GOTO 0x51E
0D1C  0AC7     INCF f, F
0D1D  2D3E     GOTO 0x53E
162:                               else
163:                                   if (tiempofalla == TIEMPOMAXIMOFALLA) tiempofalla = 0;
0D1E  0847     MOVF f, W
0D1F  3A1E     XORLW 0x1E
0D20  1D03     BTFSS STATUS, 0x2
0D21  2D3E     GOTO 0x53E
0D22  01C7     CLRF f
0D23  2D3E     GOTO 0x53E
164:                               break;
165:                           case PERIODOENCENDIDO:
0D24  3007     MOVLW 0x7
166:                               haycambio = 1;
0D25  01C2     CLRF m
0D26  0AC2     INCF m, F
167:                               if (periodoencendido < TIEMPOMAXIMOPERIODO) periodoencendido++; //
0D24  3007     MOVLW 0x7
0D27  0265     SUBWF adcenteroI, W
0D28  1C03     BTFSS STATUS, 0x0
0D29  2D2F     GOTO 0x52F
168:                               else
169:                                   if (periodoencendido == TIEMPOMAXIMOPERIODO) periodoencendido = 1;
0D2A  0865     MOVF adcenteroI, W
0D2B  3A07     XORLW 0x7
0D2C  1D03     BTFSS STATUS, 0x2
0D2D  2D3E     GOTO 0x53E
0D2E  01E5     CLRF adcenteroI
0D2F  0AE5     INCF adcenteroI, F
0D30  2D3E     GOTO 0x53E
170:                               break;
171:                           default:
172:                               break;
173:                       }
174:                       if (aniobisiesto(fecha.yr) && fecha.month == 2) {
0D3E  1283     BCF STATUS, 0x5
0D3F  086E     MOVF 0x6E, W
0D40  279E     CALL 0x79E
0D41  120A     BCF PCLATH, 0x4
0D42  158A     BSF PCLATH, 0x3
0D43  0877     MOVF Logica, W
0D44  0476     IORWF TipoPin, W
0D45  1903     BTFSC STATUS, 0x2
0D46  2D4F     GOTO 0x54F
0D47  1283     BCF STATUS, 0x5
0D48  1303     BCF STATUS, 0x6
0D49  086D     MOVF 0x6D, W
0D4A  3A02     XORLW 0x2
0D4B  1D03     BTFSS STATUS, 0x2
0D4C  2D4F     GOTO 0x54F
175:                           maximodia = 29;
0D4D  301D     MOVLW 0x1D
0D4E  2D56     GOTO 0x556
176:                       } else if (fecha.month == 2)
0D4F  1283     BCF STATUS, 0x5
0D50  1303     BCF STATUS, 0x6
0D51  086D     MOVF 0x6D, W
0D52  3A02     XORLW 0x2
0D53  1D03     BTFSS STATUS, 0x2
0D54  2D58     GOTO 0x558
177:                           maximodia = 28;
0D55  301C     MOVLW 0x1C
0D56  1683     BSF STATUS, 0x5
0D57  00C8     MOVWF 0x48
178:                       if (fecha.month == 4 || fecha.month == 6 || fecha.month == 9 || fecha.month == 11) {
0D58  1283     BCF STATUS, 0x5
0D59  086D     MOVF 0x6D, W
0D5A  3A04     XORLW 0x4
0D5B  1903     BTFSC STATUS, 0x2
0D5C  2D69     GOTO 0x569
0D5D  086D     MOVF 0x6D, W
0D5E  3A06     XORLW 0x6
0D5F  1903     BTFSC STATUS, 0x2
0D60  2D69     GOTO 0x569
0D61  086D     MOVF 0x6D, W
0D62  3A09     XORLW 0x9
0D63  1903     BTFSC STATUS, 0x2
0D64  2D69     GOTO 0x569
0D65  086D     MOVF 0x6D, W
0D66  3A0B     XORLW 0xB
0D67  1D03     BTFSS STATUS, 0x2
0D68  2D6C     GOTO 0x56C
179:                           maximodia = 30;
0D69  301E     MOVLW 0x1E
0D6A  1683     BSF STATUS, 0x5
0D6B  00C8     MOVWF 0x48
180:                       }
181:                       if (fecha.month == 1 || fecha.month == 3 || fecha.month == 5 || fecha.month == 7 || fecha.month == 8 || fecha.month == 10 || fecha.month == 12) {
0D6C  1283     BCF STATUS, 0x5
0D6D  036D     DECF 0x6D, W
0D6E  1903     BTFSC STATUS, 0x2
0D6F  2D88     GOTO 0x588
0D70  086D     MOVF 0x6D, W
0D71  3A03     XORLW 0x3
0D72  1903     BTFSC STATUS, 0x2
0D73  2D88     GOTO 0x588
0D74  086D     MOVF 0x6D, W
0D75  3A05     XORLW 0x5
0D76  1903     BTFSC STATUS, 0x2
0D77  2D88     GOTO 0x588
0D78  086D     MOVF 0x6D, W
0D79  3A07     XORLW 0x7
0D7A  1903     BTFSC STATUS, 0x2
0D7B  2D88     GOTO 0x588
0D7C  086D     MOVF 0x6D, W
0D7D  3A08     XORLW 0x8
0D7E  1903     BTFSC STATUS, 0x2
0D7F  2D88     GOTO 0x588
0D80  086D     MOVF 0x6D, W
0D81  3A0A     XORLW 0xA
0D82  1903     BTFSC STATUS, 0x2
0D83  2D88     GOTO 0x588
0D84  086D     MOVF 0x6D, W
0D85  3A0C     XORLW 0xC
0D86  1D03     BTFSS STATUS, 0x2
0D87  2D8B     GOTO 0x58B
182:                           maximodia = 31;
0D88  301F     MOVLW 0x1F
0D89  1683     BSF STATUS, 0x5
0D8A  00C8     MOVWF 0x48
183:                       }
184:                       if (fecha.day > maximodia)
0D8B  1283     BCF STATUS, 0x5
0D8C  086C     MOVF fecha, W
0D8D  1683     BSF STATUS, 0x5
0D8E  0248     SUBWF 0x48, W
0D8F  1803     BTFSC STATUS, 0x0
0D90  2D94     GOTO 0x594
185:                           fecha.day = maximodia;
0D91  0848     MOVF 0x48, W
0D92  1283     BCF STATUS, 0x5
0D93  00EC     MOVWF fecha
186:                   }
187:                   if (Pulsacion(1, BOTON_Bajar, CON_REPETICION, LOGICA_INVERSA)) {
0D94  3000     MOVLW 0x0
0D95  1283     BCF STATUS, 0x5
0D96  1303     BCF STATUS, 0x6
0D97  1886     BTFSC PORTB, 0x1
0D98  3001     MOVLW 0x1
0D99  00F5     MOVWF Pin
0D9A  3001     MOVLW 0x1
0D9B  01F6     CLRF TipoPin
0D9C  0AF6     INCF TipoPin, F
0D9D  01F7     CLRF Logica
0D9E  0AF7     INCF Logica, F
0D9F  26D1     CALL 0x6D1
0DA0  120A     BCF PCLATH, 0x4
0DA1  158A     BSF PCLATH, 0x3
0DA2  3A00     XORLW 0x0
0DA3  1903     BTFSC STATUS, 0x2
0DA4  2E93     GOTO 0x693
188:           
189:                       refrescadisplay = 1;
0DA5  1683     BSF STATUS, 0x5
0DA6  1303     BCF STATUS, 0x6
0DA7  01C5     CLRF dia
0DA8  0AC5     INCF dia, F
190:                       switch (modificafecha) {
0DA9  2E30     GOTO 0x630
0E30  0864     MOVF 0x64, W
0E31  0084     MOVWF FSR
0E32  300A     MOVLW 0xA
0E33  0204     SUBWF FSR, W
0E34  1803     BTFSC STATUS, 0x0
0E35  2E3D     GOTO 0x63D
0E36  3010     MOVLW 0x10
0E37  008A     MOVWF PCLATH
0E38  1003     BCF STATUS, 0x0
0E39  0D04     RLF FSR, W
0E3A  0704     ADDWF FSR, W
0E3B  3E54     ADDLW 0x54
0E3C  0082     MOVWF PCL
1054  120A     BCF PCLATH, 0x4
191:                           case MINUTOS:
192:                               haycambio = 1;
0DAA  01C2     CLRF m
0DAB  0AC2     INCF m, F
193:                               if ((*horario).min > 0) (*horario).min--;
0DAC  0A7D     INCF horario, W
0DAD  0084     MOVWF FSR
0DAE  1383     BCF STATUS, 0x7
0DAF  0880     MOVF INDF, F
0DB0  1903     BTFSC STATUS, 0x2
0DB1  2DB4     GOTO 0x5B4
0DB2  0A7D     INCF horario, W
0DB3  2DC8     GOTO 0x5C8
194:                               else
195:                                   if ((*horario).min == 0) (*horario).min = 59;
0DB4  0A7D     INCF horario, W
0DB5  0084     MOVWF FSR
0DB6  0880     MOVF INDF, F
0DB7  1D03     BTFSS STATUS, 0x2
0DB8  2E3D     GOTO 0x63D
0DB9  0A7D     INCF horario, W
0DBA  0084     MOVWF FSR
0DBB  303B     MOVLW 0x3B
0DBC  2DD5     GOTO 0x5D5
196:                               break;
197:                           case HORA:
198:                               haycambio = 1;
0DBD  01C2     CLRF m
0DBE  0AC2     INCF m, F
199:                               if ((*horario).hrs > 0) (*horario).hrs--;
0DBF  087D     MOVF horario, W
0DC0  3E02     ADDLW 0x2
0DC1  0084     MOVWF FSR
0DC2  1383     BCF STATUS, 0x7
0DC3  0880     MOVF INDF, F
0DC4  1903     BTFSC STATUS, 0x2
0DC5  2DCB     GOTO 0x5CB
0DC6  087D     MOVF horario, W
0DC7  3E02     ADDLW 0x2
0DC8  0084     MOVWF FSR
0DC9  0380     DECF INDF, F
0DCA  2E3D     GOTO 0x63D
200:                               else
201:                                   if ((*horario).hrs == 0) (*horario).hrs = 23;
0DCB  087D     MOVF horario, W
0DCC  3E02     ADDLW 0x2
0DCD  0084     MOVWF FSR
0DCE  0880     MOVF INDF, F
0DCF  1D03     BTFSS STATUS, 0x2
0DD0  2E3D     GOTO 0x63D
0DD1  087D     MOVF horario, W
0DD2  3E02     ADDLW 0x2
0DD3  0084     MOVWF FSR
0DD4  3017     MOVLW 0x17
0DD5  0080     MOVWF INDF
0DD6  2E3D     GOTO 0x63D
202:                               break;
203:                           case DIA:
0DD7  3002     MOVLW 0x2
204:                               haycambio = 1;
0DD8  01C2     CLRF m
0DD9  0AC2     INCF m, F
205:                               if (fecha.day > 1) fecha.day--;
0DD7  3002     MOVLW 0x2
0DDA  1283     BCF STATUS, 0x5
0DDB  026C     SUBWF fecha, W
0DDC  1C03     BTFSS STATUS, 0x0
0DDD  2DE0     GOTO 0x5E0
0DDE  03EC     DECF fecha, F
0DDF  2E3D     GOTO 0x63D
206:                               else
207:                                   if (fecha.day == 1) fecha.day = maximodia;
0DE0  0B6C     DECFSZ fecha, W
0DE1  2E3D     GOTO 0x63D
0DE2  1683     BSF STATUS, 0x5
0DE3  0848     MOVF 0x48, W
0DE4  1283     BCF STATUS, 0x5
0DE5  00EC     MOVWF fecha
0DE6  2E3D     GOTO 0x63D
208:                               break;
209:                           case MES:
0DE7  3002     MOVLW 0x2
210:                               haycambio = 1;
0DE8  01C2     CLRF m
0DE9  0AC2     INCF m, F
211:                               if (fecha.month > 1) fecha.month--;
0DE7  3002     MOVLW 0x2
0DEA  1283     BCF STATUS, 0x5
0DEB  026D     SUBWF 0x6D, W
0DEC  1C03     BTFSS STATUS, 0x0
0DED  2DF0     GOTO 0x5F0
0DEE  03ED     DECF 0x6D, F
0DEF  2E3D     GOTO 0x63D
212:                               else
213:                                   if (fecha.month == 1) fecha.month = 12;
0DF0  0B6D     DECFSZ 0x6D, W
0DF1  2E3D     GOTO 0x63D
0DF2  300C     MOVLW 0xC
0DF3  00ED     MOVWF 0x6D
0DF4  2E3D     GOTO 0x63D
214:                               break;
215:                           case ANIO:
216:                               haycambio = 1;
0DF5  01C2     CLRF m
0DF6  0AC2     INCF m, F
217:                               if (fecha.yr > 0) fecha.yr--; //solamente vamos hasta el ao 00
0DF7  1283     BCF STATUS, 0x5
0DF8  086E     MOVF 0x6E, W
0DF9  1903     BTFSC STATUS, 0x2
0DFA  2DFD     GOTO 0x5FD
0DFB  03EE     DECF 0x6E, F
0DFC  2E3D     GOTO 0x63D
218:                               else
219:                                   if (fecha.yr == 0) fecha.yr = 99; //solamente contamos desde el ao 99
0DFD  08EE     MOVF 0x6E, F
0DFE  1D03     BTFSS STATUS, 0x2
0DFF  2E3D     GOTO 0x63D
0E00  3063     MOVLW 0x63
0E01  00EE     MOVWF 0x6E
0E02  2E3D     GOTO 0x63D
220:                               break;
221:                           case SINO:
222:                               banderasino = !banderasino;
0E03  3000     MOVLW 0x0
0E04  08B6     MOVF sign, F
0E05  1903     BTFSC STATUS, 0x2
0E06  3001     MOVLW 0x1
0E07  00B6     MOVWF sign
223:                               break;
0E08  2E3D     GOTO 0x63D
224:                           case TIEMPOENCENDIDO:
225:                               haycambio = 1;
0E09  01C2     CLRF m
0E0A  0AC2     INCF m, F
226:                               if (tiempoencendido > 0) tiempoencendido--; //
0E0B  0846     MOVF y, W
0E0C  1903     BTFSC STATUS, 0x2
0E0D  2E10     GOTO 0x610
0E0E  03C6     DECF y, F
0E0F  2E3D     GOTO 0x63D
227:                               else
228:                                   if (tiempoencendido == 0) tiempoencendido = TIEMPOMAXIMOENCENDIDO;
0E10  08C6     MOVF y, F
0E11  1D03     BTFSS STATUS, 0x2
0E12  2E3D     GOTO 0x63D
0E13  303C     MOVLW 0x3C
0E14  00C6     MOVWF y
0E15  2E3D     GOTO 0x63D
229:                               break;
230:                           case TIEMPOFALLA:
231:                               haycambio = 1;
0E16  01C2     CLRF m
0E17  0AC2     INCF m, F
232:                               if (tiempofalla > 0) tiempofalla--; //
0E18  0847     MOVF f, W
0E19  1903     BTFSC STATUS, 0x2
0E1A  2E1D     GOTO 0x61D
0E1B  03C7     DECF f, F
0E1C  2E3D     GOTO 0x63D
233:                               else
234:                                   if (tiempofalla == 0) tiempofalla = TIEMPOMAXIMOFALLA;
0E1D  08C7     MOVF f, F
0E1E  1D03     BTFSS STATUS, 0x2
0E1F  2E3D     GOTO 0x63D
0E20  301E     MOVLW 0x1E
0E21  00C7     MOVWF f
0E22  2E3D     GOTO 0x63D
235:                               break;
236:                           case PERIODOENCENDIDO:
0E23  3002     MOVLW 0x2
237:                               haycambio = 1;
0E24  01C2     CLRF m
0E25  0AC2     INCF m, F
238:                               if (periodoencendido > 1) periodoencendido--; //
0E23  3002     MOVLW 0x2
0E26  0265     SUBWF adcenteroI, W
0E27  1C03     BTFSS STATUS, 0x0
0E28  2E2B     GOTO 0x62B
0E29  03E5     DECF adcenteroI, F
0E2A  2E3D     GOTO 0x63D
239:                               else
240:                                   if (periodoencendido == 1) periodoencendido = TIEMPOMAXIMOPERIODO;
0E2B  0B65     DECFSZ adcenteroI, W
0E2C  2E3D     GOTO 0x63D
0E2D  3007     MOVLW 0x7
0E2E  00E5     MOVWF adcenteroI
0E2F  2E3D     GOTO 0x63D
241:                               break;
242:                           default:
243:                               break;
244:                       }
245:                       if (aniobisiesto(fecha.yr) && fecha.month == 2) {
0E3D  1283     BCF STATUS, 0x5
0E3E  086E     MOVF 0x6E, W
0E3F  279E     CALL 0x79E
0E40  120A     BCF PCLATH, 0x4
0E41  158A     BSF PCLATH, 0x3
0E42  0877     MOVF Logica, W
0E43  0476     IORWF TipoPin, W
0E44  1903     BTFSC STATUS, 0x2
0E45  2E4E     GOTO 0x64E
0E46  1283     BCF STATUS, 0x5
0E47  1303     BCF STATUS, 0x6
0E48  086D     MOVF 0x6D, W
0E49  3A02     XORLW 0x2
0E4A  1D03     BTFSS STATUS, 0x2
0E4B  2E4E     GOTO 0x64E
246:                           maximodia = 29;
0E4C  301D     MOVLW 0x1D
0E4D  2E55     GOTO 0x655
247:                       } else if (fecha.month == 2)
0E4E  1283     BCF STATUS, 0x5
0E4F  1303     BCF STATUS, 0x6
0E50  086D     MOVF 0x6D, W
0E51  3A02     XORLW 0x2
0E52  1D03     BTFSS STATUS, 0x2
0E53  2E57     GOTO 0x657
248:                           maximodia = 28;
0E54  301C     MOVLW 0x1C
0E55  1683     BSF STATUS, 0x5
0E56  00C8     MOVWF 0x48
249:                       if (fecha.month == 4 || fecha.month == 6 || fecha.month == 9 || fecha.month == 11) {
0E57  1283     BCF STATUS, 0x5
0E58  086D     MOVF 0x6D, W
0E59  3A04     XORLW 0x4
0E5A  1903     BTFSC STATUS, 0x2
0E5B  2E68     GOTO 0x668
0E5C  086D     MOVF 0x6D, W
0E5D  3A06     XORLW 0x6
0E5E  1903     BTFSC STATUS, 0x2
0E5F  2E68     GOTO 0x668
0E60  086D     MOVF 0x6D, W
0E61  3A09     XORLW 0x9
0E62  1903     BTFSC STATUS, 0x2
0E63  2E68     GOTO 0x668
0E64  086D     MOVF 0x6D, W
0E65  3A0B     XORLW 0xB
0E66  1D03     BTFSS STATUS, 0x2
0E67  2E6B     GOTO 0x66B
250:                           maximodia = 30;
0E68  301E     MOVLW 0x1E
0E69  1683     BSF STATUS, 0x5
0E6A  00C8     MOVWF 0x48
251:                       }
252:                       if (fecha.month == 1 || fecha.month == 3 || fecha.month == 5 || fecha.month == 7 || fecha.month == 8 || fecha.month == 10 || fecha.month == 12) {
0E6B  1283     BCF STATUS, 0x5
0E6C  036D     DECF 0x6D, W
0E6D  1903     BTFSC STATUS, 0x2
0E6E  2E87     GOTO 0x687
0E6F  086D     MOVF 0x6D, W
0E70  3A03     XORLW 0x3
0E71  1903     BTFSC STATUS, 0x2
0E72  2E87     GOTO 0x687
0E73  086D     MOVF 0x6D, W
0E74  3A05     XORLW 0x5
0E75  1903     BTFSC STATUS, 0x2
0E76  2E87     GOTO 0x687
0E77  086D     MOVF 0x6D, W
0E78  3A07     XORLW 0x7
0E79  1903     BTFSC STATUS, 0x2
0E7A  2E87     GOTO 0x687
0E7B  086D     MOVF 0x6D, W
0E7C  3A08     XORLW 0x8
0E7D  1903     BTFSC STATUS, 0x2
0E7E  2E87     GOTO 0x687
0E7F  086D     MOVF 0x6D, W
0E80  3A0A     XORLW 0xA
0E81  1903     BTFSC STATUS, 0x2
0E82  2E87     GOTO 0x687
0E83  086D     MOVF 0x6D, W
0E84  3A0C     XORLW 0xC
0E85  1D03     BTFSS STATUS, 0x2
0E86  2E8A     GOTO 0x68A
253:                           maximodia = 31;
0E87  301F     MOVLW 0x1F
0E88  1683     BSF STATUS, 0x5
0E89  00C8     MOVWF 0x48
254:                       }
255:                       if (fecha.day > maximodia)
0E8A  1283     BCF STATUS, 0x5
0E8B  086C     MOVF fecha, W
0E8C  1683     BSF STATUS, 0x5
0E8D  0248     SUBWF 0x48, W
0E8E  1803     BTFSC STATUS, 0x0
0E8F  2E93     GOTO 0x693
256:                           fecha.day = maximodia;
0E90  0848     MOVF 0x48, W
0E91  1283     BCF STATUS, 0x5
0E92  00EC     MOVWF fecha
257:                   }
258:           
259:           
260:                   bandera_startglobal = 0;
0E93  1683     BSF STATUS, 0x5
0E94  1303     BCF STATUS, 0x6
0E96  01B5     CLRF counter
261:                   if (Pulsacion(3, BOTON_ONOFF, INMEDIATO, LOGICA_INVERSA)) {
0E95  3000     MOVLW 0x0
0E97  1283     BCF STATUS, 0x5
0E98  1A86     BTFSC PORTB, 0x5
0E99  3001     MOVLW 0x1
0E9A  00F5     MOVWF Pin
0E9B  3002     MOVLW 0x2
0E9C  00F6     MOVWF TipoPin
0E9D  3003     MOVLW 0x3
0E9E  01F7     CLRF Logica
0E9F  0AF7     INCF Logica, F
0EA0  26D1     CALL 0x6D1
0EA1  120A     BCF PCLATH, 0x4
0EA2  158A     BSF PCLATH, 0x3
0EA3  3A00     XORLW 0x0
0EA4  1903     BTFSC STATUS, 0x2
0EA5  2EAA     GOTO 0x6AA
262:           
263:                       bandera_startglobal = 1;
0EA6  1683     BSF STATUS, 0x5
0EA7  1303     BCF STATUS, 0x6
0EA8  01B5     CLRF counter
0EA9  0AB5     INCF counter, F
264:                   }
265:           
266:                   if (Pulsacion(4, BOTON_MENU, SIN_REPETICION/*INMEDIATO*/, LOGICA_INVERSA)) {
0EAA  3000     MOVLW 0x0
0EAB  1283     BCF STATUS, 0x5
0EAC  1303     BCF STATUS, 0x6
0EAD  1986     BTFSC PORTB, 0x3
0EAE  3001     MOVLW 0x1
0EAF  00F5     MOVWF Pin
0EB0  3004     MOVLW 0x4
0EB1  01F6     CLRF TipoPin
0EB2  01F7     CLRF Logica
0EB3  0AF7     INCF Logica, F
0EB4  26D1     CALL 0x6D1
0EB5  120A     BCF PCLATH, 0x4
0EB6  158A     BSF PCLATH, 0x3
0EB7  3A00     XORLW 0x0
0EB8  1903     BTFSC STATUS, 0x2
0EB9  2EC5     GOTO 0x6C5
267:           
268:                       buzzer_on();
0EBA  27EA     CALL 0x7EA
0EBB  120A     BCF PCLATH, 0x4
0EBC  158A     BSF PCLATH, 0x3
269:                       if (menuactual < ULTIMOMENU)
0EBD  3011     MOVLW 0x11
0EBE  1683     BSF STATUS, 0x5
0EBF  0244     SUBWF a, W
0EC0  1803     BTFSC STATUS, 0x0
0EC1  2EC4     GOTO 0x6C4
270:                           menuactual++;
0EC2  0AC4     INCF a, F
0EC3  2EC5     GOTO 0x6C5
271:                       else
272:                           menuactual = 0;
0EC4  01C4     CLRF a
273:                   }
274:                   T0IF = 0;
0EC5  110B     BCF INTCON, 0x2
275:               } else {
276:                   ///interrupciones no contempladas
277:               }
278:           
279:               /* This code stub shows general interrupt handling.  Note that these
280:               conditional statements are not handled within 3 seperate if blocks.
281:               Do not use a seperate if block for each interrupt flag to avoid run
282:               time errors. */
283:           
284:           #if 0
285:           
286:               /* Add interrupt routine code here. */
287:           
288:               /* Determine which flag generated the interrupt */
289:               if (<Interrupt Flag 1 >) {
290:                   <Interrupt Flag 1 = 0 >; /* Clear Interrupt Flag 1 */
291:               } else if (<Interrupt Flag 2 >) {
292:                   <Interrupt Flag 2 = 0 >; /* Clear Interrupt Flag 2 */
293:               } else {
294:                   /* Unhandled interrupts */
295:               }
296:           
297:           #endif
298:           
299:           }
0EC6  1283     BCF STATUS, 0x5
300:           #endif
301:           
302:           
303:           #endif
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/adcPic16.c  ---------------------------
1:             #include <xc.h>
2:             #include <stdint.h>
3:             #include <stdbool.h>
4:             #include "system.h"
5:             #include "user.h"
6:             #include "adcPic16.h"
7:             
8:             void setADCChannel(char canal) {
0FF4  00F1     MOVWF canal
1425  1283     BCF STATUS, 0x5
1426  00A4     MOVWF dato
9:                 ADCON0bits.CHS = canal; //Selecciono el canal AD0
0FF5  00F0     MOVWF divisor
0FF6  0DF0     RLF divisor, F
0FF7  0DF0     RLF divisor, F
0FF8  0DF0     RLF divisor, F
0FF9  1283     BCF STATUS, 0x5
0FFA  081F     MOVF ADCON0, W
0FFB  0670     XORWF divisor, W
0FFC  39C7     ANDLW 0xC7
0FFD  0670     XORWF divisor, W
0FFE  009F     MOVWF ADCON0
1427  00A3     MOVWF x
1428  0DA3     RLF x, F
1429  0DA3     RLF x, F
142A  0DA3     RLF x, F
142B  081F     MOVF ADCON0, W
142C  0623     XORWF x, W
142D  39C7     ANDLW 0xC7
142E  0623     XORWF x, W
142F  009F     MOVWF ADCON0
10:            };
0FFF  0008     RETURN
1430  0008     RETURN
11:            
12:            char getADCChannel(void) {
13:                return ADCON0bits.CHS; //Selecciono el canal AD0
0FDB  1283     BCF STATUS, 0x5
0FDC  0C1F     RRF ADCON0, W
0FDD  00F0     MOVWF divisor
0FDE  0CF0     RRF divisor, F
0FDF  0C70     RRF divisor, W
0FE0  3907     ANDLW 0x7
14:            };
0FE1  0008     RETURN
15:            
16:            void openADC(void) {
17:            
18:                TRISA0 = 1; //configuro como entrada para el ADC0
07EB  1683     BSF STATUS, 0x5
07EC  1303     BCF STATUS, 0x6
07ED  1405     BSF PORTA, 0x0
19:                TRISA1 = 1; //configuro como entrada para el ADC1
07EE  1485     BSF PORTA, 0x1
20:                TRISA3 = 1; //Configuro como entrada para Vref+
07EF  1585     BSF PORTA, 0x3
21:                TRISA2 = 0; //No usado
07F0  1105     BCF PORTA, 0x2
22:                TRISA4 = 0;//No usado
07F1  1205     BCF PORTA, 0x4
23:                TRISA5 = 0;//No usado
07F2  1285     BCF PORTA, 0x5
24:                ADCON1bits.PCFG = 0b101; //An3 como VREF+ , AN0 y AN1 como entrada analogica, AN0 Corriente, AN1 Tension de red
07F3  081F     MOVF ADCON0, W
07F4  39F0     ANDLW 0xF0
07F5  3805     IORLW 0x5
07F6  009F     MOVWF ADCON0
25:                ADCON1bits.ADFM = 1; //justificado a la derecha
07F7  179F     BSF ADCON0, 0x7
26:                ADCON1bits.ADCS2 = 1;
07F8  171F     BSF ADCON0, 0x6
27:                ADCON0bits.ADCS = 0b10; //Tosc/64
07F9  1283     BCF STATUS, 0x5
07FA  081F     MOVF ADCON0, W
07FB  393F     ANDLW 0x3F
07FC  3880     IORLW 0x80
07FD  009F     MOVWF ADCON0
28:                ADCON0bits.ADON = 1; //Activo el ADC
07FE  141F     BSF ADCON0, 0x0
29:            
30:            }
07FF  0008     RETURN
31:            
32:            unsigned int adcRead(void) {
33:            
34:                return ((unsigned int) ADRESH << 8) | ADRESL;
0F97  081E     MOVF ADRESH, W
0F98  00F1     MOVWF canal
0F99  01F0     CLRF divisor
0F9A  1683     BSF STATUS, 0x5
0F9B  081E     MOVF ADRESH, W
0F9C  04F0     IORWF divisor, F
35:            }
0F9D  0008     RETURN
36:            
37:            void startADC(void) {
38:                ADCON0bits.GO_DONE = 1;
0FE2  1283     BCF STATUS, 0x5
0FE3  151F     BSF ADCON0, 0x2
39:            }
0FE4  0008     RETURN
40:            
41:            void interruptADC_on(void) {
42:                ADIE = 1;
140F  1683     BSF STATUS, 0x5
1410  1303     BCF STATUS, 0x6
1411  170C     BSF PIR1, 0x6
43:            }
1412  0008     RETURN
44:            
45:            void interruptADC_off(void) {
46:                ADIE = 0;
47:            }
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/_isl1208.c  ---------------------------
1:             ////////////////////////////////////////////////////////////////////////////////////////
2:             ///                               isl1208.C                                          ///
3:             ///                     Driver for Real Time Clock                                   ///
4:             ///                     modified by Pablo Fernando Manieri - Enero 2015              ///
5:             ///                                                                                  ///
6:             /// bool ISL1208_ready(void) - Testea si el RTC est presente                        ///
7:             /// void isl1208_init(val)                                                           ///
8:             ///                  - Enable oscillator without clearing the seconds register       ///
9:             ///                    used when PIC loses power and isl1208 run from 3V BAT         ///
10:            ///                  - Config Control Register with next parameters:                 ///
11:            ///                     isl1208_ALL_DISABLED          All disabled                   ///
12:            ///                     isl1208_OUT_ON_DISABLED_HIHG  Out to Hight on Disable Out    ///
13:            ///                     isl1208_OUT_ENABLED           Out Enabled                    ///
14:            ///                     isl1208_OUT_1_HZ              Freq. Out to 1 Hz              ///
15:            ///                     isl1208_OUT_4_KHZ             Freq. Out to 4.096 Khz         ///
16:            ///                     isl1208_OUT_8_KHZ             Freq. Out to 8.192 Khz         ///
17:            ///                     isl1208_OUT_32_KHZ            Freq. Out to 32.768 Khz        ///
18:            ///                                                                                  ///
19:            ///                     Example init:                                                ///
20:            ///                     isl1208_init(isl1208_ALL_DISABLED);                          ///
21:            ///                     isl1208_init(isl1208_OUT_ENABLED | isl1208_OUT_1_HZ);        ///
22:            ///                                                                                  ///
23:            /// void isl1208_set_date_time(day,mth,year,dow,hour,min,sec) - Set the date/time    ///
24:            ///                                                                                  ///
25:            /// void isl1208_get_date(day,mth,year,dow) - Get the date                           ///
26:            ///                                                                                  ///
27:            /// void isl1208_get_time(hr,min,sec) - Get the time                                 ///
28:            ///                                                                                  ///
29:            /// char isl1208_read_nvram_unsigned char(char addr) - Read unsigned char in address ///
30:            ///                                                                                  ///
31:            /// void isl1208_write_nvram_unsigned char(char addr, char value) - Write unsigned   ///
32:            ///                                                                  char in address ///
33:            ///                                                                                  ///
34:            /// void isl1208_get_day_of_week(char* ptr) - Get string Day Of Week                 ///
35:            ///                                                                                  ///
36:            ///                                                                                  ///
37:            ////////////////////////////////////////////////////////////////////////////////////////
38:            
39:            #include <xc.h>
40:            #include <stdio.h>
41:            #include <stdbool.h>       /* For true/false definition */
42:            #include "system.h"        /* System funct/params, like osc/peripheral config */
43:            #include "HardI2C.h"
44:            #include "_isl1208.h"
45:            #include "user.h"
46:            
47:            bool ISL1208_ready(void) {
48:                bool ack;
49:            
50:                start_i2c(); // If the write command is acknowledged,
0949  2344     CALL 0x344
094A  120A     BCF PCLATH, 0x4
094B  158A     BSF PCLATH, 0x3
51:                ack = write_i2c(isl1208_Write); // then the device is ready.
094C  30DE     MOVLW 0xDE
094D  231A     CALL 0x31A
094E  120A     BCF PCLATH, 0x4
094F  158A     BSF PCLATH, 0x3
0950  1283     BCF STATUS, 0x5
0951  00A4     MOVWF dato
52:                stop_i2c();
0952  234C     CALL 0x34C
53:                return !ack; // Invert ACK returned so TRUE = ACK OK
0953  1283     BCF STATUS, 0x5
0954  3000     MOVLW 0x0
0955  08A4     MOVF dato, F
0956  1903     BTFSC STATUS, 0x2
0957  3001     MOVLW 0x1
54:            }
0958  0008     RETURN
55:            
56:            unsigned char ISL1208_Read_status(void) {
57:                char SR;
58:                start_i2c(); // If the write command is acknowledged,
0959  2344     CALL 0x344
095A  120A     BCF PCLATH, 0x4
095B  158A     BSF PCLATH, 0x3
59:                write_i2c(isl1208_Write); // then the device is ready.
095C  30DE     MOVLW 0xDE
095D  231A     CALL 0x31A
095E  120A     BCF PCLATH, 0x4
095F  158A     BSF PCLATH, 0x3
60:                write_i2c(0x07);
0960  3007     MOVLW 0x7
0961  231A     CALL 0x31A
0962  120A     BCF PCLATH, 0x4
0963  158A     BSF PCLATH, 0x3
61:                rstart_i2c(); 
0964  2388     CALL 0x388
0965  120A     BCF PCLATH, 0x4
0966  158A     BSF PCLATH, 0x3
62:                write_i2c(isl1208_Read);
0967  30DF     MOVLW 0xDF
0968  231A     CALL 0x31A
0969  120A     BCF PCLATH, 0x4
096A  158A     BSF PCLATH, 0x3
63:                SR = read_i2c(NOACK);
096B  3001     MOVLW 0x1
096C  2354     CALL 0x354
096D  120A     BCF PCLATH, 0x4
096E  158A     BSF PCLATH, 0x3
096F  00A5     MOVWF y
64:                stop_i2c();
0970  234C     CALL 0x34C
65:                return SR;
0971  1283     BCF STATUS, 0x5
0972  0825     MOVF y, W
66:            }
0973  0008     RETURN
67:            
68:            void isl1208_init(unsigned char val) {
69:            
70:                unsigned char seconds = 0;
71:            
72:            #ifndef USE_INTERRUPTS
73:                //di();
74:            #endif
75:                //TODO Verificar secuencia correcta para pode escribir en el ISL1208
76:                
77:            #ifndef USE_INTERRUPTS
78:                //ei();
79:            #endif
80:            
81:            }
82:            
83:            void isl1208_set_time(unsigned char hr, unsigned char min, unsigned char sec) {
0A93  00AC     MOVWF hr
84:            
85:            #ifndef USE_INTERRUPTS
86:                //di();
87:            #endif
88:            
89:                sec &= 0x7F;
0A95  13AB     BCF sec, 0x7
90:                min &= 0x7F;
0A96  13AA     BCF Data, 0x7
91:                hr &= 0x3F;
0A94  303F     MOVLW 0x3F
0A97  05AC     ANDWF hr, F
92:                start_i2c();
0A98  2344     CALL 0x344
0A99  120A     BCF PCLATH, 0x4
0A9A  158A     BSF PCLATH, 0x3
93:                write_i2c(isl1208_Write);
0A9B  30DE     MOVLW 0xDE
0A9C  231A     CALL 0x31A
0A9D  120A     BCF PCLATH, 0x4
0A9E  158A     BSF PCLATH, 0x3
94:                write_i2c(0x07);
0A9F  3007     MOVLW 0x7
0AA0  231A     CALL 0x31A
0AA1  120A     BCF PCLATH, 0x4
0AA2  158A     BSF PCLATH, 0x3
95:                write_i2c(0b00010000);
0AA3  3010     MOVLW 0x10
0AA4  231A     CALL 0x31A
0AA5  120A     BCF PCLATH, 0x4
0AA6  158A     BSF PCLATH, 0x3
96:                stop_i2c();
0AA7  234C     CALL 0x34C
0AA8  120A     BCF PCLATH, 0x4
0AA9  158A     BSF PCLATH, 0x3
97:                start_i2c();
0AAA  2344     CALL 0x344
0AAB  120A     BCF PCLATH, 0x4
0AAC  158A     BSF PCLATH, 0x3
98:                write_i2c(isl1208_Write);
0AAD  30DE     MOVLW 0xDE
0AAE  231A     CALL 0x31A
0AAF  120A     BCF PCLATH, 0x4
0AB0  158A     BSF PCLATH, 0x3
99:                write_i2c(0x00);
0AB1  3000     MOVLW 0x0
0AB2  231A     CALL 0x31A
0AB3  120A     BCF PCLATH, 0x4
0AB4  158A     BSF PCLATH, 0x3
100:               write_i2c(isl1208_bin2bcd(sec));
0AB5  1283     BCF STATUS, 0x5
0AB6  082B     MOVF sec, W
0AB7  2332     CALL 0x332
0AB8  120A     BCF PCLATH, 0x4
0AB9  158A     BSF PCLATH, 0x3
0ABA  231A     CALL 0x31A
0ABB  120A     BCF PCLATH, 0x4
0ABC  158A     BSF PCLATH, 0x3
101:               write_i2c(isl1208_bin2bcd(min));
0ABD  1283     BCF STATUS, 0x5
0ABE  082A     MOVF Data, W
0ABF  2332     CALL 0x332
0AC0  120A     BCF PCLATH, 0x4
0AC1  158A     BSF PCLATH, 0x3
0AC2  231A     CALL 0x31A
0AC3  120A     BCF PCLATH, 0x4
0AC4  158A     BSF PCLATH, 0x3
102:               write_i2c(isl1208_bin2bcd(hr) | 0b10000000);
0AC5  1283     BCF STATUS, 0x5
0AC6  082C     MOVF hr, W
0AC7  2332     CALL 0x332
0AC8  120A     BCF PCLATH, 0x4
0AC9  158A     BSF PCLATH, 0x3
0ACA  3880     IORLW 0x80
0ACB  231A     CALL 0x31A
0ACC  120A     BCF PCLATH, 0x4
0ACD  158A     BSF PCLATH, 0x3
103:               stop_i2c();
0ACE  2B4C     GOTO 0x34C
104:           
105:           #ifndef USE_INTERRUPTS
106:               //  ei();
107:           #endif
108:           
109:           }
110:           
111:           void isl1208_set_date(unsigned char* day, unsigned char* mth, unsigned char* year, unsigned char* dow) {
0ACF  00AD     MOVWF day
112:           
113:           #ifndef USE_INTERRUPTS
114:               //di();
115:           #endif
116:           
117:               start_i2c();
0AD0  2344     CALL 0x344
0AD1  120A     BCF PCLATH, 0x4
0AD2  158A     BSF PCLATH, 0x3
118:               write_i2c(isl1208_Write);
0AD3  30DE     MOVLW 0xDE
0AD4  231A     CALL 0x31A
0AD5  120A     BCF PCLATH, 0x4
0AD6  158A     BSF PCLATH, 0x3
119:               write_i2c(0x07);
0AD7  3007     MOVLW 0x7
0AD8  231A     CALL 0x31A
0AD9  120A     BCF PCLATH, 0x4
0ADA  158A     BSF PCLATH, 0x3
120:               write_i2c(0b00010000);
0ADB  3010     MOVLW 0x10
0ADC  231A     CALL 0x31A
0ADD  120A     BCF PCLATH, 0x4
0ADE  158A     BSF PCLATH, 0x3
121:               stop_i2c();
0ADF  234C     CALL 0x34C
0AE0  120A     BCF PCLATH, 0x4
0AE1  158A     BSF PCLATH, 0x3
122:               start_i2c();
0AE2  2344     CALL 0x344
0AE3  120A     BCF PCLATH, 0x4
0AE4  158A     BSF PCLATH, 0x3
123:               write_i2c(isl1208_Write);
0AE5  30DE     MOVLW 0xDE
0AE6  231A     CALL 0x31A
0AE7  120A     BCF PCLATH, 0x4
0AE8  158A     BSF PCLATH, 0x3
124:               write_i2c(0x03);
0AE9  3003     MOVLW 0x3
0AEA  231A     CALL 0x31A
0AEB  120A     BCF PCLATH, 0x4
0AEC  158A     BSF PCLATH, 0x3
125:               write_i2c(isl1208_bin2bcd(*day));
0AED  1283     BCF STATUS, 0x5
0AEE  082D     MOVF day, W
0AEF  0084     MOVWF FSR
0AF0  1383     BCF STATUS, 0x7
0AF1  0800     MOVF INDF, W
0AF2  2332     CALL 0x332
0AF3  120A     BCF PCLATH, 0x4
0AF4  158A     BSF PCLATH, 0x3
0AF5  231A     CALL 0x31A
0AF6  120A     BCF PCLATH, 0x4
0AF7  158A     BSF PCLATH, 0x3
126:               write_i2c(isl1208_bin2bcd(*mth));
0AF8  1283     BCF STATUS, 0x5
0AF9  082A     MOVF Data, W
0AFA  0084     MOVWF FSR
0AFB  1383     BCF STATUS, 0x7
0AFC  0800     MOVF INDF, W
0AFD  2332     CALL 0x332
0AFE  120A     BCF PCLATH, 0x4
0AFF  158A     BSF PCLATH, 0x3
0B00  231A     CALL 0x31A
0B01  120A     BCF PCLATH, 0x4
0B02  158A     BSF PCLATH, 0x3
127:               write_i2c(isl1208_bin2bcd(*year));
0B03  1283     BCF STATUS, 0x5
0B04  082B     MOVF sec, W
0B05  0084     MOVWF FSR
0B06  1383     BCF STATUS, 0x7
0B07  0800     MOVF INDF, W
0B08  2332     CALL 0x332
0B09  120A     BCF PCLATH, 0x4
0B0A  158A     BSF PCLATH, 0x3
0B0B  231A     CALL 0x31A
0B0C  120A     BCF PCLATH, 0x4
0B0D  158A     BSF PCLATH, 0x3
128:               write_i2c(isl1208_bin2bcd(*dow));
0B0E  1283     BCF STATUS, 0x5
0B0F  082C     MOVF hr, W
0B10  0084     MOVWF FSR
0B11  1383     BCF STATUS, 0x7
0B12  0800     MOVF INDF, W
0B13  2332     CALL 0x332
0B14  120A     BCF PCLATH, 0x4
0B15  158A     BSF PCLATH, 0x3
0B16  231A     CALL 0x31A
0B17  120A     BCF PCLATH, 0x4
0B18  158A     BSF PCLATH, 0x3
129:               stop_i2c();
0B19  2B4C     GOTO 0x34C
130:           
131:           #ifndef USE_INTERRUPTS
132:               //  ei();
133:           #endif
134:           
135:           }
136:           
137:           void isl1208_get_date(unsigned char* day, unsigned char* mth, unsigned char* year, unsigned char *dow) {
0A08  00AB     MOVWF sec
138:           
139:           #ifndef USE_INTERRUPTS
140:               // di();
141:           #endif
142:           
143:               start_i2c();
0A09  2344     CALL 0x344
0A0A  120A     BCF PCLATH, 0x4
0A0B  158A     BSF PCLATH, 0x3
144:               write_i2c(isl1208_Write);
0A0C  30DE     MOVLW 0xDE
0A0D  231A     CALL 0x31A
0A0E  120A     BCF PCLATH, 0x4
0A0F  158A     BSF PCLATH, 0x3
145:               write_i2c(0x03);
0A10  3003     MOVLW 0x3
0A11  231A     CALL 0x31A
0A12  120A     BCF PCLATH, 0x4
0A13  158A     BSF PCLATH, 0x3
146:               rstart_i2c();
0A14  2388     CALL 0x388
0A15  120A     BCF PCLATH, 0x4
0A16  158A     BSF PCLATH, 0x3
147:               write_i2c(isl1208_Read);
0A17  30DF     MOVLW 0xDF
0A18  231A     CALL 0x31A
0A19  120A     BCF PCLATH, 0x4
0A1A  158A     BSF PCLATH, 0x3
148:               *day = isl1208_bcd2bin(read_i2c(ACK) & 0x3f);
0A1B  1283     BCF STATUS, 0x5
0A1C  082B     MOVF sec, W
0A1D  0084     MOVWF FSR
0A1E  3000     MOVLW 0x0
0A1F  2354     CALL 0x354
0A20  120A     BCF PCLATH, 0x4
0A21  158A     BSF PCLATH, 0x3
0A22  393F     ANDLW 0x3F
0A23  237E     CALL 0x37E
0A24  120A     BCF PCLATH, 0x4
0A25  158A     BSF PCLATH, 0x3
0A26  1383     BCF STATUS, 0x7
0A27  0080     MOVWF INDF
149:               *mth = isl1208_bcd2bin(read_i2c(ACK) & 0x1f);
0A28  0828     MOVF mth, W
0A29  0084     MOVWF FSR
0A2A  3000     MOVLW 0x0
0A2B  2354     CALL 0x354
0A2C  120A     BCF PCLATH, 0x4
0A2D  158A     BSF PCLATH, 0x3
0A2E  391F     ANDLW 0x1F
0A2F  237E     CALL 0x37E
0A30  120A     BCF PCLATH, 0x4
0A31  158A     BSF PCLATH, 0x3
0A32  1383     BCF STATUS, 0x7
0A33  0080     MOVWF INDF
150:               *year = isl1208_bcd2bin(read_i2c(ACK));
0A34  0829     MOVF year, W
0A35  0084     MOVWF FSR
0A36  3000     MOVLW 0x0
0A37  2354     CALL 0x354
0A38  120A     BCF PCLATH, 0x4
0A39  158A     BSF PCLATH, 0x3
0A3A  237E     CALL 0x37E
0A3B  120A     BCF PCLATH, 0x4
0A3C  158A     BSF PCLATH, 0x3
0A3D  1383     BCF STATUS, 0x7
0A3E  0080     MOVWF INDF
151:               *dow = isl1208_bcd2bin(read_i2c(NOACK) & 0x07);
0A3F  082A     MOVF Data, W
0A40  0084     MOVWF FSR
0A41  3001     MOVLW 0x1
0A42  2354     CALL 0x354
0A43  120A     BCF PCLATH, 0x4
0A44  158A     BSF PCLATH, 0x3
0A45  3907     ANDLW 0x7
0A46  237E     CALL 0x37E
0A47  120A     BCF PCLATH, 0x4
0A48  158A     BSF PCLATH, 0x3
0A49  1383     BCF STATUS, 0x7
0A4A  0080     MOVWF INDF
152:               stop_i2c();
0A4B  2B4C     GOTO 0x34C
153:           #ifndef USE_INTERRUPTS
154:               // ei();
155:           #endif
156:           
157:           }
158:           
159:           void isl1208_get_time(unsigned char *hr, unsigned char* min, unsigned char *sec) {
0996  00AA     MOVWF Data
160:           
161:           #ifndef USE_INTERRUPTS
162:               // di();
163:           #endif
164:           
165:               start_i2c();
0997  2344     CALL 0x344
0998  120A     BCF PCLATH, 0x4
0999  158A     BSF PCLATH, 0x3
166:               write_i2c(isl1208_Write);
099A  30DE     MOVLW 0xDE
099B  231A     CALL 0x31A
099C  120A     BCF PCLATH, 0x4
099D  158A     BSF PCLATH, 0x3
167:               write_i2c(0x00);
099E  3000     MOVLW 0x0
099F  231A     CALL 0x31A
09A0  120A     BCF PCLATH, 0x4
09A1  158A     BSF PCLATH, 0x3
168:           
169:               rstart_i2c();
09A2  2388     CALL 0x388
09A3  120A     BCF PCLATH, 0x4
09A4  158A     BSF PCLATH, 0x3
170:               write_i2c(isl1208_Read);
09A5  30DF     MOVLW 0xDF
09A6  231A     CALL 0x31A
09A7  120A     BCF PCLATH, 0x4
09A8  158A     BSF PCLATH, 0x3
171:               *sec = isl1208_bcd2bin(read_i2c(ACK) & 0x7f);
09A9  1283     BCF STATUS, 0x5
09AA  0829     MOVF year, W
09AB  0084     MOVWF FSR
09AC  3000     MOVLW 0x0
09AD  2354     CALL 0x354
09AE  120A     BCF PCLATH, 0x4
09AF  158A     BSF PCLATH, 0x3
09B0  397F     ANDLW 0x7F
09B1  237E     CALL 0x37E
09B2  120A     BCF PCLATH, 0x4
09B3  158A     BSF PCLATH, 0x3
09B4  1383     BCF STATUS, 0x7
09B5  0080     MOVWF INDF
172:               * min = isl1208_bcd2bin(read_i2c(ACK) & 0x7f);
09B6  0828     MOVF mth, W
09B7  0084     MOVWF FSR
09B8  3000     MOVLW 0x0
09B9  2354     CALL 0x354
09BA  120A     BCF PCLATH, 0x4
09BB  158A     BSF PCLATH, 0x3
09BC  397F     ANDLW 0x7F
09BD  237E     CALL 0x37E
09BE  120A     BCF PCLATH, 0x4
09BF  158A     BSF PCLATH, 0x3
09C0  1383     BCF STATUS, 0x7
09C1  0080     MOVWF INDF
173:               * hr = isl1208_bcd2bin(read_i2c(NOACK) & 0x3f);
09C2  082A     MOVF Data, W
09C3  0084     MOVWF FSR
09C4  3001     MOVLW 0x1
09C5  2354     CALL 0x354
09C6  120A     BCF PCLATH, 0x4
09C7  158A     BSF PCLATH, 0x3
09C8  393F     ANDLW 0x3F
09C9  237E     CALL 0x37E
09CA  120A     BCF PCLATH, 0x4
09CB  158A     BSF PCLATH, 0x3
09CC  1383     BCF STATUS, 0x7
09CD  0080     MOVWF INDF
174:               stop_i2c();
09CE  2B4C     GOTO 0x34C
175:           
176:           #ifndef USE_INTERRUPTS
177:               // ei();
178:           #endif
179:           
180:           }
181:           
182:           void isl1208_set_time_enc(unsigned char hr, unsigned char min, unsigned char sec) {
0A6A  00AC     MOVWF hr
183:           #ifndef USE_INTERRUPTS
184:               //di();
185:           #endif
186:               min &=0x7F;
0A6C  13AA     BCF Data, 0x7
187:               hr &= 0x3F;
0A6B  303F     MOVLW 0x3F
0A6D  05AC     ANDWF hr, F
188:               
189:               start_i2c();
0A6E  2344     CALL 0x344
0A6F  120A     BCF PCLATH, 0x4
0A70  158A     BSF PCLATH, 0x3
190:               write_i2c(isl1208_Write);
0A71  30DE     MOVLW 0xDE
0A72  231A     CALL 0x31A
0A73  120A     BCF PCLATH, 0x4
0A74  158A     BSF PCLATH, 0x3
191:               write_i2c(0x0C);
0A75  300C     MOVLW 0xC
0A76  231A     CALL 0x31A
0A77  120A     BCF PCLATH, 0x4
0A78  158A     BSF PCLATH, 0x3
192:               write_i2c(isl1208_bin2bcd(0));
0A79  3000     MOVLW 0x0
0A7A  2332     CALL 0x332
0A7B  120A     BCF PCLATH, 0x4
0A7C  158A     BSF PCLATH, 0x3
0A7D  231A     CALL 0x31A
0A7E  120A     BCF PCLATH, 0x4
0A7F  158A     BSF PCLATH, 0x3
193:               write_i2c(isl1208_bin2bcd(min)| 0b10000000); //habilita la alarma de minutos
0A80  1283     BCF STATUS, 0x5
0A81  082A     MOVF Data, W
0A82  2332     CALL 0x332
0A83  120A     BCF PCLATH, 0x4
0A84  158A     BSF PCLATH, 0x3
0A85  3880     IORLW 0x80
0A86  231A     CALL 0x31A
0A87  120A     BCF PCLATH, 0x4
0A88  158A     BSF PCLATH, 0x3
194:               write_i2c(isl1208_bin2bcd(hr) | 0b10000000); //habilita la alarma de horas
0A89  1283     BCF STATUS, 0x5
0A8A  082C     MOVF hr, W
0A8B  2332     CALL 0x332
0A8C  120A     BCF PCLATH, 0x4
0A8D  158A     BSF PCLATH, 0x3
0A8E  3880     IORLW 0x80
0A8F  231A     CALL 0x31A
0A90  120A     BCF PCLATH, 0x4
0A91  158A     BSF PCLATH, 0x3
195:               stop_i2c();
0A92  2B4C     GOTO 0x34C
196:           
197:           #ifndef USE_INTERRUPTS
198:               //  ei();
199:           #endif
200:           
201:           }
202:           void isl1208_set_dow_enc(unsigned char *dow) {
0A4C  1283     BCF STATUS, 0x5
0A4D  00AA     MOVWF Data
203:           //TODO terminar de implementar la funcion de escritura de dow.
204:           #ifndef USE_INTERRUPTS
205:               //di();
206:           #endif
207:               *dow &=0x07;
0A4E  0084     MOVWF FSR
0A4F  3007     MOVLW 0x7
0A50  1383     BCF STATUS, 0x7
0A51  0580     ANDWF INDF, F
208:               start_i2c();
0A52  2344     CALL 0x344
0A53  120A     BCF PCLATH, 0x4
0A54  158A     BSF PCLATH, 0x3
209:               write_i2c(isl1208_Write);
0A55  30DE     MOVLW 0xDE
0A56  231A     CALL 0x31A
0A57  120A     BCF PCLATH, 0x4
0A58  158A     BSF PCLATH, 0x3
210:               write_i2c(0x11);
0A59  3011     MOVLW 0x11
0A5A  231A     CALL 0x31A
0A5B  120A     BCF PCLATH, 0x4
0A5C  158A     BSF PCLATH, 0x3
211:               write_i2c(isl1208_bin2bcd(*dow)| 0b10000000); //habilita la alarma de dow
0A5D  1283     BCF STATUS, 0x5
0A5E  082A     MOVF Data, W
0A5F  0084     MOVWF FSR
0A60  1383     BCF STATUS, 0x7
0A61  0800     MOVF INDF, W
0A62  2332     CALL 0x332
0A63  120A     BCF PCLATH, 0x4
0A64  158A     BSF PCLATH, 0x3
0A65  3880     IORLW 0x80
0A66  231A     CALL 0x31A
0A67  120A     BCF PCLATH, 0x4
0A68  158A     BSF PCLATH, 0x3
212:               stop_i2c();
0A69  2B4C     GOTO 0x34C
213:           
214:           #ifndef USE_INTERRUPTS
215:               //  ei();
216:           #endif
217:           
218:           }
219:           
220:           void isl1208_get_dow_enc(unsigned char *dow) {
0974  1283     BCF STATUS, 0x5
0975  00A8     MOVWF mth
221:           //TODO terminar de implementar la funcion de escritura de dow.
222:           #ifndef USE_INTERRUPTS
223:               //di();
224:           #endif
225:           
226:               start_i2c();
0976  2344     CALL 0x344
0977  120A     BCF PCLATH, 0x4
0978  158A     BSF PCLATH, 0x3
227:               write_i2c(isl1208_Write);
0979  30DE     MOVLW 0xDE
097A  231A     CALL 0x31A
097B  120A     BCF PCLATH, 0x4
097C  158A     BSF PCLATH, 0x3
228:               write_i2c(0x11);
097D  3011     MOVLW 0x11
097E  231A     CALL 0x31A
097F  120A     BCF PCLATH, 0x4
0980  158A     BSF PCLATH, 0x3
229:               rstart_i2c();
0981  2388     CALL 0x388
0982  120A     BCF PCLATH, 0x4
0983  158A     BSF PCLATH, 0x3
230:               write_i2c(isl1208_Read);
0984  30DF     MOVLW 0xDF
0985  231A     CALL 0x31A
0986  120A     BCF PCLATH, 0x4
0987  158A     BSF PCLATH, 0x3
231:               *dow = isl1208_bcd2bin(read_i2c(NOACK) & 0x07);
0988  1283     BCF STATUS, 0x5
0989  0828     MOVF mth, W
098A  0084     MOVWF FSR
098B  3001     MOVLW 0x1
098C  2354     CALL 0x354
098D  120A     BCF PCLATH, 0x4
098E  158A     BSF PCLATH, 0x3
098F  3907     ANDLW 0x7
0990  237E     CALL 0x37E
0991  120A     BCF PCLATH, 0x4
0992  158A     BSF PCLATH, 0x3
0993  1383     BCF STATUS, 0x7
0994  0080     MOVWF INDF
232:               stop_i2c();
0995  2B4C     GOTO 0x34C
233:           
234:           #ifndef USE_INTERRUPTS
235:               //  ei();
236:           #endif
237:           
238:           }
239:           void isl1208_get_time_enc(unsigned char *hr, unsigned char* min, unsigned char *sec) {
09CF  00AA     MOVWF Data
240:           
241:           #ifndef USE_INTERRUPTS
242:               // di();
243:           #endif
244:           
245:               start_i2c();
09D0  2344     CALL 0x344
09D1  120A     BCF PCLATH, 0x4
09D2  158A     BSF PCLATH, 0x3
246:               write_i2c(isl1208_Write);
09D3  30DE     MOVLW 0xDE
09D4  231A     CALL 0x31A
09D5  120A     BCF PCLATH, 0x4
09D6  158A     BSF PCLATH, 0x3
247:               write_i2c(0x0C);
09D7  300C     MOVLW 0xC
09D8  231A     CALL 0x31A
09D9  120A     BCF PCLATH, 0x4
09DA  158A     BSF PCLATH, 0x3
248:           
249:               rstart_i2c();
09DB  2388     CALL 0x388
09DC  120A     BCF PCLATH, 0x4
09DD  158A     BSF PCLATH, 0x3
250:               write_i2c(isl1208_Read);
09DE  30DF     MOVLW 0xDF
09DF  231A     CALL 0x31A
09E0  120A     BCF PCLATH, 0x4
09E1  158A     BSF PCLATH, 0x3
251:               *sec = isl1208_bcd2bin(read_i2c(ACK) & 0x7f);
09E2  1283     BCF STATUS, 0x5
09E3  0829     MOVF year, W
09E4  0084     MOVWF FSR
09E5  3000     MOVLW 0x0
09E6  2354     CALL 0x354
09E7  120A     BCF PCLATH, 0x4
09E8  158A     BSF PCLATH, 0x3
09E9  397F     ANDLW 0x7F
09EA  237E     CALL 0x37E
09EB  120A     BCF PCLATH, 0x4
09EC  158A     BSF PCLATH, 0x3
09ED  1383     BCF STATUS, 0x7
09EE  0080     MOVWF INDF
252:               * min = isl1208_bcd2bin(read_i2c(ACK) & 0x7f);
09EF  0828     MOVF mth, W
09F0  0084     MOVWF FSR
09F1  3000     MOVLW 0x0
09F2  2354     CALL 0x354
09F3  120A     BCF PCLATH, 0x4
09F4  158A     BSF PCLATH, 0x3
09F5  397F     ANDLW 0x7F
09F6  237E     CALL 0x37E
09F7  120A     BCF PCLATH, 0x4
09F8  158A     BSF PCLATH, 0x3
09F9  1383     BCF STATUS, 0x7
09FA  0080     MOVWF INDF
253:               * hr = isl1208_bcd2bin(read_i2c(NOACK) & 0x3f);
09FB  082A     MOVF Data, W
09FC  0084     MOVWF FSR
09FD  3001     MOVLW 0x1
09FE  2354     CALL 0x354
09FF  120A     BCF PCLATH, 0x4
0A00  158A     BSF PCLATH, 0x3
0A01  393F     ANDLW 0x3F
0A02  237E     CALL 0x37E
0A03  120A     BCF PCLATH, 0x4
0A04  158A     BSF PCLATH, 0x3
0A05  1383     BCF STATUS, 0x7
0A06  0080     MOVWF INDF
254:               stop_i2c();
0A07  2B4C     GOTO 0x34C
255:           
256:           #ifndef USE_INTERRUPTS
257:               // ei();
258:           #endif
259:           
260:           }
261:           
262:           char isl1208_read_nvram_byte(char addr) {
263:           
264:               char retval;
265:           
266:           #ifndef USE_INTERRUPTS
267:               // di();
268:           #endif
269:           
270:               start_i2c();
271:               write_i2c(isl1208_Write);
272:               write_i2c(addr);
273:           
274:               start_i2c();
275:               write_i2c(isl1208_Read);
276:               retval = read_i2c(NOACK);
277:               stop_i2c();
278:           
279:           
280:           
281:           #ifndef USE_INTERRUPTS
282:               // ei();
283:           #endif
284:               return (retval);
285:           }
286:           
287:           void isl1208_write_nvram_byte(char addr, char value) {
288:           
289:           #ifndef USE_INTERRUPTS
290:               //di();
291:           #endif
292:           
293:               start_i2c();
294:               write_i2c(isl1208_Write);
295:               write_i2c(addr);
296:               write_i2c(value);
297:               stop_i2c();
298:           
299:           #ifndef USE_INTERRUPTS
300:               // ei();
301:           #endif
302:           
303:           }
304:           int aniobisiesto(unsigned char year)
0F9E  00FA     MOVWF j
305:           {
306:               return ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0);
0F9F  01F9     CLRF Indice
0FA0  0AF9     INCF Indice, F
0FA1  3903     ANDLW 0x3
0FA2  1D03     BTFSS STATUS, 0x2
0FA3  2FAD     GOTO 0x7AD
0FA4  3064     MOVLW 0x64
0FA5  00F0     MOVWF divisor
0FA6  087A     MOVF j, W
0FA7  27BF     CALL 0x7BF
0FA8  120A     BCF PCLATH, 0x4
0FA9  158A     BSF PCLATH, 0x3
0FAA  3800     IORLW 0x0
0FAB  1D03     BTFSS STATUS, 0x2
0FAC  2FBB     GOTO 0x7BB
0FAD  3090     MOVLW 0x90
0FAE  00F0     MOVWF divisor
0FAF  3001     MOVLW 0x1
0FB0  00F1     MOVWF canal
0FB1  087A     MOVF j, W
0FB2  00F2     MOVWF dividend
0FB3  01F3     CLRF counter
0FB4  160A     BSF PCLATH, 0x4
0FB5  118A     BCF PCLATH, 0x3
0FB6  2459     CALL 0x459
0FB7  0871     MOVF canal, W
0FB8  0470     IORWF divisor, W
0FB9  1D03     BTFSS STATUS, 0x2
0FBA  01F9     CLRF Indice
0FBB  0879     MOVF Indice, W
0FBC  00F6     MOVWF TipoPin
0FBD  01F7     CLRF Logica
307:           }
0FBE  0008     RETURN
308:           unsigned char dia_de_la_semana(unsigned char *dia, unsigned char *mes, unsigned char *anio){
088A  00C5     MOVWF dia
309:           //se usa el algoritmo de Zeller
310:              unsigned char a,y,m,dow;
311:           
312:              a = (14 -*mes) / 12;
088B  300E     MOVLW 0xE
088C  00AB     MOVWF sec
088D  01AC     CLRF hr
088E  0837     MOVF mes, W
088F  0084     MOVWF FSR
0890  0800     MOVF INDF, W
0891  02AB     SUBWF sec, F
0892  1C03     BTFSS STATUS, 0x0
0893  03AC     DECF hr, F
0894  300C     MOVLW 0xC
0895  00A9     MOVWF year
0896  01AA     CLRF Data
0897  2104     CALL 0x104
0898  120A     BCF PCLATH, 0x4
0899  158A     BSF PCLATH, 0x3
089A  0829     MOVF year, W
089B  00C4     MOVWF a
313:           y = *anio - a;
089C  0838     MOVF anio, W
089D  0084     MOVWF FSR
089E  0844     MOVF a, W
089F  1383     BCF STATUS, 0x7
08A0  0200     SUBWF INDF, W
08A1  00C6     MOVWF y
314:           m = *mes + 12 * a - 2;
08A2  0837     MOVF mes, W
08A3  0084     MOVWF FSR
08A4  300C     MOVLW 0xC
08A5  00A3     MOVWF x
08A6  0844     MOVF a, W
08A7  23AB     CALL 0x3AB
08A8  120A     BCF PCLATH, 0x4
08A9  158A     BSF PCLATH, 0x3
08AA  1383     BCF STATUS, 0x7
08AB  0700     ADDWF INDF, W
08AC  3EFE     ADDLW 0xFE
08AD  00C2     MOVWF m
315:           
316:           //Para el calendario Juliano:
317:           //d = (5 + dia + y + y/4 + (31*m)/12) mod 7
318:           
319:           //Para el calendario Gregoriano:
320:            dow = (*dia + y + y/4 - y/100 + y/400 + (31*m)/12) % 7;
08AE  3007     MOVLW 0x7
08AF  00B1     MOVWF divisor
08B0  3090     MOVLW 0x90
08B1  01B2     CLRF 0x32
08B2  00A9     MOVWF year
08B3  3001     MOVLW 0x1
08B4  00AA     MOVWF Data
08B5  0846     MOVF y, W
08B6  00AB     MOVWF sec
08B7  01AC     CLRF hr
08B8  2104     CALL 0x104
08B9  0846     MOVF y, W
08BA  00B9     MOVWF 0x39
08BB  1003     BCF STATUS, 0x0
08BC  0CB9     RRF 0x39, F
08BD  1003     BCF STATUS, 0x0
08BE  0CB9     RRF 0x39, F
08BF  0845     MOVF dia, W
08C0  0084     MOVWF FSR
08C1  1383     BCF STATUS, 0x7
08C2  0800     MOVF INDF, W
08C3  0746     ADDWF y, W
08C4  00BA     MOVWF f1
08C5  01BB     CLRF 0x3B
08C6  0DBB     RLF 0x3B, F
08C7  0839     MOVF 0x39, W
08C8  073A     ADDWF f1, W
08C9  00BC     MOVWF 0x3C
08CA  3000     MOVLW 0x0
08CB  1803     BTFSC STATUS, 0x0
08CC  3001     MOVLW 0x1
08CD  073B     ADDWF 0x3B, W
08CE  00BD     MOVWF f1
08CF  0829     MOVF year, W
08D0  073C     ADDWF 0x3C, W
08D1  00BE     MOVWF 0x3E
08D2  082A     MOVF Data, W
08D3  1803     BTFSC STATUS, 0x0
08D4  0A2A     INCF Data, W
08D5  073D     ADDWF f1, W
08D6  00BF     MOVWF 0x3F
08D7  300C     MOVLW 0xC
08D8  00A9     MOVWF year
08D9  01AA     CLRF Data
08DA  0842     MOVF m, W
08DB  00A3     MOVWF x
08DC  301F     MOVLW 0x1F
08DD  01A4     CLRF dato
08DE  00A5     MOVWF y
08DF  01A6     CLRF x
08E0  120A     BCF PCLATH, 0x4
08E1  118A     BCF PCLATH, 0x3
08E2  2784     CALL 0x784
08E3  120A     BCF PCLATH, 0x4
08E4  158A     BSF PCLATH, 0x3
08E5  0824     MOVF dato, W
08E6  00AC     MOVWF hr
08E7  0823     MOVF x, W
08E8  00AB     MOVWF sec
08E9  2104     CALL 0x104
08EA  120A     BCF PCLATH, 0x4
08EB  158A     BSF PCLATH, 0x3
08EC  0829     MOVF year, W
08ED  073E     ADDWF 0x3E, W
08EE  00C0     MOVWF f2
08EF  082A     MOVF Data, W
08F0  1803     BTFSC STATUS, 0x0
08F1  0A2A     INCF Data, W
08F2  073F     ADDWF 0x3F, W
08F3  00C1     MOVWF 0x41
08F4  3064     MOVLW 0x64
08F5  00A3     MOVWF x
08F6  0846     MOVF y, W
08F7  2390     CALL 0x390
08F8  120A     BCF PCLATH, 0x4
08F9  158A     BSF PCLATH, 0x3
08FA  0240     SUBWF f2, W
08FB  00B3     MOVWF dividend
08FC  0841     MOVF 0x41, W
08FD  1C03     BTFSS STATUS, 0x0
08FE  0341     DECF 0x41, W
08FF  00B4     MOVWF sign
0900  23B9     CALL 0x3B9
0901  0831     MOVF divisor, W
0902  00C3     MOVWF dow
321:           
322:           //El resultado es un cero (0) para el domingo, 1 para el lunes? 6 para el sbado
323:           
324:            return (dow);
325:           }
0903  0008     RETURN
326:           ///////////////////////////////////////////////////////////////////////////////
327:           
328:           unsigned char isl1208_bin2bcd(unsigned char binary_value) {
0B32  1283     BCF STATUS, 0x5
0B33  00A9     MOVWF year
329:               return ((binary_value / 10) << 4) +binary_value % 10;
0B34  300A     MOVLW 0xA
0B35  00A3     MOVWF x
0B36  0829     MOVF year, W
0B37  2390     CALL 0x390
0B38  120A     BCF PCLATH, 0x4
0B39  158A     BSF PCLATH, 0x3
0B3A  00A8     MOVWF mth
0B3B  0E28     SWAPF mth, W
0B3C  39F0     ANDLW 0xF0
0B3D  00A8     MOVWF mth
0B3E  300A     MOVLW 0xA
0B3F  00A3     MOVWF x
0B40  0829     MOVF year, W
0B41  23F6     CALL 0x3F6
0B42  0728     ADDWF mth, W
330:           
331:           }
0B43  0008     RETURN
332:           
333:           unsigned char isl1208_bcd2bin(unsigned char bcd_value) {
0B7E  00A7     MOVWF i
334:               return (bcd_value & 0x0F) + (bcd_value >> 4) * 10;
0B7F  390F     ANDLW 0xF
0B80  00A6     MOVWF x
0B81  300A     MOVLW 0xA
0B82  00A3     MOVWF x
0B83  0E27     SWAPF i, W
0B84  390F     ANDLW 0xF
0B85  23AB     CALL 0x3AB
0B86  0726     ADDWF x, W
335:           }
0B87  0008     RETURN
336:           
337:           
338:           /*unsigned int ISL1208::bcd2bin(unsigned char val)
339:           {
340:               return (val & 0x0F) + (val >> 4) * 10;
341:           }
342:           
343:           char ISL1208::bin2bcd(unsigned int val)
344:           {
345:               return ((val / 10) << 4) + val % 10;
346:           }*/
347:           ///////////////////////////////////////////////////////////////////////////////
348:           
349:           
350:           
351:           
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/Pulsadores.c  -------------------------
1:             //Programa de gestin de pulsadores por Nocturno adaptado a xc8 por Pablo F. Manieri
2:             
3:             #include <xc.h>
4:             #include <stdint.h>
5:             #include <stdbool.h>
6:             #include "system.h"
7:             #include "user.h"
8:             #include "Pulsadores.h"
9:             
10:            /****** HARDWARE ********
11:            BOTON_Subir       	RB1
12:            BOTON_Bajar       	RB2
13:            BOTON_MENU       	RB3
14:            BOTON_MANAUT     	RB4
15:            BOTON_ONOFF		RB5
16:            **************************/
17:            
18:            bool Pulsacion(unsigned char Indice, unsigned char Pin, unsigned char TipoPin, bool Logica) {
0ED1  00F9     MOVWF Indice
19:               /*
20:                  Esta funcin gestiona las entradas de pulsador, mediante el control de un retardo
21:                  antirrebotes y con la opcin de autorrepeticin de hasta 4 velocidades
22:                  
23:                  Para que funcione, hay que dimensionar la variable Entradas con el n de pulsadores
24:                  que queramos controlar.
25:                  
26:                  ENTRADAS
27:                     Indice: hace referencia al n de pulsador a chequear
28:                     Pin: indica el estado del pin del pulsador (lgica inversa)
29:                     TipoPIN:
30:                        TipoPin=0   -> No tiene autorrepeticin
31:                        TipoPin=1   -> Pin con autorrepeticin
32:                     
33:                  SALIDA
34:                     La funcin devuelve un 1 si el pulsador est en condiciones de ser procesado
35:                     y un 0 en caso contrario.
36:                  
37:               */
38:               static unsigned int Entradas[5]={0,0,0,0,0};  // Dimensionar en funcin del n de pulsadores
39:               unsigned int j;
40:              bool resultado=0;
0ED2  01F8     CLRF resultado
41:               
42:               j=Entradas[Indice];  // Como leemos muchas veces el array, lo pasamos a variable local para 
0ED3  1003     BCF STATUS, 0x0
0ED4  0D79     RLF Indice, W
0ED5  3EA0     ADDLW 0xA0
0ED6  0084     MOVWF FSR
0ED7  1383     BCF STATUS, 0x7
0ED8  0800     MOVF INDF, W
0ED9  00FA     MOVWF j
0EDA  0A84     INCF FSR, F
0EDB  0800     MOVF INDF, W
0EDC  00FB     MOVWF 0x7B
43:                                    // incrementar la velocidad de ejecucin
44:                                    
45:               // Si se detecta pulsacin y antes no haba, devolvemos un 1 en resultado
46:               if ((((!Pin && Logica==LOGICA_INVERSA) || (Pin && Logica==LOGICA_DIRECTA)) && (j==0))) {
0EDD  08F5     MOVF Pin, F
0EDE  1903     BTFSC STATUS, 0x2
0EDF  0377     DECF Logica, W
0EE0  1903     BTFSC STATUS, 0x2
0EE1  2EE8     GOTO 0x6E8
0EE2  0875     MOVF Pin, W
0EE3  1903     BTFSC STATUS, 0x2
0EE4  2EF1     GOTO 0x6F1
0EE5  08F7     MOVF Logica, F
0EE6  1D03     BTFSS STATUS, 0x2
0EE7  2EF1     GOTO 0x6F1
0EE8  087B     MOVF 0x7B, W
0EE9  047A     IORWF j, W
0EEA  1D03     BTFSS STATUS, 0x2
0EEB  2EF1     GOTO 0x6F1
47:                     resultado=1;
0EEC  01F8     CLRF resultado
0EED  0AF8     INCF resultado, F
48:                     j=1;
0EEE  01FA     CLRF j
0EEF  0AFA     INCF j, F
0EF0  01FB     CLRF 0x7B
49:               };
50:               
51:               // Cada vez que se entra a la funcin se incrementa una unidad el array
52:               if (j>0) 
0EF1  087B     MOVF 0x7B, W
0EF2  047A     IORWF j, W
0EF3  1903     BTFSC STATUS, 0x2
0EF4  2EFE     GOTO 0x6FE
53:                     Entradas[Indice]++;
0EF5  1003     BCF STATUS, 0x0
0EF6  0D79     RLF Indice, W
0EF7  3EA0     ADDLW 0xA0
0EF8  0084     MOVWF FSR
0EF9  3001     MOVLW 0x1
0EFA  0780     ADDWF INDF, F
0EFB  0A84     INCF FSR, F
0EFC  1803     BTFSC STATUS, 0x0
0EFD  0A80     INCF INDF, F
54:               
55:               // Si se detecta que ya no se est pulsando, inicializamos a 0 el array
56:               if (((Pin && Logica==LOGICA_INVERSA) || (!Pin && Logica==LOGICA_DIRECTA)) && j>ANTIRREBOTES)
0EFE  0875     MOVF Pin, W
0EFF  1903     BTFSC STATUS, 0x2
0F00  2F04     GOTO 0x704
0F01  0377     DECF Logica, W
0F02  1903     BTFSC STATUS, 0x2
0F03  2F0A     GOTO 0x70A
0F04  08F5     MOVF Pin, F
0F05  1D03     BTFSS STATUS, 0x2
0F06  2F18     GOTO 0x718
0F07  08F7     MOVF Logica, F
0F08  1D03     BTFSS STATUS, 0x2
0F09  2F18     GOTO 0x718
0F0A  3000     MOVLW 0x0
0F0B  027B     SUBWF 0x7B, W
0F0C  3033     MOVLW 0x33
0F0D  1903     BTFSC STATUS, 0x2
0F0E  027A     SUBWF j, W
0F0F  1C03     BTFSS STATUS, 0x0
0F10  2F18     GOTO 0x718
57:                  Entradas[Indice]=0;
0F11  1003     BCF STATUS, 0x0
0F12  0D79     RLF Indice, W
0F13  3EA0     ADDLW 0xA0
0F14  0084     MOVWF FSR
0F15  0180     CLRF INDF
0F16  0A84     INCF FSR, F
0F17  0180     CLRF INDF
58:                  
59:               if (TipoPin) { // Si el pulsador tiene autorrepeticin
0F18  0876     MOVF TipoPin, W
0F19  1903     BTFSC STATUS, 0x2
0F1A  2F67     GOTO 0x767
60:                 // Cuando se supera el n de ciclos 4, devolveremos un 1 con la frecuencia VELOCIDAD4
61:                   if ((j>=CAMBIO4) && !(j%VELOCIDAD4)){
0F1B  300F     MOVLW 0xF
0F1C  027B     SUBWF 0x7B, W
0F1D  30A0     MOVLW 0xA0
0F1E  1903     BTFSC STATUS, 0x2
0F1F  027A     SUBWF j, W
0F20  1803     BTFSC STATUS, 0x0
0F21  187A     BTFSC j, 0x0
0F22  2F28     GOTO 0x728
62:                       resultado=1;
0F23  01F8     CLRF resultado
0F24  0AF8     INCF resultado, F
63:                  }else
0F25  1283     BCF STATUS, 0x5
0F26  1303     BCF STATUS, 0x6
0F27  2F67     GOTO 0x767
64:                   // Cuando se supera el n de ciclos 3, devolveremos un 1 con la frecuencia VELOCIDAD3
65:                  if ((j>=CAMBIO3) && !(j%VELOCIDAD3)){           
0F28  3007     MOVLW 0x7
0F29  027B     SUBWF 0x7B, W
0F2A  30D0     MOVLW 0xD0
0F2B  1903     BTFSC STATUS, 0x2
0F2C  027A     SUBWF j, W
0F2D  1C03     BTFSS STATUS, 0x0
0F2E  2F3D     GOTO 0x73D
0F2F  300A     MOVLW 0xA
0F30  00F0     MOVWF divisor
0F31  01F1     CLRF canal
0F32  087B     MOVF 0x7B, W
0F33  00F3     MOVWF counter
0F34  087A     MOVF j, W
0F35  00F2     MOVWF dividend
0F36  2773     CALL 0x773
0F37  120A     BCF PCLATH, 0x4
0F38  158A     BSF PCLATH, 0x3
0F39  0871     MOVF canal, W
0F3A  0470     IORWF divisor, W
0F3B  1903     BTFSC STATUS, 0x2
0F3C  2F23     GOTO 0x723
66:                     resultado=1;
67:                  } else 
68:                     // Cuando se supera el n de ciclos 2, devolveremos un 1 con la frecuencia VELOCIDAD2
69:                     if ((j>=CAMBIO2) && !(j%VELOCIDAD2)){
0F3D  3001     MOVLW 0x1
0F3E  027B     SUBWF 0x7B, W
0F3F  30F4     MOVLW 0xF4
0F40  1903     BTFSC STATUS, 0x2
0F41  027A     SUBWF j, W
0F42  1C03     BTFSS STATUS, 0x0
0F43  2F52     GOTO 0x752
0F44  3032     MOVLW 0x32
0F45  00F0     MOVWF divisor
0F46  01F1     CLRF canal
0F47  087B     MOVF 0x7B, W
0F48  00F3     MOVWF counter
0F49  087A     MOVF j, W
0F4A  00F2     MOVWF dividend
0F4B  2773     CALL 0x773
0F4C  120A     BCF PCLATH, 0x4
0F4D  158A     BSF PCLATH, 0x3
0F4E  0871     MOVF canal, W
0F4F  0470     IORWF divisor, W
0F50  1903     BTFSC STATUS, 0x2
0F51  2F23     GOTO 0x723
70:                        resultado=1;
71:                  } else
72:                     // Cuando se supera el n de ciclos 1, devolveremos un 1 con la frecuencia VELOCIDAD1
73:                     if ((j>CAMBIO1) && !(j%VELOCIDAD1)){
0F52  3000     MOVLW 0x0
0F53  027B     SUBWF 0x7B, W
0F54  3065     MOVLW 0x65
0F55  1903     BTFSC STATUS, 0x2
0F56  027A     SUBWF j, W
0F57  1C03     BTFSS STATUS, 0x0
0F58  2F67     GOTO 0x767
0F59  3064     MOVLW 0x64
0F5A  00F0     MOVWF divisor
0F5B  01F1     CLRF canal
0F5C  087B     MOVF 0x7B, W
0F5D  00F3     MOVWF counter
0F5E  087A     MOVF j, W
0F5F  00F2     MOVWF dividend
0F60  2773     CALL 0x773
0F61  120A     BCF PCLATH, 0x4
0F62  158A     BSF PCLATH, 0x3
0F63  0871     MOVF canal, W
0F64  0470     IORWF divisor, W
0F65  1903     BTFSC STATUS, 0x2
0F66  2F23     GOTO 0x723
74:                        resultado=1;
75:                  };
76:               }
77:               if ((TipoPin==INMEDIATO)&&(j>=1))
0F67  0876     MOVF TipoPin, W
0F68  3A02     XORLW 0x2
0F69  1D03     BTFSS STATUS, 0x2
0F6A  2F71     GOTO 0x771
0F6B  087B     MOVF 0x7B, W
0F6C  047A     IORWF j, W
0F6D  1903     BTFSC STATUS, 0x2
0F6E  2F71     GOTO 0x771
78:                   resultado=1;
0F6F  01F8     CLRF resultado
0F70  0AF8     INCF resultado, F
79:               return (resultado);
0F71  0878     MOVF resultado, W
80:            }
0F72  0008     RETURN
81:            
82:            
83:               
84:            
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/LCDGeneric.c  -------------------------
1:             /**
2:                \version: 1.0
3:             
4:                
5:                \author Suky (Casanova Alejandro) 
6:                \web www.infopic.comlu.com
7:                \date 16/08/10
8:             
9:             
10:            ///////////////////////////////////////////////////////////////////////////
11:            ////                                                                   ////
12:            ////                                                                   ////
13:            ////        (C) Copyright 2010 www.infopic.comlu.com                   ////
14:            //// Este cdigo puede ser usado, modificado y distribuido libremente  ////
15:            //// sin eliminar esta cabecera y  sin garanta de ningn tipo.        ////
16:            ////                                                                   ////
17:            ////                                                                   ////
18:            /////////////////////////////////////////////////////////////////////////// 
19:               
20:             *- Version Log --------------------------------------------------------------*
21:             *   Fecha       Autor                Comentarios                             *
22:             *----------------------------------------------------------------------------*
23:             * 16/08/10      Suky               Original (Rev 1.0)                        *
24:             * 20/08/10      Suky               Se incluye CodeVisionAVR                  *
25:             *----------------------------------------------------------------------------* */
26:            #include "xc.h"
27:            #include "system.h"
28:            #include "LCDGeneric.h"
29:            
30:            UINT8 NLinea;
31:            
32:            UINT8 ui8BusyLCD(void){
33:            
34:            #ifdef LCD_USE_RW
35:            	 LCD_DATA_PIN_7 = 0;
15C7  1388     BCF PORTD, 0x7
36:            	 LCD_DATA_PIN_6 = 0;
15C8  1308     BCF PORTD, 0x6
37:            	 LCD_DATA_PIN_5 = 0;
15C9  1288     BCF PORTD, 0x5
38:            	 LCD_DATA_PIN_4 = 0;
15CA  1208     BCF PORTD, 0x4
39:            
40:                 LCD_TRIS_DATA_PIN_7 = CONFIG_INPUT;
15CB  1683     BSF STATUS, 0x5
15CC  1788     BSF PORTD, 0x7
41:                 LCD_TRIS_DATA_PIN_6 = CONFIG_INPUT;
15CD  1708     BSF PORTD, 0x6
42:                 LCD_TRIS_DATA_PIN_5 = CONFIG_INPUT;
15CE  1688     BSF PORTD, 0x5
43:                 LCD_TRIS_DATA_PIN_4 = CONFIG_INPUT;
15CF  1608     BSF PORTD, 0x4
44:            
45:                 LCD_RW_PIN = 1;    
15D0  1283     BCF STATUS, 0x5
15D1  1488     BSF PORTD, 0x1
46:                 LCD_RS_PIN = 0; 
15D2  1008     BCF PORTD, 0x0
47:            	 LCD_E_PIN=1;         
15D3  1508     BSF PORTD, 0x2
48:                 __delay_1us();
15D4  2DD5     GOTO 0x5D5
15D5  2DD6     GOTO 0x5D6
15D6  0000     NOP
49:            
50:                 if(LCD_READ_PIN_7==1){
15D7  1283     BCF STATUS, 0x5
15D8  1303     BCF STATUS, 0x6
15D9  1F88     BTFSS PORTD, 0x7
15DA  2DEA     GOTO 0x5EA
51:                      LCD_E_PIN = 0; 
15DB  1108     BCF PORTD, 0x2
52:            		  __delay_1us();
15DC  2DDD     GOTO 0x5DD
15DD  2DDE     GOTO 0x5DE
15DE  0000     NOP
53:            		  LCD_E_PIN = 1;
15DF  1283     BCF STATUS, 0x5
15E0  1303     BCF STATUS, 0x6
15E1  1508     BSF PORTD, 0x2
54:            		  __delay_1us();
15E2  2DE3     GOTO 0x5E3
15E3  2DE4     GOTO 0x5E4
15E4  0000     NOP
55:            		  LCD_E_PIN = 0;
15E5  1283     BCF STATUS, 0x5
15E6  1303     BCF STATUS, 0x6
15E7  1108     BCF PORTD, 0x2
56:                  	  LCD_RW_PIN = 0; 
15E8  1088     BCF PORTD, 0x1
57:                      return 1;
15E9  3401     RETLW 0x1
58:                 }else{
59:                      LCD_E_PIN = 0;
15EA  1108     BCF PORTD, 0x2
60:            		  __delay_1us();
15EB  2DEC     GOTO 0x5EC
15EC  2DED     GOTO 0x5ED
15ED  0000     NOP
61:            		  LCD_E_PIN = 1;
15EE  1283     BCF STATUS, 0x5
15EF  1303     BCF STATUS, 0x6
15F0  1508     BSF PORTD, 0x2
62:            		  __delay_1us();
15F1  2DF2     GOTO 0x5F2
15F2  2DF3     GOTO 0x5F3
15F3  0000     NOP
63:            		  LCD_E_PIN = 0;
15F4  1283     BCF STATUS, 0x5
15F5  1303     BCF STATUS, 0x6
15F6  1108     BCF PORTD, 0x2
64:            		  LCD_RW_PIN = 0;       
15F7  1088     BCF PORTD, 0x1
65:                      return 0;
15F8  3400     RETLW 0x0
66:                 }
67:            #else
68:            	 __delay_100us();
69:            	 return 0;
70:            #endif
71:            }
72:            
73:            void vWriteLCD(UINT8 Data,UINT8 Type){
1556  00A4     MOVWF dato
74:            
75:            #ifdef LCD_USE_3PINES
76:            	UINT8 i, data_temp;
77:            #endif
78:            
79:            	while(ui8BusyLCD());
1557  25C7     CALL 0x5C7
1558  160A     BSF PCLATH, 0x4
1559  118A     BCF PCLATH, 0x3
155A  3800     IORLW 0x0
155B  1D03     BTFSS STATUS, 0x2
155C  2D57     GOTO 0x557
80:            
81:            	#ifndef LCD_USE_3PINES
82:            		#ifdef LCD_USE_RW
83:            			LCD_RW_PIN = 0;
155D  1088     BCF PORTD, 0x1
84:            		#endif   
85:            		if(Type){
155E  0823     MOVF x, W
155F  1903     BTFSC STATUS, 0x2
1560  2D63     GOTO 0x563
86:            			LCD_RS_PIN=1;
1561  1408     BSF PORTD, 0x0
87:            		}else{
1562  2D64     GOTO 0x564
88:            			LCD_RS_PIN = 0;
1563  1008     BCF PORTD, 0x0
89:            		}	  
90:            		LCD_TRIS_DATA_PIN_7 = CONFIG_OUTPUT;
1564  1683     BSF STATUS, 0x5
1565  1388     BCF PORTD, 0x7
91:            		LCD_TRIS_DATA_PIN_6 = CONFIG_OUTPUT;
1566  1308     BCF PORTD, 0x6
92:            		LCD_TRIS_DATA_PIN_5 = CONFIG_OUTPUT;
1567  1288     BCF PORTD, 0x5
93:            		LCD_TRIS_DATA_PIN_4 = CONFIG_OUTPUT;
1568  1208     BCF PORTD, 0x4
94:            		
95:            		LCD_DATA_PIN_7 = !!(Data & 0x80);
1569  1283     BCF STATUS, 0x5
156A  1FA4     BTFSS dato, 0x7
156B  2D70     GOTO 0x570
156C  1283     BCF STATUS, 0x5
156D  1303     BCF STATUS, 0x6
156E  1788     BSF PORTD, 0x7
156F  2D73     GOTO 0x573
1570  1283     BCF STATUS, 0x5
1571  1303     BCF STATUS, 0x6
1572  1388     BCF PORTD, 0x7
96:            		LCD_DATA_PIN_6 = !!(Data & 0x40);
1573  1F24     BTFSS dato, 0x6
1574  2D79     GOTO 0x579
1575  1283     BCF STATUS, 0x5
1576  1303     BCF STATUS, 0x6
1577  1708     BSF PORTD, 0x6
1578  2D7C     GOTO 0x57C
1579  1283     BCF STATUS, 0x5
157A  1303     BCF STATUS, 0x6
157B  1308     BCF PORTD, 0x6
97:            		LCD_DATA_PIN_5 = !!(Data & 0x20);
157C  1EA4     BTFSS dato, 0x5
157D  2D82     GOTO 0x582
157E  1283     BCF STATUS, 0x5
157F  1303     BCF STATUS, 0x6
1580  1688     BSF PORTD, 0x5
1581  2D85     GOTO 0x585
1582  1283     BCF STATUS, 0x5
1583  1303     BCF STATUS, 0x6
1584  1288     BCF PORTD, 0x5
98:            		LCD_DATA_PIN_4 = !!(Data & 0x10);
1585  1E24     BTFSS dato, 0x4
1586  2D8B     GOTO 0x58B
1587  1283     BCF STATUS, 0x5
1588  1303     BCF STATUS, 0x6
1589  1608     BSF PORTD, 0x4
158A  2D8E     GOTO 0x58E
158B  1283     BCF STATUS, 0x5
158C  1303     BCF STATUS, 0x6
158D  1208     BCF PORTD, 0x4
99:            	#else
100:           		data_temp=(Data>>4);  // Rs es bit 4
101:           		if(Type){
102:           			data_temp|=0x10;
103:           		}
104:           		for(i=0;i<8;i++){
105:           			LCD_DATA_PIN=!!(data_temp & 0x80);
106:           			data_temp<<=1;
107:           			LCD_CLOCK_PIN=1;
108:           			__delay_1us();
109:           			LCD_CLOCK_PIN=0;
110:           		}
111:           	#endif
112:           	__delay_1Cycle();
158E  0000     NOP
113:           	LCD_E_PIN = 1;
158F  1283     BCF STATUS, 0x5
1590  1303     BCF STATUS, 0x6
1591  1508     BSF PORTD, 0x2
114:           	__delay_1us();
1592  2D93     GOTO 0x593
1593  2D94     GOTO 0x594
1594  0000     NOP
115:           	LCD_E_PIN = 0;
1595  1283     BCF STATUS, 0x5
1596  1303     BCF STATUS, 0x6
1597  1108     BCF PORTD, 0x2
116:           	#ifndef LCD_USE_3PINES	
117:           		LCD_DATA_PIN_7 = !!(Data & 0x08);
1598  1DA4     BTFSS dato, 0x3
1599  2D9E     GOTO 0x59E
159A  1283     BCF STATUS, 0x5
159B  1303     BCF STATUS, 0x6
159C  1788     BSF PORTD, 0x7
159D  2DA1     GOTO 0x5A1
159E  1283     BCF STATUS, 0x5
159F  1303     BCF STATUS, 0x6
15A0  1388     BCF PORTD, 0x7
118:           		LCD_DATA_PIN_6 = !!(Data & 0x04);
15A1  1D24     BTFSS dato, 0x2
15A2  2DA7     GOTO 0x5A7
15A3  1283     BCF STATUS, 0x5
15A4  1303     BCF STATUS, 0x6
15A5  1708     BSF PORTD, 0x6
15A6  2DAA     GOTO 0x5AA
15A7  1283     BCF STATUS, 0x5
15A8  1303     BCF STATUS, 0x6
15A9  1308     BCF PORTD, 0x6
119:           		LCD_DATA_PIN_5 = !!(Data & 0x02);
15AA  1CA4     BTFSS dato, 0x1
15AB  2DB0     GOTO 0x5B0
15AC  1283     BCF STATUS, 0x5
15AD  1303     BCF STATUS, 0x6
15AE  1688     BSF PORTD, 0x5
15AF  2DB3     GOTO 0x5B3
15B0  1283     BCF STATUS, 0x5
15B1  1303     BCF STATUS, 0x6
15B2  1288     BCF PORTD, 0x5
120:           		LCD_DATA_PIN_4 = !!(Data & 0x01);
15B3  1C24     BTFSS dato, 0x0
15B4  2DB9     GOTO 0x5B9
15B5  1283     BCF STATUS, 0x5
15B6  1303     BCF STATUS, 0x6
15B7  1608     BSF PORTD, 0x4
15B8  2DBC     GOTO 0x5BC
15B9  1283     BCF STATUS, 0x5
15BA  1303     BCF STATUS, 0x6
15BB  1208     BCF PORTD, 0x4
121:           	#else
122:           		data_temp=(Data&0x0F);  // Rs es bit 4
123:           		if(Type){
124:           			data_temp|=0x10;
125:           		}
126:           		for(i=0;i<8;i++){
127:           			LCD_DATA_PIN=!!(data_temp & 0x80);
128:           			data_temp<<=1;
129:           			LCD_CLOCK_PIN=1;
130:           			__delay_1us();
131:           			LCD_CLOCK_PIN=0;
132:           		}
133:           	#endif
134:           	__delay_1Cycle();	
15BC  0000     NOP
135:           	LCD_E_PIN = 1;
15BD  1283     BCF STATUS, 0x5
15BE  1303     BCF STATUS, 0x6
15BF  1508     BSF PORTD, 0x2
136:           	__delay_1us();
15C0  2DC1     GOTO 0x5C1
15C1  2DC2     GOTO 0x5C2
15C2  0000     NOP
137:           	LCD_E_PIN = 0;
15C3  1283     BCF STATUS, 0x5
15C4  1303     BCF STATUS, 0x6
15C5  1108     BCF PORTD, 0x2
138:           	
139:           } 
15C6  0008     RETURN
140:           
141:           void vInitLCD(){
142:           UINT8 i;
143:           #ifdef LCD_USE_3PINES
144:           	UINT8 temp;
145:           #endif
146:           
147:           	for(i=0;i<8;i++){__delay_2ms();}
14E1  01A7     CLRF i
14E2  300D     MOVLW 0xD
14E3  00A6     MOVWF x
14E4  30FB     MOVLW 0xFB
14E5  00A5     MOVWF y
14E6  0BA5     DECFSZ y, F
14E7  2CE6     GOTO 0x4E6
14E8  0BA6     DECFSZ x, F
14E9  2CE6     GOTO 0x4E6
14EA  2CEB     GOTO 0x4EB
14EB  1283     BCF STATUS, 0x5
14EC  1303     BCF STATUS, 0x6
14ED  3008     MOVLW 0x8
14EE  0AA7     INCF i, F
14EF  0227     SUBWF i, W
14F0  1C03     BTFSS STATUS, 0x0
14F1  2CE2     GOTO 0x4E2
148:           	NLinea=1;
14F2  1683     BSF STATUS, 0x5
14F3  01B1     CLRF divisor
14F4  0AB1     INCF divisor, F
149:           	
150:           #ifndef LCD_USE_3PINES
151:           /* ** Configuracin de pines ** */	
152:           	LCD_DATA_PIN_7 = 0;
14F5  1283     BCF STATUS, 0x5
14F6  1388     BCF PORTD, 0x7
153:           	LCD_DATA_PIN_6 = 0;
14F7  1308     BCF PORTD, 0x6
154:           	LCD_DATA_PIN_5 = 0;
14F8  1288     BCF PORTD, 0x5
155:           	LCD_DATA_PIN_4 = 0;
14F9  1208     BCF PORTD, 0x4
156:           	#ifdef LCD_USE_RW
157:           		LCD_RW_PIN = 0;
14FA  1088     BCF PORTD, 0x1
158:           	#endif
159:           	LCD_RS_PIN = 0;
14FB  1008     BCF PORTD, 0x0
160:           	LCD_E_PIN = 0;
14FC  1108     BCF PORTD, 0x2
161:           	
162:           	LCD_TRIS_DATA_PIN_7 = CONFIG_OUTPUT;
14FD  1683     BSF STATUS, 0x5
14FE  1388     BCF PORTD, 0x7
163:           	LCD_TRIS_DATA_PIN_6 = CONFIG_OUTPUT;
14FF  1308     BCF PORTD, 0x6
164:           	LCD_TRIS_DATA_PIN_5 = CONFIG_OUTPUT;
1500  1288     BCF PORTD, 0x5
165:           	LCD_TRIS_DATA_PIN_4 = CONFIG_OUTPUT;
1501  1208     BCF PORTD, 0x4
166:           	#ifdef LCD_USE_RW	
167:           		LCD_TRIS_RW = CONFIG_OUTPUT;
1502  1088     BCF PORTD, 0x1
168:           	#endif
169:           	LCD_TRIS_RS = CONFIG_OUTPUT;
1503  1008     BCF PORTD, 0x0
170:           	LCD_TRIS_E = CONFIG_OUTPUT;
1504  1108     BCF PORTD, 0x2
171:           #else
172:           	LCD_DATA_PIN = 0;
173:           	LCD_CLOCK_PIN = 0;
174:           	LCD_E_PIN = 0;
175:           
176:           	LCD_TRIS_DATA = CONFIG_OUTPUT;
177:           	LCD_TRIS_CLOCK = CONFIG_OUTPUT;
178:           	LCD_TRIS_E = CONFIG_OUTPUT;
179:           	
180:           	for(i=0;i<8;i++){
181:           		LCD_DATA_PIN=0;
182:           		LCD_CLOCK_PIN=1;
183:           		__delay_1us();
184:           		LCD_CLOCK_PIN=0;
185:           	}
186:           #endif
187:           /* ** INICIALIZACION ** */     
188:           #ifndef LCD_USE_3PINES
189:           	LCD_DATA_PIN_5 = 1;
1505  1283     BCF STATUS, 0x5
1506  1688     BSF PORTD, 0x5
190:           	LCD_DATA_PIN_4 = 1;
1507  1608     BSF PORTD, 0x4
191:           #else
192:           	temp=0x03;
193:           	for(i=0;i<8;i++){
194:           		LCD_DATA_PIN=!!(temp & 0x80);
195:           		temp<<=1;
196:           		LCD_CLOCK_PIN=1;
197:           		__delay_1us();
198:           		LCD_CLOCK_PIN=0;
199:           	}
200:           #endif
201:           	for(i=0;i<3;i++){
1508  01A7     CLRF i
151F  1283     BCF STATUS, 0x5
1520  1303     BCF STATUS, 0x6
1521  3003     MOVLW 0x3
1522  0AA7     INCF i, F
1523  0227     SUBWF i, W
1524  1C03     BTFSS STATUS, 0x0
1525  2D09     GOTO 0x509
202:           		LCD_E_PIN = 1;
1509  1508     BSF PORTD, 0x2
203:           		__delay_2ms();
150A  300D     MOVLW 0xD
150B  00A6     MOVWF x
150C  30FB     MOVLW 0xFB
150D  00A5     MOVWF y
150E  0BA5     DECFSZ y, F
150F  2D0E     GOTO 0x50E
1510  0BA6     DECFSZ x, F
1511  2D0E     GOTO 0x50E
1512  2D13     GOTO 0x513
204:           		LCD_E_PIN = 0;
1513  1283     BCF STATUS, 0x5
1514  1303     BCF STATUS, 0x6
1515  1108     BCF PORTD, 0x2
205:           	 	__delay_2ms();
1516  300D     MOVLW 0xD
1517  00A6     MOVWF x
1518  30FB     MOVLW 0xFB
1519  00A5     MOVWF y
151A  0BA5     DECFSZ y, F
151B  2D1A     GOTO 0x51A
151C  0BA6     DECFSZ x, F
151D  2D1A     GOTO 0x51A
151E  2D1F     GOTO 0x51F
206:           	}
207:           #ifndef LCD_USE_3PINES
208:           	LCD_DATA_PIN_4 = 0;
1526  1208     BCF PORTD, 0x4
209:           #else
210:           	temp=0x02;
211:           	for(i=0;i<8;i++){
212:           		LCD_DATA_PIN=!!(temp & 0x80);
213:           		temp<<=1;
214:           		LCD_CLOCK_PIN=1;
215:           		__delay_1us();
216:           		LCD_CLOCK_PIN=0;
217:           	}
218:           #endif
219:           	LCD_E_PIN = 1;
1527  1508     BSF PORTD, 0x2
220:           	__delay_1us();
1528  2D29     GOTO 0x529
1529  2D2A     GOTO 0x52A
152A  0000     NOP
221:           	LCD_E_PIN = 0;
152B  1283     BCF STATUS, 0x5
152C  1303     BCF STATUS, 0x6
152D  1108     BCF PORTD, 0x2
222:           
223:           	vWriteLCD(0x20 | (LcdType<<2),LCD_COMMAND);  // Tipo display.-  
152E  3028     MOVLW 0x28
152F  01A3     CLRF x
1530  2556     CALL 0x556
1531  160A     BSF PCLATH, 0x4
1532  118A     BCF PCLATH, 0x3
224:           	__delay_2ms();     
1533  300D     MOVLW 0xD
1534  00A6     MOVWF x
1535  30FB     MOVLW 0xFB
1536  00A5     MOVWF y
1537  0BA5     DECFSZ y, F
1538  2D37     GOTO 0x537
1539  0BA6     DECFSZ x, F
153A  2D37     GOTO 0x537
153B  2D3C     GOTO 0x53C
225:           	vWriteLCD(0x01,LCD_COMMAND);	// Borramos display.-   
153C  1283     BCF STATUS, 0x5
153D  1303     BCF STATUS, 0x6
153E  3001     MOVLW 0x1
153F  01A3     CLRF x
1540  2556     CALL 0x556
1541  160A     BSF PCLATH, 0x4
1542  118A     BCF PCLATH, 0x3
226:           	__delay_2ms();           
1543  300D     MOVLW 0xD
1544  00A6     MOVWF x
1545  30FB     MOVLW 0xFB
1546  00A5     MOVWF y
1547  0BA5     DECFSZ y, F
1548  2D47     GOTO 0x547
1549  0BA6     DECFSZ x, F
154A  2D47     GOTO 0x547
154B  2D4C     GOTO 0x54C
227:           	vWriteLCD(0x06,LCD_COMMAND);	// Incrementa cursor.-
154C  1283     BCF STATUS, 0x5
154D  1303     BCF STATUS, 0x6
154E  3006     MOVLW 0x6
154F  01A3     CLRF x
1550  2556     CALL 0x556
1551  160A     BSF PCLATH, 0x4
1552  118A     BCF PCLATH, 0x3
228:           	vWriteLCD(0x0C,LCD_COMMAND);	// Encendemos display.-
1553  300C     MOVLW 0xC
229:           }
230:           
231:           
232:           void vLCD_Putc(UINT8 Data){
14B9  1283     BCF STATUS, 0x5
14BA  00AA     MOVWF Data
233:           	
234:           	switch(Data){
14BB  3A0A     XORLW 0xA
14BC  1903     BTFSC STATUS, 0x2
14BD  2CD6     GOTO 0x4D6
14BE  3A06     XORLW 0x6
14BF  1903     BTFSC STATUS, 0x2
14C0  2CC3     GOTO 0x4C3
14C1  2CDD     GOTO 0x4DD
235:           		case '\f':
236:           			vWriteLCD(0x01,LCD_COMMAND);
14C3  3001     MOVLW 0x1
14C4  01A3     CLRF x
14C5  2556     CALL 0x556
14C6  160A     BSF PCLATH, 0x4
14C7  118A     BCF PCLATH, 0x3
237:           			NLinea=1;
14C8  1683     BSF STATUS, 0x5
14CA  01B1     CLRF divisor
14CB  0AB1     INCF divisor, F
238:           			__delay_2ms();
14C9  300D     MOVLW 0xD
14CC  1283     BCF STATUS, 0x5
14CD  00A9     MOVWF year
14CE  30FB     MOVLW 0xFB
14CF  00A8     MOVWF mth
14D0  0BA8     DECFSZ mth, F
14D1  2CD0     GOTO 0x4D0
14D2  0BA9     DECFSZ year, F
14D3  2CD0     GOTO 0x4D0
14D4  2CD5     GOTO 0x4D5
239:           		break;
14D5  0008     RETURN
240:           		case '\n':
241:           			vGotoxyLCD(1,++NLinea);			
14D6  1683     BSF STATUS, 0x5
14D7  0AB1     INCF divisor, F
14D8  0831     MOVF divisor, W
14D9  1283     BCF STATUS, 0x5
14DA  00A5     MOVWF y
14DB  3001     MOVLW 0x1
14DC  2C96     GOTO 0x496
242:           		break;
243:           		default:
244:           			vWriteLCD(Data,LCD_DATA);
14DD  01A3     CLRF x
14DE  0AA3     INCF x, F
14DF  082A     MOVF Data, W
14E0  2D56     GOTO 0x556
245:           	}
246:           } 
14C2  0008     RETURN
247:           
248:           void vGotoxyLCD(UINT8 x,UINT8 y){
1496  00A6     MOVWF x
249:           UINT8 Direccion;
250:           
251:           	switch(y){
1497  2CA3     GOTO 0x4A3
14A3  0825     MOVF y, W
14A4  3A01     XORLW 0x1
14A5  1903     BTFSC STATUS, 0x2
14A6  2C98     GOTO 0x498
14A7  3A03     XORLW 0x3
14A8  1903     BTFSC STATUS, 0x2
14A9  2C9D     GOTO 0x49D
14AA  2C98     GOTO 0x498
252:           		case 1:Direccion = LCD_LINE_1_ADDRESS;NLinea=1;break;
1498  01A7     CLRF i
1499  1683     BSF STATUS, 0x5
149A  01B1     CLRF divisor
149B  0AB1     INCF divisor, F
149C  2CAB     GOTO 0x4AB
253:           		case 2:Direccion = LCD_LINE_2_ADDRESS;NLinea=2;break;
149D  3040     MOVLW 0x40
149E  00A7     MOVWF i
149F  3002     MOVLW 0x2
14A0  1683     BSF STATUS, 0x5
14A1  00B1     MOVWF divisor
14A2  2CAB     GOTO 0x4AB
254:           		#ifdef LCD_4LINES
255:           		case 3:Direccion = LCD_LINE_3_ADDRESS;NLinea=3;break;
256:           		case 4:Direccion = LCD_LINE_4_ADDRESS;NLinea=4;break;
257:           		#endif
258:           		default:Direccion = LCD_LINE_1_ADDRESS;NLinea=1;break;
259:           	}
260:           
261:           	Direccion+=x-1;
14AB  1283     BCF STATUS, 0x5
14AC  0826     MOVF x, W
14AD  3EFF     ADDLW 0xFF
14AE  07A7     ADDWF i, F
262:           	while(ui8BusyLCD());
14AF  25C7     CALL 0x5C7
14B0  160A     BSF PCLATH, 0x4
14B1  118A     BCF PCLATH, 0x3
14B2  3800     IORLW 0x0
14B3  1D03     BTFSS STATUS, 0x2
14B4  2CAF     GOTO 0x4AF
263:           	vWriteLCD(0x80|Direccion,LCD_COMMAND);
14B5  01A3     CLRF x
264:           }
265:           
266:           void vPuts_LCD(UINT8 *buffer){
267:           
268:           
269:               while(*buffer != '\0')    {
270:                  // vLCD_Putc(*buffer++);;
271:                   vWriteLCD(*buffer++,LCD_DATA);
272:               }
273:           }
274:           
275:           void vBlinkingLCD(void){
276:           	vWriteLCD(0b1101,LCD_COMMAND);
277:           }
278:           void vnoBlinkingLCD(void){
279:           	vWriteLCD(0b1100,LCD_COMMAND);
280:           }
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/HardI2C.c  ----------------------------
1:             /**************************************************************************
2:             *      Libreria para protocolo I2C Master por HardWare para HiTech        *
3:             ***************************************************************************
4:             
5:             ***************************************************************************
6:             *                                                                         *
7:             * Antes de incluir este archivo en nuestro programa hay que definir       *
8:             * algunos parametros. Estos son                                           *
9:             *                                                                         *
10:            * PIC_CLK        (se usa para calcular el valor de SSPADD)                *     
11:            * I2C_BAUD       (velocidad de transferencia)                             *
12:            *                                                                         *
13:            ***************************************************************************
14:            
15:            ***************************************************************************
16:            *                                                                         *
17:            * En esta libreria se encuentran las siguientes funciones                 *
18:            *                                                                         *
19:            * setup_i2c(char)               (inicializa el puerto I2C)                *
20:            * start_i2c()                   (envia start, inicia transmision)         *
21:            * rstar_i2c()                   (envia restart, reinicia transmision)     *
22:            * stop_i2c()                    (envia stop, termina transmision)         *
23:            * write_i2c(char)               (envia un byte)                           *
24:            * read_i2c(char)                (recibe un byte y envia ack o noack)      *
25:            *                                                                         *
26:            *  La funcion write_i2c() devuelve 0 si el dispositivo responde o 1 si el *
27:            * dispositivo no responde.                                                *
28:            *                                                                         *
29:            *  A la funcion read_i2c() hay que pasarle 0 si se quiere responder al    *
30:            * disipositivo o 1 si no se quiere responder                              *
31:            *                                                                         *
32:            *  En esta libreria estan definidos los parametros I2C_MASTER, I2C_SLAVE, *
33:            * I2C_10BIT_ADDRESS. Eston son utilizados en la funcion setup_i2c(char)   *
34:            *                                                                         *
35:            *  Tambien estan definidos ACK y NOACK que son los utilizados para        *
36:            * responder o no al dispositivo                                           *
37:            *                                                                         *
38:            ***************************************************************************
39:            
40:            * Ejemplo de configuracion y utilizacion
41:            
42:             #define PIC_CLK   10000000   // cristal 10MHz
43:             #define I2C_BAUD  100000     // velocidad 100 KHz
44:             #include "HardI2c.c"
45:            
46:             void main (void);
47:             {
48:               unsigned char respuesta;
49:               unsigned char dato;  
50:             
51:               ......
52:               ......
53:               ......
54:               setup_i2c (I2C_MASTER);
55:               start_i2c();
56:               respuesta = write_i2c (0b10101110);    // comunicacion para escribir en una 24C02C
57:               if (respuesta == ACK)
58:               {
59:                 write_i2c (0x00);                    // indico la direccion a escribir
60:                 write_i2c (0xF5);                    // escribo el dato F5
61:                 write_i2c (0x06);                    // escribo el dato 06
62:               }
63:               stop_i2c();
64:            
65:               // colocar un delay necesario para que termine de grabar la memoria
66:            
67:               start_i2c();
68:               respuesta = write_i2c (0b10101110);    // comunicacion para escribir en una 24C02C
69:               if (respuesta == ACK)
70:               {
71:                 write_i2c (0x00);                    // indico la direccion de memoria
72:                 rstart_i2c();                       // reinicio la transmisin
73:                 respuesta = write_i2c (0b10101111);  // comunicacion para leer en una 24C02C
74:                 if (respuesta == ACK)
75:                 {
76:                   dato = read_i2c (ACK);             // leo el dato y respondo
77:                   dato = read_i2c (NOACK);           // leo el dato y no respondo
78:                 }
79:               }
80:               stop_i2c();
81:             }
82:            
83:            */
84:            #include <xc.h>
85:            #include <stdbool.h>       /* For true/false definition */
86:            #include "system.h"        /* System funct/params, like osc/peripheral config */
87:            #include "HardI2C.h"
88:            
89:            
90:            #if defined (PIC_CLK) && defined (I2C_BAUD)
91:            
92:            void setup_i2c (char x)
0806  00A3     MOVWF x
93:             {
94:                TRISC3 = 1;
0807  1683     BSF STATUS, 0x5
0808  1587     BSF PORTC, 0x3
95:            
96:                TRISC4 = 1;
0809  1607     BSF PORTC, 0x4
97:            
98:                SSPSTAT = 0;
080A  0194     CLRF SSPCON
99:                SSPCON = x;
080B  1283     BCF STATUS, 0x5
080C  0823     MOVF x, W
080D  0094     MOVWF SSPCON
100:               
101:               SSPCON2 = 0;
080E  1683     BSF STATUS, 0x5
080F  0191     CLRF TMR2
102:               // SSPCON2bits.RCEN=1;
103:               if (SSPM3 == 1) SSPADD = (unsigned char)((PIC_CLK/(4*I2C_BAUD)) - 1);
0810  1283     BCF STATUS, 0x5
0811  1D94     BTFSS SSPCON, 0x3
0812  0008     RETURN
0813  300B     MOVLW 0xB
0814  1683     BSF STATUS, 0x5
0815  0093     MOVWF SSPBUF
104:           
105:           }
0816  0008     RETURN
106:           
107:             char start_i2c (void)
108:             { 
109:               while (( SSPCON2 & 0x1F ) || R_nW );
0B44  1683     BSF STATUS, 0x5
0B45  0811     MOVF TMR2, W
0B46  391F     ANDLW 0x1F
0B47  1903     BTFSC STATUS, 0x2
0B48  1914     BTFSC SSPCON, 0x2
0B49  2B44     GOTO 0x344
110:               SEN = 1;
0B4A  1411     BSF TMR2, 0x0
111:               return !BCLIF;
112:             }
0B4B  0008     RETURN
113:           
114:             void rstart_i2c (void)
115:             {
116:               while (( SSPCON2 & 0x1F ) || R_nW );
0B88  1683     BSF STATUS, 0x5
0B89  0811     MOVF TMR2, W
0B8A  391F     ANDLW 0x1F
0B8B  1903     BTFSC STATUS, 0x2
0B8C  1914     BTFSC SSPCON, 0x2
0B8D  2B88     GOTO 0x388
117:               RSEN = 1;
0B8E  1491     BSF TMR2, 0x1
118:             }
0B8F  0008     RETURN
119:           
120:             void stop_i2c (void)
121:             {
122:               while (( SSPCON2 & 0x1F ) || R_nW );
0B4C  1683     BSF STATUS, 0x5
0B4D  0811     MOVF TMR2, W
0B4E  391F     ANDLW 0x1F
0B4F  1903     BTFSC STATUS, 0x2
0B50  1914     BTFSC SSPCON, 0x2
0B51  2B4C     GOTO 0x34C
123:               PEN = 1;
0B52  1511     BSF TMR2, 0x2
124:             }
0B53  0008     RETURN
125:           
126:             char write_i2c (unsigned char data)
0B1A  1283     BCF STATUS, 0x5
0B1B  00A3     MOVWF x
127:             {
128:               if (SSPM3 == 1)
0B1C  1D94     BTFSS SSPCON, 0x3
0B1D  2B2E     GOTO 0x32E
129:               {
130:                 while (( SSPCON2 & 0x1F ) || R_nW );
0B1E  1683     BSF STATUS, 0x5
0B1F  0811     MOVF TMR2, W
0B20  391F     ANDLW 0x1F
0B21  1903     BTFSC STATUS, 0x2
0B22  1914     BTFSC SSPCON, 0x2
0B23  2B1E     GOTO 0x31E
131:                 SSPBUF = data;
0B24  1283     BCF STATUS, 0x5
0B25  0823     MOVF x, W
0B26  0093     MOVWF SSPBUF
132:                 while (R_nW == 1);
0B27  1683     BSF STATUS, 0x5
0B28  1914     BTFSC SSPCON, 0x2
0B29  2B27     GOTO 0x327
133:                 //while(ACKSTAT==1);
134:                 return ACKSTAT;
0B2A  3000     MOVLW 0x0
0B2B  1B11     BTFSC TMR2, 0x6
0B2C  3001     MOVLW 0x1
0B2D  0008     RETURN
135:               }
136:               else
137:               {
138:                 SSPBUF = data;
0B2E  0823     MOVF x, W
0B2F  0093     MOVWF SSPBUF
139:                 CKP = 1;
0B30  1614     BSF SSPCON, 0x4
140:                 return 0;
0B31  3400     RETLW 0x0
141:               }
142:             }
143:           
144:             unsigned char read_i2c (unsigned char respuesta)
0B54  1283     BCF STATUS, 0x5
0B55  00A3     MOVWF x
145:             {
146:               unsigned char dato;
147:           
148:               if (SSPM3 == 1)
0B56  1D94     BTFSS SSPCON, 0x3
0B57  2B7B     GOTO 0x37B
149:               {
150:                 while (( SSPCON2 & 0x1F ) || R_nW );
0B58  1683     BSF STATUS, 0x5
0B59  0811     MOVF TMR2, W
0B5A  391F     ANDLW 0x1F
0B5B  1903     BTFSC STATUS, 0x2
0B5C  1914     BTFSC SSPCON, 0x2
0B5D  2B58     GOTO 0x358
151:                 RCEN = 1;
0B5E  1591     BSF TMR2, 0x3
152:                 while (( SSPCON2 & 0x1F ) || R_nW );
0B5F  0811     MOVF TMR2, W
0B60  391F     ANDLW 0x1F
0B61  1903     BTFSC STATUS, 0x2
0B62  1914     BTFSC SSPCON, 0x2
0B63  2B5F     GOTO 0x35F
153:                 dato = SSPBUF;
0B64  1283     BCF STATUS, 0x5
0B65  0813     MOVF SSPBUF, W
0B66  00A4     MOVWF dato
154:                 while (( SSPCON2 & 0x1F ) || R_nW );
0B67  1683     BSF STATUS, 0x5
0B68  0811     MOVF TMR2, W
0B69  391F     ANDLW 0x1F
0B6A  1903     BTFSC STATUS, 0x2
0B6B  1914     BTFSC SSPCON, 0x2
0B6C  2B67     GOTO 0x367
155:                 ACKDT = respuesta;
0B6D  1283     BCF STATUS, 0x5
0B6E  1C23     BTFSS x, 0x0
0B6F  2B74     GOTO 0x374
0B70  1683     BSF STATUS, 0x5
0B71  1303     BCF STATUS, 0x6
0B72  1691     BSF TMR2, 0x5
0B73  2B77     GOTO 0x377
0B74  1683     BSF STATUS, 0x5
0B75  1303     BCF STATUS, 0x6
0B76  1291     BCF TMR2, 0x5
156:                 ACKEN = 1;
0B77  1611     BSF TMR2, 0x4
157:                 return dato;
0B78  1283     BCF STATUS, 0x5
0B79  0824     MOVF dato, W
0B7A  0008     RETURN
158:               }
159:               else
160:               {
161:                 dato = SSPBUF;
0B7B  0813     MOVF SSPBUF, W
0B7C  00A4     MOVWF dato
162:                 return dato;
163:               }
164:             }
0B7D  0008     RETURN
165:           #else
166:             #error Faltan definir parametros
167:           #endif
