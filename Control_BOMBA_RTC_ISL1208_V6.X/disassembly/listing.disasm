Disassembly Listing for Control_BOMBA_RTC_ISL1208_V6
Generated From:
/home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/dist/ISL1208_XC8_16f877a/production/Control_BOMBA_RTC_ISL1208_V6.X.production.cof
16/01/2015 22:36:30

---  /opt/microchip/xc8/v1.31/sources/pic/ftdiv.c  ------------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (C) 2006 HI-TECH Software
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_dividend	(*(unsigned short long *)&f1)
11:            #define	f2_as_divisor	(*(unsigned short long *)&f2)
12:            #define	f3_as_quot	(*(unsigned short long *)&f3)
13:            
14:            // floating addition
15:            #ifdef _OLDLIB
16:            #define	cntr		sign2
17:            float
18:            __ftdiv(float f2, float f1)
19:            {
20:            	unsigned char	exp1, exp2, sign1, sign2;
21:            	float	f3;
22:            	
23:            	f3_as_quot = 0;
24:            	sign1 = __ftunpack(&f1_as_dividend, &exp1);
25:            	if(exp1 == 0)
26:            		return f3;
27:            	sign2 = __ftunpack(&f2_as_divisor, &exp2);
28:            	if(exp2 == 0)
29:            		return f3;
30:            	exp1 -= exp2-127+8;	// compute new exponent
31:            	sign1 ^= sign2;
32:            	cntr = 16+8;
33:            	do {
34:            		f3_as_quot <<= 1;
35:            		if(f1_as_dividend >= f2_as_divisor) {
36:            			f1_as_dividend -= f2_as_divisor;
37:            			f3_as_quot |= 1;
38:            		}
39:            		f1_as_dividend <<= 1;
40:            	} while(--cntr != 0);
41:            	__ftpack(&f3_as_quot, exp1);
42:            	if(sign1)
43:            		f3_as_quot |= 0x800000;
44:            	return f3;
45:            }
46:            #else
47:            #define	exp2	sign
48:            float
49:            __ftdiv(float f2, float f1)
50:            {
51:            	unsigned char	exp, sign, cntr;
52:            	float	f3;
53:            	
54:            	// unpack the operands
55:            	if((exp = f1_as_dividend >> 15) == 0)
061F  084F     MOVF f1, W
0620  00D2     MOVWF 0x52
0621  0850     MOVF 0x50, W
0622  00D3     MOVWF 0x53
0623  0851     MOVF 0x51, W
0624  00D4     MOVWF 0x54
0625  1003     BCF STATUS, 0x0
0626  0D53     RLF 0x53, W
0627  0D54     RLF 0x54, W
0628  00D9     MOVWF exp
0629  08D9     MOVF exp, F
062A  1D03     BTFSS STATUS, 0x2
062B  2E30     GOTO 0x630
56:            		return 0.0;
062C  01CC     CLRF day
062D  01CD     CLRF 0x4D
062E  01CE     CLRF 0x4E
062F  0008     RETURN
57:            	if((exp2 = f2_as_divisor >> 15) == 0)
0630  084C     MOVF day, W
0631  00D2     MOVWF 0x52
0632  084D     MOVF 0x4D, W
0633  00D3     MOVWF 0x53
0634  084E     MOVF 0x4E, W
0635  00D4     MOVWF 0x54
0636  1003     BCF STATUS, 0x0
0637  0D53     RLF 0x53, W
0638  0D54     RLF 0x54, W
0639  00DA     MOVWF sign
063A  08DA     MOVF sign, F
063B  1D03     BTFSS STATUS, 0x2
063C  2E41     GOTO 0x641
58:            		return 0.0;
063D  01CC     CLRF day
063E  01CD     CLRF 0x4D
063F  01CE     CLRF 0x4E
0640  0008     RETURN
59:            	f3_as_quot = 0;
0642  01D6     CLRF f3
0643  01D7     CLRF 0x57
0644  01D8     CLRF 0x58
60:            	exp -= exp2-127+8;	// compute new exponent
0641  3089     MOVLW 0x89
0645  075A     ADDWF sign, W
0646  00D2     MOVWF 0x52
0647  02D9     SUBWF exp, F
61:            	sign = f1_as_dividend >> 16;
0648  0851     MOVF 0x51, W
0649  00DA     MOVWF sign
62:            	sign ^= (unsigned char)(f2_as_divisor >> 16);
064A  084E     MOVF 0x4E, W
064B  06DA     XORWF sign, F
63:            	sign &= 0x80;
064C  3080     MOVLW 0x80
064D  05DA     ANDWF sign, F
64:            	f1_as_dividend |= 0x8000UL;
064F  17D0     BSF 0x50, 0x7
65:            	f1_as_dividend &= 0xFFFFUL;
0650  01D1     CLRF 0x51
66:            	f2_as_divisor |= 0x8000UL;
0651  17CD     BSF 0x4D, 0x7
67:            	f2_as_divisor &= 0xFFFFUL;
0652  01CE     CLRF 0x4E
68:            	cntr = 16+8;
064E  3018     MOVLW 0x18
0653  00D5     MOVWF cntr
69:            	do {
70:            		f3_as_quot <<= 1;
0654  1003     BCF STATUS, 0x0
0655  0DD6     RLF f3, F
0656  0DD7     RLF 0x57, F
0657  0DD8     RLF 0x58, F
71:            		if(f1_as_dividend >= f2_as_divisor) {
0658  084E     MOVF 0x4E, W
0659  0251     SUBWF 0x51, W
065A  1D03     BTFSS STATUS, 0x2
065B  2E62     GOTO 0x662
065C  084D     MOVF 0x4D, W
065D  0250     SUBWF 0x50, W
065E  1D03     BTFSS STATUS, 0x2
065F  2E62     GOTO 0x662
0660  084C     MOVF day, W
0661  024F     SUBWF f1, W
0662  1C03     BTFSS STATUS, 0x0
0663  2E70     GOTO 0x670
72:            			f1_as_dividend -= f2_as_divisor;
0664  084C     MOVF day, W
0665  02CF     SUBWF f1, F
0666  084D     MOVF 0x4D, W
0667  1C03     BTFSS STATUS, 0x0
0668  0F4D     INCFSZ 0x4D, W
0669  02D0     SUBWF 0x50, F
066A  084E     MOVF 0x4E, W
066B  1C03     BTFSS STATUS, 0x0
066C  0A4E     INCF 0x4E, W
066D  02D1     SUBWF 0x51, F
73:            			f3_as_quot |= 1;
066E  1456     BSF f3, 0x0
74:            		}
75:            		f1_as_dividend <<= 1;
066F  1003     BCF STATUS, 0x0
0670  0DCF     RLF f1, F
0671  0DD0     RLF 0x50, F
0672  0DD1     RLF 0x51, F
76:            	} while(--cntr != 0);
0673  0BD5     DECFSZ cntr, F
0674  2E54     GOTO 0x654
77:            	return __ftpack(f3_as_quot, exp, sign);
0675  0856     MOVF f3, W
0676  00A3     MOVWF x
0677  0857     MOVF 0x57, W
0678  00A4     MOVWF dato
0679  0858     MOVF 0x58, W
067A  00A5     MOVWF y
067B  0859     MOVF exp, W
067C  00A6     MOVWF x
067D  085A     MOVF sign, W
067E  00A7     MOVWF i
067F  27C2     CALL 0x7C2
0680  0823     MOVF x, W
0681  00CC     MOVWF day
0682  0824     MOVF dato, W
0683  00CD     MOVWF 0x4D
0684  0825     MOVF y, W
0685  00CE     MOVWF 0x4E
78:            }
0686  0008     RETURN
79:            #endif	
---  /opt/microchip/xc8/v1.31/sources/common/wmul.c  ----------------------------------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             unsigned int
3:             __wmul(unsigned int multiplier, unsigned int multiplicand)
4:             {
5:                     unsigned int product;
6:             
7:             #ifdef _PIC18
8:             
9:             #define LOWBYTE(x)  (*(unsigned char *)(&x))
10:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
11:            
12:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
13:            /*
14:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
15:                   a  b
16:            *      c  d
17:            -----------
18:                 |   bd
19:                 |ad  0
20:                 |bc  0
21:            +  ac| 0  0 (we ignore this intermediate product
22:                         because it does not affect the low 16 bits of the result)
23:            ===========
24:             */
25:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
26:                    product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
27:                    product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
28:            
29:            #else
30:            
31:            	product = 0;
0C20  01A7     CLRF i
0C21  01A8     CLRF mth
32:            	do {
33:            		if(multiplier & 1)
0C22  1C23     BTFSS x, 0x0
0C23  2C2A     GOTO 0x42A
34:            			product += multiplicand;
0C24  0825     MOVF y, W
0C25  07A7     ADDWF i, F
0C26  1803     BTFSC STATUS, 0x0
0C27  0AA8     INCF mth, F
0C28  0826     MOVF x, W
0C29  07A8     ADDWF mth, F
35:            		multiplicand <<= 1;
0C2A  1003     BCF STATUS, 0x0
0C2B  0DA5     RLF y, F
0C2C  0DA6     RLF x, F
36:            		multiplier >>= 1;
0C2D  1003     BCF STATUS, 0x0
0C2E  0CA4     RRF dato, F
0C2F  0CA3     RRF x, F
37:            	} while(multiplier != 0);
0C30  0824     MOVF dato, W
0C31  0423     IORWF x, W
0C32  1D03     BTFSS STATUS, 0x2
0C33  2C22     GOTO 0x422
38:            
39:            #endif
40:                    return product;
0C34  0828     MOVF mth, W
0C35  00A4     MOVWF dato
0C36  0827     MOVF i, W
0C37  00A3     MOVWF x
41:            }
0C38  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/lwtoft.c  --------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            
11:            // Convert unsigned int to float
12:            
13:            #ifdef _OLDLIB
14:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
15:            float
16:            __lwtoft(unsigned int c)
17:            {
18:            	float	f1;
19:            	
20:            	if(c == 0)
21:            		return 0.0;
22:            	f1_as_mant1 = c;
23:            	__ftpack(&f1_as_mant1, 127+15);
24:            	return f1;
25:            }
26:            #else
27:            float
28:            __lwtoft(unsigned int c)
29:            {
30:            	return __ftpack(c, 127+15, 0);
05F9  0830     MOVF c, W
05FA  00A3     MOVWF x
05FB  0831     MOVF 0x31, W
05FC  00A4     MOVWF dato
05FD  308E     MOVLW 0x8E
05FE  01A5     CLRF y
05FF  00A6     MOVWF x
0600  01A7     CLRF i
0601  27C2     CALL 0x7C2
0602  0823     MOVF x, W
0603  00B0     MOVWF c
0604  0824     MOVF dato, W
0605  00B1     MOVWF 0x31
0606  0825     MOVF y, W
0607  00B2     MOVWF 0x32
31:            }
0608  0008     RETURN
32:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/lwmod.c  ---------------------------------------------------
1:             // word unsigned modulus
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwmod(unsigned int divisor, unsigned int dividend)
0BFC  082B     MOVF day, W
0F76  0871     MOVF canal, W
7:             #else
8:             __lwmod(unsigned int dividend, unsigned int divisor)
9:             #endif
10:            {
11:            	unsigned char	counter;
12:            
13:            	if(divisor != 0) {
0BFC  082B     MOVF day, W
0BFD  042A     IORWF Data, W
0BFE  1903     BTFSC STATUS, 0x2
0BFF  2C1B     GOTO 0x41B
0F76  0871     MOVF canal, W
0F77  0470     IORWF divisor, W
0F78  1903     BTFSC STATUS, 0x2
0F79  2F95     GOTO 0x795
14:            		counter = 1;
0C00  01AE     CLRF f2
0F7A  01F4     CLRF counter
15:            		while((divisor & 0x8000) == 0) {
0C02  1BAB     BTFSC day, 0x7
0C03  2C08     GOTO 0x408
0C07  2C01     GOTO 0x401
0F7C  1BF1     BTFSC canal, 0x7
0F7D  2F82     GOTO 0x782
0F81  2F7B     GOTO 0x77B
16:            			divisor <<= 1;
0C01  0AAE     INCF f2, F
0C04  1003     BCF STATUS, 0x0
0C05  0DAA     RLF Data, F
0C06  0DAB     RLF day, F
0F7B  0AF4     INCF counter, F
0F7E  1003     BCF STATUS, 0x0
0F7F  0DF0     RLF divisor, F
0F80  0DF1     RLF canal, F
17:            			counter++;
0C01  0AAE     INCF f2, F
0F7B  0AF4     INCF counter, F
18:            		}
19:            		do {
20:            			if(divisor <= dividend)
0C08  082B     MOVF day, W
0C09  022D     SUBWF 0x2D, W
0C0A  1D03     BTFSS STATUS, 0x2
0C0B  2C0E     GOTO 0x40E
0C0C  082A     MOVF Data, W
0C0D  022C     SUBWF dividend, W
0C0E  1C03     BTFSS STATUS, 0x0
0C0F  2C17     GOTO 0x417
0F82  0871     MOVF canal, W
0F83  0273     SUBWF counter, W
0F84  1D03     BTFSS STATUS, 0x2
0F85  2F88     GOTO 0x788
0F86  0870     MOVF divisor, W
0F87  0272     SUBWF dividend, W
0F88  1C03     BTFSS STATUS, 0x0
0F89  2F91     GOTO 0x791
21:            				dividend -= divisor;
0C10  082A     MOVF Data, W
0C11  02AC     SUBWF dividend, F
0C12  082B     MOVF day, W
0C13  1C03     BTFSS STATUS, 0x0
0C14  03AD     DECF 0x2D, F
0C15  02AD     SUBWF 0x2D, F
0F8A  0870     MOVF divisor, W
0F8B  02F2     SUBWF dividend, F
0F8C  0871     MOVF canal, W
0F8D  1C03     BTFSS STATUS, 0x0
0F8E  03F3     DECF counter, F
0F8F  02F3     SUBWF counter, F
22:            			divisor >>= 1;
0C16  1003     BCF STATUS, 0x0
0C17  0CAB     RRF day, F
0C18  0CAA     RRF Data, F
0F90  1003     BCF STATUS, 0x0
0F91  0CF1     RRF canal, F
0F92  0CF0     RRF divisor, F
23:            		} while(--counter != 0);
0C19  0BAE     DECFSZ f2, F
0C1A  2C08     GOTO 0x408
0F93  0BF4     DECFSZ counter, F
0F94  2F82     GOTO 0x782
24:            	}
25:            	return dividend;
0C1B  082D     MOVF 0x2D, W
0C1C  00AB     MOVWF day
0C1D  082C     MOVF dividend, W
0C1E  00AA     MOVWF Data
0F95  0873     MOVF counter, W
0F96  00F1     MOVWF canal
0F97  0872     MOVF dividend, W
0F98  00F0     MOVWF divisor
26:            }
0C1F  0008     RETURN
0F99  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/lwdiv.c  ---------------------------------------------------
1:             // word unsigned division
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwdiv(unsigned int divisor, unsigned int dividend)
7:             #else
8:             __lwdiv(unsigned int dividend, unsigned int divisor)
9:             #endif
10:            {
11:            	unsigned int	quotient;
12:            	unsigned char	counter;
13:            
14:            	quotient = 0;
0BC4  01A7     CLRF i
0BC5  01A8     CLRF mth
15:            	if(divisor != 0) {
0BC6  0824     MOVF dato, W
0BC7  0423     IORWF x, W
0BC8  1903     BTFSC STATUS, 0x2
0BC9  2BE9     GOTO 0x3E9
16:            		counter = 1;
0BCA  01A9     CLRF year
17:            		while((divisor & 0x8000) == 0) {
0BCC  1BA4     BTFSC dato, 0x7
0BCD  2BD2     GOTO 0x3D2
0BD1  2BCB     GOTO 0x3CB
18:            			divisor <<= 1;
0BCB  0AA9     INCF year, F
0BCE  1003     BCF STATUS, 0x0
0BCF  0DA3     RLF x, F
0BD0  0DA4     RLF dato, F
19:            			counter++;
0BCB  0AA9     INCF year, F
20:            		}
21:            		do {
22:            			quotient <<= 1;
0BD2  1003     BCF STATUS, 0x0
0BD3  0DA7     RLF i, F
0BD4  0DA8     RLF mth, F
23:            			if(divisor <= dividend) {
0BD5  0824     MOVF dato, W
0BD6  0226     SUBWF x, W
0BD7  1D03     BTFSS STATUS, 0x2
0BD8  2BDB     GOTO 0x3DB
0BD9  0823     MOVF x, W
0BDA  0225     SUBWF y, W
0BDB  1C03     BTFSS STATUS, 0x0
0BDC  2BE5     GOTO 0x3E5
24:            				dividend -= divisor;
0BDD  0823     MOVF x, W
0BDE  02A5     SUBWF y, F
0BDF  0824     MOVF dato, W
0BE0  1C03     BTFSS STATUS, 0x0
0BE1  03A6     DECF x, F
0BE2  02A6     SUBWF x, F
25:            				quotient |= 1;
0BE3  1427     BSF i, 0x0
26:            			}
27:            			divisor >>= 1;
0BE4  1003     BCF STATUS, 0x0
0BE5  0CA4     RRF dato, F
0BE6  0CA3     RRF x, F
28:            		} while(--counter != 0);
0BE7  0BA9     DECFSZ year, F
0BE8  2BD2     GOTO 0x3D2
29:            	}
30:            	return quotient;
0BE9  0828     MOVF mth, W
0BEA  00A4     MOVWF dato
0BEB  0827     MOVF i, W
0BEC  00A3     MOVWF x
31:            }
0BED  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/lbmod.c  ---------------------------------------------------
1:             // byte unsigned modulus
2:             
3:             unsigned char
4:             __lbmod(unsigned char dividend, unsigned char divisor)
0FC2  00F2     MOVWF dividend
17D6  00A5     MOVWF y
5:             {
6:             	unsigned char	rem;
7:             	unsigned char	counter;
8:             
9:             	counter = 8;
0FC3  3008     MOVLW 0x8
0FC4  00F3     MOVWF counter
17D7  3008     MOVLW 0x8
17D8  00A6     MOVWF x
10:            	rem = 0;
0FC5  01F4     CLRF counter
17D9  01A7     CLRF i
11:            	do {
12:            		rem = (rem << 1) | (dividend >> 7);
0FC6  0872     MOVF dividend, W
0FC7  00F1     MOVWF canal
0FC8  3007     MOVLW 0x7
0FC9  1003     BCF STATUS, 0x0
0FCA  0CF1     RRF canal, F
0FCB  3EFF     ADDLW 0xFF
0FCC  1003     BCF STATUS, 0x0
0FCD  1D03     BTFSS STATUS, 0x2
0FCE  2FCA     GOTO 0x7CA
0FCF  0D74     RLF counter, W
0FD0  0471     IORWF canal, W
0FD1  00F4     MOVWF counter
17DA  0825     MOVF y, W
17DB  00A4     MOVWF dato
17DC  3007     MOVLW 0x7
17DD  1003     BCF STATUS, 0x0
17DE  0CA4     RRF dato, F
17DF  3EFF     ADDLW 0xFF
17E0  1003     BCF STATUS, 0x0
17E1  1D03     BTFSS STATUS, 0x2
17E2  2FDE     GOTO 0x7DE
17E3  0D27     RLF i, W
17E4  0424     IORWF dato, W
17E5  00A7     MOVWF i
13:            		dividend <<= 1;
0FD2  1003     BCF STATUS, 0x0
0FD3  0DF2     RLF dividend, F
17E6  1003     BCF STATUS, 0x0
17E7  0DA5     RLF y, F
14:            		if(divisor <= rem)
0FD4  0870     MOVF divisor, W
0FD5  0274     SUBWF counter, W
0FD6  1C03     BTFSS STATUS, 0x0
0FD7  2FDA     GOTO 0x7DA
17E8  0823     MOVF x, W
17E9  0227     SUBWF i, W
17EA  1C03     BTFSS STATUS, 0x0
17EB  2FEE     GOTO 0x7EE
15:            			rem -= divisor;
0FD8  0870     MOVF divisor, W
0FD9  02F4     SUBWF counter, F
17EC  0823     MOVF x, W
17ED  02A7     SUBWF i, F
16:            	} while(--counter != 0);
0FDA  0BF3     DECFSZ counter, F
0FDB  2FC6     GOTO 0x7C6
17EE  0BA6     DECFSZ x, F
17EF  2FDA     GOTO 0x7DA
17:            	return rem;
0FDC  0874     MOVF counter, W
17F0  0827     MOVF i, W
18:            }
0FDD  0008     RETURN
17F1  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/lbdiv.c  ---------------------------------------------------
1:             // byte unsigned division
2:             
3:             unsigned char
4:             __lbdiv(unsigned char dividend, unsigned char divisor)
17BB  00A4     MOVWF dato
5:             {
6:             	unsigned char	quotient;
7:             	unsigned char	counter;
8:             
9:             	quotient = 0;
17BC  01A6     CLRF x
10:            	if(divisor != 0) {
17BD  0823     MOVF x, W
17BE  1903     BTFSC STATUS, 0x2
17BF  2FD4     GOTO 0x7D4
11:            		counter = 1;
17C0  01A5     CLRF y
12:            		while((divisor & 0x80) == 0) {
17C2  1BA3     BTFSC x, 0x7
17C3  2FC7     GOTO 0x7C7
17C6  2FC1     GOTO 0x7C1
13:            			divisor <<= 1;
17C4  1003     BCF STATUS, 0x0
17C5  0DA3     RLF x, F
14:            			counter++;
17C1  0AA5     INCF y, F
15:            		}
16:            		do {
17:            			quotient <<= 1;
17C7  1003     BCF STATUS, 0x0
17C8  0DA6     RLF x, F
18:            			if(divisor <= dividend) {
17C9  0823     MOVF x, W
17CA  0224     SUBWF dato, W
17CB  1C03     BTFSS STATUS, 0x0
17CC  2FD1     GOTO 0x7D1
19:            				dividend -= divisor;
17CD  0823     MOVF x, W
17CE  02A4     SUBWF dato, F
20:            				quotient |= 1;
17CF  1426     BSF x, 0x0
21:            			}
22:            			divisor >>= 1;
17D0  1003     BCF STATUS, 0x0
17D1  0CA3     RRF x, F
23:            		} while(--counter != 0);
17D2  0BA5     DECFSZ y, F
17D3  2FC7     GOTO 0x7C7
24:            	}
25:            	return quotient;
17D4  0826     MOVF x, W
26:            }
17D5  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/isdigit.c  -------------------------------------------------
1:             #include	<ctype.h>
2:             
3:             #ifndef isdigit
4:             
5:             #ifdef _CTYPE_BIT_FUNCS_
6:             
7:             bit
8:             isdigit(char c)
0BEE  00A4     MOVWF dato
9:             #else
10:            int
11:            isdigit(int c)
12:            #endif
13:            {
14:            	return c <= '9' && c >= '0';
0BEF  303A     MOVLW 0x3A
0BF0  01A3     CLRF x
0BF1  0224     SUBWF dato, W
0BF2  1803     BTFSC STATUS, 0x0
0BF3  2BFA     GOTO 0x3FA
0BF4  3030     MOVLW 0x30
0BF5  0224     SUBWF dato, W
0BF6  1C03     BTFSS STATUS, 0x0
0BF7  2BFA     GOTO 0x3FA
0BF8  01A3     CLRF x
0BF9  0AA3     INCF x, F
0BFA  0C23     RRF x, W
15:            }
0BFB  0008     RETURN
16:            
17:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/fttol.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
11:            
12:            // Convert float to long
13:            
14:            #ifdef _OLDLIB
15:            long
16:            __fttol(float f1)
17:            {
18:            	unsigned char	sign1, exp1;
19:            	unsigned long	lval;
20:            
21:            	sign1 = __ftunpack(&f1_as_mant1, &exp1);
22:            	lval = f1_as_mant1;
23:            	exp1 -= 127+15;
24:            	if((signed char)exp1 < 0) {
25:            		if((signed char)exp1 < -15)
26:            			return 0;
27:            		do
28:            			lval >>= 1;
29:            		while(++exp1 != 0);
30:            	} else {
31:            		if(exp1 >= 32)
32:            			return 00;
33:            		while(exp1 != 0) {
34:            			lval <<= 1;
35:            			exp1--;
36:            		}
37:            	}
38:            	if(sign1)
39:            		lval = -lval;
40:            	return lval;
41:            }
42:            #else
43:            long
44:            __fttol(float f1)
45:            {
46:            	unsigned char	sign1, exp1;
47:            	unsigned long	lval;
48:            
49:            	if((exp1 = f1_as_mant1 >> 15) == 0)
15AC  0823     MOVF x, W
15AD  00A7     MOVWF i
15AE  0824     MOVF dato, W
15AF  00A8     MOVWF mth
15B0  0825     MOVF y, W
15B1  00A9     MOVWF year
15B2  1003     BCF STATUS, 0x0
15B3  0D28     RLF mth, W
15B4  0D29     RLF year, W
15B5  00AF     MOVWF f
15B6  08AF     MOVF f, F
15B7  1D03     BTFSS STATUS, 0x2
15B8  2DBE     GOTO 0x5BE
50:            		return 0;
15B9  01A3     CLRF x
15BA  01A4     CLRF dato
15BB  01A5     CLRF y
15BC  01A6     CLRF x
15BD  0008     RETURN
51:            	sign1 = f1_as_mant1 >> 23;
15BE  0823     MOVF x, W
15BF  00A7     MOVWF i
15C0  0824     MOVF dato, W
15C1  00A8     MOVWF mth
15C2  0825     MOVF y, W
15C3  00A9     MOVWF year
15C4  3017     MOVLW 0x17
15C5  1003     BCF STATUS, 0x0
15C6  0CA9     RRF year, F
15C7  0CA8     RRF mth, F
15C8  0CA7     RRF i, F
15C9  3EFF     ADDLW 0xFF
15CA  1D03     BTFSS STATUS, 0x2
15CB  2DC5     GOTO 0x5C5
15CC  0827     MOVF i, W
15CD  00AA     MOVWF Data
52:            	f1_as_mant1 |= 0x8000UL;
15CE  17A4     BSF dato, 0x7
53:            	f1_as_mant1 &= 0xFFFFUL;
15CF  01A5     CLRF y
54:            	lval = f1_as_mant1;
15D0  0823     MOVF x, W
15D1  00AB     MOVWF day
15D2  0824     MOVF dato, W
15D3  00AC     MOVWF dividend
15D4  0825     MOVF y, W
15D5  00AD     MOVWF 0x2D
15D7  01AE     CLRF f2
55:            	exp1 -= 127+15;
15D6  308E     MOVLW 0x8E
15D8  02AF     SUBWF f, F
56:            	if((signed char)exp1 < 0) {
15D9  1FAF     BTFSS f, 0x7
15DA  2DE8     GOTO 0x5E8
57:            		if((signed char)exp1 < -15)
15DB  082F     MOVF f, W
15DC  3A80     XORLW 0x80
15DD  3E8F     ADDLW 0x8F
15DE  1C03     BTFSS STATUS, 0x0
15DF  2DB9     GOTO 0x5B9
58:            			return 0;
59:            		do
60:            			lval >>= 1;
15E0  1003     BCF STATUS, 0x0
15E1  0CAE     RRF f2, F
15E2  0CAD     RRF 0x2D, F
15E3  0CAC     RRF dividend, F
15E4  0CAB     RRF day, F
61:            		while(++exp1 != 0);
15E5  0FAF     INCFSZ f, F
15E6  2DE0     GOTO 0x5E0
15E7  2DF6     GOTO 0x5F6
62:            	} else {
63:            		if(exp1 >= 24)
15E8  3018     MOVLW 0x18
15E9  022F     SUBWF f, W
15EA  1803     BTFSC STATUS, 0x0
15EB  2DB9     GOTO 0x5B9
64:            			return 0;
65:            		while(exp1 != 0) {
15EC  08AF     MOVF f, F
15F5  2DEC     GOTO 0x5EC
66:            			lval <<= 1;
15EF  1003     BCF STATUS, 0x0
15F0  0DAB     RLF day, F
15F1  0DAC     RLF dividend, F
15F2  0DAD     RLF 0x2D, F
15F3  0DAE     RLF f2, F
67:            			exp1--;
15F4  03AF     DECF f, F
68:            		}
15EC  08AF     MOVF f, F
15ED  1903     BTFSC STATUS, 0x2
15EE  2DF6     GOTO 0x5F6
69:            	}
70:            	if(sign1)
15F6  082A     MOVF Data, W
15F7  1903     BTFSC STATUS, 0x2
15F8  2E04     GOTO 0x604
71:            		lval = -lval;
15F9  09AB     COMF day, F
15FA  09AC     COMF dividend, F
15FB  09AD     COMF 0x2D, F
15FC  09AE     COMF f2, F
15FD  0AAB     INCF day, F
15FE  1903     BTFSC STATUS, 0x2
15FF  0AAC     INCF dividend, F
1600  1903     BTFSC STATUS, 0x2
1601  0AAD     INCF 0x2D, F
1602  1903     BTFSC STATUS, 0x2
1603  0AAE     INCF f2, F
72:            	return lval;
1604  082E     MOVF f2, W
1605  00A6     MOVWF x
1606  082D     MOVF 0x2D, W
1607  00A5     MOVWF y
1608  082C     MOVF dividend, W
1609  00A4     MOVWF dato
160A  082B     MOVF day, W
160B  00A3     MOVWF x
73:            }
160C  0008     RETURN
74:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/ftsub.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
11:            #define	f2_as_mant2	(*(unsigned short long *)&f2)
12:            
13:            // floating addition
14:            
15:            float
16:            #ifdef __PICC__
17:            #warning TODO: update cgpic and this file to use the other prototype
18:            __ftsub(float f2, float f1)
19:            #else
20:            __ftsub(float f1, float f2)
21:            #endif
22:            {
23:            	f2_as_mant2 ^= 0x800000;
0609  3080     MOVLW 0x80
060A  06B9     XORWF 0x39, F
24:            	return __ftadd(f1, f2);
060B  083A     MOVF idx, W
060C  00AB     MOVWF day
060D  083B     MOVF prec, W
060E  00AC     MOVWF dividend
060F  083C     MOVF ap, W
0610  00AD     MOVWF 0x2D
0611  0837     MOVF f2, W
0612  00AE     MOVWF f2
0613  0838     MOVF 0x38, W
0614  00AF     MOVWF f
0615  0839     MOVF 0x39, W
0616  00B0     MOVWF c
0617  2702     CALL 0x702
0618  082B     MOVF day, W
0619  00B7     MOVWF f2
061A  082C     MOVF dividend, W
061B  00B8     MOVWF 0x38
061C  082D     MOVF 0x2D, W
061D  00B9     MOVWF 0x39
25:            }
061E  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/ftmul.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_plier	(*(unsigned short long *)&f1)
11:            #define	f2_as_plicand	(*(unsigned short long *)&f2)
12:            
13:            // floating addition
14:            
15:            #ifdef _OLDLIB
16:            #define	f3_as_product		(*(unsigned short long *)&f3)
17:            float
18:            __ftmul(float f1, float f2)
19:            {
20:            	unsigned char	exp1, sign1, cntr;
21:            	float	f3;
22:            	
23:            	f3_as_product = 0;
24:            	sign1 = __ftunpack(&f1_as_plier, &exp1);
25:            	sign1 ^= __ftunpack(&f2_as_plicand, &cntr);
26:            	if(cntr == 0 || exp1 == 0)
27:            		return f3;
28:            	exp1 += cntr-127-6;	// compute new exponent
29:            	cntr = 7;
30:            	do {
31:            		if(f1_as_plier & 1)
32:            			f3_as_product += f2_as_plicand;
33:            		f1_as_plier >>= 1;
34:            		f2_as_plicand <<= 1;
35:            	} while(--cntr != 0);
36:            	cntr = 9;
37:            	do {
38:            		if(f1_as_plier & 1)
39:            			f3_as_product += f2_as_plicand;
40:            		f1_as_plier >>= 1;
41:            		f3_as_product >>= 1;
42:            	} while(--cntr != 0);
43:            	__ftpack(&f3_as_product, exp1);
44:            	if(sign1)
45:            		f3_as_product |= 0x800000;
46:            	return f3;
47:            }
48:            #else
49:            #define	exp2	sign
50:            float
51:            __ftmul(float f1, float f2)
52:            {
53:            	unsigned char	exp, sign, cntr;
54:            	unsigned short long	f3_as_product;
55:            
56:            	if((exp = f1_as_plier >> 15) == 0)
0687  083D     MOVF flag, W
0688  00C3     MOVWF 0x43
0689  083E     MOVF width, W
068A  00C4     MOVWF 0x44
068B  083F     MOVF 0x3F, W
068C  00C5     MOVWF sp
068D  1003     BCF STATUS, 0x0
068E  0D44     RLF 0x44, W
068F  0D45     RLF sp, W
0690  00C6     MOVWF mth
0691  08C6     MOVF mth, F
0692  1D03     BTFSS STATUS, 0x2
0693  2E98     GOTO 0x698
57:            		return 0.0;
0694  01BD     CLRF flag
0695  01BE     CLRF width
0696  01BF     CLRF 0x3F
0697  0008     RETURN
58:            	if((exp2 = f2_as_plicand >> 15) == 0)
0698  0840     MOVF c, W
0699  00C3     MOVWF 0x43
069A  0841     MOVF _val, W
069B  00C4     MOVWF 0x44
069C  0842     MOVF 0x42, W
069D  00C5     MOVWF sp
069E  1003     BCF STATUS, 0x0
069F  0D44     RLF 0x44, W
06A0  0D45     RLF sp, W
06A1  00CB     MOVWF sec
06A2  08CB     MOVF sec, F
06A3  1D03     BTFSS STATUS, 0x2
06A4  2EA9     GOTO 0x6A9
59:            		return 0.0;
06A5  01BD     CLRF flag
06A6  01BE     CLRF width
06A7  01BF     CLRF 0x3F
06A8  0008     RETURN
60:            	exp += exp2-127-6;	// compute new exponent
06A9  084B     MOVF sec, W
06AA  3E7B     ADDLW 0x7B
06AB  07C6     ADDWF mth, F
61:            	sign = f1_as_plier >> 16;
06AC  083F     MOVF 0x3F, W
06AD  00CB     MOVWF sec
62:            	sign ^= (unsigned char)(f2_as_plicand >> 16);
06AE  0842     MOVF 0x42, W
06AF  06CB     XORWF sec, F
63:            	sign &= 0x80;
06B0  3080     MOVLW 0x80
06B1  05CB     ANDWF sec, F
64:            	f1_as_plier |= 0x8000UL;
06B3  17BE     BSF width, 0x7
65:            	//f1_as_plier &= 0xFFFFUL;		// not required
66:            	f2_as_plicand |= 0x8000UL;
06B4  17C1     BSF _val, 0x7
67:            	f2_as_plicand &= 0xFFFFUL;
06B5  01C2     CLRF 0x42
68:            	f3_as_product = 0;
06B6  01C7     CLRF year
06B7  01C8     CLRF dow
06B8  01C9     CLRF hr
69:            	cntr = 7;
06B2  3007     MOVLW 0x7
06B9  00CA     MOVWF min
70:            	do {
71:            		if(f1_as_plier & 1)
06BA  1C3D     BTFSS flag, 0x0
06BB  2ECA     GOTO 0x6CA
72:            			f3_as_product += f2_as_plicand;
06BC  0840     MOVF c, W
06BD  07C7     ADDWF year, F
06BE  0841     MOVF _val, W
06BF  1103     BCF STATUS, 0x2
06C0  1803     BTFSC STATUS, 0x0
06C1  0A41     INCF _val, W
06C2  1D03     BTFSS STATUS, 0x2
06C3  07C8     ADDWF dow, F
06C4  0842     MOVF 0x42, W
06C5  1103     BCF STATUS, 0x2
06C6  1803     BTFSC STATUS, 0x0
06C7  0A42     INCF 0x42, W
06C8  1D03     BTFSS STATUS, 0x2
06C9  07C9     ADDWF hr, F
73:            		f1_as_plier >>= 1;
06CA  1003     BCF STATUS, 0x0
06CB  0CBF     RRF 0x3F, F
06CC  0CBE     RRF width, F
06CD  0CBD     RRF flag, F
74:            		f2_as_plicand <<= 1;
06CE  1003     BCF STATUS, 0x0
06CF  0DC0     RLF c, F
06D0  0DC1     RLF _val, F
06D1  0DC2     RLF 0x42, F
75:            	} while(--cntr != 0);
06D2  0BCA     DECFSZ min, F
06D3  2EBA     GOTO 0x6BA
76:            	cntr = 9;
06D4  3009     MOVLW 0x9
06D5  00CA     MOVWF min
77:            	do {
78:            		if(f1_as_plier & 1)
06D6  1C3D     BTFSS flag, 0x0
06D7  2EE6     GOTO 0x6E6
79:            			f3_as_product += f2_as_plicand;
06D8  0840     MOVF c, W
06D9  07C7     ADDWF year, F
06DA  0841     MOVF _val, W
06DB  1103     BCF STATUS, 0x2
06DC  1803     BTFSC STATUS, 0x0
06DD  0A41     INCF _val, W
06DE  1D03     BTFSS STATUS, 0x2
06DF  07C8     ADDWF dow, F
06E0  0842     MOVF 0x42, W
06E1  1103     BCF STATUS, 0x2
06E2  1803     BTFSC STATUS, 0x0
06E3  0A42     INCF 0x42, W
06E4  1D03     BTFSS STATUS, 0x2
06E5  07C9     ADDWF hr, F
80:            		f1_as_plier >>= 1;
06E6  1003     BCF STATUS, 0x0
06E7  0CBF     RRF 0x3F, F
06E8  0CBE     RRF width, F
06E9  0CBD     RRF flag, F
81:            		f3_as_product >>= 1;
06EA  1003     BCF STATUS, 0x0
06EB  0CC9     RRF hr, F
06EC  0CC8     RRF dow, F
06ED  0CC7     RRF year, F
82:            	} while(--cntr != 0);
06EE  0BCA     DECFSZ min, F
06EF  2ED6     GOTO 0x6D6
83:            	return __ftpack(f3_as_product, exp, sign);
06F0  0847     MOVF year, W
06F1  00A3     MOVWF x
06F2  0848     MOVF dow, W
06F3  00A4     MOVWF dato
06F4  0849     MOVF hr, W
06F5  00A5     MOVWF y
06F6  0846     MOVF mth, W
06F7  00A6     MOVWF x
06F8  084B     MOVF sec, W
06F9  00A7     MOVWF i
06FA  27C2     CALL 0x7C2
06FB  0823     MOVF x, W
06FC  00BD     MOVWF flag
06FD  0824     MOVF dato, W
06FE  00BE     MOVWF width
06FF  0825     MOVF y, W
0700  00BF     MOVWF 0x3F
84:            }
0701  0008     RETURN
85:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/ftadd.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
11:            #define	f2_as_mant2	(*(unsigned short long *)&f2)
12:            
13:            // floating addition
14:            #ifdef _OLDLIB
15:            float
16:            __ftadd(float f1, float f2)
17:            {
18:            	unsigned char	exp1, exp2, sign1, sign2, cntr;
19:            	
20:            	if(sizeof(f1_as_mant1) != 3)
21:            		return 0;
22:            	sign1 = __ftunpack(&f1_as_mant1, &exp1);
23:            	if(exp1 == 0)
24:            		return f2;
25:            	sign2 = __ftunpack(&f2_as_mant2, &exp2);
26:            	if(exp2 != 0) {
27:            		cntr = 6;
28:            		// determine the smaller number. 
29:            		if(exp1 < exp2) {
30:            			if((unsigned char)(exp2-exp1) > sizeof(f1)*8) {
31:            				// return f2
32:            				f1_as_mant1 = 0;
33:            				exp1 = exp2;
34:            				sign1 = sign2;
35:            			} else {
36:            				// f1 has the smaller exponent - we can shift f2_as_mant2 up to 6 bits
37:            				// left, decrementing exp2.
38:            				do {
39:            					f2_as_mant2 <<= 1;
40:            					exp2--;
41:            				} while(exp2 != exp1 && --cntr != 0);
42:            				while(exp1 != exp2) {
43:            					f1_as_mant1 >>= 1;
44:            					exp1++;
45:            				}
46:            			}
47:            		} else if(exp1 != exp2) {
48:            			if((unsigned char)(exp1-exp2) > sizeof(f1)*8)
49:            				f2_as_mant2 = 0;
50:            			else {
51:            				// f2 has the smaller exponent - we can shift f1_as_mant1 up to 6 bits
52:            				// left, decrementing exp2.
53:            				do {
54:            					f1_as_mant1 <<= 1;
55:            					exp1--;
56:            				} while(exp2 != exp1 && --cntr != 0);
57:            				while(exp1 != exp2) {
58:            					f2_as_mant2 >>= 1;
59:            					exp2++;
60:            				}
61:            			}
62:            		}
63:            		if(sign1 != 0) { 
64:            			f1_as_mant1 ^= 0xFFFFFF;
65:            			f1_as_mant1++;
66:            		}
67:            		if(sign2 != 0) {
68:            			f2_as_mant2 ^= 0xFFFFFF;
69:            			f2_as_mant2++;
70:            		}
71:            		sign1 = 0;
72:            		f1_as_mant1 += f2_as_mant2;
73:            		if(f1_as_mant1 & 0x800000) {
74:            			f1_as_mant1 ^= 0xFFFFFF;
75:            			f1_as_mant1++;
76:            			sign1 = 1;
77:            		}
78:            	}
79:            	__ftpack(&f1_as_mant1, exp1);
80:            	if(sign1)
81:            		f1_as_mant1 ^= 0x800000;
82:            	return f1;
83:            }
84:            #else
85:            float
86:            __ftadd(float f1, float f2)
87:            {
88:            	unsigned char	exp1, exp2, sign;
89:            
90:            	exp1 = f1_as_mant1 >> 15;
0702  082B     MOVF day, W
0703  00B1     MOVWF 0x31
0704  082C     MOVF dividend, W
0705  00B2     MOVWF 0x32
0706  082D     MOVF 0x2D, W
0707  00B3     MOVWF 0x33
0708  1003     BCF STATUS, 0x0
0709  0D32     RLF 0x32, W
070A  0D33     RLF 0x33, W
070B  00B6     MOVWF exp1
91:            	exp2 = f2_as_mant2 >> 15;
070C  082E     MOVF f2, W
070D  00B1     MOVWF 0x31
070E  082F     MOVF f, W
070F  00B2     MOVWF 0x32
0710  0830     MOVF c, W
0711  00B3     MOVWF 0x33
0712  1003     BCF STATUS, 0x0
0713  0D32     RLF 0x32, W
0714  0D33     RLF 0x33, W
0715  00B5     MOVWF exp2
92:            	if(exp1 == 0 || exp1 < exp2  && (unsigned char)(exp2-exp1) > sizeof(f1)*8)
0716  0836     MOVF exp1, W
0717  1903     BTFSC STATUS, 0x2
0718  2F25     GOTO 0x725
0719  0835     MOVF exp2, W
071A  0236     SUBWF exp1, W
071B  0835     MOVF exp2, W
071C  1803     BTFSC STATUS, 0x0
071D  2F2D     GOTO 0x72D
071E  00B1     MOVWF 0x31
071F  0836     MOVF exp1, W
0720  02B1     SUBWF 0x31, F
0721  3019     MOVLW 0x19
0722  0231     SUBWF 0x31, W
0723  1C03     BTFSS STATUS, 0x0
0724  2F2C     GOTO 0x72C
93:            		return f2;
0725  082E     MOVF f2, W
0726  00AB     MOVWF day
0727  082F     MOVF f, W
0728  00AC     MOVWF dividend
0729  0830     MOVF c, W
072A  00AD     MOVWF 0x2D
072B  0008     RETURN
94:            	if(exp2 == 0 || exp1 > exp2  && (unsigned char)(exp1-exp2) > sizeof(f1)*8)
072C  0835     MOVF exp2, W
072D  1903     BTFSC STATUS, 0x2
072E  0008     RETURN
072F  0836     MOVF exp1, W
0730  0235     SUBWF exp2, W
0731  1803     BTFSC STATUS, 0x0
0732  2F3B     GOTO 0x73B
0733  0836     MOVF exp1, W
0734  00B1     MOVWF 0x31
0735  0835     MOVF exp2, W
0736  02B1     SUBWF 0x31, F
0737  3019     MOVLW 0x19
0738  0231     SUBWF 0x31, W
0739  1803     BTFSC STATUS, 0x0
073A  0008     RETURN
95:            		return f1;
96:            	sign = 6;
073B  3006     MOVLW 0x6
073C  00B4     MOVWF sign
97:            	if(f1_as_mant1 & 0x800000L)
073D  1BAD     BTFSC 0x2D, 0x7
98:            		sign |= 0x80;
073E  17B4     BSF sign, 0x7
99:            	if(f2_as_mant2 & 0x800000L)
073F  1BB0     BTFSC c, 0x7
100:           		sign |= 0x40;
0740  1734     BSF sign, 0x6
101:           	f1_as_mant1 |= 0x8000UL;
0741  17AC     BSF dividend, 0x7
102:           	f1_as_mant1 &= 0xFFFFUL;
0742  01AD     CLRF 0x2D
103:           	f2_as_mant2 |= 0x8000UL;
0743  17AF     BSF f, 0x7
104:           	f2_as_mant2 &= 0xFFFFUL;
0744  01B0     CLRF c
105:           	// determine the smaller number. 
106:           	if(exp1 < exp2) {
0745  0835     MOVF exp2, W
0746  0236     SUBWF exp1, W
0747  1803     BTFSC STATUS, 0x0
0748  2F62     GOTO 0x762
107:           		// f1 has the smaller exponent - we can shift f2_as_mant2 up to 6 bits
108:           		// left, decrementing exp2.
109:           		do {
110:           			f2_as_mant2 <<= 1;
0749  1003     BCF STATUS, 0x0
074A  0DAE     RLF f2, F
074B  0DAF     RLF f, F
074C  0DB0     RLF c, F
111:           			exp2--;
074D  03B5     DECF exp2, F
112:           		} while(exp2 != exp1 && --sign & 7);
074E  0835     MOVF exp2, W
074F  0636     XORWF exp1, W
0750  1903     BTFSC STATUS, 0x2
0751  2F5D     GOTO 0x75D
0752  03B4     DECF sign, F
0753  0834     MOVF sign, W
0754  3907     ANDLW 0x7
0755  1903     BTFSC STATUS, 0x2
0756  2F5D     GOTO 0x75D
0757  2F49     GOTO 0x749
113:           		while(exp1 != exp2) {
075D  0836     MOVF exp1, W
075E  0635     XORWF exp2, W
075F  1903     BTFSC STATUS, 0x2
0760  2F7E     GOTO 0x77E
0761  2F58     GOTO 0x758
114:           			f1_as_mant1 >>= 1;
0758  1003     BCF STATUS, 0x0
0759  0CAD     RRF 0x2D, F
075A  0CAC     RRF dividend, F
075B  0CAB     RRF day, F
115:           			exp1++;
075C  0AB6     INCF exp1, F
116:           		}
117:           	} else if(exp1 > exp2) {
0762  0836     MOVF exp1, W
0763  0235     SUBWF exp2, W
0764  1803     BTFSC STATUS, 0x0
0765  2F7E     GOTO 0x77E
118:           		// f2 has the smaller exponent - we can shift f1_as_mant1 up to 6 bits
119:           		// left, decrementing exp2.
120:           		do {
121:           			f1_as_mant1 <<= 1;
0766  1003     BCF STATUS, 0x0
0767  0DAB     RLF day, F
0768  0DAC     RLF dividend, F
0769  0DAD     RLF 0x2D, F
122:           			exp1--;
076A  03B6     DECF exp1, F
123:           		} while(exp2 != exp1 && --sign & 7);
076B  0835     MOVF exp2, W
076C  0636     XORWF exp1, W
076D  1903     BTFSC STATUS, 0x2
076E  2F7A     GOTO 0x77A
076F  03B4     DECF sign, F
0770  0834     MOVF sign, W
0771  3907     ANDLW 0x7
0772  1903     BTFSC STATUS, 0x2
0773  2F7A     GOTO 0x77A
0774  2F66     GOTO 0x766
124:           		while(exp1 != exp2) {
077A  0836     MOVF exp1, W
077B  0635     XORWF exp2, W
077C  1D03     BTFSS STATUS, 0x2
077D  2F75     GOTO 0x775
125:           			f2_as_mant2 >>= 1;
0775  1003     BCF STATUS, 0x0
0776  0CB0     RRF c, F
0777  0CAF     RRF f, F
0778  0CAE     RRF f2, F
126:           			exp2++;
0779  0AB5     INCF exp2, F
127:           		}
128:           	}
129:           	if(sign & 0x80) { 
077E  1FB4     BTFSS sign, 0x7
077F  2F89     GOTO 0x789
130:           		// complement and add 1
131:           		f1_as_mant1 ^= 0xFFFFFFUL;
0780  30FF     MOVLW 0xFF
0781  06AB     XORWF day, F
0782  06AC     XORWF dividend, F
0783  06AD     XORWF 0x2D, F
132:           		f1_as_mant1++;
0784  0AAB     INCF day, F
0785  1903     BTFSC STATUS, 0x2
0786  0AAC     INCF dividend, F
0787  1903     BTFSC STATUS, 0x2
0788  0AAD     INCF 0x2D, F
133:           	}
134:           	if(sign & 0x40) {
0789  1F34     BTFSS sign, 0x6
078A  2F94     GOTO 0x794
135:           		// complement and add 1
136:           		f2_as_mant2 ^= 0xFFFFFFUL;
078B  30FF     MOVLW 0xFF
078C  06AE     XORWF f2, F
078D  06AF     XORWF f, F
078E  06B0     XORWF c, F
137:           		f2_as_mant2++;
078F  0AAE     INCF f2, F
0790  1903     BTFSC STATUS, 0x2
0791  0AAF     INCF f, F
0792  1903     BTFSC STATUS, 0x2
0793  0AB0     INCF c, F
138:           	}
139:           	sign = 0;
0794  01B4     CLRF sign
140:           	f2_as_mant2 += f1_as_mant1;
0795  082B     MOVF day, W
0796  07AE     ADDWF f2, F
0797  082C     MOVF dividend, W
0798  1103     BCF STATUS, 0x2
0799  1803     BTFSC STATUS, 0x0
079A  0A2C     INCF dividend, W
079B  1D03     BTFSS STATUS, 0x2
079C  07AF     ADDWF f, F
079D  082D     MOVF 0x2D, W
079E  1103     BCF STATUS, 0x2
079F  1803     BTFSC STATUS, 0x0
07A0  0A2D     INCF 0x2D, W
07A1  1D03     BTFSS STATUS, 0x2
07A2  07B0     ADDWF c, F
141:           	if(f2_as_mant2 & 0x800000UL) {
07A3  1FB0     BTFSS c, 0x7
07A4  2FB0     GOTO 0x7B0
142:           		f2_as_mant2 ^= 0xFFFFFFUL;
07A5  30FF     MOVLW 0xFF
07A6  06AE     XORWF f2, F
07A7  06AF     XORWF f, F
07A8  06B0     XORWF c, F
143:           		f2_as_mant2++;
07A9  0AAE     INCF f2, F
07AA  1903     BTFSC STATUS, 0x2
07AB  0AAF     INCF f, F
07AC  1903     BTFSC STATUS, 0x2
07AD  0AB0     INCF c, F
144:           		sign = 1;
07AE  01B4     CLRF sign
07AF  0AB4     INCF sign, F
145:           	}
146:           	return __ftpack(f2_as_mant2, exp1, sign);
07B0  082E     MOVF f2, W
07B1  00A3     MOVWF x
07B2  082F     MOVF f, W
07B3  00A4     MOVWF dato
07B4  0830     MOVF c, W
07B5  00A5     MOVWF y
07B6  0836     MOVF exp1, W
07B7  00A6     MOVWF x
07B8  0834     MOVF sign, W
07B9  00A7     MOVWF i
07BA  27C2     CALL 0x7C2
07BB  0823     MOVF x, W
07BC  00AB     MOVWF day
07BD  0824     MOVF dato, W
07BE  00AC     MOVWF dividend
07BF  0825     MOVF y, W
07C0  00AD     MOVWF 0x2D
147:           
148:           }
07C1  0008     RETURN
149:           #endif
---  /opt/microchip/xc8/v1.31/sources/common/float.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             #include	"ftarith.h"
7:             
8:             
9:             //	unpack the operand pointed to. Store the exponent into the location pointed to by exp,
10:            //	and return the sign (zero is positive)
11:            
12:            #ifdef _OLDLIB
13:            
14:            unsigned char
15:            __ftunpack(unsigned short long * arg, unsigned char * exp)
16:            {
17:            	unsigned char	sign;
18:            
19:            	*exp = sign = *arg >> 15;
20:            	if(sign == 0) {
21:            		*arg = 0;
22:            		return 0;
23:            	}
24:            	sign = 0;
25:            	*arg |= 0x8000;
26:            	if(*arg & 0x800000)
27:            		sign++;
28:            	*arg &= 0xFFFF;
29:            	return sign;
30:            }
31:            
32:            // normalize and pack the supplied argument into floating point format
33:            
34:            void
35:            __ftpack(unsigned short long * arg, unsigned char exp)
36:            {
37:            	if(exp == 0 || *arg == 0) {
38:            		*arg = 0;
39:            		return;
40:            	}
41:            	while(*arg & 0xFE0000UL) {
42:            		exp++;
43:            		*arg >>= 1;
44:            	}
45:            	while(*arg & 0xFF0000UL) {
46:            		exp++;
47:            		(*arg)++;
48:            		*arg >>= 1;
49:            	}
50:            	while(!(*arg & 0x8000UL)) {
51:            		exp--;
52:            		*arg <<= 1;
53:            	}
54:            	if(!(exp & 1))
55:            		*arg &= ~0x8000L;
56:            	exp >>= 1;
57:            	*arg |= (unsigned short long)exp << 16;
58:            }
59:            
60:            #else
61:            float
62:            __ftpack(unsigned short long arg, unsigned char exp, unsigned char sign)
63:            {
64:            	if(exp == 0 || arg == 0)
07C2  0826     MOVF x, W
07C3  1903     BTFSC STATUS, 0x2
07C4  2FCA     GOTO 0x7CA
07C5  0825     MOVF y, W
07C6  0424     IORWF dato, W
07C7  0423     IORWF x, W
07C8  1D03     BTFSS STATUS, 0x2
07C9  2FD3     GOTO 0x7D3
65:            		return 0.0;
07CA  01A3     CLRF x
07CB  01A4     CLRF dato
07CC  01A5     CLRF y
07CD  0008     RETURN
66:            	while(arg & 0xFE0000UL) {
07D3  30FE     MOVLW 0xFE
07D4  0525     ANDWF y, W
07D5  1903     BTFSC STATUS, 0x2
07D6  2FE2     GOTO 0x7E2
07D7  2FCE     GOTO 0x7CE
67:            		exp++;
07CE  0AA6     INCF x, F
68:            		arg >>= 1;
07CF  1003     BCF STATUS, 0x0
07D0  0CA5     RRF y, F
07D1  0CA4     RRF dato, F
07D2  0CA3     RRF x, F
69:            	}
70:            	while(arg & 0xFF0000UL) {
07E2  30FF     MOVLW 0xFF
07E3  0525     ANDWF y, W
07E4  1903     BTFSC STATUS, 0x2
07E5  2FEC     GOTO 0x7EC
07E6  2FD8     GOTO 0x7D8
71:            		exp++;
07D8  0AA6     INCF x, F
72:            		(arg)++;
07D9  0AA3     INCF x, F
07DA  1903     BTFSC STATUS, 0x2
07DB  0AA4     INCF dato, F
07DC  1903     BTFSC STATUS, 0x2
07DD  0AA5     INCF y, F
73:            		arg >>= 1;
07DE  1003     BCF STATUS, 0x0
07DF  0CA5     RRF y, F
07E0  0CA4     RRF dato, F
07E1  0CA3     RRF x, F
74:            	}
75:            	while(!(arg & 0x8000UL)) {
07EC  1FA4     BTFSS dato, 0x7
07ED  2FE7     GOTO 0x7E7
76:            		exp--;
07E7  03A6     DECF x, F
77:            		arg <<= 1;
07E8  1003     BCF STATUS, 0x0
07E9  0DA3     RLF x, F
07EA  0DA4     RLF dato, F
07EB  0DA5     RLF y, F
78:            	}
79:            	if(!(exp & 1))
07EE  1C26     BTFSS x, 0x0
80:            		arg &= ~0x8000L;
07EF  13A4     BCF dato, 0x7
81:            	exp >>= 1;
07F0  1003     BCF STATUS, 0x0
07F1  0CA6     RRF x, F
82:            	arg |= (unsigned short long)exp << 16;
07F2  0826     MOVF x, W
07F3  00AA     MOVWF Data
07F4  01A9     CLRF year
07F5  01A8     CLRF mth
07F6  0828     MOVF mth, W
07F7  04A3     IORWF x, F
07F8  0829     MOVF year, W
07F9  04A4     IORWF dato, F
07FA  082A     MOVF Data, W
07FB  04A5     IORWF y, F
83:            	if (sign)
07FC  0827     MOVF i, W
07FD  1D03     BTFSS STATUS, 0x2
84:            		arg |= 0x800000UL;
07FE  17A5     BSF y, 0x7
85:               return *(float*)&arg;	
86:            }
07FF  0008     RETURN
87:            
88:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/doprnt.c  --------------------------------------------------
1:             #include	<stdio.h>
2:             #include	<ctype.h>
3:             #include	<stdlib.h>
4:             #include	<string.h>
5:             #include	<stdarg.h>
6:             #include	<conio.h>
7:             #include	<sys.h>
8:             #include	<math.h>
9:             #include	<float.h>
10:            
11:            // disable unused variable warnings
12:            // the compiler will optimize them away, so no harm is done
13:            #pragma warning disable 350
14:            
15:            /*
16:             *	doprnt - versions depends on conditional compilation.
17:             *	Can be customized with defines.
18:             *
19:             *	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
20:             *
21:             *	$Header$
22:             *
23:             */
24:            
25:            #ifndef	CUSTOM_PRINTF
26:            
27:             // define all flags, thus enabling all features
28:            
29:            #define	BASEM	0xC0
30:            #define	OPTSIGN	0x00
31:            #define	SPCSIGN	0x01
32:            #define	MANSIGN	0x02
33:            #define	NEGSIGN	0x03
34:            #define	FILL	0x04
35:            #define	LEFT	0x08
36:            #define	LONG	0x10
37:            #define	UPCASE	0x20
38:            #define	TEN		0x00
39:            #define	EIGHT	0x40
40:            #define	SIXTEEN	0x80
41:            #define	UNSIGN	0xC0
42:            #ifdef	__FLOAT
43:            #define	EFMT	0x100
44:            #define	GFMT	0x200
45:            #define	FFMT	0x400
46:            #endif	// __FLOAT
47:            #define	ALTERN	0x800
48:            #define POINTER	0x2000
49:            #define HEXUPCASE
50:            #define HEXLOWCASE
51:            
52:             // defines for ifdef only, not used as flags
53:            #define	WIDTH	1		// width used
54:            #define	STAR	1		// width or precision as an arg
55:            #define	STRING	1		// %s used
56:            #define	CHAR	1		// %c used
57:            #define	PERCPERC	1	// %% used
58:            #define	SPRINTF	1		// sprintf is used
59:            #define	PRINTF	1		// printf is used
60:            #define	MULTRAD	1		// handle multiple radices
61:            #define	RETVALUE	1	// return value is needed
62:            
63:            #else	// CUSTOM_PRINTF
64:            
65:            #if	defined(HEXUPCASE) || defined(HEXLOWCASE)
66:            #define	SIXTEEN
67:            #endif
68:            
69:            #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
70:            #ifndef UPCASE
71:            #define	UPCASE
72:            #endif
73:            #endif
74:            
75:             // make sure we have the right values for each define
76:            #ifdef	OPTSIGN
77:            #undef	OPTSIGN
78:            #define	OPTSIGN	0x00
79:            #endif
80:            #ifdef	SPCSIGN
81:            #undef	SPCSIGN
82:            #define	SPCSIGN	0x01
83:            #endif
84:            #ifdef	MANSIGN
85:            #undef	MANSIGN
86:            #define	MANSIGN	0x02
87:            #define	SPCSIGN	0x01
88:            #endif
89:            #ifdef	NEGSIGN
90:            #undef	NEGSIGN
91:            #define	NEGSIGN	0x03
92:            #endif
93:            #ifdef	FILL
94:            #define	WIDTH	1
95:            #undef	FILL
96:            #define	FILL	0x04
97:            #endif
98:            #ifdef	LEFT
99:            #undef	LEFT
100:            // LEFT without WIDTH is meaningless
101:           #ifdef	WIDTH
102:           #define	LEFT	0x08
103:           #endif
104:           #endif
105:           #ifdef	LONG
106:           #undef	LONG
107:           #define	LONG	0x10
108:           #define	__LONG	1
109:           #endif
110:           #ifdef	UPCASE
111:           #undef	UPCASE
112:           #define	UPCASE	0x20
113:           #endif
114:           #ifdef	TEN	
115:           #undef	TEN	
116:           #define	TEN		0x00
117:           #endif
118:           #ifdef	EIGHT
119:           #undef	EIGHT
120:           #define	EIGHT	0x40
121:           #endif
122:           #ifdef	SIXTEEN
123:           #undef	SIXTEEN
124:           #define	SIXTEEN	0x80
125:           #endif
126:           #ifdef	UNSIGN
127:           #undef	UNSIGN
128:           #define	UNSIGN	0xC0
129:           #endif
130:           #ifdef	EFMT
131:           #undef	EFMT
132:           #define	EFMT	0x100
133:           #endif
134:           #ifdef	GFMT
135:           #undef	GFMT
136:           #define	GFMT	0x200
137:           #endif
138:           #ifdef	FFMT
139:           #undef	FFMT
140:           #define	FFMT	0x400
141:           #endif
142:           #ifdef	ALTERN
143:           #undef	ALTERN
144:           #define	ALTERN	0x800
145:           #endif
146:           #ifdef	POINTER
147:           #undef	POINTER
148:           #define POINTER	0x2000
149:           #ifndef	SIXTEEN
150:           #define	SIXTEEN	0x80
151:           #endif
152:           #endif
153:           #ifdef	PRECISION
154:           #undef	PRECISION
155:           #define PRECISION	0x4000
156:           #endif
157:           
158:           #if	defined(TEN) && !defined(EIGHT) && !defined(SIXTEEN) && defined(UNSIGN)
159:           #undef	UNSIGN
160:           #define	UNSIGN	0x40
161:           #define	BASEM	UNSIGN
162:           #endif
163:           #if	defined(UNSIGN) && (defined(EIGHT) || defined(SIXTEEN))
164:           #define	MULTRAD	1
165:           #define	BASEM	(UNSIGN)
166:           #endif
167:           #if	defined(TEN) && !defined(SIXTEEN) && defined(EIGHT) && !defined(UNSIGN)
168:           #define	BASEM	EIGHT
169:           #define	MULTRAD	1
170:           #endif
171:           #if	defined(TEN) && defined(SIXTEEN) && !defined(EIGHT) && !defined(UNSIGN)
172:           #define	BASEM	SIXTEEN
173:           #define	MULTRAD	1
174:           #endif
175:           #if	defined(SIXTEEN) && defined(EIGHT) && !defined(BASEM)
176:           #define	BASEM	(SIXTEEN|EIGHT)
177:           #define	MULTRAD	1
178:           #endif
179:           
180:           #endif
181:           
182:            // float code needs these flags
183:           #if	defined(EFMT) || defined(GFMT) || defined(FFMT)
184:           #ifndef	__FLOAT
185:           #define	__FLOAT	1
186:           #endif
187:           #define	FLOATFORMAT	0x700
188:           #ifdef	PRECISION
189:           #define	DEFPREC	0x1000
190:           #endif
191:           #endif
192:           
193:           #ifdef	__FLOAT
194:           //#ifndef	MANSIGN
195:           //#define	MANSIGN	0x02
196:           //#endif
197:           //#ifndef	SPCSIGN
198:           //#define	SPCSIGN	0x01
199:           //#endif
200:           #ifndef	NEGSIGN
201:           #define	NEGSIGN	0x03
202:           #endif
203:           //#ifndef	WIDTH
204:           //#define	WIDTH	1
205:           //#endif
206:           #endif
207:           
208:           #ifdef	SPCSIGN
209:           #define	putsign()	pputc(flag & SPCSIGN ? '-' : '+')
210:           #else
211:           #define	putsign()	pputc('-')
212:           #endif	// SPCSIGN
213:           
214:           // were there ANY % formats defined?
215:           #if	defined(FLOATFORMAT) || defined(TEN) || defined(EIGHT) || defined(SIXTEEN) || \
216:           	defined(CHAR) || defined(POINTER) || defined(STRING) || defined(UNSIGN) || defined(PERCPERC)
217:           #define	ANYFORMAT
218:           #else
219:           #undef	ANYFORMAT
220:           #endif
221:           
222:           #ifdef	CHAR
223:           #ifndef	PERCPERC
224:           #define	PERCPERC
225:           #endif
226:           #endif
227:           
228:           #if	!defined(PRINTF) && !defined(VPRINTF) && !defined(SPRINTF) && !defined(VSPRINTF)
229:           #error	Must define at least one of PRINTF SPRINTF or VSPRINTF
230:           #endif
231:           
232:           #if	i8086 && SMALL_DATA
233:           #define	CONST	far
234:           #else
235:           #define	CONST	const
236:           #endif
237:           
238:            /* we don't need plus signs, use minus signs only if we have floats or signed ints */
239:           
240:           #if	!defined(NEGSIGN) && defined(TEN)
241:           #define	NEGSIGN	0x03
242:           #endif
243:           
244:           #ifndef	RETVALUE
245:           #define	INCR_CNT	/*nix */
246:           #else
247:           #define	INCR_CNT	,(++ccnt)
248:           #endif
249:           
250:           #if	defined(EFMT) || defined(GFMT) || defined(FFMT) || defined(ALTERN) || defined(DEFPREC) || defined(POINTER)
251:           #define	FLAG_SIZE	unsigned short
252:           #else
253:           #define	FLAG_SIZE	unsigned char
254:           #endif
255:           
256:           
257:           #if	(sizeof(long) == sizeof(int) || defined(__FLOAT)) && !defined(__LONG)
258:           #define	__LONG	1
259:           #endif
260:           
261:           #if	sizeof(double) == sizeof(long) && DBL_MAX_EXP == 128
262:           #undef	frexp
263:           #define	frexp(val, ptr) (void)(*(ptr) = (unsigned char)((*(unsigned long *)&val >> 23) & 255) - 126)
264:           #elif	defined(_PSOC_)
265:           #undef	frexp
266:           #define	frexp(val, ptr) (void)(*(ptr) = ((unsigned char)(*(unsigned short long *)&val >> 15)) - 126)
267:           #elif	sizeof(double) == 3 && DBL_MAX_EXP == 128
268:           #undef	frexp
269:           #define	frexp(val, ptr) (void)(*(ptr) = ((*(unsigned long *)&val >> 15) & 255) - 126)
270:           #endif
271:           
272:           #if	defined(__FLOAT) && sizeof(double) == 8
273:           #define	DOUBLE	1
274:           
275:           extern double	_dto64i(double);
276:           extern double	_64itod(double);
277:           extern double	_div64(double, double);
278:           extern double	_divto64i(double, double);
279:           extern unsigned	_div64ir(double, double);
280:           extern unsigned	_mod64i10(double);
281:           
282:           #else
283:           #define	DOUBLE	0
284:           #endif
285:           
286:           #ifdef	__LONG
287:           #define	value	long
288:           #define	NDIG	12		/* max number of digits to be printed */
289:           #else
290:           #define	value	int
291:           #define	NDIG	6		/* max number of digits to be printed */
292:           #endif
293:           
294:           #if	DOUBLE
295:           union {
296:           	unsigned long	ul[40];
297:           	double		db[20];
298:           }	_fdp =
299:           {
300:           #if	!defined(BIG_ENDIAN) && !defined(LITTLE_ENDIAN)
301:           #error Neither BIG_ENDIAN or LITTLE_ENDIAN has been set
302:           #endif
303:           #if	BIG_ENDIAN
304:           	0x00000000,0x00000001,
305:           	0x00000000,0x0000000A,
306:           	0x00000000,0x00000064,
307:           	0x00000000,0x000003E8,
308:           	0x00000000,0x00002710,
309:           	0x00000000,0x000186A0,
310:           	0x00000000,0x000F4240,
311:           	0x00000000,0x00989680,
312:           	0x00000000,0x05F5E100,
313:           	0x00000000,0x3B9ACA00,
314:           	0x00000002,0x540BE400,
315:           	0x00000017,0x4876E800,
316:           	0x000000E8,0xD4A51000,
317:           	0x00000918,0x4E72A000,
318:           	0x00005AF3,0x107A4000,
319:           	0x00038D7E,0xA4C68000,
320:           	0x002386F2,0x6FC10000,
321:           	0x01634578,0x5D8A0000,
322:           	0x0DE0B6B3,0xA7640000,
323:           	0x8AC72304,0x89E80000,
324:           #else
325:           	0x00000001,0x00000000,
326:           	0x0000000A,0x00000000,
327:           	0x00000064,0x00000000,
328:           	0x000003E8,0x00000000,
329:           	0x00002710,0x00000000,
330:           	0x000186A0,0x00000000,
331:           	0x000F4240,0x00000000,
332:           	0x00989680,0x00000000,
333:           	0x05F5E100,0x00000000,
334:           	0x3B9ACA00,0x00000000,
335:           	0x540BE400,0x00000002,
336:           	0x4876E800,0x00000017,
337:           	0xD4A51000,0x000000E8,
338:           	0x4E72A000,0x00000918,
339:           	0x107A4000,0x00005AF3,
340:           	0xA4C68000,0x00038D7E,
341:           	0x6FC10000,0x002386F2,
342:           	0x5D8A0000,0x01634578,
343:           	0xA7640000,0x0DE0B6B3,
344:           	0x89E80000,0x8AC72304,
345:           #endif
346:           };
347:           
348:           #define	fdpowers	_fdp.db
349:           
350:           #else
351:           #define	fdpowers	dpowers
352:           #endif
353:           #if defined(TEN) || defined(__FLOAT) || defined (UNSIGN)
354:           const static unsigned value	dpowers[] =	{1, 10, 100, 1000, 10000,
355:           #ifdef	__LONG
356:           						 100000, 1000000, 10000000, 100000000,
357:           						 1000000000
358:           #endif
359:           							 };
360:           #endif
361:           #ifdef	SIXTEEN
362:           const static unsigned value	hexpowers[] =	{1, 0x10, 0x100, 0x1000,
363:           #if	__LONG
364:           						 0x10000, 0x100000, 0x1000000, 0x10000000
365:           #endif
366:           							};
367:           #endif
368:           #ifdef	EIGHT
369:           const static unsigned value	octpowers[] =	{1, 010, 0100, 01000, 010000, 0100000,
370:           #ifdef	__LONG
371:           						01000000,
372:           						 010000000, 0100000000, 01000000000, 010000000000,
373:           						 0100000000000
374:           #endif
375:           							};
376:           #endif
377:           
378:           #ifdef	__FLOAT
379:           
380:           #define	NDDIG	(sizeof fdpowers/sizeof fdpowers[0])
381:           
382:           #if	DBL_MAX_10_EXP > 120
383:           #define	expon	int
384:           #else
385:           #define	expon	signed char
386:           #endif
387:           
388:           extern const double	_powers_[], _npowers_[];
389:           #ifdef	z80
390:           #define	_div_to_l_(a, b)	((unsigned long)((a)/(b)))
391:           #else
392:           extern unsigned long	_div_to_l_(double, double);
393:           #ifdef	_OMNI_CODE_
394:           extern unsigned long	_tdiv_to_l_(float, float);
395:           #ifdef	_HTKC_
396:           #pragma callname _div_to_l_ double
397:           #pragma callname _tdiv_to_l_ float
398:           #endif
399:           #define	div_to_l_(a,b)	((sizeof(double)== 3) ? _tdiv_to_l_(a,b) : _div_to_l_(a,b))
400:           #else
401:           #define	div_to_l_	_div_to_l_
402:           #endif
403:           #endif
404:           
405:           /* this routine returns a value to round to the number of decimal
406:           	places specified */
407:           #if __FLOAT
408:           static double
409:           fround(unsigned char prec)
410:           {
411:           	/* prec is guaranteed to be less than NDIG */
412:           
413:           	if(prec>=110)
414:           		return 0.5 * _npowers_[prec/100+18] * _npowers_[(prec%100)/10+9] * _npowers_[prec%10];
415:           	else if(prec > 10)
416:           		return 0.5 * _npowers_[prec/10+9] * _npowers_[prec%10];
417:           	return 0.5 * _npowers_[prec];
418:           }
419:           #endif
420:           
421:           /* this routine returns a scaling factor equal to 1 to the decimal
422:              power supplied */
423:           
424:           static double
425:           scale(expon scl)
426:           {
427:           
428:           	if(scl < 0) {
429:           		scl = -scl;
430:           		if(scl>=110)
431:           			return _npowers_[scl/100+18] * _npowers_[(scl%100)/10+9] * _npowers_[scl%10];
432:           		else if(scl > 10)
433:           			return _npowers_[scl/10+9] * _npowers_[scl%10];
434:           		return _npowers_[scl];
435:           	}
436:           	if(scl>=110)
437:           		return _powers_[scl/100+18] * _powers_[(scl%100)/10+9] * _powers_[scl%10];
438:           	else if(scl > 10)
439:           		return _powers_[scl/10+9] * _powers_[scl%10];
440:           	return _powers_[scl];
441:           }
442:           
443:           
444:           #endif	/* __FLOAT */
445:           
446:           
447:           
448:           #ifdef	_HOSTED
449:           #define	pputc(c)	(putc(c, fp) != EOF && ++ccnt)
450:           int
451:           vfprintf(FILE * fp, register const  char * f, register va_list ap)
452:           {
453:           	char		cbuf[2];
454:           #else	/* _HOSTED */
455:           int
456:           #if	defined(VPRINTF) || (defined(PRINTF) && (defined(SPRINTF) || defined(VSPRINTF)))
457:           #define	pputc(c)	if(pb->func) (pb->func(c))INCR_CNT; else ((*pb->ptr++ = c)INCR_CNT)
458:           _doprnt(struct __prbuf * pb, register const  char * f, register va_list ap)
459:           {
460:           #endif
461:           
462:           #if	defined(PRINTF) && !(defined(SPRINTF) || defined(VSPRINTF))
463:           #define	pputc(c)	(putch(c) INCR_CNT)
464:           printf(const char * f, ...)
465:           {
466:           	va_list	ap;
467:           #define	NEED_START
468:           #endif
469:           
470:           #if	!defined(PRINTF) && defined(VSPRINTF)
471:           
472:           #ifdef	SPRINTF
473:           sprintf(char * sp, const char * f, ...)
474:           {
475:           	va_list	ap;
476:           
477:           	va_start(ap, f);
478:           	vsprintf(sp, f, ap);
479:           	va_end(ap);
480:           }
481:           int
482:           #endif	// SPRINTF
483:           
484:           #define	pputc(c)	((*sp++ = (c))INCR_CNT)
485:           vsprintf(char * sp, register const  char * f, register va_list ap)
486:           {
487:           #define NEED_START
488:           #endif	// VSPRINTF
489:           
490:           #if	!defined(PRINTF) && defined(SPRINTF) && !defined(VSPRINTF)
491:           #define	pputc(c)	((*sp++ = (c))INCR_CNT)
492:           sprintf(char * sp, const  char * f, ...)
096F  00C5     MOVWF sp
493:           {
494:           	va_list	ap;
495:           #define	NEED_START
496:           #endif
497:           #endif	// HOSTED
498:           
499:           	signed char		c;
500:           #if	defined(WIDTH) || defined(__FLOAT)
501:           	int		width;
502:           #endif
503:           #ifdef	__LONG
504:           	int		prec;
505:           #else
506:           	signed char	prec;
507:           #endif
508:           	FLAG_SIZE	flag;
509:           #ifdef	RETVALUE
510:           	int		ccnt = 0;
511:           #else
512:           #define	ccnt	0
513:           #endif
514:           #ifdef	__FLOAT
515:           	char	d;
516:           	double	fval, integ;
517:           	int		exp;
518:           	double		ival;
519:           	union {
520:           		unsigned value	_val;
521:           		struct {
522:           		    CONST char *	_cp;
523:           		    unsigned	_len;
524:           		}		_str;
525:           	}		_val;
526:           #else	// __FLOAT
527:           	union {
528:           		unsigned value	_val;
529:           		struct {
530:           		    CONST char *	_cp;
531:           		    unsigned	_len;
532:           		}		_str;
533:           	}		_val;
534:           #endif	// __FLOAT
535:           
536:           #define	val	_val._val
537:           #define	cp	_val._str._cp
538:           #define	len	_val._str._len
539:           
540:           	
541:           #ifdef	NEED_START
542:           	va_start(ap, f);
0970  3031     MOVLW 0x31
0971  00BC     MOVWF ap
543:           #endif
544:           
545:           	while(c = *f++) {
0972  0830     MOVF c, W
0973  00B8     MOVWF 0x38
0974  082F     MOVF f, W
0975  00B7     MOVWF f2
0976  0AAF     INCF f, F
0977  1903     BTFSC STATUS, 0x2
0978  0AB0     INCF c, F
0979  0838     MOVF 0x38, W
097A  00FF     MOVWF 0x7F
097B  0837     MOVF f2, W
097C  0084     MOVWF FSR
097D  160A     BSF PCLATH, 0x4
097E  158A     BSF PCLATH, 0x3
097F  2000     CALL 0x0
0980  120A     BCF PCLATH, 0x4
0981  158A     BSF PCLATH, 0x3
0982  00C0     MOVWF c
0983  08C0     MOVF c, F
0984  1903     BTFSC STATUS, 0x2
0985  2BBF     GOTO 0x3BF
0BBE  2972     GOTO 0x172
546:           #ifdef	ANYFORMAT
547:           		if(c != '%')
0986  0840     MOVF c, W
0987  3A25     XORLW 0x25
0988  1903     BTFSC STATUS, 0x2
0989  2991     GOTO 0x191
548:           #endif	//ANYFORMAT
549:           		{
550:           			pputc(c);
098A  0845     MOVF sp, W
098B  0084     MOVWF FSR
098C  0840     MOVF c, W
098D  1383     BCF STATUS, 0x7
098E  0080     MOVWF INDF
098F  0AC5     INCF sp, F
551:           			continue;
0990  2972     GOTO 0x172
552:           		}
553:           #ifdef	ANYFORMAT
554:           #ifdef	WIDTH
555:           		width = 0;
0991  01BE     CLRF width
0992  01BF     CLRF 0x3F
556:           #endif
557:           		flag = 0;
0993  01BD     CLRF flag
0994  2999     GOTO 0x199
558:           #if	defined(LEFT) || defined(SPCSIGN) || defined(MANSIGN) || defined(ALTERN) || defined(FILL)
559:           		for(;;) {
560:           			switch(*f) {
0999  0830     MOVF c, W
099A  00FF     MOVWF 0x7F
099B  082F     MOVF f, W
099C  0084     MOVWF FSR
099D  160A     BSF PCLATH, 0x4
099E  158A     BSF PCLATH, 0x3
099F  2000     CALL 0x0
09A0  120A     BCF PCLATH, 0x4
09A1  158A     BSF PCLATH, 0x3
09A2  3A30     XORLW 0x30
09A3  1903     BTFSC STATUS, 0x2
09A4  2995     GOTO 0x195
09A5  29A6     GOTO 0x1A6
561:           #ifdef	LEFT
562:           			case '-':
563:           				flag |= LEFT;
564:           				f++;
565:           				continue;
566:           #endif
567:           
568:           #ifdef	SPCSIGN
569:           			case ' ':
570:           				flag |= SPCSIGN;
571:           				f++;
572:           				continue;
573:           #endif
574:           
575:           #ifdef	MANSIGN
576:           			case '+':
577:           				flag |= MANSIGN;
578:           				f++;
579:           				continue;
580:           #endif
581:           #ifdef	ALTERN
582:           			case '#':
583:           				flag |= ALTERN;
584:           				f++;
585:           				continue;
586:           #endif
587:           #ifdef	FILL
588:           			case '0':
589:           				flag |= FILL;
0995  153D     BSF flag, 0x2
590:           				f++;
0996  0AAF     INCF f, F
0997  1903     BTFSC STATUS, 0x2
0998  0AB0     INCF c, F
591:           				continue;
592:           #endif
593:           			}
594:           			break;
595:           		}
596:           #endif
597:           #if	defined(MANSIGN) && defined(SPCSIGN)
598:           		if(flag & MANSIGN)
599:           			flag &= ~SPCSIGN;
600:           #endif
601:           #if	defined(LEFT) && defined(FILL)
602:           		if(flag & LEFT)
603:           			flag &= ~FILL;
604:           #endif
605:           #ifdef	WIDTH
606:           		if(isdigit((unsigned)*f)) {
09A6  0830     MOVF c, W
09A7  00FF     MOVWF 0x7F
09A8  082F     MOVF f, W
09A9  0084     MOVWF FSR
09AA  160A     BSF PCLATH, 0x4
09AB  158A     BSF PCLATH, 0x3
09AC  2000     CALL 0x0
09AD  120A     BCF PCLATH, 0x4
09AE  158A     BSF PCLATH, 0x3
09AF  23EE     CALL 0x3EE
09B0  120A     BCF PCLATH, 0x4
09B1  158A     BSF PCLATH, 0x3
09B2  1C03     BTFSS STATUS, 0x0
09B3  2A54     GOTO 0x254
607:           			width = 0;
09B4  01BE     CLRF width
09B5  01BF     CLRF 0x3F
608:           			do {
609:           				width *= 10;
09B6  300A     MOVLW 0xA
09B7  00A3     MOVWF x
09B8  01A4     CLRF dato
09B9  083F     MOVF 0x3F, W
09BA  00A6     MOVWF x
09BB  083E     MOVF width, W
09BC  00A5     MOVWF y
09BD  2420     CALL 0x420
09BE  0824     MOVF dato, W
09BF  00BF     MOVWF 0x3F
09C0  0823     MOVF x, W
09C1  00BE     MOVWF width
610:           			   	width += *f++ - '0';
09C2  0830     MOVF c, W
09C3  00FF     MOVWF 0x7F
09C4  082F     MOVF f, W
09C5  0084     MOVWF FSR
09C6  160A     BSF PCLATH, 0x4
09C7  158A     BSF PCLATH, 0x3
09C8  2000     CALL 0x0
09C9  120A     BCF PCLATH, 0x4
09CA  158A     BSF PCLATH, 0x3
09CB  3ED0     ADDLW 0xD0
09CC  00B7     MOVWF f2
09CD  30FF     MOVLW 0xFF
09CE  1803     BTFSC STATUS, 0x0
09CF  3000     MOVLW 0x0
09D0  00B8     MOVWF 0x38
09D1  0837     MOVF f2, W
09D2  07BE     ADDWF width, F
09D3  1803     BTFSC STATUS, 0x0
09D4  0ABF     INCF 0x3F, F
09D5  0838     MOVF 0x38, W
09D6  07BF     ADDWF 0x3F, F
09D7  0AAF     INCF f, F
09D8  1903     BTFSC STATUS, 0x2
09D9  0AB0     INCF c, F
611:           			} while(isdigit((unsigned)*f));
09DA  0830     MOVF c, W
09DB  00FF     MOVWF 0x7F
09DC  082F     MOVF f, W
09DD  0084     MOVWF FSR
09DE  160A     BSF PCLATH, 0x4
09DF  158A     BSF PCLATH, 0x3
09E0  2000     CALL 0x0
09E1  120A     BCF PCLATH, 0x4
09E2  158A     BSF PCLATH, 0x3
09E3  23EE     CALL 0x3EE
09E4  120A     BCF PCLATH, 0x4
09E5  158A     BSF PCLATH, 0x3
09E6  1C03     BTFSS STATUS, 0x0
09E7  2A54     GOTO 0x254
09E8  29B6     GOTO 0x1B6
612:           #ifdef	STAR
613:           		} else if(*f == '*') {
614:           			width = va_arg(ap, int);
615:           			f++;
616:           #endif
617:           		}
618:           #endif
619:           #ifdef	PRECISION
620:           		if(*f == '.') {
621:           			flag |= PRECISION;
622:           			f++;
623:           #ifdef	STAR
624:           			if(*f == '*') {
625:           				prec = va_arg(ap, int);
626:           				f++;
627:           			} else
628:           #endif
629:           			{
630:           				prec = 0;
631:           				while(isdigit((unsigned)*f))
632:           					prec = prec*10 + *f++ - '0';
633:           			}
634:           		} else {
635:           			prec = 0;
636:           #ifdef	DEFPREC
637:           			flag |= DEFPREC;
638:           #endif	// DEFPREC
639:           		}
640:           #endif	// PRECISION
641:           #if	defined(__LONG) && defined(LONG)
642:           loop:
643:           #endif
644:           		switch(c = *f++) {
0A54  0830     MOVF c, W
0A55  00B8     MOVWF 0x38
0A56  082F     MOVF f, W
0A57  00B7     MOVWF f2
0A58  0AAF     INCF f, F
0A59  1903     BTFSC STATUS, 0x2
0A5A  0AB0     INCF c, F
0A5B  0838     MOVF 0x38, W
0A5C  00FF     MOVWF 0x7F
0A5D  0837     MOVF f2, W
0A5E  0084     MOVWF FSR
0A5F  160A     BSF PCLATH, 0x4
0A60  158A     BSF PCLATH, 0x3
0A61  2000     CALL 0x0
0A62  120A     BCF PCLATH, 0x4
0A63  158A     BSF PCLATH, 0x3
0A64  00C0     MOVWF c
0A65  3A00     XORLW 0x0
0A66  1903     BTFSC STATUS, 0x2
0A67  2BBF     GOTO 0x3BF
0A68  3A58     XORLW 0x58
0A69  1903     BTFSC STATUS, 0x2
0A6A  29E9     GOTO 0x1E9
0A6B  3A3C     XORLW 0x3C
0A6C  1903     BTFSC STATUS, 0x2
0A6D  2A7B     GOTO 0x27B
0A6E  3A0D     XORLW 0xD
0A6F  1903     BTFSC STATUS, 0x2
0A70  2A7B     GOTO 0x27B
0A71  3A1A     XORLW 0x1A
0A72  1903     BTFSC STATUS, 0x2
0A73  29EB     GOTO 0x1EB
0A74  3A06     XORLW 0x6
0A75  1903     BTFSC STATUS, 0x2
0A76  2A51     GOTO 0x251
0A77  3A0D     XORLW 0xD
0A78  1903     BTFSC STATUS, 0x2
0A79  29E9     GOTO 0x1E9
0A7A  2972     GOTO 0x172
645:           
646:           		case 0:
647:           			goto alldone;
648:           
649:           #ifdef	LONG
650:           		case 'l':
651:           #ifdef	__LONG
652:           			flag |= LONG;
653:           			goto loop;
654:           #else
655:           			cp = "(non-long printf)";
656:           			goto strings;
657:           #endif
658:           #endif
659:           
660:           #ifdef	FLOATFORMAT
661:           #ifndef	__FLOAT
662:           		case 'E':
663:           		case 'f':
664:           		case 'e':
665:           		case 'G':
666:           		case 'g':
667:           			cp = "(non-float printf)";
668:           			goto strings;
669:           #else
670:           #ifdef	FFMT
671:           		case 'f':
672:           			flag |= FFMT;
673:           			break;
674:           #endif
675:           
676:           #ifdef	EFMT
677:           #ifdef	UPCASE
678:           		case 'E':
679:           			flag |= UPCASE;
680:           #endif
681:           		case 'e':
682:           			flag |= EFMT;
683:           			break;
684:           #endif
685:           
686:           #ifdef	GFMT
687:           #ifdef	UPCASE
688:           		case 'G':
689:           			flag |= UPCASE;
690:           #endif
691:           		case 'g':
692:           			flag |= GFMT;
693:           			break;
694:           #endif	// GFMT
695:           #endif
696:           #endif	// FLOATFORMAT
697:           #ifdef	EIGHT
698:           		case 'o':
699:           #ifdef	MULTRAD
700:           			flag |= EIGHT;
701:           #endif
702:           			break;
703:           #endif
704:           
705:           #ifdef	TEN
706:           		case 'd':
707:           		case 'i':
708:           			break;
709:           #endif
710:           
711:           #ifdef	POINTER
712:           		case 'p':
713:           #if	i8086 && LARGE_DATA
714:           			flag |= LONG;
715:           #elif	_PIC18 && LARGE_DATA
716:           			flag |= POINTER;
717:           #endif
718:           #endif	// POINTER
719:           #ifdef	SIXTEEN
720:           #ifdef	HEXUPCASE
721:           		case 'X':
722:           #ifdef	UPCASE
723:           			flag |= UPCASE;
724:           #endif
725:           #endif
726:           #if	defined(HEXLOWCASE) || !defined(UPCASE)
727:           		case 'x':
728:           #endif
729:           #ifdef	MULTRAD
730:           			flag |= SIXTEEN;
09E9  17BD     BSF flag, 0x7
731:           #endif
732:           			break;
09EA  2A7B     GOTO 0x27B
733:           #endif	// SIXTEEN
734:           
735:           #if	defined(STRING) || defined(PERCPERC)
736:           #ifdef	STRING
737:           		case 's':
738:           #if	i8086 && SMALL_DATA
739:           			if(flag & LONG)
740:           				cp = va_arg(ap, far char *);
741:           			else
742:           #endif
743:           				cp = va_arg(ap, const char *);
09EB  083C     MOVF ap, W
09EC  0084     MOVWF FSR
09ED  1383     BCF STATUS, 0x7
09EE  0800     MOVF INDF, W
09EF  00C1     MOVWF _val
09F0  0A84     INCF FSR, F
09F1  0800     MOVF INDF, W
09F2  00C2     MOVWF 0x42
09F3  0ABC     INCF ap, F
09F4  0ABC     INCF ap, F
744:           #endif	// STRING
745:           #if	!defined(__FLOAT) && !defined(CUSTOM_PRINTF)
746:           strings:
747:           #endif
748:           #ifdef	STRING
749:           			if(!cp)
09F5  0441     IORWF _val, W
09F6  1D03     BTFSS STATUS, 0x2
09F7  29FC     GOTO 0x1FC
750:           				cp = "(null)";
09F8  306B     MOVLW 0x6B
09F9  00C1     MOVWF _val
09FA  3099     MOVLW 0x99
09FB  00C2     MOVWF 0x42
751:           #endif
752:           #if	defined(WIDTH) || defined(PRECISION)
753:           #if	defined(STRING)
754:           			len = 0;
09FC  01C3     CLRF 0x43
09FD  01C4     CLRF 0x44
755:           			while(cp[len])
09FE  0843     MOVF 0x43, W
09FF  0741     ADDWF _val, W
0A00  0084     MOVWF FSR
0A01  0842     MOVF 0x42, W
0A02  1803     BTFSC STATUS, 0x0
0A03  0A42     INCF 0x42, W
0A04  00FF     MOVWF 0x7F
0A05  160A     BSF PCLATH, 0x4
0A06  158A     BSF PCLATH, 0x3
0A07  2000     CALL 0x0
0A08  120A     BCF PCLATH, 0x4
0A09  158A     BSF PCLATH, 0x3
0A0A  3800     IORLW 0x0
0A0B  1903     BTFSC STATUS, 0x2
0A0C  2A11     GOTO 0x211
0A10  29FE     GOTO 0x1FE
756:           				len++;
0A0D  0AC3     INCF 0x43, F
0A0E  1903     BTFSC STATUS, 0x2
0A0F  0AC4     INCF 0x44, F
757:           #endif
758:           #ifdef	PERCPERC
759:           dostring:
760:           #endif
761:           #ifdef	PRECISION
762:           			if(prec && prec < len)
763:           				len = prec;
764:           #endif	// PRECISION
765:           #ifdef	WIDTH
766:           			if(width > len)
0A11  083F     MOVF 0x3F, W
0A12  0244     SUBWF 0x44, W
0A13  1D03     BTFSS STATUS, 0x2
0A14  2A17     GOTO 0x217
0A15  083E     MOVF width, W
0A16  0243     SUBWF 0x43, W
0A17  1803     BTFSC STATUS, 0x0
0A18  2A20     GOTO 0x220
767:           				width -= len;
0A19  0843     MOVF 0x43, W
0A1A  02BE     SUBWF width, F
0A1B  0844     MOVF 0x44, W
0A1C  1C03     BTFSS STATUS, 0x0
0A1D  03BF     DECF 0x3F, F
0A1E  02BF     SUBWF 0x3F, F
0A1F  2A22     GOTO 0x222
768:           			else
769:           				width = 0;
0A20  01BE     CLRF width
0A21  01BF     CLRF 0x3F
770:           #ifdef	LEFT
771:           			if(!(flag & LEFT))
772:           #endif	// LEFT
773:           				while(width--)
0A22  30FF     MOVLW 0xFF
0A23  07BE     ADDWF width, F
0A24  1C03     BTFSS STATUS, 0x0
0A25  03BF     DECF 0x3F, F
0A26  0A3E     INCF width, W
0A27  1903     BTFSC STATUS, 0x2
0A28  0A3F     INCF 0x3F, W
0A29  1903     BTFSC STATUS, 0x2
0A2A  2A45     GOTO 0x245
0A31  2A22     GOTO 0x222
774:           					pputc(' ');
0A2B  0845     MOVF sp, W
0A2C  0084     MOVWF FSR
0A2D  3020     MOVLW 0x20
0A2E  1383     BCF STATUS, 0x7
0A2F  0080     MOVWF INDF
0A30  0AC5     INCF sp, F
775:           #endif	// WIDTH
776:           			while(len--)
0A45  3001     MOVLW 0x1
0A46  02C3     SUBWF 0x43, F
0A47  3000     MOVLW 0x0
0A48  1C03     BTFSS STATUS, 0x0
0A49  03C4     DECF 0x44, F
0A4A  02C4     SUBWF 0x44, F
0A4B  0A43     INCF 0x43, W
0A4C  1903     BTFSC STATUS, 0x2
0A4D  0A44     INCF 0x44, W
0A4E  1903     BTFSC STATUS, 0x2
0A4F  2972     GOTO 0x172
0A50  2A32     GOTO 0x232
777:           				pputc(*cp++);
0A32  0842     MOVF 0x42, W
0A33  00FF     MOVWF 0x7F
0A34  0841     MOVF _val, W
0A35  0084     MOVWF FSR
0A36  160A     BSF PCLATH, 0x4
0A37  158A     BSF PCLATH, 0x3
0A38  2000     CALL 0x0
0A39  120A     BCF PCLATH, 0x4
0A3A  158A     BSF PCLATH, 0x3
0A3B  00B7     MOVWF f2
0A3C  0845     MOVF sp, W
0A3D  0084     MOVWF FSR
0A3E  0837     MOVF f2, W
0A3F  1383     BCF STATUS, 0x7
0A40  0080     MOVWF INDF
0A41  0AC1     INCF _val, F
0A42  1903     BTFSC STATUS, 0x2
0A43  0AC2     INCF 0x42, F
0A44  0AC5     INCF sp, F
778:           #ifdef	LEFT
779:           			if(flag & LEFT)
780:           				while(width--)
781:           					pputc(' ');
782:           #endif	// LEFT
783:           			continue;
784:           #else	// WIDTH || PRECISION
785:           #if	defined(STRING)
786:           			while(*cp)
787:           				pputc(*cp++);
788:           			continue;
789:           #endif
790:           #endif	// WIDTH || PRECISION
791:           #endif	// defined(STRING) || defined(PERCPERC)
792:           #ifdef	CHAR
793:           		case 'c':
794:           #if	_HOSTED
795:           			val = va_arg(ap, int);
796:           			c = val >> 8;
797:           			if(flag & LONG && c && (unsigned char)c != 0xFF) {
798:           				cbuf[0] = c;
799:           				cbuf[1] = val;
800:           				len = 2;
801:           			} else {
802:           				cbuf[0] = val;
803:           				len = 1;
804:           			}
805:           			cp = cbuf;
806:           			goto dostring;
807:           #else
808:           			c = va_arg(ap, int);
809:           #endif	// _HOSTED
810:           #endif	// CHAR
811:           		default:
812:           #ifdef	PERCPERC
813:           #if	defined(WIDTH) || defined(PRECISION)
814:           			cp = (char *)&c;
815:           			len = 1;
816:           			goto dostring;
817:           #else
818:           			pputc(c);
819:           			continue;
820:           #endif
821:           #else	// PERCPERC
822:           			continue;
823:           #endif
824:           
825:           #ifdef	UNSIGN
826:           		case 'u':
827:           			flag |= UNSIGN;
0A51  30C0     MOVLW 0xC0
0A52  04BD     IORWF flag, F
828:           			break;
0A53  2A7B     GOTO 0x27B
829:           #endif
830:           
831:           		}
832:           #endif	// ANYFORMAT
833:           #ifdef	__FLOAT
834:           		if(flag & (FLOATFORMAT)) {
835:           #ifdef	DEFPREC
836:           			if(flag & DEFPREC)
837:           #endif
838:           				prec = 6;
839:           			fval = va_arg(ap, double);	// source the floating point value
840:           			if(fval < 0.0) {
841:           				fval = -fval;		// get the absolute value
842:           				flag |= NEGSIGN;
843:           			}
844:           			exp = 0;		/* If the number is zero, the exponent is zero. */
845:           			if( fval!=0) {		/* If the number is non-zero, find the exponent. */
846:           				frexp(fval, &exp);		/* get binary exponent */
847:           				exp--;				/* adjust 0.5 -> 1.0 */
848:           				exp *= 3;
849:           				exp /= 10;			/* estimate decimal exponent */
850:           				if(exp < 0)
851:           					exp--;
852:           				// the following line can cause "recursive call" errors because scale calls
853:           				// ftmul, and is used when evaluating an argument to ftmul
854:           				//integ = fval * scale(-exp);
855:           				integ = scale(-exp);		// replaced with this
856:           				integ *= fval;
857:           				if(integ < 1.0)
858:           					exp--;
859:           				else if(integ >= 10.0)
860:           					exp++;
861:           			}
862:           #if	defined(EFMT) || defined(GFMT)
863:           			if(exp <= 0)	// value is 0.??? (neg expnt) whole characters = 1 (allow zero)
864:           				c = 1;
865:           			else
866:           				c = exp;
867:           			if(
868:           #ifdef	EFMT
869:           					flag & EFMT
870:           #ifdef	GFMT
871:           					||
872:           #endif
873:           #endif
874:           #ifdef	GFMT
875:           					flag & GFMT && (exp < -4 || exp >= (int)prec)
876:           #endif
877:           				) {	/* use e format */
878:           #ifdef	GFMT
879:           				if(prec && flag & GFMT)
880:           					prec--;		/* g format precision includes integer digit */
881:           #endif
882:           				if((unsigned)prec > NDDIG - 2)
883:           					c = NDDIG - 2;
884:           				else
885:           					c = prec;
886:           				if( fval!=0) {	/* Normalise only if the number is non-zero. */
887:           					fval /= scale(exp-c);
888:           #if	DOUBLE
889:           					ival = _dto64i(fval);
890:           					if(fval - _64itod(ival) >= 0.5) {
891:           						fval += 0.5;
892:           						ival = _dto64i(fval);
893:           					}
894:           					if(ival >= fdpowers[c+1]) {
895:           						fval *= 1e-1;
896:           						exp++;
897:           					} else if(ival < fdpowers[c]) {
898:           						fval *= 10.0;
899:           						exp--;
900:           					}
901:           #else	
902:           					if(fval - (double)(unsigned long)fval >= 0.5)
903:           						fval += 0.5;
904:           					if((unsigned long)fval >= fdpowers[c+1]) {
905:           						fval *= 1e-1;
906:           						exp++;
907:           					} else if((unsigned long)fval < fdpowers[c]) {
908:           						fval *= 10.0;
909:           						exp--;
910:           					}
911:           #endif
912:           				}
913:           #if defined(GFMT) && defined(ALTERN)
914:           				if(flag & GFMT && !(flag & ALTERN)) {		/* g format, precision means something different */
915:           					if(prec > (int)(NDDIG))
916:           						prec = NDDIG;
917:           #if	DOUBLE
918:           					ival = _dto64i(fval);
919:           					while(ival != 0.0 && _mod64i10(ival) == 0) {
920:           						prec--;
921:           						ival = _div64(ival, fdpowers[1]);
922:           					}
923:           #else
924:           					val = (unsigned long)fval;
925:           					while(val && val % 10 == 0) {
926:           						prec--;
927:           						val /= 10;
928:           					}
929:           #endif
930:           					if(prec < c) {
931:           						fval /= scale(c-prec);
932:           						c = prec;
933:           					}
934:           
935:           				}
936:           #endif
937:           #ifdef	WIDTH
938:           				width -=  prec + 5;
939:           #ifdef	ALTERN
940:           				if(prec || flag & ALTERN)
941:           					width--;
942:           #endif
943:           				if(flag & NEGSIGN)
944:           					width--;
945:           #if	DBL_MAX_10_EXP >= 100
946:           #if	DBL_MAX_10_EXP >= 1000
947:           				if(exp >= 1000 || exp <= -1000)	/* 4 digit exponent */
948:           					width--;
949:           #endif
950:           				if(exp >= 100 || exp <= -100)	/* 3 digit exponent */
951:           					width--;
952:           #endif
953:           #endif	// WIDTH
954:           #ifdef	FILL
955:           				if(flag & FILL) {
956:           #if defined(MANSIGN) && defined(SPCSIGN)
957:           					if(flag & MANSIGN)
958:           						pputc(flag & SPCSIGN ? '-' : '+');
959:           					else if(flag & SPCSIGN)
960:           						pputc(' ');
961:           #endif
962:           					while(width > 0) {
963:           						pputc('0');
964:           						width--;
965:           					}
966:           				} else
967:           #endif	// FILL
968:           				{
969:           #ifdef	WIDTH
970:           #ifdef	LEFT
971:           					if(!(flag & LEFT))
972:           #endif
973:           						while(width > 0) {
974:           							pputc(' ');
975:           							width--;
976:           						}
977:           #endif	// WIDTH
978:           #ifdef	MANSIGN
979:           					if(flag & MANSIGN)
980:           						putsign();
981:           #else
982:           					if(flag & NEGSIGN)
983:           						pputc('-');
984:           #endif	// MANSIGN
985:           #ifdef	SPCSIGN
986:           					else if(flag & SPCSIGN)
987:           						pputc(' ');
988:           #endif	// SPCSIGN
989:           				}
990:           #if	DOUBLE
991:           				ival = _dto64i(fval);
992:           				pputc(_div64ir(ival, fdpowers[c]) + '0');
993:           #else
994:           				val = (unsigned long)fval;
995:           				pputc(val/dpowers[c] + '0');
996:           				val %= dpowers[c];
997:           #endif
998:           #ifdef	ALTERN
999:           				if(prec || flag & ALTERN)
1000:          #else
1001:          				if(prec)
1002:          #endif
1003:          				{
1004:          					pputc('.');
1005:          					prec -= c;
1006:          					while(c--) {
1007:          #if	DOUBLE
1008:          						pputc('0' + _mod64i10(_div64(ival, fdpowers[c])));
1009:          #else
1010:          #ifdef	GFMT
1011:          						if(flag & GFMT && val == 0) {
1012:          							prec = c = 0;
1013:          							break;
1014:          						}
1015:          #endif
1016:          						pputc('0' + (val/dpowers[c]));
1017:          						val %= dpowers[c];
1018:          #endif
1019:          					}
1020:          					while(prec) {
1021:          						pputc('0');
1022:          						prec--;
1023:          					}
1024:          				}
1025:          #ifdef	UPCASE
1026:          				if(flag & UPCASE)
1027:          					pputc('E');
1028:          				else
1029:          #endif
1030:          					pputc('e');
1031:          				if(exp < 0) {
1032:          					exp = -exp;
1033:          					pputc('-');
1034:          				} else
1035:          					pputc('+');
1036:          #if	DBL_MAX_10_EXP >= 100
1037:          #if	DBL_MAX_10_EXP >= 1000
1038:          				if(exp >= 1000) {
1039:          					pputc(exp / 1000 + '0');
1040:          					exp %= 1000;
1041:          				}
1042:          #endif
1043:          				if(exp >= 100) {
1044:          					pputc(exp / 100 + '0');
1045:          					exp %= 100;
1046:          				}
1047:          #endif
1048:          				pputc(exp / 10 + '0');
1049:          				pputc(exp % 10 + '0');
1050:          #ifdef	LEFT
1051:          				if((flag & LEFT) && width > 0)
1052:          					do
1053:          						pputc(' ');
1054:          					while(--width);
1055:          #endif	// LEFT
1056:          					continue;
1057:          				}
1058:          #endif	// EFMT || GFMT
1059:          				/* here for f format */
1060:          #if	DOUBLE
1061:          #ifdef	GFMT
1062:          				if(flag & GFMT) {
1063:          					if(exp < 0)	// fractional part only
1064:          						prec -= exp-1;
1065:          					ival = _dto64i(fval);
1066:          					for(c = 1 ; c != NDDIG ; c++)
1067:          						if(ival < fdpowers[c])
1068:          							break;
1069:          					if(prec > NDDIG)
1070:          						prec = NDDIG;
1071:          					prec -= c;
1072:          					ival = _dto64i((fval - _64itod(ival)) * scale(prec)+0.5);
1073:          					// see how many zeros are at the end of the fractional part
1074:          					while(prec && _mod64i10(ival) == 0) {
1075:          						prec--;
1076:          						ival = _div64(ival, fdpowers[1]);
1077:          					}
1078:          				}
1079:          #endif	// GFMT
1080:          				if(prec <= (int)NDDIG)
1081:          					fval += fround(prec);
1082:          				if(exp > (int)(NDDIG)-2) {
1083:          					exp -= NDDIG-2;
1084:          					ival = _divto64i(fval, scale(exp));
1085:          					fval = 0.0;
1086:          				} else {
1087:          					ival = _dto64i(fval);
1088:          					fval -= _64itod(ival);
1089:          					exp = 0;
1090:          				}
1091:          				for(c = 1 ; c != NDDIG ; c++)
1092:          					if(ival < fdpowers[c])
1093:          						break;
1094:          #else	// DOUBLE
1095:          #ifdef	GFMT
1096:          				if(flag & GFMT) {
1097:          					if(exp < 0)	// fractional part only
1098:          						prec -= (exp+1);
1099:          					// count number of digits in the integral part (this is for %g)
1100:          					val = (unsigned long)fval;
1101:          					for(c = 0 ; c != NDDIG ; c++)
1102:          						if(val < fdpowers[c])
1103:          							break;
1104:          					prec -= c;		// reduce precision by this
1105:          					if(prec <= NDIG)
1106:          						fval += fround(prec);
1107:          					// get fractional part and count trailing zeros - reduce
1108:          					// prec as required
1109:          					{
1110:          						double	temp;
1111:          						temp = scale(prec);
1112:          						temp *= fval - (double)val;
1113:          						val = (unsigned long)temp;
1114:          					}
1115:          					while(prec && val % 10 == 0) {
1116:          						val /= 10;
1117:          						prec--;
1118:          					}
1119:          				} else
1120:          #endif	//GFMT
1121:          					if(prec <= NDIG)
1122:          						fval += fround(prec);
1123:          
1124:          				/* ~4.2e9 is the largest float that will fit into a 32-bit long */
1125:          				if((exp > 9)||(fval != 0 && (unsigned long)fval == 0 && exp > 1)) {
1126:          					// fval is > 4.2e9
1127:          					// new exp must be such that div_to_l() is < 4.2e9
1128:          					// OLD CODE:	if(fval / scale(exp) < 4.294967296){
1129:          					if(integ < 4.294967296){
1130:          						exp -= NDDIG-1;
1131:          					}else{
1132:          						exp -= NDDIG-2;
1133:          					}
1134:          					integ = scale(exp);
1135:          					val = div_to_l_(fval, integ);
1136:           					//val = _div_to_l_(integ, fval);
1137:          					//val = (long)(integ * fval);	// fit as much signifigant data into the long as it can hold
1138:          					fval = 0.0;	// There will be no fractional component
1139:          				} else {
1140:          					val = (unsigned long)fval;
1141:          					fval -= (double)val;
1142:          					exp = 0;
1143:          				}
1144:          				// count digits in integral part
1145:          				for(c = 1 ; c != NDDIG ; c++)
1146:          					if(val < fdpowers[c])
1147:          						break;
1148:          #endif	// DOUBLE
1149:          #ifdef	WIDTH
1150:          				// at this point, c contains the number of whole-number digits to print
1151:          				width -= prec + c + exp;
1152:          				if(
1153:          #ifdef	ALTERN
1154:          						flag & ALTERN ||
1155:          #endif
1156:          						prec)
1157:          					width--;		// allow for decimal point
1158:          				if(flag & NEGSIGN)
1159:          					width--;
1160:          #endif	// WIDTH
1161:          #ifdef	FILL
1162:          				if(flag & FILL) {
1163:          #ifdef	MANSIGN
1164:          					if(flag & MANSIGN)
1165:          #else
1166:          					if(flag & NEGSIGN)
1167:          #endif	// MANSIGN
1168:          						putsign();
1169:          #if defined(MANSIGN) && defined(SPCSIGN)
1170:          					else
1171:          #endif
1172:          #ifdef	SPCSIGN
1173:          					if(flag & SPCSIGN)
1174:          						pputc(' ');
1175:          #endif	// SPCSIGN
1176:          #ifdef	WIDTH
1177:          					while(width > 0) {
1178:          						pputc('0');
1179:          						width--;
1180:          					}
1181:          #endif	// WIDTH
1182:          				} else
1183:          #endif	// FILL
1184:          				{
1185:          #ifdef	LEFT
1186:          					if(!(flag & LEFT))
1187:          #endif
1188:          #ifdef	WIDTH
1189:          					while(width > 0) {
1190:          						pputc(' ');
1191:          						width--;
1192:          					}
1193:          #endif	// WIDTH
1194:          #ifdef	MANSIGN
1195:          				if(flag & MANSIGN)
1196:          #else
1197:          				if(flag & NEGSIGN)
1198:          #endif	// MANSIGN
1199:          					putsign();
1200:          #ifdef	SPCSIGN
1201:          				else if(flag & SPCSIGN)
1202:          					pputc(' ');
1203:          #endif	// SPCSIGN
1204:          			}
1205:          			while(c--) {
1206:          #if	DOUBLE
1207:          				pputc('0' + _mod64i10(_div64(ival, fdpowers[c])));
1208:          #else
1209:          				{
1210:          					unsigned long vd = val/dpowers[c];
1211:          					vd %= 10;
1212:          					pputc('0' + vd);
1213:          				}
1214:          #endif	// DOUBLE
1215:          			}
1216:          			while(exp > 0) {
1217:          				pputc('0');
1218:          				exp--;
1219:          			}
1220:          			if(prec > (int)(NDDIG-2))
1221:          				c = NDDIG-2;
1222:          			else
1223:          				c = prec;
1224:          			prec -= c;
1225:          #ifdef	ALTERN
1226:          			if(c || flag & ALTERN)
1227:          #else
1228:          			if(c)
1229:          #endif
1230:          				pputc('.');
1231:          #if	DOUBLE
1232:          			ival = _dto64i(fval * scale(c));
1233:          			while(c)
1234:          				pputc('0' + _mod64i10(_div64(ival, fdpowers[--c])));
1235:          #else	// DOUBLE
1236:          			val = (long)(fval * scale(c));
1237:          			while(c--) {
1238:          				unsigned long vd = val/dpowers[c];
1239:          				vd %= 10;
1240:          				pputc('0' + vd);
1241:          				val %= dpowers[c];
1242:          			}
1243:          #endif	// DOUBLE
1244:          			while(prec) {
1245:          				pputc('0');
1246:          				prec--;
1247:          			}
1248:          #ifdef	LEFT
1249:          			if((flag & LEFT) && width > 0)
1250:          				do
1251:          					pputc(' ');
1252:          				while(--width);
1253:          #endif
1254:          			continue;
1255:          		}
1256:          #endif	/* __FLOAT */
1257:          
1258:          #if	defined(TEN)
1259:          #ifdef	BASEM
1260:          		if((flag & BASEM) == TEN)
0A7B  083D     MOVF flag, W
0A7C  39C0     ANDLW 0xC0
0A7D  1D03     BTFSS STATUS, 0x2
0A7E  2A93     GOTO 0x293
1261:          #endif	//BASEM
1262:          		{
1263:          #ifdef	LONG
1264:          			if(flag & LONG)
1265:          				val = va_arg(ap, long);
1266:          			else
1267:          #endif	// LONG
1268:          				val = (value)va_arg(ap, int);
0A7F  083C     MOVF ap, W
0A80  0084     MOVWF FSR
0A81  1383     BCF STATUS, 0x7
0A82  0800     MOVF INDF, W
0A83  00C1     MOVWF _val
0A84  0A84     INCF FSR, F
0A85  0800     MOVF INDF, W
0A86  00C2     MOVWF 0x42
0A87  0ABC     INCF ap, F
0A88  0ABC     INCF ap, F
1269:          #ifdef	NEGSIGN
1270:          			if((value)val < 0) {
0A89  1FC2     BTFSS 0x42, 0x7
0A8A  2AE4     GOTO 0x2E4
1271:          				flag |= NEGSIGN;
0A8B  3003     MOVLW 0x3
0A8C  04BD     IORWF flag, F
1272:          				val = -val;
0A8D  09C1     COMF _val, F
0A8E  09C2     COMF 0x42, F
0A8F  0AC1     INCF _val, F
0A90  1903     BTFSC STATUS, 0x2
0A91  0AC2     INCF 0x42, F
0A92  2AE4     GOTO 0x2E4
1273:          			}
1274:          #endif
1275:          		}
1276:          #ifdef	BASEM
1277:          		else
1278:          #endif
1279:          #endif	// TEN
1280:          
1281:          #if	defined(EIGHT) || defined(SIXTEEN) || defined(UNSIGN)
1282:          		{
1283:          #ifdef	__LONG
1284:          #if	defined(_PIC18) && defined(LARGE_DATA) && defined(POINTER)
1285:          			if(flag & POINTER)
1286:          				val = (unsigned long)va_arg(ap, far char *);
1287:          			else
1288:          #endif
1289:          #ifdef	LONG
1290:          				if(flag & LONG)
1291:          				val = va_arg(ap, unsigned long);
1292:          			else
1293:          #endif	// LONG
1294:          #endif	// __LONG
1295:          				val = va_arg(ap, unsigned);
0A93  083C     MOVF ap, W
0A94  0084     MOVWF FSR
0A95  1383     BCF STATUS, 0x7
0A96  0800     MOVF INDF, W
0A97  00C1     MOVWF _val
0A98  0A84     INCF FSR, F
0A99  0800     MOVF INDF, W
0A9A  00C2     MOVWF 0x42
0A9B  0ABC     INCF ap, F
0A9C  0ABC     INCF ap, F
0A9D  2AE4     GOTO 0x2E4
1296:          		}
1297:          #endif	// EIGHT or SIXTEEN or UNSIGN
1298:          #ifdef	PRECISION
1299:          		if(prec == 0 && val == 0)
1300:          			prec++;
1301:          #endif
1302:          #ifdef	MULTRAD
1303:          		switch((unsigned char)(flag & BASEM)) {
0AE4  083D     MOVF flag, W
0AE5  39C0     ANDLW 0xC0
0AE6  1903     BTFSC STATUS, 0x2
0AE7  2A9E     GOTO 0x29E
0AE8  3A80     XORLW 0x80
0AE9  1903     BTFSC STATUS, 0x2
0AEA  2AC1     GOTO 0x2C1
0AEB  3A40     XORLW 0x40
0AEC  1903     BTFSC STATUS, 0x2
0AED  2A9E     GOTO 0x29E
0AEE  2AEF     GOTO 0x2EF
1304:          #endif
1305:          #if	defined(TEN) || defined(UNSIGN)
1306:          #ifdef	MULTRAD
1307:          #ifdef	TEN
1308:          		case TEN:
1309:          #endif
1310:          #ifdef	UNSIGN
1311:          		case UNSIGN:
1312:          #endif
1313:          #endif	// MULTRAD
1314:          			for(c = 1 ; c != sizeof dpowers/sizeof dpowers[0] ; c++)
0A9E  01C0     CLRF c
0A9F  0AC0     INCF c, F
0ABB  0AC0     INCF c, F
0ABC  0840     MOVF c, W
0ABD  3A05     XORLW 0x5
0ABE  1903     BTFSC STATUS, 0x2
0ABF  2AEF     GOTO 0x2EF
0AC0  2AA0     GOTO 0x2A0
1315:          				if(val < dpowers[c])
0AA0  1003     BCF STATUS, 0x0
0AA1  0D40     RLF c, W
0AA2  3E12     ADDLW 0x12
0AA3  0084     MOVWF FSR
0AA4  3098     MOVLW 0x98
0AA5  1803     BTFSC STATUS, 0x0
0AA6  3E01     ADDLW 0x1
0AA7  00FF     MOVWF 0x7F
0AA8  160A     BSF PCLATH, 0x4
0AA9  158A     BSF PCLATH, 0x3
0AAA  2000     CALL 0x0
0AAB  120A     BCF PCLATH, 0x4
0AAC  158A     BSF PCLATH, 0x3
0AAD  00B7     MOVWF f2
0AAE  160A     BSF PCLATH, 0x4
0AAF  158A     BSF PCLATH, 0x3
0AB0  2000     CALL 0x0
0AB1  120A     BCF PCLATH, 0x4
0AB2  158A     BSF PCLATH, 0x3
0AB3  00B8     MOVWF 0x38
0AB4  0242     SUBWF 0x42, W
0AB5  1D03     BTFSS STATUS, 0x2
0AB6  2AB9     GOTO 0x2B9
0AB7  0837     MOVF f2, W
0AB8  0241     SUBWF _val, W
0AB9  1C03     BTFSS STATUS, 0x0
0ABA  2AEF     GOTO 0x2EF
1316:          					break;
1317:          #ifdef	MULTRAD
1318:          			break;
1319:          #endif
1320:          #endif	// TEN || UNSIGN
1321:          #ifdef	SIXTEEN
1322:          #ifdef	MULTRAD
1323:          		case SIXTEEN:
1324:          #endif	// MULTRAD
1325:          			for(c = 1 ; c != sizeof hexpowers/sizeof hexpowers[0] ; c++)
0AC1  01C0     CLRF c
0AC2  0AC0     INCF c, F
0ADE  0AC0     INCF c, F
0ADF  0840     MOVF c, W
0AE0  3A04     XORLW 0x4
0AE1  1903     BTFSC STATUS, 0x2
0AE2  2AEF     GOTO 0x2EF
0AE3  2AC3     GOTO 0x2C3
1326:          				if(val < hexpowers[c])
0AC3  1003     BCF STATUS, 0x0
0AC4  0D40     RLF c, W
0AC5  3E1C     ADDLW 0x1C
0AC6  0084     MOVWF FSR
0AC7  3098     MOVLW 0x98
0AC8  1803     BTFSC STATUS, 0x0
0AC9  3E01     ADDLW 0x1
0ACA  00FF     MOVWF 0x7F
0ACB  160A     BSF PCLATH, 0x4
0ACC  158A     BSF PCLATH, 0x3
0ACD  2000     CALL 0x0
0ACE  120A     BCF PCLATH, 0x4
0ACF  158A     BSF PCLATH, 0x3
0AD0  00B7     MOVWF f2
0AD1  160A     BSF PCLATH, 0x4
0AD2  158A     BSF PCLATH, 0x3
0AD3  2000     CALL 0x0
0AD4  120A     BCF PCLATH, 0x4
0AD5  158A     BSF PCLATH, 0x3
0AD6  00B8     MOVWF 0x38
0AD7  0242     SUBWF 0x42, W
0AD8  1D03     BTFSS STATUS, 0x2
0AD9  2ADC     GOTO 0x2DC
0ADA  0837     MOVF f2, W
0ADB  0241     SUBWF _val, W
0ADC  1C03     BTFSS STATUS, 0x0
0ADD  2AEF     GOTO 0x2EF
1327:          					break;
1328:          #ifdef	MULTRAD
1329:          			break;
1330:          #endif
1331:          #endif
1332:          
1333:          #ifdef	EIGHT
1334:          #ifdef	MULTRAD
1335:          		case EIGHT:
1336:          #endif	// MULTRAD
1337:          			for(c = 1 ; c != sizeof octpowers/sizeof octpowers[0] ; c++)
1338:          				if(val < octpowers[c])
1339:          					break;
1340:          #ifdef	MULTRAD
1341:          			break;
1342:          #endif
1343:          #endif
1344:          #ifdef	MULTRAD
1345:          		}
1346:          #endif
1347:          #ifdef	PRECISION
1348:          		if(c < prec)
1349:          			c = prec;
1350:          		else if(prec < c)
1351:          			prec = c;
1352:          #endif
1353:          #if	defined(WIDTH) && defined(NEGSIGN)
1354:          		if(width && flag & NEGSIGN)
0AEF  083F     MOVF 0x3F, W
0AF0  043E     IORWF width, W
0AF1  1903     BTFSC STATUS, 0x2
0AF2  2AFB     GOTO 0x2FB
0AF3  083D     MOVF flag, W
0AF4  3903     ANDLW 0x3
0AF5  1903     BTFSC STATUS, 0x2
0AF6  2AFB     GOTO 0x2FB
1355:          			width--;
0AF7  30FF     MOVLW 0xFF
0AF8  07BE     ADDWF width, F
0AF9  1C03     BTFSS STATUS, 0x0
0AFA  03BF     DECF 0x3F, F
1356:          #ifdef	PRECISION
1357:          		if(flag & PRECISION) {
1358:          			if(width > prec)
1359:          				width -= prec;
1360:          			else
1361:          				width = 0;
1362:          		}
1363:          #endif
1364:          #ifdef	ALTERN
1365:          #ifdef	EIGHT
1366:          		if((flag & (
1367:          #ifdef	FILL
1368:          						FILL|
1369:          #endif
1370:          							BASEM|ALTERN)) == (EIGHT|ALTERN)) {
1371:          			if(width)
1372:          				width--;
1373:          		} else
1374:          #endif	// EIGHT
1375:          #if	defined(SIXTEEN)
1376:          #ifdef	BASEM
1377:          		if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1378:          #else
1379:          		if(flag & ALTERN) {
1380:          #endif
1381:          			if(width > 2)
1382:          				width -= 2;
1383:          			else
1384:          				width = 0;
1385:          		}
1386:          #endif	// SIXTEEN
1387:          #endif	// ALTERN
1388:          #endif	// WIDTH
1389:          #ifdef	WIDTH
1390:          		if(width > c)
0AFB  0840     MOVF c, W
0AFC  00B7     MOVWF f2
0AFD  01B8     CLRF 0x38
0AFE  1BB7     BTFSC f2, 0x7
0AFF  03B8     DECF 0x38, F
0B00  0838     MOVF 0x38, W
0B01  3A80     XORLW 0x80
0B02  00B9     MOVWF 0x39
0B03  083F     MOVF 0x3F, W
0B04  3A80     XORLW 0x80
0B05  0239     SUBWF 0x39, W
0B06  1D03     BTFSS STATUS, 0x2
0B07  2B0A     GOTO 0x30A
0B08  083E     MOVF width, W
0B09  0237     SUBWF f2, W
0B0A  1803     BTFSC STATUS, 0x0
0B0B  2B19     GOTO 0x319
1391:          			width -= c;
0B0C  1283     BCF STATUS, 0x5
0B0D  1303     BCF STATUS, 0x6
0B0E  0840     MOVF c, W
0B0F  00B7     MOVWF f2
0B10  01B8     CLRF 0x38
0B11  1BB7     BTFSC f2, 0x7
0B12  03B8     DECF 0x38, F
0B13  02BE     SUBWF width, F
0B14  0838     MOVF 0x38, W
0B15  1C03     BTFSS STATUS, 0x0
0B16  03BF     DECF 0x3F, F
0B17  02BF     SUBWF 0x3F, F
0B18  2B1D     GOTO 0x31D
1392:          		else
1393:          			width = 0;
0B19  1283     BCF STATUS, 0x5
0B1A  1303     BCF STATUS, 0x6
0B1B  01BE     CLRF width
0B1C  01BF     CLRF 0x3F
1394:          #endif
1395:          #ifdef	FILL
1396:          		if(flag & FILL) {
0B1D  1D3D     BTFSS flag, 0x2
0B1E  2B38     GOTO 0x338
1397:          #ifdef	MANSIGN
1398:          			if(flag & MANSIGN)
1399:          				putsign();
1400:          #elif defined(NEGSIGN)
1401:          			if(flag & NEGSIGN)
0B1F  083D     MOVF flag, W
0B20  3903     ANDLW 0x3
0B21  1903     BTFSC STATUS, 0x2
0B22  2B29     GOTO 0x329
1402:          				pputc('-');
0B23  0845     MOVF sp, W
0B24  0084     MOVWF FSR
0B25  302D     MOVLW 0x2D
0B26  1383     BCF STATUS, 0x7
0B27  0080     MOVWF INDF
0B28  0AC5     INCF sp, F
1403:          #endif
1404:          #if defined(MANSIGN) || defined(NEGSIGN) && defined(SPCSIGN)
1405:          			else
1406:          #endif	// MANSIGN
1407:          #ifdef	SPCSIGN
1408:          			if(flag & SPCSIGN)
1409:          				pputc(' ');
1410:          #endif
1411:          #if defined(ALTERN) && defined(SIXTEEN)
1412:          			else if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1413:          				pputc('0');
1414:          #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
1415:          				pputc(flag & UPCASE ? 'X' : 'x');
1416:          #elif defined(HEXUPCASE)
1417:          				pputc('X');
1418:          #else
1419:          				pputc('x');
1420:          #endif	// HEXUPCASE
1421:          			}
1422:          #endif	// ALTERN
1423:          #ifdef	WIDTH
1424:          			if(width)
0B29  083F     MOVF 0x3F, W
0B2A  043E     IORWF width, W
0B2B  1903     BTFSC STATUS, 0x2
0B2C  2B54     GOTO 0x354
1425:          				do
1426:          					pputc('0');
0B2D  0845     MOVF sp, W
0B2E  0084     MOVWF FSR
0B2F  3030     MOVLW 0x30
0B30  1383     BCF STATUS, 0x7
0B31  0080     MOVWF INDF
0B33  0AC5     INCF sp, F
1427:          				while(--width);
0B32  30FF     MOVLW 0xFF
0B34  07BE     ADDWF width, F
0B35  1C03     BTFSS STATUS, 0x0
0B36  03BF     DECF 0x3F, F
0B37  2B29     GOTO 0x329
1428:          #endif	// WIDTH
1429:          		} else
1430:          #endif	//FILL
1431:          		{
1432:          #ifdef	WIDTH
1433:          			if(width
1434:          #ifdef	LEFT
1435:          					&& !(flag & LEFT)
1436:          #endif
1437:          					)
0B38  083F     MOVF 0x3F, W
0B39  043E     IORWF width, W
0B3A  1903     BTFSC STATUS, 0x2
0B3B  2B4A     GOTO 0x34A
1438:          				do
1439:          					pputc(' ');
0B3C  0845     MOVF sp, W
0B3D  0084     MOVWF FSR
0B3E  3020     MOVLW 0x20
0B3F  1383     BCF STATUS, 0x7
0B40  0080     MOVWF INDF
0B42  0AC5     INCF sp, F
1440:          				while(--width);
0B41  30FF     MOVLW 0xFF
0B43  07BE     ADDWF width, F
0B44  1C03     BTFSS STATUS, 0x0
0B45  03BF     DECF 0x3F, F
0B46  083F     MOVF 0x3F, W
0B47  043E     IORWF width, W
0B48  1D03     BTFSS STATUS, 0x2
0B49  2B3C     GOTO 0x33C
1441:          #endif	// WIDTH
1442:          #ifdef	MANSIGN
1443:          			if(flag & MANSIGN)
1444:          				putsign();
1445:          #else
1446:          #ifdef	NEGSIGN
1447:          			if(flag & NEGSIGN)
0B4A  083D     MOVF flag, W
0B4B  3903     ANDLW 0x3
0B4C  1903     BTFSC STATUS, 0x2
0B4D  2B54     GOTO 0x354
1448:          				pputc('-');
0B4E  0845     MOVF sp, W
0B4F  0084     MOVWF FSR
0B50  302D     MOVLW 0x2D
0B51  1383     BCF STATUS, 0x7
0B52  0080     MOVWF INDF
0B53  0AC5     INCF sp, F
1449:          #endif
1450:          #endif	// MANSIGN
1451:          #ifdef	SPCSIGN
1452:          			else if(flag & SPCSIGN)
1453:          				pputc(' ');
1454:          #endif
1455:          #ifdef	ALTERN
1456:          #ifdef	EIGHT
1457:          			if((flag & (BASEM|ALTERN)) == (EIGHT|ALTERN))
1458:          				pputc('0');
1459:          			else
1460:          #endif	// EIGHT
1461:          #ifdef	SIXTEEN
1462:          #ifdef	BASEM
1463:          			if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1464:          #else
1465:          			if(flag & ALTERN) {
1466:          #endif
1467:          				pputc('0');
1468:          #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
1469:          				pputc(flag & UPCASE ? 'X' : 'x');
1470:          #elif defined(HEXUPCASE)
1471:          				pputc('X');
1472:          #else
1473:          				pputc('x');
1474:          #endif
1475:          			}
1476:          #endif	// SIXTEEN
1477:          #endif	// ALTERN
1478:          		}
1479:          #if	defined(SIXTEEN) || defined(TEN) || defined(EIGHT) || defined(UNSIGN)
1480:          #ifndef	PRECISION
1481:          		prec = c;
0B54  0840     MOVF c, W
0B55  00BB     MOVWF prec
1482:          #endif
1483:          		while(prec--) {
0B56  2BBB     GOTO 0x3BB
0BBB  03BB     DECF prec, F
0BBC  0F3B     INCFSZ prec, W
0BBD  2BAA     GOTO 0x3AA
1484:          #ifdef	MULTRAD
1485:          			switch((unsigned char)(flag & BASEM))
0BAA  083D     MOVF flag, W
0BAB  39C0     ANDLW 0xC0
0BAC  1903     BTFSC STATUS, 0x2
0BAD  2B57     GOTO 0x357
0BAE  3A80     XORLW 0x80
0BAF  1903     BTFSC STATUS, 0x2
0BB0  2B7F     GOTO 0x37F
0BB1  3A40     XORLW 0x40
0BB2  1903     BTFSC STATUS, 0x2
0BB3  2B57     GOTO 0x357
0BB4  2BB5     GOTO 0x3B5
1486:          #endif
1487:          			{
1488:          
1489:          #if	defined(TEN) || defined(UNSIGN)
1490:          #ifdef	MULTRAD
1491:          #ifdef	TEN
1492:          		case TEN:
1493:          #endif
1494:          #ifdef	UNSIGN
1495:          		case UNSIGN:
1496:          #endif
1497:          #endif	// MULTRAD
1498:          				c = (val / dpowers[prec]) % 10 + '0';
0B57  300A     MOVLW 0xA
0B58  00AA     MOVWF Data
0B59  01AB     CLRF day
0B5A  1003     BCF STATUS, 0x0
0B5B  0D3B     RLF prec, W
0B5C  3E12     ADDLW 0x12
0B5D  0084     MOVWF FSR
0B5E  3098     MOVLW 0x98
0B5F  1803     BTFSC STATUS, 0x0
0B60  3E01     ADDLW 0x1
0B61  00FF     MOVWF 0x7F
0B62  160A     BSF PCLATH, 0x4
0B63  158A     BSF PCLATH, 0x3
0B64  2000     CALL 0x0
0B65  120A     BCF PCLATH, 0x4
0B66  158A     BSF PCLATH, 0x3
0B67  00A3     MOVWF x
0B68  160A     BSF PCLATH, 0x4
0B69  158A     BSF PCLATH, 0x3
0B6A  2000     CALL 0x0
0B6B  120A     BCF PCLATH, 0x4
0B6C  158A     BSF PCLATH, 0x3
0B6D  00A4     MOVWF dato
0B6E  0842     MOVF 0x42, W
0B6F  00A6     MOVWF x
0B70  0841     MOVF _val, W
0B71  00A5     MOVWF y
0B72  23C4     CALL 0x3C4
0B73  120A     BCF PCLATH, 0x4
0B74  158A     BSF PCLATH, 0x3
0B75  0824     MOVF dato, W
0B76  00AD     MOVWF 0x2D
0B77  0823     MOVF x, W
0B78  00AC     MOVWF dividend
0B79  23FC     CALL 0x3FC
0B7A  120A     BCF PCLATH, 0x4
0B7B  158A     BSF PCLATH, 0x3
0B7C  082A     MOVF Data, W
0B7D  3E30     ADDLW 0x30
0B7E  2BA8     GOTO 0x3A8
1499:          #ifdef	MULTRAD
1500:          				break;
1501:          #endif
1502:          #endif	// TEN || UNSIGN
1503:          
1504:          #ifdef	SIXTEEN
1505:          #ifdef	MULTRAD
1506:          			case SIXTEEN:
1507:          #endif
1508:          			{
1509:          				unsigned char idx = (val / hexpowers[prec]) & 0xF;
0B7F  0842     MOVF 0x42, W
0B80  00A6     MOVWF x
0B81  0841     MOVF _val, W
0B82  00A5     MOVWF y
0B83  1003     BCF STATUS, 0x0
0B84  0D3B     RLF prec, W
0B85  3E1C     ADDLW 0x1C
0B86  0084     MOVWF FSR
0B87  3098     MOVLW 0x98
0B88  1803     BTFSC STATUS, 0x0
0B89  3E01     ADDLW 0x1
0B8A  00FF     MOVWF 0x7F
0B8B  160A     BSF PCLATH, 0x4
0B8C  158A     BSF PCLATH, 0x3
0B8D  2000     CALL 0x0
0B8E  120A     BCF PCLATH, 0x4
0B8F  158A     BSF PCLATH, 0x3
0B90  00A3     MOVWF x
0B91  160A     BSF PCLATH, 0x4
0B92  158A     BSF PCLATH, 0x3
0B93  2000     CALL 0x0
0B94  120A     BCF PCLATH, 0x4
0B95  158A     BSF PCLATH, 0x3
0B96  00A4     MOVWF dato
0B97  23C4     CALL 0x3C4
0B98  0823     MOVF x, W
0B99  00BA     MOVWF idx
0B9A  300F     MOVLW 0xF
0B9B  05BA     ANDWF idx, F
1510:          #if	defined(HEXLOWCASE) && defined(HEXUPCASE)
1511:          				c = (flag & UPCASE ? "0123456789ABCDEF" : "0123456789abcdef")[idx];
1512:          #elif	defined(HEXUPCASE)
1513:          				c = "0123456789ABCDEF"[idx];
0B9C  083A     MOVF idx, W
0B9D  3E39     ADDLW 0x39
0B9E  0084     MOVWF FSR
0B9F  3098     MOVLW 0x98
0BA0  1803     BTFSC STATUS, 0x0
0BA1  3E01     ADDLW 0x1
0BA2  00FF     MOVWF 0x7F
0BA3  160A     BSF PCLATH, 0x4
0BA4  158A     BSF PCLATH, 0x3
0BA5  2000     CALL 0x0
0BA6  120A     BCF PCLATH, 0x4
0BA7  158A     BSF PCLATH, 0x3
0BA8  00C0     MOVWF c
1514:          #else
1515:          				c = "0123456789abcdef"[idx];
1516:          #endif	//HEXCASE
1517:          			}
1518:          #ifdef	MULTRAD
1519:          				break;
0BA9  2BB5     GOTO 0x3B5
1520:          #endif
1521:          #endif
1522:          
1523:          #ifdef	EIGHT
1524:          #ifdef	MULTRAD
1525:          			case EIGHT:
1526:          #endif	// MULTRAD
1527:          				c = ((val / octpowers[prec]) & 07) + '0';
1528:          #ifdef	MULTRAD
1529:          				break;
1530:          #endif	// MULTRAD
1531:          #endif	// EIGHT
1532:          			}
1533:          			pputc(c);
0BB5  0845     MOVF sp, W
0BB6  0084     MOVWF FSR
0BB7  0840     MOVF c, W
0BB8  1383     BCF STATUS, 0x7
0BB9  0080     MOVWF INDF
0BBA  0AC5     INCF sp, F
1534:          		}
1535:          #endif	// 16 or 10 or 8
1536:          #ifdef	LEFT
1537:          		if((flag & LEFT) && width > 0)
1538:          			do
1539:          				pputc(' ');
1540:          			while(--width);
1541:          #endif	// LEFT
1542:          	}
1543:          #ifdef	ANYFORMAT
1544:          alldone:
1545:          #endif	// ANYFORMAT
1546:          #if	!defined(PRINTF) && (defined(SPRINTF) || defined(VSPRINTF))
1547:          	*sp = 0;
0BBF  0845     MOVF sp, W
0BC0  0084     MOVWF FSR
0BC1  1383     BCF STATUS, 0x7
0BC2  0180     CLRF INDF
1548:          #endif
1549:          	return ccnt;
1550:          }
0BC3  0008     RETURN
1551:          
---  /opt/microchip/xc8/v1.31/sources/common/bmul.c  ----------------------------------------------------
1:             // 8 x 8 bit multiplication with 8 bit result
2:             
3:             unsigned char
4:             __bmul(unsigned char multiplier, unsigned char multiplicand)
17F2  00A5     MOVWF y
5:             {
6:             	unsigned char product;
7:             
8:             	product = 0;
17F3  01A4     CLRF dato
9:             	do {
10:            		if(multiplier & 1)
17F4  0823     MOVF x, W
17F5  1825     BTFSC y, 0x0
11:            			product += multiplicand;
17F4  0823     MOVF x, W
17F6  07A4     ADDWF dato, F
12:            		multiplicand <<= 1;
17F7  1003     BCF STATUS, 0x0
17F8  0DA3     RLF x, F
13:            		multiplier >>= 1;
17F9  1003     BCF STATUS, 0x0
17FA  0CA5     RRF y, F
14:            	} while(multiplier != 0);
17FB  08A5     MOVF y, F
17FC  1D03     BTFSS STATUS, 0x2
17FD  2FF4     GOTO 0x7F4
15:            	return product;
17FE  0824     MOVF dato, W
16:            }
17FF  0008     RETURN
17:            
---  /opt/microchip/xc8/v1.31/sources/common/awmod.c  ---------------------------------------------------
1:             // integer signed unsigned modulus
2:             
3:             signed int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __awmod(signed int divisor, signed int dividend)
7:             #else
8:             __awmod(signed int dividend, signed int divisor)
9:             #endif
10:            {
11:            	unsigned char	counter, sign;
12:            
13:            	sign = 0;
156F  01F5     CLRF Pin
14:            	if(dividend < 0) {
1570  1FF3     BTFSS counter, 0x7
1571  2D79     GOTO 0x579
15:            		dividend = -dividend;
1572  09F2     COMF dividend, F
1573  09F3     COMF counter, F
1574  0AF2     INCF dividend, F
1575  1903     BTFSC STATUS, 0x2
1576  0AF3     INCF counter, F
16:            		sign = 1;
1577  01F5     CLRF Pin
1578  0AF5     INCF Pin, F
17:            	}
18:            	if(divisor < 0)
1579  1FF1     BTFSS canal, 0x7
157A  2D80     GOTO 0x580
19:            		divisor = -divisor;
157B  09F0     COMF divisor, F
157C  09F1     COMF canal, F
157D  0AF0     INCF divisor, F
157E  1903     BTFSC STATUS, 0x2
157F  0AF1     INCF canal, F
20:            	if(divisor != 0) {
1580  0871     MOVF canal, W
1581  0470     IORWF divisor, W
1582  1903     BTFSC STATUS, 0x2
1583  2D9F     GOTO 0x59F
21:            		counter = 1;
1584  01F4     CLRF counter
22:            		while(((unsigned int)divisor & 0x8000U) == 0) {
1586  1BF1     BTFSC canal, 0x7
1587  2D8C     GOTO 0x58C
158B  2D85     GOTO 0x585
23:            			divisor <<= 1;
1585  0AF4     INCF counter, F
1588  1003     BCF STATUS, 0x0
1589  0DF0     RLF divisor, F
158A  0DF1     RLF canal, F
24:            			counter++;
1585  0AF4     INCF counter, F
25:            		}
26:            		do {
27:            			if((unsigned int)divisor <= (unsigned int)dividend)
158C  0871     MOVF canal, W
158D  0273     SUBWF counter, W
158E  1D03     BTFSS STATUS, 0x2
158F  2D92     GOTO 0x592
1590  0870     MOVF divisor, W
1591  0272     SUBWF dividend, W
1592  1C03     BTFSS STATUS, 0x0
1593  2D9B     GOTO 0x59B
28:            				dividend -= divisor;
1594  0870     MOVF divisor, W
1595  02F2     SUBWF dividend, F
1596  0871     MOVF canal, W
1597  1C03     BTFSS STATUS, 0x0
1598  03F3     DECF counter, F
1599  02F3     SUBWF counter, F
29:            			*(unsigned int *)&divisor >>= 1;
159A  1003     BCF STATUS, 0x0
159B  0CF1     RRF canal, F
159C  0CF0     RRF divisor, F
30:            		} while(--counter != 0);
159D  0BF4     DECFSZ counter, F
159E  2D8C     GOTO 0x58C
31:            	}
32:            	if(sign)
159F  0875     MOVF Pin, W
15A0  1903     BTFSC STATUS, 0x2
15A1  2DA7     GOTO 0x5A7
33:            		dividend = -dividend;
15A2  09F2     COMF dividend, F
15A3  09F3     COMF counter, F
15A4  0AF2     INCF dividend, F
15A5  1903     BTFSC STATUS, 0x2
15A6  0AF3     INCF counter, F
34:            	return dividend;
15A7  0873     MOVF counter, W
15A8  00F1     MOVWF canal
15A9  0872     MOVF dividend, W
15AA  00F0     MOVWF divisor
35:            }
15AB  0008     RETURN
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/user.c  -------------------------------
1:             
2:             /******************************************************************************/
3:             /* Files to Include                                                           */
4:             /******************************************************************************/
5:             
6:             #if defined(__XC)
7:                 #include <xc.h>         /* XC8 General Include File */
8:             #elif defined(HI_TECH_C)
9:                 #include <htc.h>        /* HiTech General Include File */
10:            #endif
11:            
12:            #include <stdint.h>         /* For uint8_t definition */
13:            #include <stdbool.h>        /* For true/false definition */
14:            
15:            #include "user.h"
16:            #include "LCDGeneric.h"
17:            /******************************************************************************/
18:            /* User Functions                                                             */
19:            /******************************************************************************/
20:            
21:            /* <Initialize variables in user.h and insert code for user algorithms.> */
22:            
23:            void InitApp(void)
24:            {
25:                /* Initialize User Ports/Peripherals/Project here */
26:            
27:                /* Setup analog functionality and port direction */
28:            
29:                /* Initialize peripherals */
30:            
31:                /* Enable interrupts */
32:            }
33:            
34:            //prototipo de la funcion PUTCH para poder enviar al USART  o al LCD con printf
35:            void putch(char data) {
36:                //la variable envia_por nos indica si el printf envia los datos al lcd o al USART
37:              if (envia_por==LCD)
38:               vLCD_Putc(data);
39:              else{
40:                while( ! TXIF)
41:                continue;
42:                TXREG = data;
43:                }
44:            }
45:            
46:            
47:            int aniobisiesto(unsigned char year)
0FA1  00FA     MOVWF j
48:            {
49:                return ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0);
0FA2  01F9     CLRF Indice
0FA3  0AF9     INCF Indice, F
0FA4  3903     ANDLW 0x3
0FA5  1D03     BTFSS STATUS, 0x2
0FA6  2FB0     GOTO 0x7B0
0FA7  3064     MOVLW 0x64
0FA8  00F0     MOVWF divisor
0FA9  087A     MOVF j, W
0FAA  27C2     CALL 0x7C2
0FAB  120A     BCF PCLATH, 0x4
0FAC  158A     BSF PCLATH, 0x3
0FAD  3800     IORLW 0x0
0FAE  1D03     BTFSS STATUS, 0x2
0FAF  2FBE     GOTO 0x7BE
0FB0  3090     MOVLW 0x90
0FB1  00F0     MOVWF divisor
0FB2  3001     MOVLW 0x1
0FB3  00F1     MOVWF canal
0FB4  087A     MOVF j, W
0FB5  00F2     MOVWF dividend
0FB6  01F3     CLRF counter
0FB7  160A     BSF PCLATH, 0x4
0FB8  118A     BCF PCLATH, 0x3
0FB9  256F     CALL 0x56F
0FBA  0871     MOVF canal, W
0FBB  0470     IORWF divisor, W
0FBC  1D03     BTFSS STATUS, 0x2
0FBD  01F9     CLRF Indice
0FBE  0879     MOVF Indice, W
0FBF  00F6     MOVWF TipoPin
0FC0  01F7     CLRF Logica
50:            }
0FC1  0008     RETURN
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/pwm.c  --------------------------------
1:             #include <xc.h>
2:             #include <stdint.h>         /* For uint8_t definition */
3:             #include <stdbool.h>        /* For true/false definition */
4:             #include "system.h"
5:             #include "pwm.h"
6:             #include "user.h"
7:             /*The following steps should be taken when configuring
8:             the CCP module for PWM operation:
9:             1. Set the PWM period by writing to the PR2 register.
10:            2. Set the PWM duty cycle by writing to the
11:            CCPR1L register and CCP1CON<5:4> bits.
12:            3. Make the CCP1 pin an output by clearing the
13:            TRISC<2> bit.
14:            4. Set the TMR2 prescale value and enable Timer2
15:            by writing to T2CON.
16:            5. Configure the CCP1 module for PWM operation.*/
17:            #define FrecuenciaPWM 4880UL
18:            #define PeriodoPWM 1/FrecuenciaPWM
19:            #define PRESCALERTIMER2 4
20:            #define asignaPR2 _XTAL_FREQ/PRESCALERTIMER2/4*PeriodoPWM-1
21:            
22:            void set_periodo_buzzer(void){
23:            //PWM Period = [(PR2) + 1] * 4 * TOSC *(TMR2 Prescale Value)
24:                //PR2=PWM PERIOD/(4*TOSC*TMR2 Prescale Value)-1
25:                //para una frecuencia de __XTAL_FREQ/4=5Mhz
26:                PR2=asignaPR2;//periodo;;//periodo; //asigno el periodo
1547  30FF     MOVLW 0xFF
1548  0092     MOVWF T2CON
27:                T2CONbits.TMR2ON=1; //Habilito el timer2
1549  1283     BCF STATUS, 0x5
154A  1512     BSF T2CON, 0x2
28:                T2CONbits.T2CKPS=1; //prescaler en 4
154B  0812     MOVF T2CON, W
154C  39FC     ANDLW 0xFC
154D  3801     IORLW 0x1
154E  0092     MOVWF T2CON
29:                // CCP1CONbits.CCP1M=0b1100; //Configuro el CCp1 como PWM
30:                RB2=0;
154F  1106     BCF PORTB, 0x2
31:               TRISC2=0;//pongo el pin RC2/PWM1 como salida
1550  1683     BSF STATUS, 0x5
1551  1107     BCF PORTC, 0x2
32:            #warning No olvidar que si el PWM_duty > PWM_period no queda bien definida la frecuencia
33:               set_duty(512);
1552  1283     BCF STATUS, 0x5
34:            }
35:            
36:            /*/PWM Duty Cycle =(CCPR1L:CCP1CON<5:4>)*TOSC*(TMR2 Prescale Value)*/
37:            void set_duty(unsigned int duty){
38:            
39:            #define PWM10Bits
40:                //pwm modo 10bits
41:            #ifdef PWM10Bits
42:                CCPR1L=duty>>2;
1557  0824     MOVF dato, W
1558  00A6     MOVWF x
1559  0823     MOVF x, W
155A  00A5     MOVWF y
155B  1003     BCF STATUS, 0x0
155C  0CA6     RRF x, F
155D  0CA5     RRF y, F
155E  1003     BCF STATUS, 0x0
155F  0CA6     RRF x, F
1560  0CA5     RRF y, F
1561  0825     MOVF y, W
1562  0095     MOVWF CCPR1
43:            #endif
44:            CCP1CON = (CCP1CON & 0xCF) | ((duty <<4) & 0x30);
1563  0823     MOVF x, W
1564  00A5     MOVWF y
1565  0E25     SWAPF y, W
1566  39F0     ANDLW 0xF0
1567  00A5     MOVWF y
1568  3930     ANDLW 0x30
1569  00A6     MOVWF x
156A  0817     MOVF CCP1CON, W
156B  39CF     ANDLW 0xCF
156C  0426     IORWF x, W
156D  0097     MOVWF CCP1CON
45:            
46:            
47:            
48:            }
156E  0008     RETURN
49:            
50:            void buzzer_off(void){
0FE7  30F0     MOVLW 0xF0
1513  30F0     MOVLW 0xF0
51:              //activapor=0;
52:                CCP1CONbits.CCP1M=0; //desactiva pwm
0FE7  30F0     MOVLW 0xF0
0FE8  0597     ANDWF CCP1CON, F
1513  30F0     MOVLW 0xF0
1514  1283     BCF STATUS, 0x5
1515  1303     BCF STATUS, 0x6
1516  0597     ANDWF CCP1CON, F
53:            PORTCbits.RC2=0; //pongo el pin de reloj en bajo
0FE9  1107     BCF PORTC, 0x2
1517  1107     BCF PORTC, 0x2
54:            
55:            }
0FEA  0008     RETURN
1518  0008     RETURN
56:            void buzzer_on(void){
0FEB  3003     MOVLW 0x3
1521  3003     MOVLW 0x3
57:              activapor=3;
0FEB  3003     MOVLW 0x3
0FEC  1283     BCF STATUS, 0x5
0FED  1303     BCF STATUS, 0x6
0FEE  00DC     MOVWF activapor
1521  3003     MOVLW 0x3
1522  1283     BCF STATUS, 0x5
1523  1303     BCF STATUS, 0x6
1524  00DC     MOVWF activapor
58:                CCP1CONbits.CCP1M=0b1100; //activa pwm
0FEF  0817     MOVF CCP1CON, W
0FF0  39F0     ANDLW 0xF0
0FF1  380C     IORLW 0xC
0FF2  0097     MOVWF CCP1CON
1525  0817     MOVF CCP1CON, W
1526  39F0     ANDLW 0xF0
1527  380C     IORLW 0xC
1528  0097     MOVWF CCP1CON
59:                  }
0FF3  0008     RETURN
1529  0008     RETURN
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/main.c  -------------------------------
1:             /******************************************************************************/
2:             /* Files to Include                                                           */
3:             /******************************************************************************/
4:             // Real Time Clock & NVRAM
5:             // Hardware isl1208 of Dallas Maxim
6:             // With interface I2C
7:             #ifndef __PICCPRO__
8:             #define __PICCPRO__
9:             #endif
10:            #if defined(__XC)
11:            #include <xc.h>         /* XC8 General Include File */
12:            #elif defined(HI_TECH_C)
13:            #include <htc.h>        /* HiTech General Include File */
14:            #endif
15:            
16:            #include <stdint.h>        /* For uint8_t definition */
17:            #include <stdbool.h>       /* For true/false definition */
18:            #include <stdio.h>
19:            #include "system.h"        /* System funct/params, like osc/peripheral config */
20:            #include "user.h"          /* User funct/params, such as InitApp */
21:            #include "Pulsadores.h"
22:            #include "pwm.h"
23:            #include "adcPic16.h"
24:            /******************************************************************************/
25:            /* User Global Variable Declaration                                           */
26:            /******************************************************************************/
27:            
28:            /* i.e. uint8_t <variable_name>; */
29:            
30:            /******************************************************************************/
31:            /* Main Program                                                               */
32:            /******************************************************************************/
33:            
34:            //#fuses HS,MCLR,NOWDT,NOPROTECT,NOPUT,NOBROWNOUT,NOPBADEN,NOLVP,NOCPD,NODEBUG,NOWRT,NOVREGEN
35:            //#use delay(clock=20000000)
36:            //#use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7)
37:            
38:            // Libreria isl1208.c //////////////////////////////////////////////////////////
39:            
40:            #define RTC_SDA  PIN_B0
41:            #define RTC_SCL  PIN_B1
42:            
43:            #define USE_INTERRUPTS 1
44:            
45:            #include "_isl1208.h"
46:            #include "HardI2C.h"
47:            #include "usart1.h"
48:            #include "LCDGeneric.h"
49:            ///////////////////////////////////////////////////////////////////////////////
50:            
51:            void lee_y_transmite_date_and_time(void) {
52:            
53:                // isl1208_get_day_of_week( sdow);
54:                isl1208_get_date(&fecha.day, &fecha.month, &fecha.yr, &fecha.dow);
160D  3066     MOVLW 0x66
160E  1283     BCF STATUS, 0x5
160F  00A8     MOVWF mth
1610  3067     MOVLW 0x67
1611  00A9     MOVWF year
1612  3068     MOVLW 0x68
1613  00AA     MOVWF Data
1614  3065     MOVLW 0x65
1615  2685     CALL 0x685
1616  160A     BSF PCLATH, 0x4
1617  118A     BCF PCLATH, 0x3
55:                //TODO arreglar el accceso a la estructura por puntero
56:                isl1208_get_time(&horarioactual.hrs, &horarioactual.min, &horarioactual.sec);
1618  306A     MOVLW 0x6A
57:                // printf ("%s %02d/%02d/%02d\r\n ",sdow,fecha.day,fecha.month,fecha.yr);
58:                //printf("%02d:%02d:%02d\r\n", horario.hrs,horario.min,horario.sec);
59:            }
60:            
61:            void main() {
62:                TMR1IE = 0; //   disable_interrupts(int_timer1);
0034  1683     BSF STATUS, 0x5
0035  100C     BCF PIR1, 0x0
63:                RCIE = 0; //    disable_interrupts(int_rda);
0036  128C     BCF PIR1, 0x5
64:                RBIE = 0;
0037  118B     BCF INTCON, 0x3
65:                INTE = 0; //disable_interrupts(int_ext);
0038  120B     BCF INTCON, 0x4
66:                ADCON1 = 0x06; //todos puertos digitales
0039  3006     MOVLW 0x6
003A  009F     MOVWF ADCON0
67:                //setup_counters(RTCC_INTERNAL,RTCC_DIV_2);
68:                T0CS = 0; // TMR0 Clock Source Select bit: internal
003B  1281     BCF TMR0, 0x5
69:                PSA = 0; //Prescaler is assigned to the Timer0 module
003C  1181     BCF TMR0, 0x3
70:                OPTION_REGbits.PS = 0b101; //: Prescaler Rate Select bits 1/64
003D  0801     MOVF TMR0, W
003E  39F8     ANDLW 0xF8
003F  3805     IORLW 0x5
0040  0081     MOVWF TMR0
71:                //setup_timer_1(T1_INTERNAL | T1_DIV_BY_1);
72:                T1CON = 1;
0041  3001     MOVLW 0x1
0042  1283     BCF STATUS, 0x5
0043  0090     MOVWF T1CON
73:                CCP1CONbits.CCP1M = 0;
0044  30F0     MOVLW 0xF0
0045  0597     ANDWF CCP1CON, F
74:                //configura_USART();
75:                setup_i2c(I2C_MASTER);
0046  3038     MOVLW 0x38
0047  160A     BSF PCLATH, 0x4
0048  118A     BCF PCLATH, 0x3
0049  2536     CALL 0x536
004A  120A     BCF PCLATH, 0x4
004B  118A     BCF PCLATH, 0x3
76:            
77:            
78:                TRISB = 0b00111111; //Configuro las entradas de las teclas y la entrada del reloj
004C  303F     MOVLW 0x3F
004D  1683     BSF STATUS, 0x5
004E  0086     MOVWF PORTB
79:                PORTB = 0;
004F  1283     BCF STATUS, 0x5
0050  0186     CLRF PORTB
80:                TRISC0 = 0; //Configuro el pin de activacion de la bomba como salida
0051  1683     BSF STATUS, 0x5
0052  1007     BCF PORTC, 0x0
81:                TRISD = 0x00;
0053  0188     CLRF PORTD
82:                PORTD = 0;
0054  1283     BCF STATUS, 0x5
0055  0188     CLRF PORTD
83:                TRISE = 0b00000000;
0056  1683     BSF STATUS, 0x5
0057  0189     CLRF PORTE
84:                PORTE = 0;
0058  1283     BCF STATUS, 0x5
0059  0189     CLRF PORTE
85:            
86:                vInitLCD();
005A  120A     BCF PCLATH, 0x4
005B  158A     BSF PCLATH, 0x3
005C  2059     CALL 0x59
005D  120A     BCF PCLATH, 0x4
005E  118A     BCF PCLATH, 0x3
87:                sprintf(cadenaamostrar, "        ");
005F  305F     MOVLW 0x5F
0060  00AF     MOVWF f
0061  3098     MOVLW 0x98
0062  00B0     MOVWF c
0063  30B5     MOVLW 0xB5
0064  120A     BCF PCLATH, 0x4
0065  158A     BSF PCLATH, 0x3
0066  216F     CALL 0x16F
0067  120A     BCF PCLATH, 0x4
0068  118A     BCF PCLATH, 0x3
88:                vGotoxyLCD(1, 1);
0069  3001     MOVLW 0x1
006A  01A5     CLRF y
006B  0AA5     INCF y, F
006C  120A     BCF PCLATH, 0x4
006D  158A     BSF PCLATH, 0x3
006E  2015     CALL 0x15
006F  120A     BCF PCLATH, 0x4
0070  118A     BCF PCLATH, 0x3
89:                char *cadena = &cadenaamostrar[0];
0071  30B5     MOVLW 0xB5
0072  1683     BSF STATUS, 0x5
0073  00EB     MOVWF 0x6B
90:                while (*cadena != '\0')
0074  086B     MOVF 0x6B, W
0075  0084     MOVWF FSR
0076  1383     BCF STATUS, 0x7
0077  0880     MOVF INDF, F
0078  1903     BTFSC STATUS, 0x2
0079  2886     GOTO 0x86
0085  2874     GOTO 0x74
91:                    vLCD_Putc(*cadena++);
007A  086B     MOVF 0x6B, W
007B  0084     MOVWF FSR
007C  0800     MOVF INDF, W
007D  120A     BCF PCLATH, 0x4
007E  158A     BSF PCLATH, 0x3
007F  2035     CALL 0x35
0080  120A     BCF PCLATH, 0x4
0081  118A     BCF PCLATH, 0x3
0082  1683     BSF STATUS, 0x5
0083  1303     BCF STATUS, 0x6
0084  0AEB     INCF 0x6B, F
92:                vGotoxyLCD(1, 2);
0086  3002     MOVLW 0x2
0087  1283     BCF STATUS, 0x5
0088  00A5     MOVWF y
0089  3001     MOVLW 0x1
008A  120A     BCF PCLATH, 0x4
008B  158A     BSF PCLATH, 0x3
008C  2015     CALL 0x15
008D  120A     BCF PCLATH, 0x4
008E  118A     BCF PCLATH, 0x3
93:                char *cadena = &cadenaamostrar2[0];
008F  30C5     MOVLW 0xC5
0090  1683     BSF STATUS, 0x5
0091  00EB     MOVWF 0x6B
94:                while (*cadena != '\0')
0092  086B     MOVF 0x6B, W
0093  0084     MOVWF FSR
0094  1383     BCF STATUS, 0x7
0095  0880     MOVF INDF, F
0096  1903     BTFSC STATUS, 0x2
0097  28A4     GOTO 0xA4
00A3  2892     GOTO 0x92
95:                    vLCD_Putc(*cadena++);
0098  086B     MOVF 0x6B, W
0099  0084     MOVWF FSR
009A  0800     MOVF INDF, W
009B  120A     BCF PCLATH, 0x4
009C  158A     BSF PCLATH, 0x3
009D  2035     CALL 0x35
009E  120A     BCF PCLATH, 0x4
009F  118A     BCF PCLATH, 0x3
00A0  1683     BSF STATUS, 0x5
00A1  1303     BCF STATUS, 0x6
00A2  0AEB     INCF 0x6B, F
96:                refrescadisplay = 0;
00A4  300D     MOVLW 0xD
00A5  01B2     CLRF 0x32
97:                __delay_ms(500);
00A4  300D     MOVLW 0xD
00A6  00DA     MOVWF sign
00A7  30AF     MOVLW 0xAF
00A8  00D9     MOVWF exp
00A9  30C1     MOVLW 0xC1
00AA  00D8     MOVWF 0x58
00AB  0BD8     DECFSZ 0x58, F
00AC  28AB     GOTO 0xAB
00AD  0BD9     DECFSZ exp, F
00AE  28AB     GOTO 0xAB
00AF  0BDA     DECFSZ sign, F
00B0  28AB     GOTO 0xAB
00B1  0000     NOP
98:                sprintf(cadenaamostrar, "Ini...");
00B2  3072     MOVLW 0x72
00B3  1283     BCF STATUS, 0x5
00B4  1303     BCF STATUS, 0x6
00B5  00AF     MOVWF f
00B6  3099     MOVLW 0x99
00B7  00B0     MOVWF c
00B8  30B5     MOVLW 0xB5
00B9  120A     BCF PCLATH, 0x4
00BA  158A     BSF PCLATH, 0x3
00BB  216F     CALL 0x16F
00BC  120A     BCF PCLATH, 0x4
00BD  118A     BCF PCLATH, 0x3
99:                vGotoxyLCD(1, 1);
00BE  3001     MOVLW 0x1
00BF  01A5     CLRF y
00C0  0AA5     INCF y, F
00C1  120A     BCF PCLATH, 0x4
00C2  158A     BSF PCLATH, 0x3
00C3  2015     CALL 0x15
00C4  120A     BCF PCLATH, 0x4
00C5  118A     BCF PCLATH, 0x3
100:               char *cadena = &cadenaamostrar[0];
00C6  30B5     MOVLW 0xB5
00C7  1683     BSF STATUS, 0x5
00C8  00EB     MOVWF 0x6B
101:               while (*cadena != '\0')
00C9  086B     MOVF 0x6B, W
00CA  0084     MOVWF FSR
00CB  1383     BCF STATUS, 0x7
00CC  0880     MOVF INDF, F
00CD  1903     BTFSC STATUS, 0x2
00CE  28DB     GOTO 0xDB
00DA  28C9     GOTO 0xC9
102:                   vLCD_Putc(*cadena++);
00CF  086B     MOVF 0x6B, W
00D0  0084     MOVWF FSR
00D1  0800     MOVF INDF, W
00D2  120A     BCF PCLATH, 0x4
00D3  158A     BSF PCLATH, 0x3
00D4  2035     CALL 0x35
00D5  120A     BCF PCLATH, 0x4
00D6  118A     BCF PCLATH, 0x3
00D7  1683     BSF STATUS, 0x5
00D8  1303     BCF STATUS, 0x6
00D9  0AEB     INCF 0x6B, F
103:               vGotoxyLCD(1, 2);
00DB  3002     MOVLW 0x2
00DC  1283     BCF STATUS, 0x5
00DD  00A5     MOVWF y
00DE  3001     MOVLW 0x1
00DF  120A     BCF PCLATH, 0x4
00E0  158A     BSF PCLATH, 0x3
00E1  2015     CALL 0x15
00E2  120A     BCF PCLATH, 0x4
00E3  118A     BCF PCLATH, 0x3
104:               char *cadena = &cadenaamostrar2[0];
00E4  30C5     MOVLW 0xC5
00E5  1683     BSF STATUS, 0x5
00E6  00EB     MOVWF 0x6B
105:               while (*cadena != '\0')
00E7  086B     MOVF 0x6B, W
00E8  0084     MOVWF FSR
00E9  1383     BCF STATUS, 0x7
00EA  0880     MOVF INDF, F
00EB  1903     BTFSC STATUS, 0x2
00EC  28F9     GOTO 0xF9
00F8  28E7     GOTO 0xE7
106:                   vLCD_Putc(*cadena++);
00ED  086B     MOVF 0x6B, W
00EE  0084     MOVWF FSR
00EF  0800     MOVF INDF, W
00F0  120A     BCF PCLATH, 0x4
00F1  158A     BSF PCLATH, 0x3
00F2  2035     CALL 0x35
00F3  120A     BCF PCLATH, 0x4
00F4  118A     BCF PCLATH, 0x3
00F5  1683     BSF STATUS, 0x5
00F6  1303     BCF STATUS, 0x6
00F7  0AEB     INCF 0x6B, F
107:               refrescadisplay = 0;
00F9  01B2     CLRF 0x32
108:           
109:           
110:               set_periodo_buzzer(); //configuro el pwm para una frecuencia de 3khz
00FA  160A     BSF PCLATH, 0x4
00FB  118A     BCF PCLATH, 0x3
00FC  2547     CALL 0x547
00FD  120A     BCF PCLATH, 0x4
00FE  118A     BCF PCLATH, 0x3
111:               buzzer_on();
00FF  160A     BSF PCLATH, 0x4
0100  118A     BCF PCLATH, 0x3
0101  2521     CALL 0x521
0102  120A     BCF PCLATH, 0x4
0103  118A     BCF PCLATH, 0x3
112:               __delay_ms(200);
0104  3006     MOVLW 0x6
0105  1683     BSF STATUS, 0x5
0106  00DA     MOVWF sign
0107  3013     MOVLW 0x13
0108  00D9     MOVWF exp
0109  30B1     MOVLW 0xB1
010A  00D8     MOVWF 0x58
010B  0BD8     DECFSZ 0x58, F
010C  290B     GOTO 0x10B
010D  0BD9     DECFSZ exp, F
010E  290B     GOTO 0x10B
010F  0BDA     DECFSZ sign, F
0110  290B     GOTO 0x10B
0111  2912     GOTO 0x112
113:               buzzer_off();
0112  160A     BSF PCLATH, 0x4
0113  118A     BCF PCLATH, 0x3
0114  2513     CALL 0x513
0115  120A     BCF PCLATH, 0x4
0116  118A     BCF PCLATH, 0x3
114:               __delay_ms(200);
0117  3006     MOVLW 0x6
0118  1683     BSF STATUS, 0x5
0119  00DA     MOVWF sign
011A  3013     MOVLW 0x13
011B  00D9     MOVWF exp
011C  30B1     MOVLW 0xB1
011D  00D8     MOVWF 0x58
011E  0BD8     DECFSZ 0x58, F
011F  291E     GOTO 0x11E
0120  0BD9     DECFSZ exp, F
0121  291E     GOTO 0x11E
0122  0BDA     DECFSZ sign, F
0123  291E     GOTO 0x11E
0124  2925     GOTO 0x125
115:               buzzer_on();
0125  160A     BSF PCLATH, 0x4
0126  118A     BCF PCLATH, 0x3
0127  2521     CALL 0x521
0128  120A     BCF PCLATH, 0x4
0129  118A     BCF PCLATH, 0x3
116:               __delay_ms(200);
012A  3006     MOVLW 0x6
012B  1683     BSF STATUS, 0x5
012C  00DA     MOVWF sign
012D  3013     MOVLW 0x13
012E  00D9     MOVWF exp
012F  30B1     MOVLW 0xB1
0130  00D8     MOVWF 0x58
0131  0BD8     DECFSZ 0x58, F
0132  2931     GOTO 0x131
0133  0BD9     DECFSZ exp, F
0134  2931     GOTO 0x131
0135  0BDA     DECFSZ sign, F
0136  2931     GOTO 0x131
0137  2938     GOTO 0x138
117:               buzzer_off();
0138  160A     BSF PCLATH, 0x4
0139  118A     BCF PCLATH, 0x3
013A  2513     CALL 0x513
013B  120A     BCF PCLATH, 0x4
013C  118A     BCF PCLATH, 0x3
118:               //ext_int_edge(2,H_TO_L);
119:               INTEDG = 0;
013D  1683     BSF STATUS, 0x5
013E  1301     BCF TMR0, 0x6
120:               INTE = 1; // enable_interrupts(int_ext2);
013F  160B     BSF INTCON, 0x4
121:               TMR0IE = 1;
0140  168B     BSF INTCON, 0x5
122:               setADCChannel(MIDECORRIENTE);
0141  3000     MOVLW 0x0
0142  160A     BSF PCLATH, 0x4
0143  118A     BCF PCLATH, 0x3
0144  252A     CALL 0x52A
0145  120A     BCF PCLATH, 0x4
0146  118A     BCF PCLATH, 0x3
123:               __delay_us(20);
0147  3021     MOVLW 0x21
0148  1683     BSF STATUS, 0x5
0149  00D8     MOVWF 0x58
014A  0BD8     DECFSZ 0x58, F
014B  294A     GOTO 0x14A
124:               openADC();
014C  120A     BCF PCLATH, 0x4
014D  158A     BSF PCLATH, 0x3
014E  2000     CALL 0x0
014F  120A     BCF PCLATH, 0x4
0150  118A     BCF PCLATH, 0x3
125:               __delay_us(20);
0151  3021     MOVLW 0x21
0152  1683     BSF STATUS, 0x5
0153  00D8     MOVWF 0x58
0154  0BD8     DECFSZ 0x58, F
0155  2954     GOTO 0x154
126:               interruptADC_on();
0156  160A     BSF PCLATH, 0x4
0157  118A     BCF PCLATH, 0x3
0158  250F     CALL 0x50F
0159  120A     BCF PCLATH, 0x4
015A  118A     BCF PCLATH, 0x3
127:               __delay_ms(500);
015B  300D     MOVLW 0xD
015C  00DA     MOVWF sign
015D  30AF     MOVLW 0xAF
015E  00D9     MOVWF exp
015F  30C1     MOVLW 0xC1
0160  00D8     MOVWF 0x58
0161  0BD8     DECFSZ 0x58, F
0162  2961     GOTO 0x161
0163  0BD9     DECFSZ exp, F
0164  2961     GOTO 0x161
0165  0BDA     DECFSZ sign, F
0166  2961     GOTO 0x161
0167  0000     NOP
128:           
129:           
130:               ADIF = 0;
0168  1283     BCF STATUS, 0x5
0169  1303     BCF STATUS, 0x6
016A  130C     BCF PIR1, 0x6
131:               INTF = 0; // borro las banderas de interrupcion
016B  108B     BCF INTCON, 0x1
132:               TMR0IF = 0;
016C  110B     BCF INTCON, 0x2
133:           
134:           
135:           
136:               if (ISL1208_ready()){
016D  160A     BSF PCLATH, 0x4
016E  118A     BCF PCLATH, 0x3
016F  261F     CALL 0x61F
0170  120A     BCF PCLATH, 0x4
0171  118A     BCF PCLATH, 0x3
0172  3A00     XORLW 0x0
0173  1903     BTFSC STATUS, 0x2
0174  29C8     GOTO 0x1C8
137:                   sprintf(cadenaamostrar, "RTC OK");
0175  3079     MOVLW 0x79
0176  00AF     MOVWF f
0177  3099     MOVLW 0x99
0178  00B0     MOVWF c
0179  30B5     MOVLW 0xB5
017A  120A     BCF PCLATH, 0x4
017B  158A     BSF PCLATH, 0x3
017C  216F     CALL 0x16F
017D  120A     BCF PCLATH, 0x4
017E  118A     BCF PCLATH, 0x3
138:                   vGotoxyLCD(1, 1);
017F  3001     MOVLW 0x1
0180  01A5     CLRF y
0181  0AA5     INCF y, F
0182  120A     BCF PCLATH, 0x4
0183  158A     BSF PCLATH, 0x3
0184  2015     CALL 0x15
0185  120A     BCF PCLATH, 0x4
0186  118A     BCF PCLATH, 0x3
139:                   char *cadena = &cadenaamostrar[0];
0187  30B5     MOVLW 0xB5
0188  1683     BSF STATUS, 0x5
0189  00E7     MOVWF 0x67
140:                   while (*cadena != '\0')
018A  0867     MOVF 0x67, W
018B  0084     MOVWF FSR
018C  1383     BCF STATUS, 0x7
018D  0880     MOVF INDF, F
018E  1903     BTFSC STATUS, 0x2
018F  299C     GOTO 0x19C
019B  298A     GOTO 0x18A
141:                       vLCD_Putc(*cadena++);
0190  0867     MOVF 0x67, W
0191  0084     MOVWF FSR
0192  0800     MOVF INDF, W
0193  120A     BCF PCLATH, 0x4
0194  158A     BSF PCLATH, 0x3
0195  2035     CALL 0x35
0196  120A     BCF PCLATH, 0x4
0197  118A     BCF PCLATH, 0x3
0198  1683     BSF STATUS, 0x5
0199  1303     BCF STATUS, 0x6
019A  0AE7     INCF 0x67, F
142:           
143:                   __delay_ms(500);
019C  300D     MOVLW 0xD
019D  00DA     MOVWF sign
019E  30AF     MOVLW 0xAF
019F  00D9     MOVWF exp
01A0  30C1     MOVLW 0xC1
01A1  00D8     MOVWF 0x58
01A2  0BD8     DECFSZ 0x58, F
01A3  29A2     GOTO 0x1A2
01A4  0BD9     DECFSZ exp, F
01A5  29A2     GOTO 0x1A2
01A6  0BDA     DECFSZ sign, F
01A7  29A2     GOTO 0x1A2
01A8  0000     NOP
144:                   __delay_ms(500);
01A9  300D     MOVLW 0xD
01AA  1683     BSF STATUS, 0x5
01AB  1303     BCF STATUS, 0x6
01AC  00DA     MOVWF sign
01AD  30AF     MOVLW 0xAF
01AE  00D9     MOVWF exp
01AF  30C1     MOVLW 0xC1
01B0  00D8     MOVWF 0x58
01B1  0BD8     DECFSZ 0x58, F
01B2  29B1     GOTO 0x1B1
01B3  0BD9     DECFSZ exp, F
01B4  29B1     GOTO 0x1B1
01B5  0BDA     DECFSZ sign, F
01B6  29B1     GOTO 0x1B1
01B7  0000     NOP
145:                   __delay_ms(500);
01B8  300D     MOVLW 0xD
01B9  1683     BSF STATUS, 0x5
01BA  1303     BCF STATUS, 0x6
01BB  00DA     MOVWF sign
01BC  30AF     MOVLW 0xAF
01BD  00D9     MOVWF exp
01BE  30C1     MOVLW 0xC1
01BF  00D8     MOVWF 0x58
01C0  0BD8     DECFSZ 0x58, F
01C1  29C0     GOTO 0x1C0
01C2  0BD9     DECFSZ exp, F
01C3  29C0     GOTO 0x1C0
01C4  0BDA     DECFSZ sign, F
01C5  29C0     GOTO 0x1C0
01C6  0000     NOP
146:               }else {
01C7  29EF     GOTO 0x1EF
147:                   sprintf(cadenaamostrar, "RTC ERRO");
01C8  3059     MOVLW 0x59
01C9  00AF     MOVWF f
01CA  3099     MOVLW 0x99
01CB  00B0     MOVWF c
01CC  30B5     MOVLW 0xB5
01CD  120A     BCF PCLATH, 0x4
01CE  158A     BSF PCLATH, 0x3
01CF  216F     CALL 0x16F
01D0  120A     BCF PCLATH, 0x4
01D1  118A     BCF PCLATH, 0x3
148:                   vGotoxyLCD(1, 1);
01D2  3001     MOVLW 0x1
01D3  01A5     CLRF y
01D4  0AA5     INCF y, F
01D5  120A     BCF PCLATH, 0x4
01D6  158A     BSF PCLATH, 0x3
01D7  2015     CALL 0x15
01D8  120A     BCF PCLATH, 0x4
01D9  118A     BCF PCLATH, 0x3
149:                   char *cadena = &cadenaamostrar[0];
01DA  30B5     MOVLW 0xB5
01DB  1683     BSF STATUS, 0x5
01DC  00E8     MOVWF 0x68
150:                   while (*cadena != '\0')
01DD  0868     MOVF 0x68, W
01DE  0084     MOVWF FSR
01DF  1383     BCF STATUS, 0x7
01E0  0880     MOVF INDF, F
01E1  1903     BTFSC STATUS, 0x2
01E2  299C     GOTO 0x19C
01EE  29DD     GOTO 0x1DD
151:                       vLCD_Putc(*cadena++);
01E3  0868     MOVF 0x68, W
01E4  0084     MOVWF FSR
01E5  0800     MOVF INDF, W
01E6  120A     BCF PCLATH, 0x4
01E7  158A     BSF PCLATH, 0x3
01E8  2035     CALL 0x35
01E9  120A     BCF PCLATH, 0x4
01EA  118A     BCF PCLATH, 0x3
01EB  1683     BSF STATUS, 0x5
01EC  1303     BCF STATUS, 0x6
01ED  0AE8     INCF 0x68, F
152:           
153:                   __delay_ms(500);
154:                   __delay_ms(500);
155:                   __delay_ms(500);
156:           
157:               };
158:               isl1208SR.Valor = 0x00;
01EF  1683     BSF STATUS, 0x5
01F0  1303     BCF STATUS, 0x6
01F1  01B0     CLRF c
159:               isl1208SR.Valor = ISL1208_Read_status();
01F2  160A     BSF PCLATH, 0x4
01F3  118A     BCF PCLATH, 0x3
01F4  262F     CALL 0x62F
01F5  120A     BCF PCLATH, 0x4
01F6  118A     BCF PCLATH, 0x3
01F7  1683     BSF STATUS, 0x5
01F8  00B0     MOVWF c
160:               sprintf(cadenaamostrar, "%X",isl1208SR.Valor);
01F9  3089     MOVLW 0x89
01FA  1283     BCF STATUS, 0x5
01FB  00AF     MOVWF f
01FC  3099     MOVLW 0x99
01FD  00B0     MOVWF c
01FE  1683     BSF STATUS, 0x5
01FF  0830     MOVF c, W
0200  1283     BCF STATUS, 0x5
0201  00B1     MOVWF 0x31
0202  30B5     MOVLW 0xB5
0203  01B2     CLRF 0x32
0204  120A     BCF PCLATH, 0x4
0205  158A     BSF PCLATH, 0x3
0206  216F     CALL 0x16F
0207  120A     BCF PCLATH, 0x4
0208  118A     BCF PCLATH, 0x3
161:                   vGotoxyLCD(1, 2);
0209  3002     MOVLW 0x2
020A  00A5     MOVWF y
020B  3001     MOVLW 0x1
020C  120A     BCF PCLATH, 0x4
020D  158A     BSF PCLATH, 0x3
020E  2015     CALL 0x15
020F  120A     BCF PCLATH, 0x4
0210  118A     BCF PCLATH, 0x3
162:                   char *cadena = &cadenaamostrar[0];
0211  30B5     MOVLW 0xB5
0212  1683     BSF STATUS, 0x5
0213  00EB     MOVWF 0x6B
163:                   while (*cadena != '\0')
0214  086B     MOVF 0x6B, W
0215  0084     MOVWF FSR
0216  1383     BCF STATUS, 0x7
0217  0880     MOVF INDF, F
0218  1903     BTFSC STATUS, 0x2
0219  2A26     GOTO 0x226
0225  2A14     GOTO 0x214
164:                       vLCD_Putc(*cadena++);
021A  086B     MOVF 0x6B, W
021B  0084     MOVWF FSR
021C  0800     MOVF INDF, W
021D  120A     BCF PCLATH, 0x4
021E  158A     BSF PCLATH, 0x3
021F  2035     CALL 0x35
0220  120A     BCF PCLATH, 0x4
0221  118A     BCF PCLATH, 0x3
0222  1683     BSF STATUS, 0x5
0223  1303     BCF STATUS, 0x6
0224  0AEB     INCF 0x6B, F
165:           
166:                   __delay_ms(500);
0226  300D     MOVLW 0xD
0227  00DA     MOVWF sign
0228  30AF     MOVLW 0xAF
0229  00D9     MOVWF exp
022A  30C1     MOVLW 0xC1
022B  00D8     MOVWF 0x58
022C  0BD8     DECFSZ 0x58, F
022D  2A2C     GOTO 0x22C
022E  0BD9     DECFSZ exp, F
022F  2A2C     GOTO 0x22C
0230  0BDA     DECFSZ sign, F
0231  2A2C     GOTO 0x22C
0232  0000     NOP
167:                   __delay_ms(500);
0233  300D     MOVLW 0xD
0234  1683     BSF STATUS, 0x5
0235  1303     BCF STATUS, 0x6
0236  00DA     MOVWF sign
0237  30AF     MOVLW 0xAF
0238  00D9     MOVWF exp
0239  30C1     MOVLW 0xC1
023A  00D8     MOVWF 0x58
023B  0BD8     DECFSZ 0x58, F
023C  2A3B     GOTO 0x23B
023D  0BD9     DECFSZ exp, F
023E  2A3B     GOTO 0x23B
023F  0BDA     DECFSZ sign, F
0240  2A3B     GOTO 0x23B
0241  0000     NOP
168:                   __delay_ms(500);
0242  300D     MOVLW 0xD
0243  1683     BSF STATUS, 0x5
0244  1303     BCF STATUS, 0x6
0245  00DA     MOVWF sign
0246  30AF     MOVLW 0xAF
0247  00D9     MOVWF exp
0248  30C1     MOVLW 0xC1
0249  00D8     MOVWF 0x58
024A  0BD8     DECFSZ 0x58, F
024B  2A4A     GOTO 0x24A
024C  0BD9     DECFSZ exp, F
024D  2A4A     GOTO 0x24A
024E  0BDA     DECFSZ sign, F
024F  2A4A     GOTO 0x24A
0250  0000     NOP
169:           
170:           
171:               if (isl1208SR.RTCF) {//Si se reseteo el RTC, envio directamente a configurar la hora
0251  1683     BSF STATUS, 0x5
0252  1303     BCF STATUS, 0x6
0253  1C30     BTFSS c, 0x0
0254  2A58     GOTO 0x258
172:                   menuactual = MENU_CONFIGURAHORARIO;
0255  3003     MOVLW 0x3
0256  00B1     MOVWF 0x31
173:           
174:               }else
0257  2A5D     GOTO 0x25D
175:               {
176:                lee_y_transmite_date_and_time();
0258  160A     BSF PCLATH, 0x4
0259  118A     BCF PCLATH, 0x3
025A  260D     CALL 0x60D
025B  120A     BCF PCLATH, 0x4
025C  118A     BCF PCLATH, 0x3
177:               }
178:               ei(); //enable_interrupts(global);
025D  178B     BSF INTCON, 0x7
025E  2D30     GOTO 0x530
179:               // Inicializa isl1208
180:               //TODO   isl1208_init(isl1208_OUT_ENABLED | isl1208_OUT_1_HZ);
181:           
182:               //TODO lee_y_transmite_date_and_time();
183:           
184:           
185:               while (1) {//
186:                   // di(); //
187:                   switch (menuactual) {
0530  1683     BSF STATUS, 0x5
0531  1303     BCF STATUS, 0x6
0532  0831     MOVF 0x31, W
0533  0084     MOVWF FSR
0534  3012     MOVLW 0x12
0535  0204     SUBWF FSR, W
0536  1803     BTFSC STATUS, 0x0
0537  2D45     GOTO 0x545
0538  3010     MOVLW 0x10
0539  008A     MOVWF PCLATH
053A  1003     BCF STATUS, 0x0
053B  0D04     RLF FSR, W
053C  0704     ADDWF FSR, W
053D  3E00     ADDLW 0x0
053E  0082     MOVWF PCL
1000  120A     BCF PCLATH, 0x4
1001  118A     BCF PCLATH, 0x3
1002  2A5F     GOTO 0x25F
1003  120A     BCF PCLATH, 0x4
1004  118A     BCF PCLATH, 0x3
1005  2ABA     GOTO 0x2BA
1006  120A     BCF PCLATH, 0x4
1007  118A     BCF PCLATH, 0x3
1008  2BFF     GOTO 0x3FF
1009  120A     BCF PCLATH, 0x4
100A  118A     BCF PCLATH, 0x3
100B  2ACD     GOTO 0x2CD
100C  120A     BCF PCLATH, 0x4
100D  118A     BCF PCLATH, 0x3
100E  2AD5     GOTO 0x2D5
100F  120A     BCF PCLATH, 0x4
1010  118A     BCF PCLATH, 0x3
1011  2B02     GOTO 0x302
1012  120A     BCF PCLATH, 0x4
1013  118A     BCF PCLATH, 0x3
1014  2B13     GOTO 0x313
1015  120A     BCF PCLATH, 0x4
1016  118A     BCF PCLATH, 0x3
1017  2B1B     GOTO 0x31B
1018  120A     BCF PCLATH, 0x4
1019  118A     BCF PCLATH, 0x3
101A  2B29     GOTO 0x329
101B  120A     BCF PCLATH, 0x4
101C  118A     BCF PCLATH, 0x3
101D  2B3A     GOTO 0x33A
101E  120A     BCF PCLATH, 0x4
101F  118A     BCF PCLATH, 0x3
1020  2B5E     GOTO 0x35E
1021  120A     BCF PCLATH, 0x4
1022  118A     BCF PCLATH, 0x3
1023  2B66     GOTO 0x366
1024  120A     BCF PCLATH, 0x4
1025  118A     BCF PCLATH, 0x3
1026  2B76     GOTO 0x376
1027  120A     BCF PCLATH, 0x4
1028  118A     BCF PCLATH, 0x3
1029  2B99     GOTO 0x399
102A  120A     BCF PCLATH, 0x4
102B  118A     BCF PCLATH, 0x3
102C  2BAD     GOTO 0x3AD
102D  120A     BCF PCLATH, 0x4
102E  118A     BCF PCLATH, 0x3
102F  2BC4     GOTO 0x3C4
1030  120A     BCF PCLATH, 0x4
1031  118A     BCF PCLATH, 0x3
1032  2BC5     GOTO 0x3C5
1033  120A     BCF PCLATH, 0x4
1034  118A     BCF PCLATH, 0x3
1035  2BDD     GOTO 0x3DD
188:                       case MENU_MUESTRAHORA:
189:                       {
190:                           horario = &horarioactual;
025F  3069     MOVLW 0x69
0260  00FD     MOVWF horario
191:                           //Se actualiza lo que se muestra en el display, solamente cuando hay cambios en lo que mostrar
192:                           if (!I2Cstate) {
0261  08A7     MOVF i, F
0262  1D03     BTFSS STATUS, 0x2
0263  2AA4     GOTO 0x2A4
193:                               if (flanco) {
0264  087C     MOVF flanco, W
0265  1903     BTFSC STATUS, 0x2
0266  2A88     GOTO 0x288
194:                                   lee_y_transmite_date_and_time();
0267  160A     BSF PCLATH, 0x4
0268  118A     BCF PCLATH, 0x3
0269  260D     CALL 0x60D
026A  120A     BCF PCLATH, 0x4
026B  118A     BCF PCLATH, 0x3
195:                                    //if (refrescadisplay) lee_y_transmite_date_and_time();
196:                                   sprintf(cadenaamostrar, "%02d:%02d    ", horarioactual.hrs, horarioactual.min);
026C  3076     MOVLW 0x76
026D  1283     BCF STATUS, 0x5
026E  00AF     MOVWF f
026F  3098     MOVLW 0x98
0270  00B0     MOVWF c
0271  086B     MOVF 0x6B, W
0272  00B1     MOVWF 0x31
0273  01B2     CLRF 0x32
0274  086A     MOVF 0x6A, W
0275  00B3     MOVWF 0x33
0276  30B5     MOVLW 0xB5
0277  01B4     CLRF sign
0278  120A     BCF PCLATH, 0x4
0279  158A     BSF PCLATH, 0x3
027A  216F     CALL 0x16F
027B  120A     BCF PCLATH, 0x4
027C  118A     BCF PCLATH, 0x3
197:                                   sprintf(cadenaamostrar2, "             ");
027D  305A     MOVLW 0x5A
027E  00AF     MOVWF f
027F  3098     MOVLW 0x98
0280  00B0     MOVWF c
0281  30C5     MOVLW 0xC5
0282  120A     BCF PCLATH, 0x4
0283  158A     BSF PCLATH, 0x3
0284  216F     CALL 0x16F
0285  120A     BCF PCLATH, 0x4
0286  118A     BCF PCLATH, 0x3
198:                               } else {
0287  2D45     GOTO 0x545
199:                                   sprintf(cadenaamostrar, "%02d %02d    ", horarioactual.hrs, horarioactual.min);
0288  3068     MOVLW 0x68
0289  1283     BCF STATUS, 0x5
028A  00AF     MOVWF f
028B  3098     MOVLW 0x98
028C  00B0     MOVWF c
028D  086B     MOVF 0x6B, W
028E  00B1     MOVWF 0x31
028F  01B2     CLRF 0x32
0290  086A     MOVF 0x6A, W
0291  00B3     MOVWF 0x33
0292  30B5     MOVLW 0xB5
0293  01B4     CLRF sign
0294  120A     BCF PCLATH, 0x4
0295  158A     BSF PCLATH, 0x3
0296  216F     CALL 0x16F
0297  120A     BCF PCLATH, 0x4
0298  118A     BCF PCLATH, 0x3
200:                                   sprintf(cadenaamostrar2, "             ");
0299  305A     MOVLW 0x5A
029A  00AF     MOVWF f
029B  3098     MOVLW 0x98
029C  00B0     MOVWF c
029D  30C5     MOVLW 0xC5
029E  120A     BCF PCLATH, 0x4
029F  158A     BSF PCLATH, 0x3
02A0  216F     CALL 0x16F
02A1  120A     BCF PCLATH, 0x4
02A2  118A     BCF PCLATH, 0x3
02A3  2D45     GOTO 0x545
201:                               }
202:                           } else {
203:                               sprintf(cadenaamostrar, "RTC erro");
02A4  3062     MOVLW 0x62
02A5  1283     BCF STATUS, 0x5
02A6  00AF     MOVWF f
02A7  3099     MOVLW 0x99
02A8  00B0     MOVWF c
02A9  30B5     MOVLW 0xB5
02AA  120A     BCF PCLATH, 0x4
02AB  158A     BSF PCLATH, 0x3
02AC  216F     CALL 0x16F
02AD  120A     BCF PCLATH, 0x4
02AE  118A     BCF PCLATH, 0x3
204:                               sprintf(cadenaamostrar2, "             ");
02AF  305A     MOVLW 0x5A
02B0  00AF     MOVWF f
02B1  3098     MOVLW 0x98
02B2  00B0     MOVWF c
02B3  30C5     MOVLW 0xC5
02B4  120A     BCF PCLATH, 0x4
02B5  158A     BSF PCLATH, 0x3
02B6  216F     CALL 0x16F
02B7  120A     BCF PCLATH, 0x4
02B8  118A     BCF PCLATH, 0x3
02B9  2D45     GOTO 0x545
205:                           }
206:           
207:           
208:                           break;
209:                       }
210:                       case MENU_MUESTRAFECHA:
211:                       {
212:           
213:                           if (flanco) {
02BA  087C     MOVF flanco, W
02BB  1903     BTFSC STATUS, 0x2
02BC  2D45     GOTO 0x545
214:                               //TODO lee_y_transmite_date_and_time();
215:                               sprintf(cadenaamostrar, "%02d/%02d/%02d ", fecha.day, fecha.month, fecha.yr);
02BD  304A     MOVLW 0x4A
02BE  1283     BCF STATUS, 0x5
02BF  00AF     MOVWF f
02C0  3098     MOVLW 0x98
02C1  00B0     MOVWF c
02C2  0865     MOVF fecha, W
02C3  00B1     MOVWF 0x31
02C4  01B2     CLRF 0x32
02C5  0866     MOVF 0x66, W
02C6  00B3     MOVWF 0x33
02C7  01B4     CLRF sign
02C8  0867     MOVF 0x67, W
02C9  00B5     MOVWF exp2
02CA  30B5     MOVLW 0xB5
02CB  01B6     CLRF exp1
02CC  2BF5     GOTO 0x3F5
216:                               sprintf(cadenaamostrar2, "             ");
217:                           }
218:           
219:           
220:                           break;
221:                       }
222:                       case MENU_CONFIGURAHORARIO:
223:                       {
224:           
225:                           if (flanco) {
02CD  087C     MOVF flanco, W
02CE  1903     BTFSC STATUS, 0x2
02CF  2D45     GOTO 0x545
226:                               sprintf(cadenaamostrar, "SET HORA ");
02D0  3005     MOVLW 0x5
02D1  1283     BCF STATUS, 0x5
02D2  00AF     MOVWF f
02D3  3099     MOVLW 0x99
02D4  2BF3     GOTO 0x3F3
227:                               sprintf(cadenaamostrar2, "             ");
228:                           }
229:           
230:                           break;
231:                       }
232:                       case SUBMENU_CONFIGURAHORA:
233:                       {
234:                           modificafecha = HORA;
02D5  3069     MOVLW 0x69
02D6  01EC     CLRF 0x6C
235:                           horario = &horarioactual;
02D5  3069     MOVLW 0x69
02D7  00FD     MOVWF horario
236:                           if (flanco || haycambio) {
02D8  08FC     MOVF flanco, F
02D9  1903     BTFSC STATUS, 0x2
02DA  082F     MOVF f, W
02DB  1903     BTFSC STATUS, 0x2
02DC  2AFB     GOTO 0x2FB
237:                               sprintf(cadenaamostrar, "%02d:%02d    ", horarioactual.hrs, horarioactual.min);
02DD  3076     MOVLW 0x76
02DE  1283     BCF STATUS, 0x5
02DF  00AF     MOVWF f
02E0  3098     MOVLW 0x98
02E1  00B0     MOVWF c
02E2  086B     MOVF 0x6B, W
02E3  00B1     MOVWF 0x31
02E4  01B2     CLRF 0x32
02E5  086A     MOVF 0x6A, W
02E6  00B3     MOVWF 0x33
02E7  30B5     MOVLW 0xB5
02E8  01B4     CLRF sign
02E9  120A     BCF PCLATH, 0x4
02EA  158A     BSF PCLATH, 0x3
02EB  216F     CALL 0x16F
02EC  120A     BCF PCLATH, 0x4
02ED  118A     BCF PCLATH, 0x3
238:                               sprintf(cadenaamostrar2, "             ");
02EE  305A     MOVLW 0x5A
02EF  00AF     MOVWF f
02F0  3098     MOVLW 0x98
02F1  00B0     MOVWF c
02F2  30C5     MOVLW 0xC5
02F3  120A     BCF PCLATH, 0x4
02F4  158A     BSF PCLATH, 0x3
02F5  216F     CALL 0x16F
02F6  120A     BCF PCLATH, 0x4
02F7  118A     BCF PCLATH, 0x3
239:                               haycambio = 0;
02F8  1683     BSF STATUS, 0x5
02F9  01AF     CLRF f
240:                           } else {
02FA  2D45     GOTO 0x545
241:                               sprintf(cadenaamostrar, "  :%02d    ", horarioactual.min);
02FB  30BA     MOVLW 0xBA
02FC  1283     BCF STATUS, 0x5
02FD  00AF     MOVWF f
02FE  3098     MOVLW 0x98
02FF  00B0     MOVWF c
0300  086A     MOVF 0x6A, W
0301  2B95     GOTO 0x395
242:                               sprintf(cadenaamostrar2, "             ");
243:                           }
244:                           break;
245:                       }
246:                       case SUBMENU_CONFIGURAMINUTOS:
0302  3069     MOVLW 0x69
247:                       {
248:                           modificafecha = MINUTOS;
0303  01EC     CLRF 0x6C
0304  0AEC     INCF 0x6C, F
249:                           horario = &horarioactual;
0302  3069     MOVLW 0x69
0305  00FD     MOVWF horario
250:                           if (flanco || haycambio) {
0306  08FC     MOVF flanco, F
0307  1D03     BTFSS STATUS, 0x2
0308  2ADD     GOTO 0x2DD
0309  082F     MOVF f, W
030A  1D03     BTFSS STATUS, 0x2
251:                               sprintf(cadenaamostrar, "%02d:%02d    ", horarioactual.hrs, horarioactual.min);
030B  2ADD     GOTO 0x2DD
252:                               sprintf(cadenaamostrar2, "             ");
253:                               haycambio = 0;
254:                           } else {
255:                               sprintf(cadenaamostrar, "%02d:      ", horarioactual.hrs);
030C  30AE     MOVLW 0xAE
030D  1283     BCF STATUS, 0x5
030E  00AF     MOVWF f
030F  3098     MOVLW 0x98
0310  00B0     MOVWF c
0311  086B     MOVF 0x6B, W
0312  2B95     GOTO 0x395
256:                               sprintf(cadenaamostrar2, "             ");
257:                           }
258:                           break;
259:                       }
260:                       case MENU_CONFIGURAFECHA:
261:                       {
262:           
263:                           if (flanco) {
0313  087C     MOVF flanco, W
0314  1903     BTFSC STATUS, 0x2
0315  2D45     GOTO 0x545
264:                               sprintf(cadenaamostrar, "SET FECHA");
0316  3019     MOVLW 0x19
0317  1283     BCF STATUS, 0x5
0318  00AF     MOVWF f
0319  3099     MOVLW 0x99
031A  2BF3     GOTO 0x3F3
265:                               sprintf(cadenaamostrar2, "             ");
266:                           }
267:                           break;
268:                       }
269:                       case SUBMENU_CONFIGURADIA:
270:                       {
271:                           modificafecha = DIA;
031B  3002     MOVLW 0x2
031C  00EC     MOVWF 0x6C
272:           
273:                           if (flanco || haycambio) {
031D  08FC     MOVF flanco, F
031E  1903     BTFSC STATUS, 0x2
031F  082F     MOVF f, W
0320  1D03     BTFSS STATUS, 0x2
274:                               sprintf(cadenaamostrar, "%02d/%02d/%02d ", fecha.day, fecha.month, fecha.yr);
0321  2B41     GOTO 0x341
275:                               sprintf(cadenaamostrar2, "             ");
276:                               haycambio = 0;
277:                           } else {
278:                               sprintf(cadenaamostrar, "  /%02d/%02d ", fecha.month, fecha.yr);
0322  30A0     MOVLW 0xA0
0323  1283     BCF STATUS, 0x5
0324  00AF     MOVWF f
0325  3098     MOVLW 0x98
0326  00B0     MOVWF c
0327  0866     MOVF 0x66, W
0328  2B36     GOTO 0x336
279:                               sprintf(cadenaamostrar2, "             ");
280:                           }
281:                           break;
282:                       }
283:                       case SUBMENU_CONFIGURAMES:
284:                       {
285:                           modificafecha = MES;
0329  3003     MOVLW 0x3
032A  00EC     MOVWF 0x6C
286:           
287:                           if (flanco || haycambio) {
032B  08FC     MOVF flanco, F
032C  1903     BTFSC STATUS, 0x2
032D  082F     MOVF f, W
032E  1D03     BTFSS STATUS, 0x2
288:                               sprintf(cadenaamostrar, "%02d/%02d/%02d ", fecha.day, fecha.month, fecha.yr);
032F  2B41     GOTO 0x341
289:                               sprintf(cadenaamostrar2, "             ");
290:                               haycambio = 0;
291:                           } else {
292:                               sprintf(cadenaamostrar, "%02d/  /%02d ", fecha.day, fecha.yr);
0330  3092     MOVLW 0x92
0331  1283     BCF STATUS, 0x5
0332  00AF     MOVWF f
0333  3098     MOVLW 0x98
0334  00B0     MOVWF c
0335  0865     MOVF fecha, W
0336  00B1     MOVWF 0x31
0337  01B2     CLRF 0x32
0338  0867     MOVF 0x67, W
0339  2B5A     GOTO 0x35A
293:                               sprintf(cadenaamostrar2, "             ");
294:                           }
295:                           break;
296:                       }
297:                       case SUBMENU_CONFIGURAANIO:
298:                       {
299:                           modificafecha = ANIO;
033A  3004     MOVLW 0x4
033B  00EC     MOVWF 0x6C
300:           
301:                           if (flanco || haycambio) {
033C  08FC     MOVF flanco, F
033D  1903     BTFSC STATUS, 0x2
033E  082F     MOVF f, W
033F  1903     BTFSC STATUS, 0x2
0340  2B51     GOTO 0x351
302:                               sprintf(cadenaamostrar, "%02d/%02d/%02d ", fecha.day, fecha.month, fecha.yr);
0341  304A     MOVLW 0x4A
0342  1283     BCF STATUS, 0x5
0343  00AF     MOVWF f
0344  3098     MOVLW 0x98
0345  00B0     MOVWF c
0346  0865     MOVF fecha, W
0347  00B1     MOVWF 0x31
0348  01B2     CLRF 0x32
0349  0866     MOVF 0x66, W
034A  00B3     MOVWF 0x33
034B  01B4     CLRF sign
034C  0867     MOVF 0x67, W
034D  00B5     MOVWF exp2
034E  30B5     MOVLW 0xB5
034F  01B6     CLRF exp1
0350  2AE9     GOTO 0x2E9
303:                               sprintf(cadenaamostrar2, "             ");
304:                               haycambio = 0;
305:                           } else {
306:                               sprintf(cadenaamostrar, "%02d/%02d/   ", fecha.day, fecha.month);
0351  3084     MOVLW 0x84
0352  1283     BCF STATUS, 0x5
0353  00AF     MOVWF f
0354  3098     MOVLW 0x98
0355  00B0     MOVWF c
0356  0865     MOVF fecha, W
0357  00B1     MOVWF 0x31
0358  01B2     CLRF 0x32
0359  0866     MOVF 0x66, W
035A  00B3     MOVWF 0x33
035B  30B5     MOVLW 0xB5
035C  01B4     CLRF sign
035D  2BF5     GOTO 0x3F5
307:                               sprintf(cadenaamostrar2, "             ");
308:                           }
309:                           break;
310:                       }
311:                       case MENU_CONFIGURAENCENDIDO:
312:                       {
313:           
314:                           if (flanco) {
035E  087C     MOVF flanco, W
035F  1903     BTFSC STATUS, 0x2
0360  2D45     GOTO 0x545
315:                               sprintf(cadenaamostrar, "SET ENC  ");
0361  30F1     MOVLW 0xF1
0362  1283     BCF STATUS, 0x5
0363  00AF     MOVWF f
0364  3098     MOVLW 0x98
0365  2BF3     GOTO 0x3F3
316:                               sprintf(cadenaamostrar2, "             ");
317:                           }
318:           
319:                           break;
320:                       }
321:                       case SUBMENU_CONFIGURAHORAENCENDIDO:
322:                       {
323:                           modificafecha = HORA;
0366  30D5     MOVLW 0xD5
0367  01EC     CLRF 0x6C
324:                           horario = &horarioenc;
0366  30D5     MOVLW 0xD5
0368  00FD     MOVWF horario
325:                           if (flanco || haycambio) {
0369  08FC     MOVF flanco, F
036A  1903     BTFSC STATUS, 0x2
036B  082F     MOVF f, W
036C  1D03     BTFSS STATUS, 0x2
036D  2B7F     GOTO 0x37F
326:                               sprintf(cadenaamostrar, "%02d:%02d    ", horarioenc.hrs, horarioenc.min);
327:                               sprintf(cadenaamostrar2, "             ");
328:                               haycambio = 0;
329:                           } else {
330:                               sprintf(cadenaamostrar, "  :%02d    ", horarioenc.min);
036E  30BA     MOVLW 0xBA
036F  1283     BCF STATUS, 0x5
0370  00AF     MOVWF f
0371  3098     MOVLW 0x98
0372  00B0     MOVWF c
0373  1683     BSF STATUS, 0x5
0374  0856     MOVF f3, W
0375  2B94     GOTO 0x394
331:                               sprintf(cadenaamostrar2, "             ");
332:                           }
333:           
334:                           break;
335:                       }
336:                       case SUBMENU_CONFIGURAMINUTOSENCENDIDO:
0376  30D5     MOVLW 0xD5
337:                       {
338:                           modificafecha = MINUTOS;
0377  01EC     CLRF 0x6C
0378  0AEC     INCF 0x6C, F
339:                           horario = &horarioenc;
0376  30D5     MOVLW 0xD5
0379  00FD     MOVWF horario
340:                           if (flanco || haycambio) {
037A  08FC     MOVF flanco, F
037B  1903     BTFSC STATUS, 0x2
037C  082F     MOVF f, W
037D  1903     BTFSC STATUS, 0x2
037E  2B8D     GOTO 0x38D
341:                               sprintf(cadenaamostrar, "%02d:%02d    ", horarioenc.hrs, horarioenc.min);
037F  3076     MOVLW 0x76
0380  1283     BCF STATUS, 0x5
0381  00AF     MOVWF f
0382  3098     MOVLW 0x98
0383  00B0     MOVWF c
0384  1683     BSF STATUS, 0x5
0385  0857     MOVF 0x57, W
0386  1283     BCF STATUS, 0x5
0387  00B1     MOVWF 0x31
0388  01B2     CLRF 0x32
0389  1683     BSF STATUS, 0x5
038A  0856     MOVF f3, W
038B  1283     BCF STATUS, 0x5
038C  2AE6     GOTO 0x2E6
342:                               sprintf(cadenaamostrar2, "             ");
343:                               haycambio = 0;
344:                           } else {
345:                               sprintf(cadenaamostrar, "%02d:      ", horarioenc.hrs);
038D  30AE     MOVLW 0xAE
038E  1283     BCF STATUS, 0x5
038F  00AF     MOVWF f
0390  3098     MOVLW 0x98
0391  00B0     MOVWF c
0392  1683     BSF STATUS, 0x5
0393  0857     MOVF 0x57, W
0394  1283     BCF STATUS, 0x5
0395  00B1     MOVWF 0x31
0396  30B5     MOVLW 0xB5
0397  01B2     CLRF 0x32
0398  2BF5     GOTO 0x3F5
346:                               sprintf(cadenaamostrar2, "             ");
347:                           }
348:                           break;
349:                       }
350:           
351:                       case SUBMENU_CONFIGURATIEMPOENCENDIDO:
352:                       {
353:                           modificafecha = TIEMPOENCENDIDO;
0399  3007     MOVLW 0x7
039A  00EC     MOVWF 0x6C
354:           
355:                           if (flanco || haycambio) {
039B  08FC     MOVF flanco, F
039C  1903     BTFSC STATUS, 0x2
039D  082F     MOVF f, W
039E  1903     BTFSC STATUS, 0x2
039F  2BA8     GOTO 0x3A8
356:                               sprintf(cadenaamostrar, "ENCEN:%02d", tiempoencendido);
03A0  30DC     MOVLW 0xDC
03A1  1283     BCF STATUS, 0x5
03A2  00AF     MOVWF f
03A3  3098     MOVLW 0x98
03A4  00B0     MOVWF c
03A5  1683     BSF STATUS, 0x5
03A6  0833     MOVF 0x33, W
03A7  2BD3     GOTO 0x3D3
357:                               sprintf(cadenaamostrar2, "             ");
358:                               haycambio = 0;
359:                           } else {
360:                               sprintf(cadenaamostrar, "ENCEN:  ");
03A8  303E     MOVLW 0x3E
03A9  1283     BCF STATUS, 0x5
03AA  00AF     MOVWF f
03AB  3099     MOVLW 0x99
03AC  2BF3     GOTO 0x3F3
361:                               sprintf(cadenaamostrar2, "             ");
362:                           }
363:                           break;
364:                       }
365:                       case SUBMENU_CONFIGURAREPITECADA12HORAS:
366:                       {
367:                           modificafecha = SINO;
03AD  3006     MOVLW 0x6
03AE  00EC     MOVWF 0x6C
368:           
369:                           if (flanco)
03AF  087C     MOVF flanco, W
03B0  1903     BTFSC STATUS, 0x2
03B1  2BBF     GOTO 0x3BF
370:                               if (banderasino) {
03B2  082B     MOVF day, W
03B3  1903     BTFSC STATUS, 0x2
03B4  2BBA     GOTO 0x3BA
371:                                   sprintf(cadenaamostrar, "REPIT SI");
03B5  3047     MOVLW 0x47
03B6  1283     BCF STATUS, 0x5
03B7  00AF     MOVWF f
03B8  3099     MOVLW 0x99
03B9  2BF3     GOTO 0x3F3
372:                                   sprintf(cadenaamostrar2, "             ");
373:                               } else {
374:                                   sprintf(cadenaamostrar, "REPIT NO");
03BA  3050     MOVLW 0x50
03BB  1283     BCF STATUS, 0x5
03BC  00AF     MOVWF f
03BD  3099     MOVLW 0x99
03BE  2BF3     GOTO 0x3F3
375:                                   sprintf(cadenaamostrar2, "             ");
376:                               } else {
377:                               sprintf(cadenaamostrar, "REPIT   ");
03BF  302C     MOVLW 0x2C
03C0  1283     BCF STATUS, 0x5
03C1  00AF     MOVWF f
03C2  3099     MOVLW 0x99
03C3  2BF3     GOTO 0x3F3
378:                               sprintf(cadenaamostrar2, "             ");
379:                           }
380:                           break;
381:                       }
382:                       case MENU_CONFIGURAFALLACORRIENTE:
383:                       {
384:                           modificafecha = SINO;
03C4  2BDD     GOTO 0x3DD
385:           
386:                           if (flanco)
387:                               if (banderasino) {
388:                                   sprintf(cadenaamostrar, "NORMAL A ");
389:                                   sprintf(cadenaamostrar2, "             ");
390:                               } else {
391:                                   sprintf(cadenaamostrar, "NORMAL C ");
392:                                   sprintf(cadenaamostrar2, "             ");
393:                               } else {
394:                               sprintf(cadenaamostrar, "NORMAL   ");
395:                               sprintf(cadenaamostrar2, "             ");
396:                           }
397:                           break;
398:                       }
399:                       case MENU_CONFIGURATIEMPOFALLACORRIENTE:
400:                       {
401:                           modificafecha = TIEMPOFALLA;
03C5  3008     MOVLW 0x8
03C6  00EC     MOVWF 0x6C
402:           
403:                           if (flanco || haycambio) {
03C7  08FC     MOVF flanco, F
03C8  1903     BTFSC STATUS, 0x2
03C9  082F     MOVF f, W
03CA  1903     BTFSC STATUS, 0x2
03CB  2BD8     GOTO 0x3D8
404:                               sprintf(cadenaamostrar, "FALLA:%02d", tiempofalla);
03CC  30D1     MOVLW 0xD1
03CD  1283     BCF STATUS, 0x5
03CE  00AF     MOVWF f
03CF  3098     MOVLW 0x98
03D0  00B0     MOVWF c
03D1  1683     BSF STATUS, 0x5
03D2  0834     MOVF sign, W
03D3  1283     BCF STATUS, 0x5
03D4  00B1     MOVWF 0x31
03D5  30B5     MOVLW 0xB5
03D6  01B2     CLRF 0x32
03D7  2AE9     GOTO 0x2E9
405:                               sprintf(cadenaamostrar2, "             ");
406:                               haycambio = 0;
407:                           } else {
408:                               sprintf(cadenaamostrar, "FALLA:  ");
03D8  3035     MOVLW 0x35
03D9  1283     BCF STATUS, 0x5
03DA  00AF     MOVWF f
03DB  3099     MOVLW 0x99
03DC  2BF3     GOTO 0x3F3
409:                               sprintf(cadenaamostrar2, "             ");
410:                           }
411:                           break;
412:                       }
413:                       case MENU_CONFIGURAINDICACIONDENIVEL:
414:                       {
415:                           modificafecha = SINO;
03DD  3006     MOVLW 0x6
03DE  00EC     MOVWF 0x6C
416:           
417:           
418:                           if (flanco)
03DF  087C     MOVF flanco, W
03E0  1903     BTFSC STATUS, 0x2
03E1  2BEF     GOTO 0x3EF
419:                               if (banderasino) {
03E2  082B     MOVF day, W
03E3  1903     BTFSC STATUS, 0x2
03E4  2BEA     GOTO 0x3EA
420:                                   sprintf(cadenaamostrar, "NORMAL A ");
03E5  30FB     MOVLW 0xFB
03E6  1283     BCF STATUS, 0x5
03E7  00AF     MOVWF f
03E8  3098     MOVLW 0x98
03E9  2BF3     GOTO 0x3F3
421:                                   sprintf(cadenaamostrar2, "             ");
422:                               } else {
423:                                   sprintf(cadenaamostrar, "NORMAL C ");
03EA  300F     MOVLW 0xF
03EB  1283     BCF STATUS, 0x5
03EC  00AF     MOVWF f
03ED  3099     MOVLW 0x99
03EE  2BF3     GOTO 0x3F3
424:                                   sprintf(cadenaamostrar2, "             ");
425:                               } else {
426:                               sprintf(cadenaamostrar, "NORMAL   ");
03EF  30E7     MOVLW 0xE7
03F0  1283     BCF STATUS, 0x5
03F1  00AF     MOVWF f
03F2  3098     MOVLW 0x98
03F3  00B0     MOVWF c
03F4  30B5     MOVLW 0xB5
03F5  120A     BCF PCLATH, 0x4
03F6  158A     BSF PCLATH, 0x3
03F7  216F     CALL 0x16F
03F8  120A     BCF PCLATH, 0x4
03F9  118A     BCF PCLATH, 0x3
427:                               sprintf(cadenaamostrar2, "             ");
03FA  305A     MOVLW 0x5A
03FB  00AF     MOVWF f
03FC  3098     MOVLW 0x98
03FD  00B0     MOVWF c
03FE  2D28     GOTO 0x528
428:                           }
429:           
430:                           break;
431:                       }
432:                       case MENU_MUESTRAMEDICIONES:
433:                       {
434:                           unsigned int adcenteroI;
435:                           unsigned int adcdecimalI;
436:                           unsigned int adcenteroV;
437:                           mediciondecorriente = (float) medidaI_adc * 50 / 1024;
03FF  1283     BCF STATUS, 0x5
0400  3080     MOVLW 0x80
0401  01CC     CLRF day
0402  00CD     MOVWF 0x4D
0403  3044     MOVLW 0x44
0404  00CE     MOVWF 0x4E
0405  3048     MOVLW 0x48
0406  01BD     CLRF flag
0407  00BE     MOVWF width
0408  3042     MOVLW 0x42
0409  00BF     MOVWF 0x3F
040A  1683     BSF STATUS, 0x5
040B  0824     MOVF dato, W
040C  1283     BCF STATUS, 0x5
040D  00B1     MOVWF 0x31
040E  1683     BSF STATUS, 0x5
040F  0823     MOVF x, W
0410  1283     BCF STATUS, 0x5
0411  00B0     MOVWF c
0412  120A     BCF PCLATH, 0x4
0413  118A     BCF PCLATH, 0x3
0414  25F9     CALL 0x5F9
0415  120A     BCF PCLATH, 0x4
0416  118A     BCF PCLATH, 0x3
0417  0830     MOVF c, W
0418  00C0     MOVWF c
0419  0831     MOVF 0x31, W
041A  00C1     MOVWF _val
041B  0832     MOVF 0x32, W
041C  00C2     MOVWF 0x42
041D  120A     BCF PCLATH, 0x4
041E  118A     BCF PCLATH, 0x3
041F  2687     CALL 0x687
0420  120A     BCF PCLATH, 0x4
0421  118A     BCF PCLATH, 0x3
0422  083D     MOVF flag, W
0423  00CF     MOVWF f1
0424  083E     MOVF width, W
0425  00D0     MOVWF 0x50
0426  083F     MOVF 0x3F, W
0427  00D1     MOVWF 0x51
0428  120A     BCF PCLATH, 0x4
0429  118A     BCF PCLATH, 0x3
042A  261F     CALL 0x61F
042B  120A     BCF PCLATH, 0x4
042C  118A     BCF PCLATH, 0x3
042D  084C     MOVF day, W
042E  1683     BSF STATUS, 0x5
042F  00A0     MOVWF 0x20
0430  1283     BCF STATUS, 0x5
0431  084D     MOVF 0x4D, W
0432  1683     BSF STATUS, 0x5
0433  00A1     MOVWF 0x21
0434  1283     BCF STATUS, 0x5
0435  084E     MOVF 0x4E, W
0436  1683     BSF STATUS, 0x5
0437  00A2     MOVWF 0x22
438:                           float mediciondevoltaje = (float) medidaV_adc * 440 / 1024;
0438  1283     BCF STATUS, 0x5
0439  3080     MOVLW 0x80
043A  01CC     CLRF day
043B  00CD     MOVWF 0x4D
043C  3044     MOVLW 0x44
043D  00CE     MOVWF 0x4E
043E  30DC     MOVLW 0xDC
043F  01BD     CLRF flag
0440  00BE     MOVWF width
0441  3043     MOVLW 0x43
0442  00BF     MOVWF 0x3F
0443  1683     BSF STATUS, 0x5
0444  0826     MOVF x, W
0445  1283     BCF STATUS, 0x5
0446  00B1     MOVWF 0x31
0447  1683     BSF STATUS, 0x5
0448  0825     MOVF y, W
0449  1283     BCF STATUS, 0x5
044A  00B0     MOVWF c
044B  120A     BCF PCLATH, 0x4
044C  118A     BCF PCLATH, 0x3
044D  25F9     CALL 0x5F9
044E  120A     BCF PCLATH, 0x4
044F  118A     BCF PCLATH, 0x3
0450  0830     MOVF c, W
0451  00C0     MOVWF c
0452  0831     MOVF 0x31, W
0453  00C1     MOVWF _val
0454  0832     MOVF 0x32, W
0455  00C2     MOVWF 0x42
0456  120A     BCF PCLATH, 0x4
0457  118A     BCF PCLATH, 0x3
0458  2687     CALL 0x687
0459  120A     BCF PCLATH, 0x4
045A  118A     BCF PCLATH, 0x3
045B  083D     MOVF flag, W
045C  00CF     MOVWF f1
045D  083E     MOVF width, W
045E  00D0     MOVWF 0x50
045F  083F     MOVF 0x3F, W
0460  00D1     MOVWF 0x51
0461  120A     BCF PCLATH, 0x4
0462  118A     BCF PCLATH, 0x3
0463  261F     CALL 0x61F
0464  120A     BCF PCLATH, 0x4
0465  118A     BCF PCLATH, 0x3
0466  084C     MOVF day, W
0467  1683     BSF STATUS, 0x5
0468  00DB     MOVWF NLinea
0469  1283     BCF STATUS, 0x5
046A  084D     MOVF 0x4D, W
046B  1683     BSF STATUS, 0x5
046C  00DC     MOVWF activapor
046D  1283     BCF STATUS, 0x5
046E  084E     MOVF 0x4E, W
046F  1683     BSF STATUS, 0x5
0470  00DD     MOVWF cambio_de_canal
439:                           adcenteroI = (unsigned int) mediciondecorriente;
0471  0820     MOVF 0x20, W
0472  1283     BCF STATUS, 0x5
0473  00A3     MOVWF x
0474  1683     BSF STATUS, 0x5
0475  0821     MOVF 0x21, W
0476  1283     BCF STATUS, 0x5
0477  00A4     MOVWF dato
0478  1683     BSF STATUS, 0x5
0479  0822     MOVF 0x22, W
047A  1283     BCF STATUS, 0x5
047B  00A5     MOVWF y
047C  160A     BSF PCLATH, 0x4
047D  118A     BCF PCLATH, 0x3
047E  25AC     CALL 0x5AC
047F  120A     BCF PCLATH, 0x4
0480  118A     BCF PCLATH, 0x3
0481  0824     MOVF dato, W
0482  1683     BSF STATUS, 0x5
0483  00E2     MOVWF cuentaminutos
0484  1283     BCF STATUS, 0x5
0485  0823     MOVF x, W
0486  1683     BSF STATUS, 0x5
0487  00E1     MOVWF cuentahoras
440:                           adcdecimalI = (unsigned int) ((mediciondecorriente - (unsigned int) mediciondecorriente)*10);
0488  0820     MOVF 0x20, W
0489  1283     BCF STATUS, 0x5
048A  00BA     MOVWF idx
048B  1683     BSF STATUS, 0x5
048C  0821     MOVF 0x21, W
048D  1283     BCF STATUS, 0x5
048E  00BB     MOVWF prec
048F  1683     BSF STATUS, 0x5
0490  0822     MOVF 0x22, W
0491  1283     BCF STATUS, 0x5
0492  00BC     MOVWF ap
0493  1683     BSF STATUS, 0x5
0494  0820     MOVF 0x20, W
0495  1283     BCF STATUS, 0x5
0496  00A3     MOVWF x
0497  1683     BSF STATUS, 0x5
0498  0821     MOVF 0x21, W
0499  1283     BCF STATUS, 0x5
049A  00A4     MOVWF dato
049B  1683     BSF STATUS, 0x5
049C  0822     MOVF 0x22, W
049D  1283     BCF STATUS, 0x5
049E  00A5     MOVWF y
049F  160A     BSF PCLATH, 0x4
04A0  118A     BCF PCLATH, 0x3
04A1  25AC     CALL 0x5AC
04A2  120A     BCF PCLATH, 0x4
04A3  118A     BCF PCLATH, 0x3
04A4  0824     MOVF dato, W
04A5  00B1     MOVWF 0x31
04A6  0823     MOVF x, W
04A7  00B0     MOVWF c
04A8  120A     BCF PCLATH, 0x4
04A9  118A     BCF PCLATH, 0x3
04AA  25F9     CALL 0x5F9
04AB  120A     BCF PCLATH, 0x4
04AC  118A     BCF PCLATH, 0x3
04AD  0830     MOVF c, W
04AE  00B7     MOVWF f2
04AF  0831     MOVF 0x31, W
04B0  00B8     MOVWF 0x38
04B1  0832     MOVF 0x32, W
04B2  00B9     MOVWF 0x39
04B3  120A     BCF PCLATH, 0x4
04B4  118A     BCF PCLATH, 0x3
04B5  2609     CALL 0x609
04B6  120A     BCF PCLATH, 0x4
04B7  118A     BCF PCLATH, 0x3
04B8  0837     MOVF f2, W
04B9  00C0     MOVWF c
04BA  0838     MOVF 0x38, W
04BB  00C1     MOVWF _val
04BC  0839     MOVF 0x39, W
04BD  00C2     MOVWF 0x42
04BE  3020     MOVLW 0x20
04BF  01BD     CLRF flag
04C0  00BE     MOVWF width
04C1  3041     MOVLW 0x41
04C2  00BF     MOVWF 0x3F
04C3  120A     BCF PCLATH, 0x4
04C4  118A     BCF PCLATH, 0x3
04C5  2687     CALL 0x687
04C6  120A     BCF PCLATH, 0x4
04C7  118A     BCF PCLATH, 0x3
04C8  083D     MOVF flag, W
04C9  1683     BSF STATUS, 0x5
04CA  00DE     MOVWF cuenta40ms
04CB  1283     BCF STATUS, 0x5
04CC  083E     MOVF width, W
04CD  1683     BSF STATUS, 0x5
04CE  00DF     MOVWF cuenta500ms
04CF  1283     BCF STATUS, 0x5
04D0  083F     MOVF 0x3F, W
04D1  1683     BSF STATUS, 0x5
04D2  00E0     MOVWF cuentadias
04D3  085E     MOVF cuenta40ms, W
04D4  1283     BCF STATUS, 0x5
04D5  00A3     MOVWF x
04D6  1683     BSF STATUS, 0x5
04D7  085F     MOVF cuenta500ms, W
04D8  1283     BCF STATUS, 0x5
04D9  00A4     MOVWF dato
04DA  1683     BSF STATUS, 0x5
04DB  0860     MOVF cuentadias, W
04DC  1283     BCF STATUS, 0x5
04DD  00A5     MOVWF y
04DE  160A     BSF PCLATH, 0x4
04DF  118A     BCF PCLATH, 0x3
04E0  25AC     CALL 0x5AC
04E1  120A     BCF PCLATH, 0x4
04E2  118A     BCF PCLATH, 0x3
04E3  0824     MOVF dato, W
04E4  1683     BSF STATUS, 0x5
04E5  00E4     MOVWF maximodia
04E6  1283     BCF STATUS, 0x5
04E7  0823     MOVF x, W
04E8  1683     BSF STATUS, 0x5
04E9  00E3     MOVWF cuentasegundos
441:                           adcenteroV = (unsigned int) mediciondevoltaje;
04EA  085B     MOVF NLinea, W
04EB  1283     BCF STATUS, 0x5
04EC  00A3     MOVWF x
04ED  1683     BSF STATUS, 0x5
04EE  085C     MOVF activapor, W
04EF  1283     BCF STATUS, 0x5
04F0  00A4     MOVWF dato
04F1  1683     BSF STATUS, 0x5
04F2  085D     MOVF cambio_de_canal, W
04F3  1283     BCF STATUS, 0x5
04F4  00A5     MOVWF y
04F5  160A     BSF PCLATH, 0x4
04F6  118A     BCF PCLATH, 0x3
04F7  25AC     CALL 0x5AC
04F8  120A     BCF PCLATH, 0x4
04F9  118A     BCF PCLATH, 0x3
04FA  0824     MOVF dato, W
04FB  1683     BSF STATUS, 0x5
04FC  00E6     MOVWF 0x66
04FD  1283     BCF STATUS, 0x5
04FE  0823     MOVF x, W
04FF  1683     BSF STATUS, 0x5
0500  00E5     MOVWF fecha
442:                           sprintf(cadenaamostrar, "%2u.%uA   ", (unsigned int) adcenteroI, (unsigned int) adcdecimalI);
0501  30C6     MOVLW 0xC6
0502  1283     BCF STATUS, 0x5
0503  00AF     MOVWF f
0504  3098     MOVLW 0x98
0505  00B0     MOVWF c
0506  1683     BSF STATUS, 0x5
0507  0862     MOVF cuentaminutos, W
0508  1283     BCF STATUS, 0x5
0509  00B2     MOVWF 0x32
050A  1683     BSF STATUS, 0x5
050B  0861     MOVF cuentahoras, W
050C  1283     BCF STATUS, 0x5
050D  00B1     MOVWF 0x31
050E  1683     BSF STATUS, 0x5
050F  0864     MOVF maximodia, W
0510  1283     BCF STATUS, 0x5
0511  00B4     MOVWF sign
0512  1683     BSF STATUS, 0x5
0513  0863     MOVF cuentasegundos, W
0514  1283     BCF STATUS, 0x5
0515  00B3     MOVWF 0x33
0516  30B5     MOVLW 0xB5
0517  120A     BCF PCLATH, 0x4
0518  158A     BSF PCLATH, 0x3
0519  216F     CALL 0x16F
051A  120A     BCF PCLATH, 0x4
051B  118A     BCF PCLATH, 0x3
443:                           sprintf(cadenaamostrar2, "%3uV    ", (unsigned int) adcenteroV);
051C  3023     MOVLW 0x23
051D  00AF     MOVWF f
051E  3099     MOVLW 0x99
051F  00B0     MOVWF c
0520  1683     BSF STATUS, 0x5
0521  0866     MOVF 0x66, W
0522  1283     BCF STATUS, 0x5
0523  00B2     MOVWF 0x32
0524  1683     BSF STATUS, 0x5
0525  0865     MOVF fecha, W
0526  1283     BCF STATUS, 0x5
0527  00B1     MOVWF 0x31
0528  30C5     MOVLW 0xC5
0529  120A     BCF PCLATH, 0x4
052A  158A     BSF PCLATH, 0x3
052B  216F     CALL 0x16F
052C  120A     BCF PCLATH, 0x4
052D  118A     BCF PCLATH, 0x3
444:                           break;
052E  1683     BSF STATUS, 0x5
052F  2D45     GOTO 0x545
445:                       }
446:                       default:
447:                           break;
448:                   };
449:           
450:           
451:                   switch (activabomba) {
0545  1683     BSF STATUS, 0x5
0546  0828     MOVF mth, W
0547  3A00     XORLW 0x0
0548  1903     BTFSC STATUS, 0x2
0549  2D42     GOTO 0x542
054A  3A01     XORLW 0x1
054B  1903     BTFSC STATUS, 0x2
054C  2D3F     GOTO 0x53F
054D  2D4E     GOTO 0x54E
452:                       case ENCIENDEBOMBA:
453:                       {
454:                           salidabomba = 1;
053F  1283     BCF STATUS, 0x5
0540  1407     BSF PORTC, 0x0
455:                           break;
0541  2D4E     GOTO 0x54E
456:                       }
457:                       case APAGABOMBA:
458:                       {
459:                           salidabomba = 0;
0542  1283     BCF STATUS, 0x5
0543  1007     BCF PORTC, 0x0
460:                           break;
0544  2D4E     GOTO 0x54E
461:                       }
462:                   }
463:                   switch (estadobomba) {
054E  1683     BSF STATUS, 0x5
054F  082C     MOVF dividend, W
0550  3A00     XORLW 0x0
0551  1903     BTFSC STATUS, 0x2
0552  2D57     GOTO 0x557
0553  3A01     XORLW 0x1
0554  1903     BTFSC STATUS, 0x2
0555  2D57     GOTO 0x557
0556  2D57     GOTO 0x557
464:                       case BOMBAAPAGADA:
465:                       {
466:           
467:                           break;
468:                       }
469:                       case BOMBAENCENDIDA:
470:                       {
471:           
472:                           break;
473:                       }
474:           
475:           
476:                   }
477:                   switch (estadonivel) {
0557  082E     MOVF f2, W
0558  3A00     XORLW 0x0
0559  1903     BTFSC STATUS, 0x2
055A  2D5F     GOTO 0x55F
055B  3A01     XORLW 0x1
055C  1903     BTFSC STATUS, 0x2
055D  2D5F     GOTO 0x55F
055E  2D5F     GOTO 0x55F
478:                       case NIVELNORMAL:
479:                       {
480:           
481:                           break;
482:                       }
483:                       case NIVELBAJO:
484:                       {
485:           
486:                           break;
487:                       }
488:                       default:
489:                           break;
490:                   }
491:           
492:                   switch (estadofalla) {
055F  082D     MOVF 0x2D, W
0560  3A00     XORLW 0x0
0561  1903     BTFSC STATUS, 0x2
0562  2D67     GOTO 0x567
0563  3A01     XORLW 0x1
0564  1903     BTFSC STATUS, 0x2
0565  2D67     GOTO 0x567
0566  2D67     GOTO 0x567
493:                       case CORRIENTENORMAL:
494:                       {
495:                           break;
496:                       }
497:                       case FALLACORRIENTE:
498:                       {
499:                           break;
500:                       }
501:           
502:                   }
503:                   //TODO borrAr esta linea
504:                   //refrescadisplay = 1;
505:                   if (refrescadisplay) {
0567  0832     MOVF 0x32, W
0568  1903     BTFSC STATUS, 0x2
0569  2DA7     GOTO 0x5A7
506:                       vGotoxyLCD(1, 1);
056A  1283     BCF STATUS, 0x5
056B  3001     MOVLW 0x1
056C  01A5     CLRF y
056D  0AA5     INCF y, F
056E  120A     BCF PCLATH, 0x4
056F  158A     BSF PCLATH, 0x3
0570  2015     CALL 0x15
0571  120A     BCF PCLATH, 0x4
0572  118A     BCF PCLATH, 0x3
507:                       char *cadena = &cadenaamostrar[0];
0573  30B5     MOVLW 0xB5
0574  1683     BSF STATUS, 0x5
0575  00EA     MOVWF 0x6A
508:                       while (*cadena != '\0')
0576  086A     MOVF 0x6A, W
0577  0084     MOVWF FSR
0578  1383     BCF STATUS, 0x7
0579  0880     MOVF INDF, F
057A  1903     BTFSC STATUS, 0x2
057B  2D88     GOTO 0x588
0587  2D76     GOTO 0x576
509:                           vLCD_Putc(*cadena++);
057C  086A     MOVF 0x6A, W
057D  0084     MOVWF FSR
057E  0800     MOVF INDF, W
057F  120A     BCF PCLATH, 0x4
0580  158A     BSF PCLATH, 0x3
0581  2035     CALL 0x35
0582  120A     BCF PCLATH, 0x4
0583  118A     BCF PCLATH, 0x3
0584  1683     BSF STATUS, 0x5
0585  1303     BCF STATUS, 0x6
0586  0AEA     INCF 0x6A, F
510:                       vGotoxyLCD(1, 2);
0588  3002     MOVLW 0x2
0589  1283     BCF STATUS, 0x5
058A  00A5     MOVWF y
058B  3001     MOVLW 0x1
058C  120A     BCF PCLATH, 0x4
058D  158A     BSF PCLATH, 0x3
058E  2015     CALL 0x15
058F  120A     BCF PCLATH, 0x4
0590  118A     BCF PCLATH, 0x3
511:                       char *cadena = &cadenaamostrar2[0];
0591  30C5     MOVLW 0xC5
0592  1683     BSF STATUS, 0x5
0593  00EA     MOVWF 0x6A
512:                       while (*cadena != '\0')
0594  086A     MOVF 0x6A, W
0595  0084     MOVWF FSR
0596  1383     BCF STATUS, 0x7
0597  0880     MOVF INDF, F
0598  1903     BTFSC STATUS, 0x2
0599  2DA6     GOTO 0x5A6
05A5  2D94     GOTO 0x594
513:                           vLCD_Putc(*cadena++);
059A  086A     MOVF 0x6A, W
059B  0084     MOVWF FSR
059C  0800     MOVF INDF, W
059D  120A     BCF PCLATH, 0x4
059E  158A     BSF PCLATH, 0x3
059F  2035     CALL 0x35
05A0  120A     BCF PCLATH, 0x4
05A1  118A     BCF PCLATH, 0x3
05A2  1683     BSF STATUS, 0x5
05A3  1303     BCF STATUS, 0x6
05A4  0AEA     INCF 0x6A, F
514:           
515:                       refrescadisplay = 0;
05A6  01B2     CLRF 0x32
516:                   }
517:           
518:                   //convierto el valor decimal a float
519:                   //para una entrada de 3.3V la lectura es 1023
520:                   //para 0 V la lectura es 0
521:                   //para una maxima lectura quiero que en el display se observe 50A
522:                   //como deseo que tambien me muetre los decimales.
523:                   //como la resolucion es 1024, cada bit corresponde a 50A/1024=0.048828125A
524:                   //cada 20 muestras tengo aproximdamente 1A
525:           
526:                   if (bandera_startglobal) {
05A7  082A     MOVF Data, W
05A8  1903     BTFSC STATUS, 0x2
05A9  2DAC     GOTO 0x5AC
527:                       bandera_grabafechay_hora = 1;
05AA  01A9     CLRF year
05AB  0AA9     INCF year, F
528:           
529:                   }
530:                   if (!bandera_startglobal && bandera_grabafechay_hora) {
05AC  08AA     MOVF Data, F
05AD  1D03     BTFSS STATUS, 0x2
05AE  2DF6     GOTO 0x5F6
05AF  0829     MOVF year, W
05B0  1903     BTFSC STATUS, 0x2
05B1  2DF6     GOTO 0x5F6
531:           
532:                       isl1208_set_date_time(&fecha.day, &fecha.month, &fecha.yr, &fecha.dow, (*horario).hrs, (*horario).min, 00);
05B2  3066     MOVLW 0x66
05B3  1283     BCF STATUS, 0x5
05B4  00C6     MOVWF mth
05B5  3067     MOVLW 0x67
05B6  00C7     MOVWF year
05B7  3068     MOVLW 0x68
05B8  00C8     MOVWF dow
05B9  087D     MOVF horario, W
05BA  3E02     ADDLW 0x2
05BB  0084     MOVWF FSR
05BC  1383     BCF STATUS, 0x7
05BD  0800     MOVF INDF, W
05BE  00C9     MOVWF hr
05BF  0A7D     INCF horario, W
05C0  0084     MOVWF FSR
05C1  0800     MOVF INDF, W
05C2  00CA     MOVWF min
05C3  3065     MOVLW 0x65
05C4  01CB     CLRF sec
05C5  160A     BSF PCLATH, 0x4
05C6  118A     BCF PCLATH, 0x3
05C7  26FF     CALL 0x6FF
05C8  120A     BCF PCLATH, 0x4
05C9  118A     BCF PCLATH, 0x3
533:                       bandera_grabafechay_hora = 0;
05CB  01A9     CLRF year
534:           
535:                   vGotoxyLCD(1, 2);
05CA  3002     MOVLW 0x2
05CC  1283     BCF STATUS, 0x5
05CD  00A5     MOVWF y
05CE  3001     MOVLW 0x1
05CF  120A     BCF PCLATH, 0x4
05D0  158A     BSF PCLATH, 0x3
05D1  2015     CALL 0x15
05D2  120A     BCF PCLATH, 0x4
05D3  118A     BCF PCLATH, 0x3
536:                       char *cadena = &cadenaamostrar[0];
05D4  30B5     MOVLW 0xB5
05D5  1683     BSF STATUS, 0x5
05D6  00E9     MOVWF horarioactual
537:                       while (*cadena != '\0')
05D7  0869     MOVF horarioactual, W
05D8  0084     MOVWF FSR
05D9  1383     BCF STATUS, 0x7
05DA  0880     MOVF INDF, F
05DB  1903     BTFSC STATUS, 0x2
05DC  2DE9     GOTO 0x5E9
05E8  2DD7     GOTO 0x5D7
538:                           vLCD_Putc(*cadena++);
05DD  0869     MOVF horarioactual, W
05DE  0084     MOVWF FSR
05DF  0800     MOVF INDF, W
05E0  120A     BCF PCLATH, 0x4
05E1  158A     BSF PCLATH, 0x3
05E2  2035     CALL 0x35
05E3  120A     BCF PCLATH, 0x4
05E4  118A     BCF PCLATH, 0x3
05E5  1683     BSF STATUS, 0x5
05E6  1303     BCF STATUS, 0x6
05E7  0AE9     INCF horarioactual, F
539:                       __delay_ms(500);
05E9  300D     MOVLW 0xD
05EA  00DA     MOVWF sign
05EB  30AF     MOVLW 0xAF
05EC  00D9     MOVWF exp
05ED  30C1     MOVLW 0xC1
05EE  00D8     MOVWF 0x58
05EF  0BD8     DECFSZ 0x58, F
05F0  2DEF     GOTO 0x5EF
05F1  0BD9     DECFSZ exp, F
05F2  2DEF     GOTO 0x5EF
05F3  0BDA     DECFSZ sign, F
05F4  2DEF     GOTO 0x5EF
05F5  0000     NOP
540:                   }
541:           
542:           
543:           
544:           
545:           
546:           
547:           
548:           
549:           
550:           
551:           
552:                   NOP();
05F6  0000     NOP
553:                   NOP();
05F7  0000     NOP
554:           
555:               }
556:           }
557:           
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/interrupts.c  -------------------------
1:             
2:             /******************************************************************************/
3:             /*Files to Include                                                            */
4:             /******************************************************************************/
5:             
6:             #if defined(__XC)
7:             #include <xc.h>         /* XC8 General Include File */
8:             #elif defined(HI_TECH_C)
9:             #include <htc.h>        /* HiTech General Include File */
10:            #endif
11:            #include <stdbool.h>        /* For true/false definition */
12:            #include <stdint.h>
13:            #include "user.h"
14:            #include "system.h"
15:            
16:            #include "Pulsadores.h"
17:            #include "pwm.h"
18:            #include "adcPic16.h"
19:            /* Interrupt Routines                                                         */
20:            /******************************************************************************/
21:            
22:            /* Baseline devices don't have interrupts. Note that some PIC16's 
23:             * are baseline devices.  Unfortunately the baseline detection macro is 
24:             * _PIC12 */
25:            #ifndef _PIC18
26:            #ifndef _PIC12
27:            
28:            void interrupt isr(void) {
0004  00FE     MOVWF 0x7E
0005  0E03     SWAPF STATUS, W
0006  1283     BCF STATUS, 0x5
0007  1303     BCF STATUS, 0x6
0008  00A0     MOVWF 0x20
0009  0804     MOVF FSR, W
000A  00A1     MOVWF 0x21
000B  080A     MOVF PCLATH, W
000C  00A2     MOVWF 0x22
000D  120A     BCF PCLATH, 0x4
000E  158A     BSF PCLATH, 0x3
000F  2C39     GOTO 0x439
0010  120A     BCF PCLATH, 0x4
0011  118A     BCF PCLATH, 0x3
0012  2813     GOTO 0x13
29:                if (ADIF && ADIE) {
0C39  1F0C     BTFSS PIR1, 0x6
0C3A  2C5C     GOTO 0x45C
0C3B  1683     BSF STATUS, 0x5
0C3C  1F0C     BTFSS PIR1, 0x6
0C3D  2C5C     GOTO 0x45C
30:                    if (getADCChannel() == MIDECORRIENTE) {
0C3E  27DE     CALL 0x7DE
0C3F  120A     BCF PCLATH, 0x4
0C40  158A     BSF PCLATH, 0x3
0C41  3800     IORLW 0x0
0C42  1D03     BTFSS STATUS, 0x2
0C43  2C4D     GOTO 0x44D
31:                        medidaI_adc = adcRead();
0C44  279A     CALL 0x79A
0C45  120A     BCF PCLATH, 0x4
0C46  158A     BSF PCLATH, 0x3
0C47  0871     MOVF canal, W
0C48  00A4     MOVWF dato
0C49  0870     MOVF divisor, W
0C4A  00A3     MOVWF x
32:                        setADCChannel(MIDETENSION);
0C4B  3001     MOVLW 0x1
0C4C  2C55     GOTO 0x455
33:                    } else {
34:                        medidaV_adc = adcRead();
0C4D  279A     CALL 0x79A
0C4E  120A     BCF PCLATH, 0x4
0C4F  158A     BSF PCLATH, 0x3
0C50  0871     MOVF canal, W
0C51  00A6     MOVWF x
0C52  0870     MOVF divisor, W
0C53  00A5     MOVWF y
35:                        /*TODO debo realizar un promedio en las mediciones para filtrar las
36:                        variaciones rpidas de tensin*/
37:                        setADCChannel(MIDECORRIENTE);
0C54  3000     MOVLW 0x0
0C55  27F4     CALL 0x7F4
0C56  120A     BCF PCLATH, 0x4
0C57  158A     BSF PCLATH, 0x3
38:                    }
39:                    ADIF = 0;
0C58  130C     BCF PIR1, 0x6
40:                    cambio_de_canal = 1;
0C59  01DD     CLRF cambio_de_canal
0C5A  0ADD     INCF cambio_de_canal, F
41:                } else if (INTF && INTE) { // INTERRUPCION por EXT2 Clock Out --------------------------------------------
0C5B  2EC9     GOTO 0x6C9
0C5C  188B     BTFSC INTCON, 0x1
0C5D  1E0B     BTFSS INTCON, 0x4
0C5E  2C6C     GOTO 0x46C
42:                    if (INTEDG == 1) {
0C5F  1683     BSF STATUS, 0x5
0C60  1F01     BTFSS TMR0, 0x6
0C61  2C65     GOTO 0x465
43:                        //      ext_int_edge(2,H_TO_L);
44:                        INTEDG = 0;
0C62  1301     BCF TMR0, 0x6
45:                        flanco = 0;
0C63  01FC     CLRF flanco
46:                        //PORTEbits.RE0 = 1; //output_high(PIN_E0);
47:                    } else {
0C64  2C68     GOTO 0x468
48:                        //   ext_int_edge(2,L_TO_H);
49:                        INTEDG = 1;
0C65  1701     BSF TMR0, 0x6
50:                        flanco = 1;
0C66  01FC     CLRF flanco
0C67  0AFC     INCF flanco, F
51:                        // PORTEbits.RE0 = 0; //output_low(PIN_E0);
52:                        //      flanco=1;
53:            
54:                    }
55:                    refrescadisplay = 1;
0C68  01B2     CLRF 0x32
0C69  0AB2     INCF 0x32, F
56:                    INTF = 0;
0C6A  108B     BCF INTCON, 0x1
57:                } else if (T0IF && T0IE) {
0C6B  2EC9     GOTO 0x6C9
0C6C  190B     BTFSC INTCON, 0x2
0C6D  1E8B     BTFSS INTCON, 0x5
0C6E  2EC9     GOTO 0x6C9
58:            
59:                    //Interrupcion por desborde del timer0. Tal como esta configurado, se el timer desborda cada
60:                    //0.003264seg o sea 3.264 ms, por lo tanto para que pase alrededor de 0.5segundo, se debe entrar 150 veces
61:                    //como con un unsigned int no funciona uso unsigned char y solo hasta 150
62:                    //cada 3ms realizamos una conversion analogica para obtener la medida de corriente
63:                    if (cambio_de_canal)
0C6F  1283     BCF STATUS, 0x5
0C70  085D     MOVF cambio_de_canal, W
0C71  1903     BTFSC STATUS, 0x2
0C72  2C75     GOTO 0x475
64:                        cambio_de_canal = 0;
0C73  01DD     CLRF cambio_de_canal
0C74  2C78     GOTO 0x478
65:                    else
66:                        startADC();
0C75  27E5     CALL 0x7E5
0C76  120A     BCF PCLATH, 0x4
0C77  158A     BSF PCLATH, 0x3
67:                    if (cuenta40ms < 12) {
0C78  300C     MOVLW 0xC
0C79  025E     SUBWF cuenta40ms, W
0C7A  1803     BTFSC STATUS, 0x0
0C7B  2C7E     GOTO 0x47E
68:                        cuenta40ms++;
0C7C  0ADE     INCF cuenta40ms, F
69:                    } else {
0C7D  2CCF     GOTO 0x4CF
70:                        cuenta40ms = 0;
0C7E  01DE     CLRF cuenta40ms
71:                        if (activapor > 0) {
0C7F  085C     MOVF activapor, W
0C80  1903     BTFSC STATUS, 0x2
0C81  2C84     GOTO 0x484
72:                            activapor--;
0C82  03DC     DECF activapor, F
73:                        } else {
0C83  2C88     GOTO 0x488
74:                            buzzer_off();
0C84  27E7     CALL 0x7E7
0C85  120A     BCF PCLATH, 0x4
0C86  158A     BSF PCLATH, 0x3
75:                            activapor = 0;
0C87  01DC     CLRF activapor
76:                        }
77:                        if (cuenta500ms < 11) {
0C88  300B     MOVLW 0xB
0C89  025F     SUBWF cuenta500ms, W
0C8A  1803     BTFSC STATUS, 0x0
0C8B  2C8E     GOTO 0x48E
78:                            cuenta500ms++;
0C8C  0ADF     INCF cuenta500ms, F
79:            
80:            
81:                        } else {
0C8D  2CCF     GOTO 0x4CF
82:            
83:                            cuenta500ms = 0;
0C8E  3000     MOVLW 0x0
0C8F  01DF     CLRF cuenta500ms
84:                            flanco = !flanco;
0C8E  3000     MOVLW 0x0
0C90  08FC     MOVF flanco, F
0C91  1903     BTFSC STATUS, 0x2
0C92  3001     MOVLW 0x1
0C93  00FC     MOVWF flanco
85:                            refrescadisplay = 1;
0C94  1683     BSF STATUS, 0x5
0C96  01B2     CLRF 0x32
0C97  0AB2     INCF 0x32, F
86:                            if (cuentasegundos < 60) {
0C95  303C     MOVLW 0x3C
0C98  1283     BCF STATUS, 0x5
0C99  0263     SUBWF cuentasegundos, W
0C9A  1803     BTFSC STATUS, 0x0
0C9B  2C9E     GOTO 0x49E
87:            
88:                                cuentasegundos++;
0C9C  0AE3     INCF cuentasegundos, F
89:                            } else {
0C9D  2CCF     GOTO 0x4CF
90:                                //TODO quitar esto en la version final
91:                                TRISDbits.TRISD3 = 0;
0C9E  1683     BSF STATUS, 0x5
0C9F  1188     BCF PORTD, 0x3
92:                                PORTDbits.RD3 = !PORTDbits.RD3;
0CA0  1003     BCF STATUS, 0x0
0CA1  1283     BCF STATUS, 0x5
0CA2  1D88     BTFSS PORTD, 0x3
0CA3  1403     BSF STATUS, 0x0
0CA4  1C03     BTFSS STATUS, 0x0
0CA5  2CAA     GOTO 0x4AA
0CA6  1283     BCF STATUS, 0x5
0CA7  1303     BCF STATUS, 0x6
0CA8  1588     BSF PORTD, 0x3
0CA9  2CAD     GOTO 0x4AD
0CAA  1283     BCF STATUS, 0x5
0CAB  1303     BCF STATUS, 0x6
0CAC  1188     BCF PORTD, 0x3
93:                                //TODO quitar esto en la version final
94:                                salidabomba = !salidabomba;
0CAD  1003     BCF STATUS, 0x0
0CAE  1C07     BTFSS PORTC, 0x0
0CAF  1403     BSF STATUS, 0x0
0CB0  1C03     BTFSS STATUS, 0x0
0CB1  2CB6     GOTO 0x4B6
0CB2  1283     BCF STATUS, 0x5
0CB3  1303     BCF STATUS, 0x6
0CB4  1407     BSF PORTC, 0x0
0CB5  2CB9     GOTO 0x4B9
0CB6  1283     BCF STATUS, 0x5
0CB7  1303     BCF STATUS, 0x6
0CB8  1007     BCF PORTC, 0x0
95:                                cuentasegundos = 0;
0CB9  303C     MOVLW 0x3C
0CBA  01E3     CLRF cuentasegundos
96:                                if (cuentaminutos < 60) {
0CB9  303C     MOVLW 0x3C
0CBB  0262     SUBWF cuentaminutos, W
0CBC  1803     BTFSC STATUS, 0x0
0CBD  2CC0     GOTO 0x4C0
97:                                    cuentaminutos++;
0CBE  0AE2     INCF cuentaminutos, F
98:                                } else {
0CBF  2CCF     GOTO 0x4CF
99:                                    cuentaminutos = 0;
0CC0  3018     MOVLW 0x18
0CC1  01E2     CLRF cuentaminutos
100:                                   if (cuentahoras < 24) {
0CC0  3018     MOVLW 0x18
0CC2  0261     SUBWF cuentahoras, W
0CC3  1803     BTFSC STATUS, 0x0
0CC4  2CC7     GOTO 0x4C7
101:                                       cuentahoras++;
0CC5  0AE1     INCF cuentahoras, F
102:                                   } else
0CC6  2CC8     GOTO 0x4C8
103:                                       cuentahoras = 0;
0CC7  01E1     CLRF cuentahoras
104:                                   if (cuentadias < 30) {
0CC8  301E     MOVLW 0x1E
0CC9  0260     SUBWF cuentadias, W
0CCA  1803     BTFSC STATUS, 0x0
0CCB  2CCE     GOTO 0x4CE
105:                                       cuentadias++;
0CCC  0AE0     INCF cuentadias, F
106:                                   } else {
0CCD  2CCF     GOTO 0x4CF
107:                                       cuentadias = 0;
0CCE  01E0     CLRF cuentadias
108:                                   }
109:                               }
110:           
111:                           }
112:                       }
113:                   }
114:           
115:           
116:                   //interrupcion_pulsadores();
117:                   static char maximodia;
118:                   //TODO calculo de los segundos y minutos que pasaron
119:           
120:           
121:                   if (Pulsacion(0, BOTON_Subir, CON_REPETICION, LOGICA_INVERSA)) {
0CCF  3000     MOVLW 0x0
0CD0  1886     BTFSC PORTB, 0x1
0CD1  3001     MOVLW 0x1
0CD2  00F5     MOVWF Pin
0CD3  3000     MOVLW 0x0
0CD4  01F6     CLRF TipoPin
0CD5  0AF6     INCF TipoPin, F
0CD6  01F7     CLRF Logica
0CD7  0AF7     INCF Logica, F
0CD8  26D4     CALL 0x6D4
0CD9  120A     BCF PCLATH, 0x4
0CDA  158A     BSF PCLATH, 0x3
0CDB  3A00     XORLW 0x0
0CDC  1903     BTFSC STATUS, 0x2
0CDD  2DB2     GOTO 0x5B2
122:           
123:                       refrescadisplay = 1;
0CDE  1683     BSF STATUS, 0x5
0CDF  1303     BCF STATUS, 0x6
0CE0  01B2     CLRF 0x32
0CE1  0AB2     INCF 0x32, F
124:                       switch (modificafecha) {
0CE2  2D5B     GOTO 0x55B
0D5B  086C     MOVF 0x6C, W
0D5C  0084     MOVWF FSR
0D5D  3009     MOVLW 0x9
0D5E  0204     SUBWF FSR, W
0D5F  1803     BTFSC STATUS, 0x0
0D60  2D68     GOTO 0x568
0D61  3010     MOVLW 0x10
0D62  008A     MOVWF PCLATH
0D63  1003     BCF STATUS, 0x0
0D64  0D04     RLF FSR, W
0D65  0704     ADDWF FSR, W
0D66  3E36     ADDLW 0x36
0D67  0082     MOVWF PCL
1036  120A     BCF PCLATH, 0x4
1037  158A     BSF PCLATH, 0x3
1038  2CF4     GOTO 0x4F4
1039  120A     BCF PCLATH, 0x4
103A  158A     BSF PCLATH, 0x3
103B  2CE3     GOTO 0x4E3
103C  120A     BCF PCLATH, 0x4
103D  158A     BSF PCLATH, 0x3
103E  2D0E     GOTO 0x50E
103F  120A     BCF PCLATH, 0x4
1040  158A     BSF PCLATH, 0x3
1041  2D1C     GOTO 0x51C
1042  120A     BCF PCLATH, 0x4
1043  158A     BSF PCLATH, 0x3
1044  2D2A     GOTO 0x52A
1045  120A     BCF PCLATH, 0x4
1046  158A     BSF PCLATH, 0x3
1047  2D68     GOTO 0x568
1048  120A     BCF PCLATH, 0x4
1049  158A     BSF PCLATH, 0x3
104A  2D39     GOTO 0x539
104B  120A     BCF PCLATH, 0x4
104C  158A     BSF PCLATH, 0x3
104D  2D3F     GOTO 0x53F
104E  120A     BCF PCLATH, 0x4
104F  158A     BSF PCLATH, 0x3
1050  2D4D     GOTO 0x54D
125:                           case MINUTOS:
126:                               haycambio = 1;
0CE3  01AF     CLRF f
0CE4  0AAF     INCF f, F
127:                               if ((*horario).min < 59) (*horario).min++;
0CE5  0A7D     INCF horario, W
0CE6  0084     MOVWF FSR
0CE7  303B     MOVLW 0x3B
0CE8  1383     BCF STATUS, 0x7
0CE9  0200     SUBWF INDF, W
0CEA  0A7D     INCF horario, W
0CEC  1C03     BTFSS STATUS, 0x0
0CED  2D01     GOTO 0x501
128:                               else
129:                                   if ((*horario).min == 59) (*horario).min = 0;
0CEB  0084     MOVWF FSR
0CEE  0800     MOVF INDF, W
0CEF  3A3B     XORLW 0x3B
0CF0  1D03     BTFSS STATUS, 0x2
0CF1  2D68     GOTO 0x568
0CF2  0A7D     INCF horario, W
0CF3  2D0B     GOTO 0x50B
130:                               break;
131:                           case HORA:
132:                               haycambio = 1;
0CF4  01AF     CLRF f
0CF5  0AAF     INCF f, F
133:                               if ((*horario).hrs < 23) (*horario).hrs++;
0CF6  087D     MOVF horario, W
0CF7  3E02     ADDLW 0x2
0CF8  0084     MOVWF FSR
0CF9  3017     MOVLW 0x17
0CFA  1383     BCF STATUS, 0x7
0CFB  0200     SUBWF INDF, W
0CFC  087D     MOVF horario, W
0CFD  1803     BTFSC STATUS, 0x0
0CFE  2D03     GOTO 0x503
0CFF  3E02     ADDLW 0x2
0D00  0084     MOVWF FSR
0D01  0A80     INCF INDF, F
0D02  2D68     GOTO 0x568
134:                               else
135:                                   if ((*horario).hrs == 23) (*horario).hrs = 0;
0D03  3E02     ADDLW 0x2
0D04  0084     MOVWF FSR
0D05  0800     MOVF INDF, W
0D06  3A17     XORLW 0x17
0D07  1D03     BTFSS STATUS, 0x2
0D08  2D68     GOTO 0x568
0D09  087D     MOVF horario, W
0D0A  3E02     ADDLW 0x2
0D0B  0084     MOVWF FSR
0D0C  0180     CLRF INDF
0D0D  2D68     GOTO 0x568
136:                               break;
137:                           case DIA:
138:                               haycambio = 1;
0D0E  01AF     CLRF f
0D0F  0AAF     INCF f, F
139:                               if (fecha.day < maximodia) fecha.day++;
0D10  1283     BCF STATUS, 0x5
0D11  0864     MOVF maximodia, W
0D12  0265     SUBWF fecha, W
0D13  1C03     BTFSS STATUS, 0x0
0D14  2D1A     GOTO 0x51A
140:                               else
141:                                   if (fecha.day == maximodia) fecha.day = 1;
0D15  0865     MOVF fecha, W
0D16  0664     XORWF maximodia, W
0D17  1D03     BTFSS STATUS, 0x2
0D18  2D68     GOTO 0x568
0D19  01E5     CLRF fecha
0D1A  0AE5     INCF fecha, F
0D1B  2D68     GOTO 0x568
142:                               break;
143:                           case MES:
0D1C  300C     MOVLW 0xC
144:                               haycambio = 1;
0D1D  01AF     CLRF f
0D1E  0AAF     INCF f, F
145:                               if (fecha.month < 12) fecha.month++;
0D1C  300C     MOVLW 0xC
0D1F  1283     BCF STATUS, 0x5
0D20  0266     SUBWF 0x66, W
0D21  1C03     BTFSS STATUS, 0x0
0D22  2D28     GOTO 0x528
146:                               else
147:                                   if (fecha.month == 12) fecha.month = 1;
0D23  0866     MOVF 0x66, W
0D24  3A0C     XORLW 0xC
0D25  1D03     BTFSS STATUS, 0x2
0D26  2D68     GOTO 0x568
0D27  01E6     CLRF 0x66
0D28  0AE6     INCF 0x66, F
0D29  2D68     GOTO 0x568
148:                               break;
149:                           case ANIO:
0D2A  3063     MOVLW 0x63
150:                               haycambio = 1;
0D2B  01AF     CLRF f
0D2C  0AAF     INCF f, F
151:                               if (fecha.yr < 99) fecha.yr++; //solamente vamos hasta el ao 00
0D2A  3063     MOVLW 0x63
0D2D  1283     BCF STATUS, 0x5
0D2E  0267     SUBWF 0x67, W
0D2F  1803     BTFSC STATUS, 0x0
0D30  2D33     GOTO 0x533
0D31  0AE7     INCF 0x67, F
0D32  2D68     GOTO 0x568
152:                               else
153:                                   if (fecha.yr == 99) fecha.yr = 0; //solamente contamos desde el ao 99
0D33  0867     MOVF 0x67, W
0D34  3A63     XORLW 0x63
0D35  1D03     BTFSS STATUS, 0x2
0D36  2D68     GOTO 0x568
0D37  01E7     CLRF 0x67
0D38  2D68     GOTO 0x568
154:                               break;
155:                           case SINO:
156:                               banderasino = !banderasino;
0D39  3000     MOVLW 0x0
0D3A  08AB     MOVF day, F
0D3B  1903     BTFSC STATUS, 0x2
0D3C  3001     MOVLW 0x1
0D3D  00AB     MOVWF day
157:                               break;
0D3E  2D68     GOTO 0x568
158:                           case TIEMPOENCENDIDO:
0D3F  303C     MOVLW 0x3C
159:                               haycambio = 1;
0D40  01AF     CLRF f
0D41  0AAF     INCF f, F
160:                               if (tiempoencendido < TIEMPOMAXIMOENCENDIDO) tiempoencendido++; //
0D3F  303C     MOVLW 0x3C
0D42  0233     SUBWF 0x33, W
0D43  1803     BTFSC STATUS, 0x0
0D44  2D47     GOTO 0x547
0D45  0AB3     INCF 0x33, F
0D46  2D68     GOTO 0x568
161:                               else
162:                                   if (tiempoencendido == TIEMPOMAXIMOENCENDIDO) tiempoencendido = 0;
0D47  0833     MOVF 0x33, W
0D48  3A3C     XORLW 0x3C
0D49  1D03     BTFSS STATUS, 0x2
0D4A  2D68     GOTO 0x568
0D4B  01B3     CLRF 0x33
0D4C  2D68     GOTO 0x568
163:                               break;
164:                           case TIEMPOFALLA:
0D4D  301E     MOVLW 0x1E
165:                               haycambio = 1;
0D4E  01AF     CLRF f
0D4F  0AAF     INCF f, F
166:                               if (tiempofalla < TIEMPOMAXIMOFALLA) tiempofalla++; //
0D4D  301E     MOVLW 0x1E
0D50  0234     SUBWF sign, W
0D51  1803     BTFSC STATUS, 0x0
0D52  2D55     GOTO 0x555
0D53  0AB4     INCF sign, F
0D54  2D68     GOTO 0x568
167:                               else
168:                                   if (tiempofalla == TIEMPOMAXIMOFALLA) tiempofalla = 0;
0D55  0834     MOVF sign, W
0D56  3A1E     XORLW 0x1E
0D57  1D03     BTFSS STATUS, 0x2
0D58  2D68     GOTO 0x568
0D59  01B4     CLRF sign
0D5A  2D68     GOTO 0x568
169:                               break;
170:           
171:                           default:
172:                               break;
173:                       }
174:                       if (aniobisiesto(fecha.yr) && fecha.month == 2) {
0D68  1283     BCF STATUS, 0x5
0D69  0867     MOVF 0x67, W
0D6A  27A1     CALL 0x7A1
0D6B  120A     BCF PCLATH, 0x4
0D6C  158A     BSF PCLATH, 0x3
0D6D  0877     MOVF Logica, W
0D6E  0476     IORWF TipoPin, W
0D6F  1903     BTFSC STATUS, 0x2
0D70  2D77     GOTO 0x577
0D71  0866     MOVF 0x66, W
0D72  3A02     XORLW 0x2
0D73  1D03     BTFSS STATUS, 0x2
0D74  2D77     GOTO 0x577
175:                           maximodia = 29;
0D75  301D     MOVLW 0x1D
0D76  2D7C     GOTO 0x57C
176:                       } else if (fecha.month == 2)
0D77  0866     MOVF 0x66, W
0D78  3A02     XORLW 0x2
0D79  1D03     BTFSS STATUS, 0x2
0D7A  2D7D     GOTO 0x57D
177:                           maximodia = 28;
0D7B  301C     MOVLW 0x1C
0D7C  00E4     MOVWF maximodia
178:                       if (fecha.month == 4 || fecha.month == 6 || fecha.month == 9 || fecha.month == 11) {
0D7D  0866     MOVF 0x66, W
0D7E  3A04     XORLW 0x4
0D7F  1903     BTFSC STATUS, 0x2
0D80  2D8D     GOTO 0x58D
0D81  0866     MOVF 0x66, W
0D82  3A06     XORLW 0x6
0D83  1903     BTFSC STATUS, 0x2
0D84  2D8D     GOTO 0x58D
0D85  0866     MOVF 0x66, W
0D86  3A09     XORLW 0x9
0D87  1903     BTFSC STATUS, 0x2
0D88  2D8D     GOTO 0x58D
0D89  0866     MOVF 0x66, W
0D8A  3A0B     XORLW 0xB
0D8B  1D03     BTFSS STATUS, 0x2
0D8C  2D8F     GOTO 0x58F
179:                           maximodia = 30;
0D8D  301E     MOVLW 0x1E
0D8E  00E4     MOVWF maximodia
180:                       }
181:                       if (fecha.month == 1 || fecha.month == 3 || fecha.month == 5 || fecha.month == 7 || fecha.month == 8 || fecha.month == 10 || fecha.month == 12) {
0D8F  0366     DECF 0x66, W
0D90  1903     BTFSC STATUS, 0x2
0D91  2DAA     GOTO 0x5AA
0D92  0866     MOVF 0x66, W
0D93  3A03     XORLW 0x3
0D94  1903     BTFSC STATUS, 0x2
0D95  2DAA     GOTO 0x5AA
0D96  0866     MOVF 0x66, W
0D97  3A05     XORLW 0x5
0D98  1903     BTFSC STATUS, 0x2
0D99  2DAA     GOTO 0x5AA
0D9A  0866     MOVF 0x66, W
0D9B  3A07     XORLW 0x7
0D9C  1903     BTFSC STATUS, 0x2
0D9D  2DAA     GOTO 0x5AA
0D9E  0866     MOVF 0x66, W
0D9F  3A08     XORLW 0x8
0DA0  1903     BTFSC STATUS, 0x2
0DA1  2DAA     GOTO 0x5AA
0DA2  0866     MOVF 0x66, W
0DA3  3A0A     XORLW 0xA
0DA4  1903     BTFSC STATUS, 0x2
0DA5  2DAA     GOTO 0x5AA
0DA6  0866     MOVF 0x66, W
0DA7  3A0C     XORLW 0xC
0DA8  1D03     BTFSS STATUS, 0x2
0DA9  2DAC     GOTO 0x5AC
182:                           maximodia = 31;
0DAA  301F     MOVLW 0x1F
0DAB  00E4     MOVWF maximodia
183:                       }
184:                       if (fecha.day > maximodia)
0DAC  0865     MOVF fecha, W
0DAD  0264     SUBWF maximodia, W
0DAE  1803     BTFSC STATUS, 0x0
0DAF  2DB2     GOTO 0x5B2
185:                           fecha.day = maximodia;
0DB0  0864     MOVF maximodia, W
0DB1  00E5     MOVWF fecha
186:                   }
187:                   if (Pulsacion(1, BOTON_Bajar, CON_REPETICION, LOGICA_INVERSA)) {
0DB2  3000     MOVLW 0x0
0DB3  1283     BCF STATUS, 0x5
0DB4  1303     BCF STATUS, 0x6
0DB5  1906     BTFSC PORTB, 0x2
0DB6  3001     MOVLW 0x1
0DB7  00F5     MOVWF Pin
0DB8  3001     MOVLW 0x1
0DB9  01F6     CLRF TipoPin
0DBA  0AF6     INCF TipoPin, F
0DBB  01F7     CLRF Logica
0DBC  0AF7     INCF Logica, F
0DBD  26D4     CALL 0x6D4
0DBE  120A     BCF PCLATH, 0x4
0DBF  158A     BSF PCLATH, 0x3
0DC0  3A00     XORLW 0x0
0DC1  1903     BTFSC STATUS, 0x2
0DC2  2E96     GOTO 0x696
188:           
189:                       refrescadisplay = 1;
0DC3  1683     BSF STATUS, 0x5
0DC4  1303     BCF STATUS, 0x6
0DC5  01B2     CLRF 0x32
0DC6  0AB2     INCF 0x32, F
190:                       switch (modificafecha) {
0DC7  2E3F     GOTO 0x63F
0E3F  086C     MOVF 0x6C, W
0E40  0084     MOVWF FSR
0E41  3009     MOVLW 0x9
0E42  0204     SUBWF FSR, W
0E43  1803     BTFSC STATUS, 0x0
0E44  2E4C     GOTO 0x64C
0E45  3010     MOVLW 0x10
0E46  008A     MOVWF PCLATH
0E47  1003     BCF STATUS, 0x0
0E48  0D04     RLF FSR, W
0E49  0704     ADDWF FSR, W
0E4A  3E51     ADDLW 0x51
0E4B  0082     MOVWF PCL
1051  120A     BCF PCLATH, 0x4
191:                           case MINUTOS:
192:                               haycambio = 1;
0DC8  01AF     CLRF f
0DC9  0AAF     INCF f, F
193:                               if ((*horario).min > 0) (*horario).min--;
0DCA  0A7D     INCF horario, W
0DCB  0084     MOVWF FSR
0DCC  1383     BCF STATUS, 0x7
0DCD  0880     MOVF INDF, F
0DCE  1903     BTFSC STATUS, 0x2
0DCF  2DD2     GOTO 0x5D2
0DD0  0A7D     INCF horario, W
0DD1  2DE6     GOTO 0x5E6
194:                               else
195:                                   if ((*horario).min == 0) (*horario).min = 59;
0DD2  0A7D     INCF horario, W
0DD3  0084     MOVWF FSR
0DD4  0880     MOVF INDF, F
0DD5  1D03     BTFSS STATUS, 0x2
0DD6  2E4C     GOTO 0x64C
0DD7  0A7D     INCF horario, W
0DD8  0084     MOVWF FSR
0DD9  303B     MOVLW 0x3B
0DDA  2DF3     GOTO 0x5F3
196:                               break;
197:                           case HORA:
198:                               haycambio = 1;
0DDB  01AF     CLRF f
0DDC  0AAF     INCF f, F
199:                               if ((*horario).hrs > 0) (*horario).hrs--;
0DDD  087D     MOVF horario, W
0DDE  3E02     ADDLW 0x2
0DDF  0084     MOVWF FSR
0DE0  1383     BCF STATUS, 0x7
0DE1  0880     MOVF INDF, F
0DE2  1903     BTFSC STATUS, 0x2
0DE3  2DE9     GOTO 0x5E9
0DE4  087D     MOVF horario, W
0DE5  3E02     ADDLW 0x2
0DE6  0084     MOVWF FSR
0DE7  0380     DECF INDF, F
0DE8  2E4C     GOTO 0x64C
200:                               else
201:                                   if ((*horario).hrs == 0) (*horario).hrs = 23;
0DE9  087D     MOVF horario, W
0DEA  3E02     ADDLW 0x2
0DEB  0084     MOVWF FSR
0DEC  0880     MOVF INDF, F
0DED  1D03     BTFSS STATUS, 0x2
0DEE  2E4C     GOTO 0x64C
0DEF  087D     MOVF horario, W
0DF0  3E02     ADDLW 0x2
0DF1  0084     MOVWF FSR
0DF2  3017     MOVLW 0x17
0DF3  0080     MOVWF INDF
0DF4  2E4C     GOTO 0x64C
202:                               break;
203:                           case DIA:
0DF5  3002     MOVLW 0x2
204:                               haycambio = 1;
0DF6  01AF     CLRF f
0DF7  0AAF     INCF f, F
205:                               if (fecha.day > 1) fecha.day--;
0DF5  3002     MOVLW 0x2
0DF8  1283     BCF STATUS, 0x5
0DF9  0265     SUBWF fecha, W
0DFA  1C03     BTFSS STATUS, 0x0
0DFB  2DFE     GOTO 0x5FE
0DFC  03E5     DECF fecha, F
0DFD  2E4C     GOTO 0x64C
206:                               else
207:                                   if (fecha.day == 1) fecha.day = maximodia;
0DFE  0B65     DECFSZ fecha, W
0DFF  2E4C     GOTO 0x64C
0E00  0864     MOVF maximodia, W
0E01  00E5     MOVWF fecha
0E02  2E4C     GOTO 0x64C
208:                               break;
209:                           case MES:
0E03  3002     MOVLW 0x2
210:                               haycambio = 1;
0E04  01AF     CLRF f
0E05  0AAF     INCF f, F
211:                               if (fecha.month > 1) fecha.month--;
0E03  3002     MOVLW 0x2
0E06  1283     BCF STATUS, 0x5
0E07  0266     SUBWF 0x66, W
0E08  1C03     BTFSS STATUS, 0x0
0E09  2E0C     GOTO 0x60C
0E0A  03E6     DECF 0x66, F
0E0B  2E4C     GOTO 0x64C
212:                               else
213:                                   if (fecha.month == 1) fecha.month = 12;
0E0C  0B66     DECFSZ 0x66, W
0E0D  2E4C     GOTO 0x64C
0E0E  300C     MOVLW 0xC
0E0F  00E6     MOVWF 0x66
0E10  2E4C     GOTO 0x64C
214:                               break;
215:                           case ANIO:
216:                               haycambio = 1;
0E11  01AF     CLRF f
0E12  0AAF     INCF f, F
217:                               if (fecha.yr > 0) fecha.yr--; //solamente vamos hasta el ao 00
0E13  1283     BCF STATUS, 0x5
0E14  0867     MOVF 0x67, W
0E15  1903     BTFSC STATUS, 0x2
0E16  2E19     GOTO 0x619
0E17  03E7     DECF 0x67, F
0E18  2E4C     GOTO 0x64C
218:                               else
219:                                   if (fecha.yr == 0) fecha.yr = 99; //solamente contamos desde el ao 99
0E19  08E7     MOVF 0x67, F
0E1A  1D03     BTFSS STATUS, 0x2
0E1B  2E4C     GOTO 0x64C
0E1C  3063     MOVLW 0x63
0E1D  00E7     MOVWF 0x67
0E1E  2E4C     GOTO 0x64C
220:                               break;
221:                           case SINO:
222:                               banderasino = !banderasino;
0E1F  3000     MOVLW 0x0
0E20  08AB     MOVF day, F
0E21  1903     BTFSC STATUS, 0x2
0E22  3001     MOVLW 0x1
0E23  00AB     MOVWF day
223:                               break;
0E24  2E4C     GOTO 0x64C
224:                           case TIEMPOENCENDIDO:
225:                               haycambio = 1;
0E25  01AF     CLRF f
0E26  0AAF     INCF f, F
226:                               if (tiempoencendido > 0) tiempoencendido--; //
0E27  0833     MOVF 0x33, W
0E28  1903     BTFSC STATUS, 0x2
0E29  2E2C     GOTO 0x62C
0E2A  03B3     DECF 0x33, F
0E2B  2E4C     GOTO 0x64C
227:                               else
228:                                   if (tiempoencendido == 0) tiempoencendido = TIEMPOMAXIMOENCENDIDO;
0E2C  08B3     MOVF 0x33, F
0E2D  1D03     BTFSS STATUS, 0x2
0E2E  2E4C     GOTO 0x64C
0E2F  303C     MOVLW 0x3C
0E30  00B3     MOVWF 0x33
0E31  2E4C     GOTO 0x64C
229:                               break;
230:                           case TIEMPOFALLA:
231:                               haycambio = 1;
0E32  01AF     CLRF f
0E33  0AAF     INCF f, F
232:                               if (tiempofalla > 0) tiempofalla--; //
0E34  0834     MOVF sign, W
0E35  1903     BTFSC STATUS, 0x2
0E36  2E39     GOTO 0x639
0E37  03B4     DECF sign, F
0E38  2E4C     GOTO 0x64C
233:                               else
234:                                   if (tiempofalla == 0) tiempofalla = TIEMPOMAXIMOFALLA;
0E39  08B4     MOVF sign, F
0E3A  1D03     BTFSS STATUS, 0x2
0E3B  2E4C     GOTO 0x64C
0E3C  301E     MOVLW 0x1E
0E3D  00B4     MOVWF sign
0E3E  2E4C     GOTO 0x64C
235:                               break;
236:                           default:
237:                               break;
238:                       }
239:                       if (aniobisiesto(fecha.yr) && fecha.month == 2) {
0E4C  1283     BCF STATUS, 0x5
0E4D  0867     MOVF 0x67, W
0E4E  27A1     CALL 0x7A1
0E4F  120A     BCF PCLATH, 0x4
0E50  158A     BSF PCLATH, 0x3
0E51  0877     MOVF Logica, W
0E52  0476     IORWF TipoPin, W
0E53  1903     BTFSC STATUS, 0x2
0E54  2E5B     GOTO 0x65B
0E55  0866     MOVF 0x66, W
0E56  3A02     XORLW 0x2
0E57  1D03     BTFSS STATUS, 0x2
0E58  2E5B     GOTO 0x65B
240:                           maximodia = 29;
0E59  301D     MOVLW 0x1D
0E5A  2E60     GOTO 0x660
241:                       } else if (fecha.month == 2)
0E5B  0866     MOVF 0x66, W
0E5C  3A02     XORLW 0x2
0E5D  1D03     BTFSS STATUS, 0x2
0E5E  2E61     GOTO 0x661
242:                           maximodia = 28;
0E5F  301C     MOVLW 0x1C
0E60  00E4     MOVWF maximodia
243:                       if (fecha.month == 4 || fecha.month == 6 || fecha.month == 9 || fecha.month == 11) {
0E61  0866     MOVF 0x66, W
0E62  3A04     XORLW 0x4
0E63  1903     BTFSC STATUS, 0x2
0E64  2E71     GOTO 0x671
0E65  0866     MOVF 0x66, W
0E66  3A06     XORLW 0x6
0E67  1903     BTFSC STATUS, 0x2
0E68  2E71     GOTO 0x671
0E69  0866     MOVF 0x66, W
0E6A  3A09     XORLW 0x9
0E6B  1903     BTFSC STATUS, 0x2
0E6C  2E71     GOTO 0x671
0E6D  0866     MOVF 0x66, W
0E6E  3A0B     XORLW 0xB
0E6F  1D03     BTFSS STATUS, 0x2
0E70  2E73     GOTO 0x673
244:                           maximodia = 30;
0E71  301E     MOVLW 0x1E
0E72  00E4     MOVWF maximodia
245:                       }
246:                       if (fecha.month == 1 || fecha.month == 3 || fecha.month == 5 || fecha.month == 7 || fecha.month == 8 || fecha.month == 10 || fecha.month == 12) {
0E73  0366     DECF 0x66, W
0E74  1903     BTFSC STATUS, 0x2
0E75  2E8E     GOTO 0x68E
0E76  0866     MOVF 0x66, W
0E77  3A03     XORLW 0x3
0E78  1903     BTFSC STATUS, 0x2
0E79  2E8E     GOTO 0x68E
0E7A  0866     MOVF 0x66, W
0E7B  3A05     XORLW 0x5
0E7C  1903     BTFSC STATUS, 0x2
0E7D  2E8E     GOTO 0x68E
0E7E  0866     MOVF 0x66, W
0E7F  3A07     XORLW 0x7
0E80  1903     BTFSC STATUS, 0x2
0E81  2E8E     GOTO 0x68E
0E82  0866     MOVF 0x66, W
0E83  3A08     XORLW 0x8
0E84  1903     BTFSC STATUS, 0x2
0E85  2E8E     GOTO 0x68E
0E86  0866     MOVF 0x66, W
0E87  3A0A     XORLW 0xA
0E88  1903     BTFSC STATUS, 0x2
0E89  2E8E     GOTO 0x68E
0E8A  0866     MOVF 0x66, W
0E8B  3A0C     XORLW 0xC
0E8C  1D03     BTFSS STATUS, 0x2
0E8D  2E90     GOTO 0x690
247:                           maximodia = 31;
0E8E  301F     MOVLW 0x1F
0E8F  00E4     MOVWF maximodia
248:                       }
249:                       if (fecha.day > maximodia)
0E90  0865     MOVF fecha, W
0E91  0264     SUBWF maximodia, W
0E92  1803     BTFSC STATUS, 0x0
0E93  2E96     GOTO 0x696
250:                           fecha.day = maximodia;
0E94  0864     MOVF maximodia, W
0E95  00E5     MOVWF fecha
251:                   }
252:           
253:                   //bandera_modificaglobal=0;
254:                   /*  if (Pulsacion(3, Modifica, SIN_REPETICION, LOGICA_INVERSA)) {
255:                          refrescadisplay = 1;
256:                         if (modificafecha < ANIO)
257:                             modificafecha = modificafecha + 1;
258:                         else
259:                             modificafecha = HORA;
260:                         //bandera_modificaglobal=1;
261:           
262:                     }*/
263:           
264:                   bandera_startglobal = 0;
0E96  1683     BSF STATUS, 0x5
0E97  1303     BCF STATUS, 0x6
0E99  01AA     CLRF Data
265:                   if (Pulsacion(3, BOTON_ONOFF, INMEDIATO, LOGICA_INVERSA)) {
0E98  3000     MOVLW 0x0
0E9A  1283     BCF STATUS, 0x5
0E9B  1A86     BTFSC PORTB, 0x5
0E9C  3001     MOVLW 0x1
0E9D  00F5     MOVWF Pin
0E9E  3002     MOVLW 0x2
0E9F  00F6     MOVWF TipoPin
0EA0  3003     MOVLW 0x3
0EA1  01F7     CLRF Logica
0EA2  0AF7     INCF Logica, F
0EA3  26D4     CALL 0x6D4
0EA4  120A     BCF PCLATH, 0x4
0EA5  158A     BSF PCLATH, 0x3
0EA6  3A00     XORLW 0x0
0EA7  1903     BTFSC STATUS, 0x2
0EA8  2EAD     GOTO 0x6AD
266:           
267:                       bandera_startglobal = 1;
0EA9  1683     BSF STATUS, 0x5
0EAA  1303     BCF STATUS, 0x6
0EAB  01AA     CLRF Data
0EAC  0AAA     INCF Data, F
268:                   }
269:           
270:                   if (Pulsacion(4, BOTON_MENU, SIN_REPETICION/*INMEDIATO*/, LOGICA_INVERSA)) {
0EAD  3000     MOVLW 0x0
0EAE  1283     BCF STATUS, 0x5
0EAF  1303     BCF STATUS, 0x6
0EB0  1986     BTFSC PORTB, 0x3
0EB1  3001     MOVLW 0x1
0EB2  00F5     MOVWF Pin
0EB3  3004     MOVLW 0x4
0EB4  01F6     CLRF TipoPin
0EB5  01F7     CLRF Logica
0EB6  0AF7     INCF Logica, F
0EB7  26D4     CALL 0x6D4
0EB8  120A     BCF PCLATH, 0x4
0EB9  158A     BSF PCLATH, 0x3
0EBA  3A00     XORLW 0x0
0EBB  1903     BTFSC STATUS, 0x2
0EBC  2EC8     GOTO 0x6C8
271:           
272:                       buzzer_on();
0EBD  27EB     CALL 0x7EB
0EBE  120A     BCF PCLATH, 0x4
0EBF  158A     BSF PCLATH, 0x3
273:                       if (menuactual < ULTIMOMENU)
0EC0  3011     MOVLW 0x11
0EC1  1683     BSF STATUS, 0x5
0EC2  0231     SUBWF 0x31, W
0EC3  1803     BTFSC STATUS, 0x0
0EC4  2EC7     GOTO 0x6C7
274:                           menuactual++;
0EC5  0AB1     INCF 0x31, F
0EC6  2EC8     GOTO 0x6C8
275:                       else
276:                           menuactual = 0;
0EC7  01B1     CLRF 0x31
277:                   }
278:                   INTCONbits.T0IF = 0;
0EC8  110B     BCF INTCON, 0x2
279:               } else {
280:                   ///interrupciones no contempladas
281:               }
282:           
283:               /* This code stub shows general interrupt handling.  Note that these
284:               conditional statements are not handled within 3 seperate if blocks.
285:               Do not use a seperate if block for each interrupt flag to avoid run
286:               time errors. */
287:           
288:           #if 0
289:           
290:               /* Add interrupt routine code here. */
291:           
292:               /* Determine which flag generated the interrupt */
293:               if (<Interrupt Flag 1 >) {
294:                   <Interrupt Flag 1 = 0 >; /* Clear Interrupt Flag 1 */
295:               } else if (<Interrupt Flag 2 >) {
296:                   <Interrupt Flag 2 = 0 >; /* Clear Interrupt Flag 2 */
297:               } else {
298:                   /* Unhandled interrupts */
299:               }
300:           
301:           #endif
302:           
303:           }
0EC9  1283     BCF STATUS, 0x5
304:           #endif
305:           
306:           
307:           #endif
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/adcPic16.c  ---------------------------
1:             #include <xc.h>
2:             #include <stdint.h>
3:             #include <stdbool.h>
4:             #include "system.h"
5:             #include "user.h"
6:             #include "adcPic16.h"
7:             
8:             void setADCChannel(char canal) {
0FF4  00F1     MOVWF canal
152A  1283     BCF STATUS, 0x5
152B  00A4     MOVWF dato
9:                 ADCON0bits.CHS = canal; //Selecciono el canal AD0
0FF5  00F0     MOVWF divisor
0FF6  0DF0     RLF divisor, F
0FF7  0DF0     RLF divisor, F
0FF8  0DF0     RLF divisor, F
0FF9  1283     BCF STATUS, 0x5
0FFA  081F     MOVF ADCON0, W
0FFB  0670     XORWF divisor, W
0FFC  39C7     ANDLW 0xC7
0FFD  0670     XORWF divisor, W
0FFE  009F     MOVWF ADCON0
152C  00A3     MOVWF x
152D  0DA3     RLF x, F
152E  0DA3     RLF x, F
152F  0DA3     RLF x, F
1530  081F     MOVF ADCON0, W
1531  0623     XORWF x, W
1532  39C7     ANDLW 0xC7
1533  0623     XORWF x, W
1534  009F     MOVWF ADCON0
10:            };
0FFF  0008     RETURN
1535  0008     RETURN
11:            
12:            char getADCChannel(void) {
13:                return ADCON0bits.CHS; //Selecciono el canal AD0
0FDE  1283     BCF STATUS, 0x5
0FDF  0C1F     RRF ADCON0, W
0FE0  00F0     MOVWF divisor
0FE1  0CF0     RRF divisor, F
0FE2  0C70     RRF divisor, W
0FE3  3907     ANDLW 0x7
14:            };
0FE4  0008     RETURN
15:            
16:            void openADC(void) {
17:            
18:                TRISA0 = 1; //configuro como entrada para el ADC0
0800  1683     BSF STATUS, 0x5
0801  1303     BCF STATUS, 0x6
0802  1405     BSF PORTA, 0x0
19:                TRISA1 = 1; //configuro como entrada para el ADC1
0803  1485     BSF PORTA, 0x1
20:                TRISA3 = 1; //Configuro como entrada para Vref+
0804  1585     BSF PORTA, 0x3
21:                TRISA2 = 0; //No usado
0805  1105     BCF PORTA, 0x2
22:                TRISA4 = 0;//No usado
0806  1205     BCF PORTA, 0x4
23:                TRISA5 = 0;//No usado
0807  1285     BCF PORTA, 0x5
24:                ADCON1bits.PCFG = 0b101; //An3 como VREF+ , AN0 y AN1 como entrada analogica, AN0 Corriente, AN1 Tension de red
0808  081F     MOVF ADCON0, W
0809  39F0     ANDLW 0xF0
080A  3805     IORLW 0x5
080B  009F     MOVWF ADCON0
25:                ADCON1bits.ADFM = 1; //justificado a la derecha
080C  179F     BSF ADCON0, 0x7
26:                ADCON1bits.ADCS2 = 1;
080D  171F     BSF ADCON0, 0x6
27:                ADCON0bits.ADCS = 0b10; //Tosc/64
080E  1283     BCF STATUS, 0x5
080F  081F     MOVF ADCON0, W
0810  393F     ANDLW 0x3F
0811  3880     IORLW 0x80
0812  009F     MOVWF ADCON0
28:                ADCON0bits.ADON = 1; //Activo el ADC
0813  141F     BSF ADCON0, 0x0
29:            
30:            }
0814  0008     RETURN
31:            
32:            unsigned int adcRead(void) {
33:            
34:                return ((unsigned int) ADRESH << 8) | ADRESL;
0F9A  081E     MOVF ADRESH, W
0F9B  00F1     MOVWF canal
0F9C  01F0     CLRF divisor
0F9D  1683     BSF STATUS, 0x5
0F9E  081E     MOVF ADRESH, W
0F9F  04F0     IORWF divisor, F
35:            }
0FA0  0008     RETURN
36:            
37:            void startADC(void) {
38:                ADCON0bits.GO_DONE = 1;
0FE5  151F     BSF ADCON0, 0x2
39:            }
0FE6  0008     RETURN
40:            
41:            void interruptADC_on(void) {
42:                ADIE = 1;
150F  1683     BSF STATUS, 0x5
1510  1303     BCF STATUS, 0x6
1511  170C     BSF PIR1, 0x6
43:            }
1512  0008     RETURN
44:            
45:            void interruptADC_off(void) {
46:                ADIE = 0;
47:            }
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/_isl1208.c  ---------------------------
1:             ////////////////////////////////////////////////////////////////////////////////////////
2:             ///                               isl1208.C                                          ///
3:             ///                     Driver for Real Time Clock                                   ///
4:             ///                     modified by Pablo Fernando Manieri - Enero 2015              ///
5:             ///                                                                                  ///
6:             /// bool ISL1208_ready(void) - Testea si el RTC est presente                        ///
7:             /// void isl1208_init(val)                                                           ///
8:             ///                  - Enable oscillator without clearing the seconds register       ///
9:             ///                    used when PIC loses power and isl1208 run from 3V BAT         ///
10:            ///                  - Config Control Register with next parameters:                 ///
11:            ///                     isl1208_ALL_DISABLED          All disabled                   ///
12:            ///                     isl1208_OUT_ON_DISABLED_HIHG  Out to Hight on Disable Out    ///
13:            ///                     isl1208_OUT_ENABLED           Out Enabled                    ///
14:            ///                     isl1208_OUT_1_HZ              Freq. Out to 1 Hz              ///
15:            ///                     isl1208_OUT_4_KHZ             Freq. Out to 4.096 Khz         ///
16:            ///                     isl1208_OUT_8_KHZ             Freq. Out to 8.192 Khz         ///
17:            ///                     isl1208_OUT_32_KHZ            Freq. Out to 32.768 Khz        ///
18:            ///                                                                                  ///
19:            ///                     Example init:                                                ///
20:            ///                     isl1208_init(isl1208_ALL_DISABLED);                          ///
21:            ///                     isl1208_init(isl1208_OUT_ENABLED | isl1208_OUT_1_HZ);        ///
22:            ///                                                                                  ///
23:            /// void isl1208_set_date_time(day,mth,year,dow,hour,min,sec) - Set the date/time    ///
24:            ///                                                                                  ///
25:            /// void isl1208_get_date(day,mth,year,dow) - Get the date                           ///
26:            ///                                                                                  ///
27:            /// void isl1208_get_time(hr,min,sec) - Get the time                                 ///
28:            ///                                                                                  ///
29:            /// char isl1208_read_nvram_unsigned char(char addr) - Read unsigned char in address ///
30:            ///                                                                                  ///
31:            /// void isl1208_write_nvram_unsigned char(char addr, char value) - Write unsigned   ///
32:            ///                                                                  char in address ///
33:            ///                                                                                  ///
34:            /// void isl1208_get_day_of_week(char* ptr) - Get string Day Of Week                 ///
35:            ///                                                                                  ///
36:            ///                                                                                  ///
37:            ////////////////////////////////////////////////////////////////////////////////////////
38:            
39:            #include <xc.h>
40:            #include <stdio.h>
41:            #include <stdbool.h>       /* For true/false definition */
42:            #include "system.h"        /* System funct/params, like osc/peripheral config */
43:            #include "HardI2C.h"
44:            #include "_isl1208.h"
45:            #include "user.h"
46:            
47:            bool ISL1208_ready(void) {
48:                bool ack;
49:            
50:                start_i2c(); // If the write command is acknowledged,
161F  27A3     CALL 0x7A3
1620  160A     BSF PCLATH, 0x4
1621  118A     BCF PCLATH, 0x3
51:                ack = write_i2c(isl1208_Write); // then the device is ready.
1622  30DE     MOVLW 0xDE
1623  277A     CALL 0x77A
1624  160A     BSF PCLATH, 0x4
1625  118A     BCF PCLATH, 0x3
1626  1283     BCF STATUS, 0x5
1627  00A4     MOVWF dato
52:                stop_i2c();
1628  27AB     CALL 0x7AB
53:                return !ack; // Invert ACK returned so TRUE = ACK OK
1629  1283     BCF STATUS, 0x5
162A  3000     MOVLW 0x0
162B  08A4     MOVF dato, F
162C  1903     BTFSC STATUS, 0x2
162D  3001     MOVLW 0x1
54:            }
162E  0008     RETURN
55:            
56:            unsigned char ISL1208_Read_status(void) {
57:                char SR;
58:                start_i2c(); // If the write command is acknowledged,
162F  27A3     CALL 0x7A3
1630  160A     BSF PCLATH, 0x4
1631  118A     BCF PCLATH, 0x3
59:                write_i2c(isl1208_Write); // then the device is ready.
1632  30DE     MOVLW 0xDE
1633  277A     CALL 0x77A
1634  160A     BSF PCLATH, 0x4
1635  118A     BCF PCLATH, 0x3
60:                write_i2c(0x07);
1636  3007     MOVLW 0x7
1637  277A     CALL 0x77A
1638  160A     BSF PCLATH, 0x4
1639  118A     BCF PCLATH, 0x3
61:                rstart_i2c(); //TODO cambiado start por rstart
163A  27B3     CALL 0x7B3
163B  160A     BSF PCLATH, 0x4
163C  118A     BCF PCLATH, 0x3
62:                write_i2c(isl1208_Read);
163D  30DF     MOVLW 0xDF
163E  277A     CALL 0x77A
163F  160A     BSF PCLATH, 0x4
1640  118A     BCF PCLATH, 0x3
63:                SR = read_i2c(NOACK);
1641  3001     MOVLW 0x1
1642  26CB     CALL 0x6CB
1643  160A     BSF PCLATH, 0x4
1644  118A     BCF PCLATH, 0x3
1645  00A5     MOVWF y
64:                stop_i2c();
1646  27AB     CALL 0x7AB
65:                return SR;
1647  1283     BCF STATUS, 0x5
1648  0825     MOVF y, W
66:            }
1649  0008     RETURN
67:            
68:            void isl1208_init(unsigned char val) {
69:            
70:                unsigned char seconds = 0;
71:            
72:            #ifndef USE_INTERRUPTS
73:                //di();
74:            #endif
75:                //TODO Verificar secuencia correcta para pode escribir en el ISL1208
76:                start_i2c();
77:                I2Cstate = write_i2c(isl1208_Write);
78:                write_i2c(0x00);
79:                rstart_i2c();
80:                write_i2c(isl1208_Read);
81:                seconds = isl1208_bcd2bin(read_i2c(NOACK));
82:                stop_i2c();
83:                seconds &= 0x7F;
84:            
85:                __delay_us(3);
86:            
87:                start_i2c();
88:                write_i2c(isl1208_Write);
89:                write_i2c(0x00);
90:                write_i2c(isl1208_bin2bcd(seconds));
91:                stop_i2c();
92:                start_i2c();
93:                write_i2c(isl1208_Write);
94:                write_i2c(0x07);
95:                write_i2c(val);
96:                stop_i2c();
97:            
98:            #ifndef USE_INTERRUPTS
99:                //ei();
100:           #endif
101:           
102:           }
103:           
104:           void isl1208_set_date_time(unsigned char* day, unsigned char* mth, unsigned char* year, unsigned char* dow, unsigned char hr, unsigned char min, unsigned char sec) {
16FF  00CC     MOVWF day
105:           
106:           #ifndef USE_INTERRUPTS
107:               //di();
108:           #endif
109:           
110:               sec &= 0x7F;
1701  13CB     BCF sec, 0x7
111:              hr &= 0x3F;
1700  303F     MOVLW 0x3F
1702  05C9     ANDWF hr, F
112:               start_i2c();
1703  27A3     CALL 0x7A3
1704  160A     BSF PCLATH, 0x4
1705  118A     BCF PCLATH, 0x3
113:               write_i2c(isl1208_Write);
1706  30DE     MOVLW 0xDE
1707  277A     CALL 0x77A
1708  160A     BSF PCLATH, 0x4
1709  118A     BCF PCLATH, 0x3
114:               write_i2c(0x07);
170A  3007     MOVLW 0x7
170B  277A     CALL 0x77A
170C  160A     BSF PCLATH, 0x4
170D  118A     BCF PCLATH, 0x3
115:               write_i2c(0b00010000);
170E  3010     MOVLW 0x10
170F  277A     CALL 0x77A
1710  160A     BSF PCLATH, 0x4
1711  118A     BCF PCLATH, 0x3
116:               stop_i2c();
1712  27AB     CALL 0x7AB
1713  160A     BSF PCLATH, 0x4
1714  118A     BCF PCLATH, 0x3
117:              isl1208SR.Valor=ISL1208_Read_status();
1715  262F     CALL 0x62F
1716  1683     BSF STATUS, 0x5
1717  00B0     MOVWF c
118:           
119:               
120:               sprintf(cadenaamostrar, "%X   ",isl1208SR.Valor);
1718  3080     MOVLW 0x80
1719  1283     BCF STATUS, 0x5
171A  00AF     MOVWF f
171B  3099     MOVLW 0x99
171C  00B0     MOVWF c
171D  1683     BSF STATUS, 0x5
171E  0830     MOVF c, W
171F  1283     BCF STATUS, 0x5
1720  00B1     MOVWF 0x31
1721  30B5     MOVLW 0xB5
1722  01B2     CLRF 0x32
1723  120A     BCF PCLATH, 0x4
1724  158A     BSF PCLATH, 0x3
1725  216F     CALL 0x16F
1726  160A     BSF PCLATH, 0x4
1727  118A     BCF PCLATH, 0x3
121:           
122:           
123:           
124:           
125:               start_i2c();
1728  27A3     CALL 0x7A3
1729  160A     BSF PCLATH, 0x4
172A  118A     BCF PCLATH, 0x3
126:               I2Cstate = write_i2c(isl1208_Write);
172B  30DE     MOVLW 0xDE
172C  277A     CALL 0x77A
172D  160A     BSF PCLATH, 0x4
172E  118A     BCF PCLATH, 0x3
172F  1683     BSF STATUS, 0x5
1730  00A7     MOVWF i
127:               write_i2c(0x00);
1731  3000     MOVLW 0x0
1732  277A     CALL 0x77A
1733  160A     BSF PCLATH, 0x4
1734  118A     BCF PCLATH, 0x3
128:               write_i2c(isl1208_bin2bcd(sec));
1735  1283     BCF STATUS, 0x5
1736  084B     MOVF sec, W
1737  2792     CALL 0x792
1738  160A     BSF PCLATH, 0x4
1739  118A     BCF PCLATH, 0x3
173A  277A     CALL 0x77A
173B  160A     BSF PCLATH, 0x4
173C  118A     BCF PCLATH, 0x3
129:               write_i2c(isl1208_bin2bcd(min));
173D  1283     BCF STATUS, 0x5
173E  084A     MOVF min, W
173F  2792     CALL 0x792
1740  160A     BSF PCLATH, 0x4
1741  118A     BCF PCLATH, 0x3
1742  277A     CALL 0x77A
1743  160A     BSF PCLATH, 0x4
1744  118A     BCF PCLATH, 0x3
130:               write_i2c(isl1208_bin2bcd(hr));
1745  1283     BCF STATUS, 0x5
1746  0849     MOVF hr, W
1747  2792     CALL 0x792
1748  160A     BSF PCLATH, 0x4
1749  118A     BCF PCLATH, 0x3
174A  277A     CALL 0x77A
174B  160A     BSF PCLATH, 0x4
174C  118A     BCF PCLATH, 0x3
131:               write_i2c(isl1208_bin2bcd(*dow));
174D  1283     BCF STATUS, 0x5
174E  0848     MOVF dow, W
174F  0084     MOVWF FSR
1750  1383     BCF STATUS, 0x7
1751  0800     MOVF INDF, W
1752  2792     CALL 0x792
1753  160A     BSF PCLATH, 0x4
1754  118A     BCF PCLATH, 0x3
1755  277A     CALL 0x77A
1756  160A     BSF PCLATH, 0x4
1757  118A     BCF PCLATH, 0x3
132:               write_i2c(isl1208_bin2bcd(*day));
1758  1283     BCF STATUS, 0x5
1759  084C     MOVF day, W
175A  0084     MOVWF FSR
175B  1383     BCF STATUS, 0x7
175C  0800     MOVF INDF, W
175D  2792     CALL 0x792
175E  160A     BSF PCLATH, 0x4
175F  118A     BCF PCLATH, 0x3
1760  277A     CALL 0x77A
1761  160A     BSF PCLATH, 0x4
1762  118A     BCF PCLATH, 0x3
133:               write_i2c(isl1208_bin2bcd(*mth));
1763  1283     BCF STATUS, 0x5
1764  0846     MOVF mth, W
1765  0084     MOVWF FSR
1766  1383     BCF STATUS, 0x7
1767  0800     MOVF INDF, W
1768  2792     CALL 0x792
1769  160A     BSF PCLATH, 0x4
176A  118A     BCF PCLATH, 0x3
176B  277A     CALL 0x77A
176C  160A     BSF PCLATH, 0x4
176D  118A     BCF PCLATH, 0x3
134:               write_i2c(isl1208_bin2bcd(*year));
176E  1283     BCF STATUS, 0x5
176F  0847     MOVF year, W
1770  0084     MOVWF FSR
1771  1383     BCF STATUS, 0x7
1772  0800     MOVF INDF, W
1773  2792     CALL 0x792
1774  160A     BSF PCLATH, 0x4
1775  118A     BCF PCLATH, 0x3
1776  277A     CALL 0x77A
1777  160A     BSF PCLATH, 0x4
1778  118A     BCF PCLATH, 0x3
135:               stop_i2c();
1779  2FAB     GOTO 0x7AB
136:           
137:           #ifndef USE_INTERRUPTS
138:               //  ei();
139:           #endif
140:           
141:           }
142:           
143:           void isl1208_get_date(unsigned char* day, unsigned char* mth, unsigned char* year, unsigned char *dow) {
1685  00AB     MOVWF day
144:           
145:           #ifndef USE_INTERRUPTS
146:               // di();
147:           #endif
148:           
149:               start_i2c();
1686  27A3     CALL 0x7A3
1687  160A     BSF PCLATH, 0x4
1688  118A     BCF PCLATH, 0x3
150:               I2Cstate = write_i2c(isl1208_Write);
1689  30DE     MOVLW 0xDE
168A  277A     CALL 0x77A
168B  160A     BSF PCLATH, 0x4
168C  118A     BCF PCLATH, 0x3
168D  1683     BSF STATUS, 0x5
168E  00A7     MOVWF i
151:               write_i2c(0x03);
168F  3003     MOVLW 0x3
1690  277A     CALL 0x77A
1691  160A     BSF PCLATH, 0x4
1692  118A     BCF PCLATH, 0x3
152:               rstart_i2c();
1693  27B3     CALL 0x7B3
1694  160A     BSF PCLATH, 0x4
1695  118A     BCF PCLATH, 0x3
153:               write_i2c(isl1208_Read);
1696  30DF     MOVLW 0xDF
1697  277A     CALL 0x77A
1698  160A     BSF PCLATH, 0x4
1699  118A     BCF PCLATH, 0x3
154:               *dow = isl1208_bcd2bin(read_i2c(ACK) & 0x07);
169A  1283     BCF STATUS, 0x5
169B  082A     MOVF Data, W
169C  0084     MOVWF FSR
169D  3000     MOVLW 0x0
169E  26CB     CALL 0x6CB
169F  160A     BSF PCLATH, 0x4
16A0  118A     BCF PCLATH, 0x3
16A1  3907     ANDLW 0x7
16A2  26F5     CALL 0x6F5
16A3  160A     BSF PCLATH, 0x4
16A4  118A     BCF PCLATH, 0x3
16A5  1383     BCF STATUS, 0x7
16A6  0080     MOVWF INDF
155:               *day = isl1208_bcd2bin(read_i2c(ACK) & 0x3f);
16A7  082B     MOVF day, W
16A8  0084     MOVWF FSR
16A9  3000     MOVLW 0x0
16AA  26CB     CALL 0x6CB
16AB  160A     BSF PCLATH, 0x4
16AC  118A     BCF PCLATH, 0x3
16AD  393F     ANDLW 0x3F
16AE  26F5     CALL 0x6F5
16AF  160A     BSF PCLATH, 0x4
16B0  118A     BCF PCLATH, 0x3
16B1  1383     BCF STATUS, 0x7
16B2  0080     MOVWF INDF
156:               *mth = isl1208_bcd2bin(read_i2c(ACK) & 0x1f);
16B3  0828     MOVF mth, W
16B4  0084     MOVWF FSR
16B5  3000     MOVLW 0x0
16B6  26CB     CALL 0x6CB
16B7  160A     BSF PCLATH, 0x4
16B8  118A     BCF PCLATH, 0x3
16B9  391F     ANDLW 0x1F
16BA  26F5     CALL 0x6F5
16BB  160A     BSF PCLATH, 0x4
16BC  118A     BCF PCLATH, 0x3
16BD  1383     BCF STATUS, 0x7
16BE  0080     MOVWF INDF
157:               *year = isl1208_bcd2bin(read_i2c(NOACK));
16BF  0829     MOVF year, W
16C0  0084     MOVWF FSR
16C1  3001     MOVLW 0x1
16C2  26CB     CALL 0x6CB
16C3  160A     BSF PCLATH, 0x4
16C4  118A     BCF PCLATH, 0x3
16C5  26F5     CALL 0x6F5
16C6  160A     BSF PCLATH, 0x4
16C7  118A     BCF PCLATH, 0x3
16C8  1383     BCF STATUS, 0x7
16C9  0080     MOVWF INDF
158:               stop_i2c();
16CA  2FAB     GOTO 0x7AB
159:           #ifndef USE_INTERRUPTS
160:               // ei();
161:           #endif
162:           
163:           }
164:           
165:           void isl1208_get_time(unsigned char *hr, unsigned char* min, unsigned char *sec) {
164A  00AA     MOVWF Data
166:           
167:           #ifndef USE_INTERRUPTS
168:               // di();
169:           #endif
170:           
171:               start_i2c();
164B  27A3     CALL 0x7A3
164C  160A     BSF PCLATH, 0x4
164D  118A     BCF PCLATH, 0x3
172:               I2Cstate = write_i2c(isl1208_Write);
164E  30DE     MOVLW 0xDE
164F  277A     CALL 0x77A
1650  160A     BSF PCLATH, 0x4
1651  118A     BCF PCLATH, 0x3
1652  1683     BSF STATUS, 0x5
1653  00A7     MOVWF i
173:               write_i2c(0x00);
1654  3000     MOVLW 0x0
1655  277A     CALL 0x77A
1656  160A     BSF PCLATH, 0x4
1657  118A     BCF PCLATH, 0x3
174:           
175:               rstart_i2c();
1658  27B3     CALL 0x7B3
1659  160A     BSF PCLATH, 0x4
165A  118A     BCF PCLATH, 0x3
176:               write_i2c(isl1208_Read);
165B  30DF     MOVLW 0xDF
165C  277A     CALL 0x77A
165D  160A     BSF PCLATH, 0x4
165E  118A     BCF PCLATH, 0x3
177:               *sec = isl1208_bcd2bin(read_i2c(ACK) & 0x7f);
165F  1283     BCF STATUS, 0x5
1660  0829     MOVF year, W
1661  0084     MOVWF FSR
1662  3000     MOVLW 0x0
1663  26CB     CALL 0x6CB
1664  160A     BSF PCLATH, 0x4
1665  118A     BCF PCLATH, 0x3
1666  397F     ANDLW 0x7F
1667  26F5     CALL 0x6F5
1668  160A     BSF PCLATH, 0x4
1669  118A     BCF PCLATH, 0x3
166A  1383     BCF STATUS, 0x7
166B  0080     MOVWF INDF
178:               * min = isl1208_bcd2bin(read_i2c(ACK) & 0x7f);
166C  0828     MOVF mth, W
166D  0084     MOVWF FSR
166E  3000     MOVLW 0x0
166F  26CB     CALL 0x6CB
1670  160A     BSF PCLATH, 0x4
1671  118A     BCF PCLATH, 0x3
1672  397F     ANDLW 0x7F
1673  26F5     CALL 0x6F5
1674  160A     BSF PCLATH, 0x4
1675  118A     BCF PCLATH, 0x3
1676  1383     BCF STATUS, 0x7
1677  0080     MOVWF INDF
179:               * hr = isl1208_bcd2bin(read_i2c(NOACK) & 0x3f);
1678  082A     MOVF Data, W
1679  0084     MOVWF FSR
167A  3001     MOVLW 0x1
167B  26CB     CALL 0x6CB
167C  160A     BSF PCLATH, 0x4
167D  118A     BCF PCLATH, 0x3
167E  393F     ANDLW 0x3F
167F  26F5     CALL 0x6F5
1680  160A     BSF PCLATH, 0x4
1681  118A     BCF PCLATH, 0x3
1682  1383     BCF STATUS, 0x7
1683  0080     MOVWF INDF
180:               stop_i2c();
1684  2FAB     GOTO 0x7AB
181:           
182:           #ifndef USE_INTERRUPTS
183:               // ei();
184:           #endif
185:           
186:           }
187:           
188:           char isl1208_read_nvram_byte(char addr) {
189:           
190:               char retval;
191:           
192:           #ifndef USE_INTERRUPTS
193:               // di();
194:           #endif
195:           
196:               start_i2c();
197:               I2Cstate = write_i2c(isl1208_Write);
198:               write_i2c(addr);
199:           
200:               start_i2c();
201:               write_i2c(isl1208_Read);
202:               retval = read_i2c(NOACK);
203:               stop_i2c();
204:           
205:           
206:           
207:           #ifndef USE_INTERRUPTS
208:               // ei();
209:           #endif
210:               return (retval);
211:           }
212:           
213:           void isl1208_write_nvram_byte(char addr, char value) {
214:           
215:           #ifndef USE_INTERRUPTS
216:               //di();
217:           #endif
218:           
219:               start_i2c();
220:               I2Cstate = write_i2c(isl1208_Write);
221:               write_i2c(addr);
222:               write_i2c(value);
223:               stop_i2c();
224:           
225:           #ifndef USE_INTERRUPTS
226:               // ei();
227:           #endif
228:           
229:           }
230:           
231:           void isl1208_get_day_of_week(char* ptr) {
232:           
233:               unsigned char *plday;
234:               unsigned char *plmonth;
235:               unsigned char *plyr;
236:               unsigned char *pldow;
237:               unsigned char lday = 0;
238:               unsigned char lmonth = 0;
239:               unsigned char lyr = 0;
240:               unsigned char ldow = 0;
241:               plday = &lday;
242:               plmonth = &lmonth;
243:               plyr = &lyr;
244:               pldow = &ldow;
245:               isl1208_get_date(plday, plmonth, plyr, pldow);
246:               sprintf(ptr, "%s", days_of_week[*pldow - 1]);
247:           }
248:           
249:           ///////////////////////////////////////////////////////////////////////////////
250:           
251:           unsigned char isl1208_bin2bcd(unsigned char binary_value) {
1792  00A9     MOVWF year
252:               return ((binary_value / 10) << 4) +binary_value % 10;
1793  300A     MOVLW 0xA
1794  00A3     MOVWF x
1795  0829     MOVF year, W
1796  27BB     CALL 0x7BB
1797  160A     BSF PCLATH, 0x4
1798  118A     BCF PCLATH, 0x3
1799  00A8     MOVWF mth
179A  0E28     SWAPF mth, W
179B  39F0     ANDLW 0xF0
179C  00A8     MOVWF mth
179D  300A     MOVLW 0xA
179E  00A3     MOVWF x
179F  0829     MOVF year, W
17A0  27D6     CALL 0x7D6
17A1  0728     ADDWF mth, W
253:           
254:           }
17A2  0008     RETURN
255:           
256:           unsigned char isl1208_bcd2bin(unsigned char bcd_value) {
16F5  00A7     MOVWF i
257:               return (bcd_value & 0x0F) + (bcd_value >> 4) * 10;
16F6  390F     ANDLW 0xF
16F7  00A6     MOVWF x
16F8  300A     MOVLW 0xA
16F9  00A3     MOVWF x
16FA  0E27     SWAPF i, W
16FB  390F     ANDLW 0xF
16FC  27F2     CALL 0x7F2
16FD  0726     ADDWF x, W
258:           }
16FE  0008     RETURN
259:           
260:           
261:           /*unsigned int ISL1208::bcd2bin(unsigned char val)
262:           {
263:               return (val & 0x0F) + (val >> 4) * 10;
264:           }
265:           
266:           char ISL1208::bin2bcd(unsigned int val)
267:           {
268:               return ((val / 10) << 4) + val % 10;
269:           }*/
270:           ///////////////////////////////////////////////////////////////////////////////
271:           
272:           
273:           
274:           
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/Pulsadores.c  -------------------------
1:             //Programa de gestin de pulsadores por Nocturno adaptado a xc8 por Pablo F. Manieri
2:             
3:             #include <xc.h>
4:             #include <stdint.h>
5:             #include <stdbool.h>
6:             #include "system.h"
7:             #include "user.h"
8:             #include "Pulsadores.h"
9:             
10:            /****** HARDWARE ********
11:            BOTON_Subir       	RB1
12:            BOTON_Bajar       	RB2
13:            BOTON_MENU       	RB3
14:            BOTON_MANAUT     	RB4
15:            BOTON_ONOFF		RB5
16:            **************************/
17:            
18:            bool Pulsacion(unsigned char Indice, unsigned char Pin, unsigned char TipoPin, bool Logica) {
0ED4  00F9     MOVWF Indice
19:               /*
20:                  Esta funcin gestiona las entradas de pulsador, mediante el control de un retardo
21:                  antirrebotes y con la opcin de autorrepeticin de hasta 4 velocidades
22:                  
23:                  Para que funcione, hay que dimensionar la variable Entradas con el n de pulsadores
24:                  que queramos controlar.
25:                  
26:                  ENTRADAS
27:                     Indice: hace referencia al n de pulsador a chequear
28:                     Pin: indica el estado del pin del pulsador (lgica inversa)
29:                     TipoPIN:
30:                        TipoPin=0   -> No tiene autorrepeticin
31:                        TipoPin=1   -> Pin con autorrepeticin
32:                     
33:                  SALIDA
34:                     La funcin devuelve un 1 si el pulsador est en condiciones de ser procesado
35:                     y un 0 en caso contrario.
36:                  
37:               */
38:               static unsigned int Entradas[5]={0,0,0,0,0};  // Dimensionar en funcin del n de pulsadores
39:               unsigned int j;
40:              bool resultado=0;
0ED5  01F8     CLRF resultado
41:               
42:               j=Entradas[Indice];  // Como leemos muchas veces el array, lo pasamos a variable local para 
0ED6  1003     BCF STATUS, 0x0
0ED7  0D79     RLF Indice, W
0ED8  3E90     ADDLW 0x90
0ED9  0084     MOVWF FSR
0EDA  1783     BSF STATUS, 0x7
0EDB  0800     MOVF INDF, W
0EDC  00FA     MOVWF j
0EDD  0A84     INCF FSR, F
0EDE  0800     MOVF INDF, W
0EDF  00FB     MOVWF 0x7B
43:                                    // incrementar la velocidad de ejecucin
44:                                    
45:               // Si se detecta pulsacin y antes no haba, devolvemos un 1 en resultado
46:               if ((((!Pin && Logica==LOGICA_INVERSA) || (Pin && Logica==LOGICA_DIRECTA)) && (j==0))) {
0EE0  08F5     MOVF Pin, F
0EE1  1903     BTFSC STATUS, 0x2
0EE2  0377     DECF Logica, W
0EE3  1903     BTFSC STATUS, 0x2
0EE4  2EEB     GOTO 0x6EB
0EE5  0875     MOVF Pin, W
0EE6  1903     BTFSC STATUS, 0x2
0EE7  2EF4     GOTO 0x6F4
0EE8  08F7     MOVF Logica, F
0EE9  1D03     BTFSS STATUS, 0x2
0EEA  2EF4     GOTO 0x6F4
0EEB  087B     MOVF 0x7B, W
0EEC  047A     IORWF j, W
0EED  1D03     BTFSS STATUS, 0x2
0EEE  2EF4     GOTO 0x6F4
47:                     resultado=1;
0EEF  01F8     CLRF resultado
0EF0  0AF8     INCF resultado, F
48:                     j=1;
0EF1  01FA     CLRF j
0EF2  0AFA     INCF j, F
0EF3  01FB     CLRF 0x7B
49:               };
50:               
51:               // Cada vez que se entra a la funcin se incrementa una unidad el array
52:               if (j>0) 
0EF4  087B     MOVF 0x7B, W
0EF5  047A     IORWF j, W
0EF6  1903     BTFSC STATUS, 0x2
0EF7  2F01     GOTO 0x701
53:                     Entradas[Indice]++;
0EF8  1003     BCF STATUS, 0x0
0EF9  0D79     RLF Indice, W
0EFA  3E90     ADDLW 0x90
0EFB  0084     MOVWF FSR
0EFC  3001     MOVLW 0x1
0EFD  0780     ADDWF INDF, F
0EFE  0A84     INCF FSR, F
0EFF  1803     BTFSC STATUS, 0x0
0F00  0A80     INCF INDF, F
54:               
55:               // Si se detecta que ya no se est pulsando, inicializamos a 0 el array
56:               if (((Pin && Logica==LOGICA_INVERSA) || (!Pin && Logica==LOGICA_DIRECTA)) && j>ANTIRREBOTES)
0F01  0875     MOVF Pin, W
0F02  1903     BTFSC STATUS, 0x2
0F03  2F07     GOTO 0x707
0F04  0377     DECF Logica, W
0F05  1903     BTFSC STATUS, 0x2
0F06  2F0D     GOTO 0x70D
0F07  08F5     MOVF Pin, F
0F08  1D03     BTFSS STATUS, 0x2
0F09  2F1B     GOTO 0x71B
0F0A  08F7     MOVF Logica, F
0F0B  1D03     BTFSS STATUS, 0x2
0F0C  2F1B     GOTO 0x71B
0F0D  3000     MOVLW 0x0
0F0E  027B     SUBWF 0x7B, W
0F0F  3015     MOVLW 0x15
0F10  1903     BTFSC STATUS, 0x2
0F11  027A     SUBWF j, W
0F12  1C03     BTFSS STATUS, 0x0
0F13  2F1B     GOTO 0x71B
57:                  Entradas[Indice]=0;
0F14  1003     BCF STATUS, 0x0
0F15  0D79     RLF Indice, W
0F16  3E90     ADDLW 0x90
0F17  0084     MOVWF FSR
0F18  0180     CLRF INDF
0F19  0A84     INCF FSR, F
0F1A  0180     CLRF INDF
58:                  
59:               if (TipoPin) { // Si el pulsador tiene autorrepeticin
0F1B  0876     MOVF TipoPin, W
0F1C  1903     BTFSC STATUS, 0x2
0F1D  2F6A     GOTO 0x76A
60:                 // Cuando se supera el n de ciclos 4, devolveremos un 1 con la frecuencia VELOCIDAD4
61:                   if ((j>=CAMBIO4) && !(j%VELOCIDAD4)){
0F1E  300F     MOVLW 0xF
0F1F  027B     SUBWF 0x7B, W
0F20  30A0     MOVLW 0xA0
0F21  1903     BTFSC STATUS, 0x2
0F22  027A     SUBWF j, W
0F23  1803     BTFSC STATUS, 0x0
0F24  187A     BTFSC j, 0x0
0F25  2F2B     GOTO 0x72B
62:                       resultado=1;
0F26  01F8     CLRF resultado
0F27  0AF8     INCF resultado, F
63:                  }else
0F28  1283     BCF STATUS, 0x5
0F29  1303     BCF STATUS, 0x6
0F2A  2F6A     GOTO 0x76A
64:                   // Cuando se supera el n de ciclos 3, devolveremos un 1 con la frecuencia VELOCIDAD3
65:                  if ((j>=CAMBIO3) && !(j%VELOCIDAD3)){           
0F2B  3007     MOVLW 0x7
0F2C  027B     SUBWF 0x7B, W
0F2D  30D0     MOVLW 0xD0
0F2E  1903     BTFSC STATUS, 0x2
0F2F  027A     SUBWF j, W
0F30  1C03     BTFSS STATUS, 0x0
0F31  2F40     GOTO 0x740
0F32  300A     MOVLW 0xA
0F33  00F0     MOVWF divisor
0F34  01F1     CLRF canal
0F35  087B     MOVF 0x7B, W
0F36  00F3     MOVWF counter
0F37  087A     MOVF j, W
0F38  00F2     MOVWF dividend
0F39  2776     CALL 0x776
0F3A  120A     BCF PCLATH, 0x4
0F3B  158A     BSF PCLATH, 0x3
0F3C  0871     MOVF canal, W
0F3D  0470     IORWF divisor, W
0F3E  1903     BTFSC STATUS, 0x2
0F3F  2F26     GOTO 0x726
66:                     resultado=1;
67:                  } else 
68:                     // Cuando se supera el n de ciclos 2, devolveremos un 1 con la frecuencia VELOCIDAD2
69:                     if ((j>=CAMBIO2) && !(j%VELOCIDAD2)){
0F40  3001     MOVLW 0x1
0F41  027B     SUBWF 0x7B, W
0F42  30F4     MOVLW 0xF4
0F43  1903     BTFSC STATUS, 0x2
0F44  027A     SUBWF j, W
0F45  1C03     BTFSS STATUS, 0x0
0F46  2F55     GOTO 0x755
0F47  3032     MOVLW 0x32
0F48  00F0     MOVWF divisor
0F49  01F1     CLRF canal
0F4A  087B     MOVF 0x7B, W
0F4B  00F3     MOVWF counter
0F4C  087A     MOVF j, W
0F4D  00F2     MOVWF dividend
0F4E  2776     CALL 0x776
0F4F  120A     BCF PCLATH, 0x4
0F50  158A     BSF PCLATH, 0x3
0F51  0871     MOVF canal, W
0F52  0470     IORWF divisor, W
0F53  1903     BTFSC STATUS, 0x2
0F54  2F26     GOTO 0x726
70:                        resultado=1;
71:                  } else
72:                     // Cuando se supera el n de ciclos 1, devolveremos un 1 con la frecuencia VELOCIDAD1
73:                     if ((j>CAMBIO1) && !(j%VELOCIDAD1)){
0F55  3000     MOVLW 0x0
0F56  027B     SUBWF 0x7B, W
0F57  3065     MOVLW 0x65
0F58  1903     BTFSC STATUS, 0x2
0F59  027A     SUBWF j, W
0F5A  1C03     BTFSS STATUS, 0x0
0F5B  2F6A     GOTO 0x76A
0F5C  3064     MOVLW 0x64
0F5D  00F0     MOVWF divisor
0F5E  01F1     CLRF canal
0F5F  087B     MOVF 0x7B, W
0F60  00F3     MOVWF counter
0F61  087A     MOVF j, W
0F62  00F2     MOVWF dividend
0F63  2776     CALL 0x776
0F64  120A     BCF PCLATH, 0x4
0F65  158A     BSF PCLATH, 0x3
0F66  0871     MOVF canal, W
0F67  0470     IORWF divisor, W
0F68  1903     BTFSC STATUS, 0x2
0F69  2F26     GOTO 0x726
74:                        resultado=1;
75:                  };
76:               }
77:               if ((TipoPin==INMEDIATO)&&(j>=1))
0F6A  0876     MOVF TipoPin, W
0F6B  3A02     XORLW 0x2
0F6C  1D03     BTFSS STATUS, 0x2
0F6D  2F74     GOTO 0x774
0F6E  087B     MOVF 0x7B, W
0F6F  047A     IORWF j, W
0F70  1903     BTFSC STATUS, 0x2
0F71  2F74     GOTO 0x774
78:                   resultado=1;
0F72  01F8     CLRF resultado
0F73  0AF8     INCF resultado, F
79:               return (resultado);
0F74  0878     MOVF resultado, W
80:            }
0F75  0008     RETURN
81:            
82:            
83:               
84:            
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/LCDGeneric.c  -------------------------
1:             /**
2:                \version: 1.0
3:             
4:                
5:                \author Suky (Casanova Alejandro) 
6:                \web www.infopic.comlu.com
7:                \date 16/08/10
8:             
9:             
10:            ///////////////////////////////////////////////////////////////////////////
11:            ////                                                                   ////
12:            ////                                                                   ////
13:            ////        (C) Copyright 2010 www.infopic.comlu.com                   ////
14:            //// Este cdigo puede ser usado, modificado y distribuido libremente  ////
15:            //// sin eliminar esta cabecera y  sin garanta de ningn tipo.        ////
16:            ////                                                                   ////
17:            ////                                                                   ////
18:            /////////////////////////////////////////////////////////////////////////// 
19:               
20:             *- Version Log --------------------------------------------------------------*
21:             *   Fecha       Autor                Comentarios                             *
22:             *----------------------------------------------------------------------------*
23:             * 16/08/10      Suky               Original (Rev 1.0)                        *
24:             * 20/08/10      Suky               Se incluye CodeVisionAVR                  *
25:             *----------------------------------------------------------------------------* */
26:            #include "xc.h"
27:            #include "system.h"
28:            #include "LCDGeneric.h"
29:            
30:            UINT8 NLinea;
31:            
32:            UINT8 ui8BusyLCD(void){
33:            
34:            #ifdef LCD_USE_RW
35:            	 LCD_DATA_PIN_7 = 0;
093D  1388     BCF PORTD, 0x7
36:            	 LCD_DATA_PIN_6 = 0;
093E  1308     BCF PORTD, 0x6
37:            	 LCD_DATA_PIN_5 = 0;
093F  1288     BCF PORTD, 0x5
38:            	 LCD_DATA_PIN_4 = 0;
0940  1208     BCF PORTD, 0x4
39:            
40:                 LCD_TRIS_DATA_PIN_7 = CONFIG_INPUT;
0941  1683     BSF STATUS, 0x5
0942  1788     BSF PORTD, 0x7
41:                 LCD_TRIS_DATA_PIN_6 = CONFIG_INPUT;
0943  1708     BSF PORTD, 0x6
42:                 LCD_TRIS_DATA_PIN_5 = CONFIG_INPUT;
0944  1688     BSF PORTD, 0x5
43:                 LCD_TRIS_DATA_PIN_4 = CONFIG_INPUT;
0945  1608     BSF PORTD, 0x4
44:            
45:                 LCD_RW_PIN = 1;    
0946  1283     BCF STATUS, 0x5
0947  1488     BSF PORTD, 0x1
46:                 LCD_RS_PIN = 0; 
0948  1008     BCF PORTD, 0x0
47:            	 LCD_E_PIN=1;         
0949  1508     BSF PORTD, 0x2
48:                 __delay_1us();
094A  294B     GOTO 0x14B
094B  294C     GOTO 0x14C
094C  0000     NOP
49:            
50:                 if(LCD_READ_PIN_7==1){
094D  1283     BCF STATUS, 0x5
094E  1303     BCF STATUS, 0x6
094F  1F88     BTFSS PORTD, 0x7
0950  2960     GOTO 0x160
51:                      LCD_E_PIN = 0; 
0951  1108     BCF PORTD, 0x2
52:            		  __delay_1us();
0952  2953     GOTO 0x153
0953  2954     GOTO 0x154
0954  0000     NOP
53:            		  LCD_E_PIN = 1;
0955  1283     BCF STATUS, 0x5
0956  1303     BCF STATUS, 0x6
0957  1508     BSF PORTD, 0x2
54:            		  __delay_1us();
0958  2959     GOTO 0x159
0959  295A     GOTO 0x15A
095A  0000     NOP
55:            		  LCD_E_PIN = 0;
095B  1283     BCF STATUS, 0x5
095C  1303     BCF STATUS, 0x6
095D  1108     BCF PORTD, 0x2
56:                  	  LCD_RW_PIN = 0; 
095E  1088     BCF PORTD, 0x1
57:                      return 1;
095F  3401     RETLW 0x1
58:                 }else{
59:                      LCD_E_PIN = 0;
0960  1108     BCF PORTD, 0x2
60:            		  __delay_1us();
0961  2962     GOTO 0x162
0962  2963     GOTO 0x163
0963  0000     NOP
61:            		  LCD_E_PIN = 1;
0964  1283     BCF STATUS, 0x5
0965  1303     BCF STATUS, 0x6
0966  1508     BSF PORTD, 0x2
62:            		  __delay_1us();
0967  2968     GOTO 0x168
0968  2969     GOTO 0x169
0969  0000     NOP
63:            		  LCD_E_PIN = 0;
096A  1283     BCF STATUS, 0x5
096B  1303     BCF STATUS, 0x6
096C  1108     BCF PORTD, 0x2
64:            		  LCD_RW_PIN = 0;       
096D  1088     BCF PORTD, 0x1
65:                      return 0;
096E  3400     RETLW 0x0
66:                 }
67:            #else
68:            	 __delay_100us();
69:            	 return 0;
70:            #endif
71:            }
72:            
73:            void vWriteLCD(UINT8 Data,UINT8 Type){
08CC  00A4     MOVWF dato
74:            
75:            #ifdef LCD_USE_3PINES
76:            	UINT8 i, data_temp;
77:            #endif
78:            
79:            	while(ui8BusyLCD());
08CD  213D     CALL 0x13D
08CE  120A     BCF PCLATH, 0x4
08CF  158A     BSF PCLATH, 0x3
08D0  3800     IORLW 0x0
08D1  1D03     BTFSS STATUS, 0x2
08D2  28CD     GOTO 0xCD
80:            
81:            	#ifndef LCD_USE_3PINES
82:            		#ifdef LCD_USE_RW
83:            			LCD_RW_PIN = 0;
08D3  1088     BCF PORTD, 0x1
84:            		#endif   
85:            		if(Type){
08D4  0823     MOVF x, W
08D5  1903     BTFSC STATUS, 0x2
08D6  28D9     GOTO 0xD9
86:            			LCD_RS_PIN=1;
08D7  1408     BSF PORTD, 0x0
87:            		}else{
08D8  28DA     GOTO 0xDA
88:            			LCD_RS_PIN = 0;
08D9  1008     BCF PORTD, 0x0
89:            		}	  
90:            		LCD_TRIS_DATA_PIN_7 = CONFIG_OUTPUT;
08DA  1683     BSF STATUS, 0x5
08DB  1388     BCF PORTD, 0x7
91:            		LCD_TRIS_DATA_PIN_6 = CONFIG_OUTPUT;
08DC  1308     BCF PORTD, 0x6
92:            		LCD_TRIS_DATA_PIN_5 = CONFIG_OUTPUT;
08DD  1288     BCF PORTD, 0x5
93:            		LCD_TRIS_DATA_PIN_4 = CONFIG_OUTPUT;
08DE  1208     BCF PORTD, 0x4
94:            		
95:            		LCD_DATA_PIN_7 = !!(Data & 0x80);
08DF  1283     BCF STATUS, 0x5
08E0  1FA4     BTFSS dato, 0x7
08E1  28E6     GOTO 0xE6
08E2  1283     BCF STATUS, 0x5
08E3  1303     BCF STATUS, 0x6
08E4  1788     BSF PORTD, 0x7
08E5  28E9     GOTO 0xE9
08E6  1283     BCF STATUS, 0x5
08E7  1303     BCF STATUS, 0x6
08E8  1388     BCF PORTD, 0x7
96:            		LCD_DATA_PIN_6 = !!(Data & 0x40);
08E9  1F24     BTFSS dato, 0x6
08EA  28EF     GOTO 0xEF
08EB  1283     BCF STATUS, 0x5
08EC  1303     BCF STATUS, 0x6
08ED  1708     BSF PORTD, 0x6
08EE  28F2     GOTO 0xF2
08EF  1283     BCF STATUS, 0x5
08F0  1303     BCF STATUS, 0x6
08F1  1308     BCF PORTD, 0x6
97:            		LCD_DATA_PIN_5 = !!(Data & 0x20);
08F2  1EA4     BTFSS dato, 0x5
08F3  28F8     GOTO 0xF8
08F4  1283     BCF STATUS, 0x5
08F5  1303     BCF STATUS, 0x6
08F6  1688     BSF PORTD, 0x5
08F7  28FB     GOTO 0xFB
08F8  1283     BCF STATUS, 0x5
08F9  1303     BCF STATUS, 0x6
08FA  1288     BCF PORTD, 0x5
98:            		LCD_DATA_PIN_4 = !!(Data & 0x10);
08FB  1E24     BTFSS dato, 0x4
08FC  2901     GOTO 0x101
08FD  1283     BCF STATUS, 0x5
08FE  1303     BCF STATUS, 0x6
08FF  1608     BSF PORTD, 0x4
0900  2904     GOTO 0x104
0901  1283     BCF STATUS, 0x5
0902  1303     BCF STATUS, 0x6
0903  1208     BCF PORTD, 0x4
99:            	#else
100:           		data_temp=(Data>>4);  // Rs es bit 4
101:           		if(Type){
102:           			data_temp|=0x10;
103:           		}
104:           		for(i=0;i<8;i++){
105:           			LCD_DATA_PIN=!!(data_temp & 0x80);
106:           			data_temp<<=1;
107:           			LCD_CLOCK_PIN=1;
108:           			__delay_1us();
109:           			LCD_CLOCK_PIN=0;
110:           		}
111:           	#endif
112:           	__delay_1Cycle();
0904  0000     NOP
113:           	LCD_E_PIN = 1;
0905  1283     BCF STATUS, 0x5
0906  1303     BCF STATUS, 0x6
0907  1508     BSF PORTD, 0x2
114:           	__delay_1us();
0908  2909     GOTO 0x109
0909  290A     GOTO 0x10A
090A  0000     NOP
115:           	LCD_E_PIN = 0;
090B  1283     BCF STATUS, 0x5
090C  1303     BCF STATUS, 0x6
090D  1108     BCF PORTD, 0x2
116:           	#ifndef LCD_USE_3PINES	
117:           		LCD_DATA_PIN_7 = !!(Data & 0x08);
090E  1DA4     BTFSS dato, 0x3
090F  2914     GOTO 0x114
0910  1283     BCF STATUS, 0x5
0911  1303     BCF STATUS, 0x6
0912  1788     BSF PORTD, 0x7
0913  2917     GOTO 0x117
0914  1283     BCF STATUS, 0x5
0915  1303     BCF STATUS, 0x6
0916  1388     BCF PORTD, 0x7
118:           		LCD_DATA_PIN_6 = !!(Data & 0x04);
0917  1D24     BTFSS dato, 0x2
0918  291D     GOTO 0x11D
0919  1283     BCF STATUS, 0x5
091A  1303     BCF STATUS, 0x6
091B  1708     BSF PORTD, 0x6
091C  2920     GOTO 0x120
091D  1283     BCF STATUS, 0x5
091E  1303     BCF STATUS, 0x6
091F  1308     BCF PORTD, 0x6
119:           		LCD_DATA_PIN_5 = !!(Data & 0x02);
0920  1CA4     BTFSS dato, 0x1
0921  2926     GOTO 0x126
0922  1283     BCF STATUS, 0x5
0923  1303     BCF STATUS, 0x6
0924  1688     BSF PORTD, 0x5
0925  2929     GOTO 0x129
0926  1283     BCF STATUS, 0x5
0927  1303     BCF STATUS, 0x6
0928  1288     BCF PORTD, 0x5
120:           		LCD_DATA_PIN_4 = !!(Data & 0x01);
0929  1C24     BTFSS dato, 0x0
092A  292F     GOTO 0x12F
092B  1283     BCF STATUS, 0x5
092C  1303     BCF STATUS, 0x6
092D  1608     BSF PORTD, 0x4
092E  2932     GOTO 0x132
092F  1283     BCF STATUS, 0x5
0930  1303     BCF STATUS, 0x6
0931  1208     BCF PORTD, 0x4
121:           	#else
122:           		data_temp=(Data&0x0F);  // Rs es bit 4
123:           		if(Type){
124:           			data_temp|=0x10;
125:           		}
126:           		for(i=0;i<8;i++){
127:           			LCD_DATA_PIN=!!(data_temp & 0x80);
128:           			data_temp<<=1;
129:           			LCD_CLOCK_PIN=1;
130:           			__delay_1us();
131:           			LCD_CLOCK_PIN=0;
132:           		}
133:           	#endif
134:           	__delay_1Cycle();	
0932  0000     NOP
135:           	LCD_E_PIN = 1;
0933  1283     BCF STATUS, 0x5
0934  1303     BCF STATUS, 0x6
0935  1508     BSF PORTD, 0x2
136:           	__delay_1us();
0936  2937     GOTO 0x137
0937  2938     GOTO 0x138
0938  0000     NOP
137:           	LCD_E_PIN = 0;
0939  1283     BCF STATUS, 0x5
093A  1303     BCF STATUS, 0x6
093B  1108     BCF PORTD, 0x2
138:           	
139:           } 
093C  0008     RETURN
140:           
141:           void vInitLCD(){
142:           UINT8 i;
143:           #ifdef LCD_USE_3PINES
144:           	UINT8 temp;
145:           #endif
146:           
147:           	for(i=0;i<8;i++){__delay_2ms();}
0859  01A7     CLRF i
085A  300D     MOVLW 0xD
085B  00A6     MOVWF x
085C  30FB     MOVLW 0xFB
085D  00A5     MOVWF y
085E  0BA5     DECFSZ y, F
085F  285E     GOTO 0x5E
0860  0BA6     DECFSZ x, F
0861  285E     GOTO 0x5E
0862  2863     GOTO 0x63
0863  1283     BCF STATUS, 0x5
0864  1303     BCF STATUS, 0x6
0865  3008     MOVLW 0x8
0866  0AA7     INCF i, F
0867  0227     SUBWF i, W
0868  1C03     BTFSS STATUS, 0x0
0869  285A     GOTO 0x5A
148:           	NLinea=1;
086A  01DB     CLRF NLinea
086B  0ADB     INCF NLinea, F
149:           	
150:           #ifndef LCD_USE_3PINES
151:           /* ** Configuracin de pines ** */	
152:           	LCD_DATA_PIN_7 = 0;
086C  1388     BCF PORTD, 0x7
153:           	LCD_DATA_PIN_6 = 0;
086D  1308     BCF PORTD, 0x6
154:           	LCD_DATA_PIN_5 = 0;
086E  1288     BCF PORTD, 0x5
155:           	LCD_DATA_PIN_4 = 0;
086F  1208     BCF PORTD, 0x4
156:           	#ifdef LCD_USE_RW
157:           		LCD_RW_PIN = 0;
0870  1088     BCF PORTD, 0x1
158:           	#endif
159:           	LCD_RS_PIN = 0;
0871  1008     BCF PORTD, 0x0
160:           	LCD_E_PIN = 0;
0872  1108     BCF PORTD, 0x2
161:           	
162:           	LCD_TRIS_DATA_PIN_7 = CONFIG_OUTPUT;
0873  1683     BSF STATUS, 0x5
0874  1388     BCF PORTD, 0x7
163:           	LCD_TRIS_DATA_PIN_6 = CONFIG_OUTPUT;
0875  1308     BCF PORTD, 0x6
164:           	LCD_TRIS_DATA_PIN_5 = CONFIG_OUTPUT;
0876  1288     BCF PORTD, 0x5
165:           	LCD_TRIS_DATA_PIN_4 = CONFIG_OUTPUT;
0877  1208     BCF PORTD, 0x4
166:           	#ifdef LCD_USE_RW	
167:           		LCD_TRIS_RW = CONFIG_OUTPUT;
0878  1088     BCF PORTD, 0x1
168:           	#endif
169:           	LCD_TRIS_RS = CONFIG_OUTPUT;
0879  1008     BCF PORTD, 0x0
170:           	LCD_TRIS_E = CONFIG_OUTPUT;
087A  1108     BCF PORTD, 0x2
171:           #else
172:           	LCD_DATA_PIN = 0;
173:           	LCD_CLOCK_PIN = 0;
174:           	LCD_E_PIN = 0;
175:           
176:           	LCD_TRIS_DATA = CONFIG_OUTPUT;
177:           	LCD_TRIS_CLOCK = CONFIG_OUTPUT;
178:           	LCD_TRIS_E = CONFIG_OUTPUT;
179:           	
180:           	for(i=0;i<8;i++){
181:           		LCD_DATA_PIN=0;
182:           		LCD_CLOCK_PIN=1;
183:           		__delay_1us();
184:           		LCD_CLOCK_PIN=0;
185:           	}
186:           #endif
187:           /* ** INICIALIZACION ** */     
188:           #ifndef LCD_USE_3PINES
189:           	LCD_DATA_PIN_5 = 1;
087B  1283     BCF STATUS, 0x5
087C  1688     BSF PORTD, 0x5
190:           	LCD_DATA_PIN_4 = 1;
087D  1608     BSF PORTD, 0x4
191:           #else
192:           	temp=0x03;
193:           	for(i=0;i<8;i++){
194:           		LCD_DATA_PIN=!!(temp & 0x80);
195:           		temp<<=1;
196:           		LCD_CLOCK_PIN=1;
197:           		__delay_1us();
198:           		LCD_CLOCK_PIN=0;
199:           	}
200:           #endif
201:           	for(i=0;i<3;i++){
087E  01A7     CLRF i
0895  1283     BCF STATUS, 0x5
0896  1303     BCF STATUS, 0x6
0897  3003     MOVLW 0x3
0898  0AA7     INCF i, F
0899  0227     SUBWF i, W
089A  1C03     BTFSS STATUS, 0x0
089B  287F     GOTO 0x7F
202:           		LCD_E_PIN = 1;
087F  1508     BSF PORTD, 0x2
203:           		__delay_2ms();
0880  300D     MOVLW 0xD
0881  00A6     MOVWF x
0882  30FB     MOVLW 0xFB
0883  00A5     MOVWF y
0884  0BA5     DECFSZ y, F
0885  2884     GOTO 0x84
0886  0BA6     DECFSZ x, F
0887  2884     GOTO 0x84
0888  2889     GOTO 0x89
204:           		LCD_E_PIN = 0;
0889  1283     BCF STATUS, 0x5
088A  1303     BCF STATUS, 0x6
088B  1108     BCF PORTD, 0x2
205:           	 	__delay_2ms();
088C  300D     MOVLW 0xD
088D  00A6     MOVWF x
088E  30FB     MOVLW 0xFB
088F  00A5     MOVWF y
0890  0BA5     DECFSZ y, F
0891  2890     GOTO 0x90
0892  0BA6     DECFSZ x, F
0893  2890     GOTO 0x90
0894  2895     GOTO 0x95
206:           	}
207:           #ifndef LCD_USE_3PINES
208:           	LCD_DATA_PIN_4 = 0;
089C  1208     BCF PORTD, 0x4
209:           #else
210:           	temp=0x02;
211:           	for(i=0;i<8;i++){
212:           		LCD_DATA_PIN=!!(temp & 0x80);
213:           		temp<<=1;
214:           		LCD_CLOCK_PIN=1;
215:           		__delay_1us();
216:           		LCD_CLOCK_PIN=0;
217:           	}
218:           #endif
219:           	LCD_E_PIN = 1;
089D  1508     BSF PORTD, 0x2
220:           	__delay_1us();
089E  289F     GOTO 0x9F
089F  28A0     GOTO 0xA0
08A0  0000     NOP
221:           	LCD_E_PIN = 0;
08A1  1283     BCF STATUS, 0x5
08A2  1303     BCF STATUS, 0x6
08A3  1108     BCF PORTD, 0x2
222:           
223:           	vWriteLCD(0x20 | (LcdType<<2),LCD_COMMAND);  // Tipo display.-  
08A4  3028     MOVLW 0x28
08A5  01A3     CLRF x
08A6  20CC     CALL 0xCC
08A7  120A     BCF PCLATH, 0x4
08A8  158A     BSF PCLATH, 0x3
224:           	__delay_2ms();     
08A9  300D     MOVLW 0xD
08AA  00A6     MOVWF x
08AB  30FB     MOVLW 0xFB
08AC  00A5     MOVWF y
08AD  0BA5     DECFSZ y, F
08AE  28AD     GOTO 0xAD
08AF  0BA6     DECFSZ x, F
08B0  28AD     GOTO 0xAD
08B1  28B2     GOTO 0xB2
225:           	vWriteLCD(0x01,LCD_COMMAND);	// Borramos display.-   
08B2  1283     BCF STATUS, 0x5
08B3  1303     BCF STATUS, 0x6
08B4  3001     MOVLW 0x1
08B5  01A3     CLRF x
08B6  20CC     CALL 0xCC
08B7  120A     BCF PCLATH, 0x4
08B8  158A     BSF PCLATH, 0x3
226:           	__delay_2ms();           
08B9  300D     MOVLW 0xD
08BA  00A6     MOVWF x
08BB  30FB     MOVLW 0xFB
08BC  00A5     MOVWF y
08BD  0BA5     DECFSZ y, F
08BE  28BD     GOTO 0xBD
08BF  0BA6     DECFSZ x, F
08C0  28BD     GOTO 0xBD
08C1  28C2     GOTO 0xC2
227:           	vWriteLCD(0x06,LCD_COMMAND);	// Incrementa cursor.-
08C2  1283     BCF STATUS, 0x5
08C3  1303     BCF STATUS, 0x6
08C4  3006     MOVLW 0x6
08C5  01A3     CLRF x
08C6  20CC     CALL 0xCC
08C7  120A     BCF PCLATH, 0x4
08C8  158A     BSF PCLATH, 0x3
228:           	vWriteLCD(0x0C,LCD_COMMAND);	// Encendemos display.-
08C9  300C     MOVLW 0xC
229:           }
230:           
231:           
232:           void vLCD_Putc(UINT8 Data){
0835  1283     BCF STATUS, 0x5
0836  00AA     MOVWF Data
233:           	
234:           	switch(Data){
0837  3A0A     XORLW 0xA
0838  1903     BTFSC STATUS, 0x2
0839  2850     GOTO 0x50
083A  3A06     XORLW 0x6
083B  1903     BTFSC STATUS, 0x2
083C  283F     GOTO 0x3F
083D  2855     GOTO 0x55
235:           		case '\f':
236:           			vWriteLCD(0x01,LCD_COMMAND);
083F  3001     MOVLW 0x1
0840  01A3     CLRF x
0841  20CC     CALL 0xCC
0842  120A     BCF PCLATH, 0x4
0843  158A     BSF PCLATH, 0x3
237:           			NLinea=1;
0845  01DB     CLRF NLinea
0846  0ADB     INCF NLinea, F
238:           			__delay_2ms();
0844  300D     MOVLW 0xD
0847  00A9     MOVWF year
0848  30FB     MOVLW 0xFB
0849  00A8     MOVWF mth
084A  0BA8     DECFSZ mth, F
084B  284A     GOTO 0x4A
084C  0BA9     DECFSZ year, F
084D  284A     GOTO 0x4A
084E  284F     GOTO 0x4F
239:           		break;
084F  0008     RETURN
240:           		case '\n':
241:           			vGotoxyLCD(1,++NLinea);			
0850  0ADB     INCF NLinea, F
0851  085B     MOVF NLinea, W
0852  00A5     MOVWF y
0853  3001     MOVLW 0x1
0854  2815     GOTO 0x15
242:           		break;
243:           		default:
244:           			vWriteLCD(Data,LCD_DATA);
0855  01A3     CLRF x
0856  0AA3     INCF x, F
0857  082A     MOVF Data, W
0858  28CC     GOTO 0xCC
245:           	}
246:           } 
083E  0008     RETURN
247:           
248:           void vGotoxyLCD(UINT8 x,UINT8 y){
0815  00A6     MOVWF x
249:           UINT8 Direccion;
250:           
251:           	switch(y){
0816  2820     GOTO 0x20
0820  0825     MOVF y, W
0821  3A01     XORLW 0x1
0822  1903     BTFSC STATUS, 0x2
0823  2817     GOTO 0x17
0824  3A03     XORLW 0x3
0825  1903     BTFSC STATUS, 0x2
0826  281B     GOTO 0x1B
0827  2817     GOTO 0x17
252:           		case 1:Direccion = LCD_LINE_1_ADDRESS;NLinea=1;break;
0817  01A7     CLRF i
0818  01DB     CLRF NLinea
0819  0ADB     INCF NLinea, F
081A  2828     GOTO 0x28
253:           		case 2:Direccion = LCD_LINE_2_ADDRESS;NLinea=2;break;
081B  3040     MOVLW 0x40
081C  00A7     MOVWF i
081D  3002     MOVLW 0x2
081E  00DB     MOVWF NLinea
081F  2828     GOTO 0x28
254:           		#ifdef LCD_4LINES
255:           		case 3:Direccion = LCD_LINE_3_ADDRESS;NLinea=3;break;
256:           		case 4:Direccion = LCD_LINE_4_ADDRESS;NLinea=4;break;
257:           		#endif
258:           		default:Direccion = LCD_LINE_1_ADDRESS;NLinea=1;break;
259:           	}
260:           
261:           	Direccion+=x-1;
0828  0826     MOVF x, W
0829  3EFF     ADDLW 0xFF
082A  07A7     ADDWF i, F
262:           	while(ui8BusyLCD());
082B  213D     CALL 0x13D
082C  120A     BCF PCLATH, 0x4
082D  158A     BSF PCLATH, 0x3
082E  3800     IORLW 0x0
082F  1D03     BTFSS STATUS, 0x2
0830  282B     GOTO 0x2B
263:           	vWriteLCD(0x80|Direccion,LCD_COMMAND);
0831  01A3     CLRF x
264:           }
265:           
266:           void vPuts_LCD(UINT8 *buffer){
267:           
268:           
269:               while(*buffer != '\0')    {
270:                  // vLCD_Putc(*buffer++);;
271:                   vWriteLCD(*buffer++,LCD_DATA);
272:               }
273:           }
274:           
275:           void vBlinkingLCD(void){
276:           	vWriteLCD(0b1101,LCD_COMMAND);
277:           }
278:           void vnoBlinkingLCD(void){
279:           	vWriteLCD(0b1100,LCD_COMMAND);
280:           }
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/HardI2C.c  ----------------------------
1:             /**************************************************************************
2:             *      Libreria para protocolo I2C Master por HardWare para HiTech        *
3:             ***************************************************************************
4:             
5:             ***************************************************************************
6:             *                                                                         *
7:             * Antes de incluir este archivo en nuestro programa hay que definir       *
8:             * algunos parametros. Estos son                                           *
9:             *                                                                         *
10:            * PIC_CLK        (se usa para calcular el valor de SSPADD)                *     
11:            * I2C_BAUD       (velocidad de transferencia)                             *
12:            *                                                                         *
13:            ***************************************************************************
14:            
15:            ***************************************************************************
16:            *                                                                         *
17:            * En esta libreria se encuentran las siguientes funciones                 *
18:            *                                                                         *
19:            * setup_i2c(char)               (inicializa el puerto I2C)                *
20:            * start_i2c()                   (envia start, inicia transmision)         *
21:            * rstar_i2c()                   (envia restart, reinicia transmision)     *
22:            * stop_i2c()                    (envia stop, termina transmision)         *
23:            * write_i2c(char)               (envia un byte)                           *
24:            * read_i2c(char)                (recibe un byte y envia ack o noack)      *
25:            *                                                                         *
26:            *  La funcion write_i2c() devuelve 0 si el dispositivo responde o 1 si el *
27:            * dispositivo no responde.                                                *
28:            *                                                                         *
29:            *  A la funcion read_i2c() hay que pasarle 0 si se quiere responder al    *
30:            * disipositivo o 1 si no se quiere responder                              *
31:            *                                                                         *
32:            *  En esta libreria estan definidos los parametros I2C_MASTER, I2C_SLAVE, *
33:            * I2C_10BIT_ADDRESS. Eston son utilizados en la funcion setup_i2c(char)   *
34:            *                                                                         *
35:            *  Tambien estan definidos ACK y NOACK que son los utilizados para        *
36:            * responder o no al dispositivo                                           *
37:            *                                                                         *
38:            ***************************************************************************
39:            
40:            * Ejemplo de configuracion y utilizacion
41:            
42:             #define PIC_CLK   10000000   // cristal 10MHz
43:             #define I2C_BAUD  100000     // velocidad 100 KHz
44:             #include "HardI2c.c"
45:            
46:             void main (void);
47:             {
48:               unsigned char respuesta;
49:               unsigned char dato;  
50:             
51:               ......
52:               ......
53:               ......
54:               setup_i2c (I2C_MASTER);
55:               start_i2c();
56:               respuesta = write_i2c (0b10101110);    // comunicacion para escribir en una 24C02C
57:               if (respuesta == ACK)
58:               {
59:                 write_i2c (0x00);                    // indico la direccion a escribir
60:                 write_i2c (0xF5);                    // escribo el dato F5
61:                 write_i2c (0x06);                    // escribo el dato 06
62:               }
63:               stop_i2c();
64:            
65:               // colocar un delay necesario para que termine de grabar la memoria
66:            
67:               start_i2c();
68:               respuesta = write_i2c (0b10101110);    // comunicacion para escribir en una 24C02C
69:               if (respuesta == ACK)
70:               {
71:                 write_i2c (0x00);                    // indico la direccion de memoria
72:                 rstart_i2c();                       // reinicio la transmisin
73:                 respuesta = write_i2c (0b10101111);  // comunicacion para leer en una 24C02C
74:                 if (respuesta == ACK)
75:                 {
76:                   dato = read_i2c (ACK);             // leo el dato y respondo
77:                   dato = read_i2c (NOACK);           // leo el dato y no respondo
78:                 }
79:               }
80:               stop_i2c();
81:             }
82:            
83:            */
84:            #include <xc.h>
85:            #include <stdbool.h>       /* For true/false definition */
86:            #include "system.h"        /* System funct/params, like osc/peripheral config */
87:            #include "HardI2C.h"
88:            
89:            
90:            #if defined (PIC_CLK) && defined (I2C_BAUD)
91:            
92:            void setup_i2c (char x)
1536  00A3     MOVWF x
93:             {
94:                TRISC3 = 1;
1537  1683     BSF STATUS, 0x5
1538  1587     BSF PORTC, 0x3
95:            
96:                TRISC4 = 1;
1539  1607     BSF PORTC, 0x4
97:            
98:                SSPSTAT = 0;
153A  0194     CLRF SSPCON
99:                SSPCON = x;
153B  1283     BCF STATUS, 0x5
153C  0823     MOVF x, W
153D  0094     MOVWF SSPCON
100:               
101:               SSPCON2 = 0;
153E  1683     BSF STATUS, 0x5
153F  0191     CLRF TMR2
102:               // SSPCON2bits.RCEN=1;
103:               if (SSPM3 == 1) SSPADD = (unsigned char)((PIC_CLK/(4*I2C_BAUD)) - 1);
1540  1283     BCF STATUS, 0x5
1541  1D94     BTFSS SSPCON, 0x3
1542  0008     RETURN
1543  300B     MOVLW 0xB
1544  1683     BSF STATUS, 0x5
1545  0093     MOVWF SSPBUF
104:           
105:           }
1546  0008     RETURN
106:           
107:             char start_i2c (void)
108:             { 
109:               while (( SSPCON2 & 0x1F ) || R_nW );
17A3  1683     BSF STATUS, 0x5
17A4  0811     MOVF TMR2, W
17A5  391F     ANDLW 0x1F
17A6  1903     BTFSC STATUS, 0x2
17A7  1914     BTFSC SSPCON, 0x2
17A8  2FA3     GOTO 0x7A3
110:               SEN = 1;
17A9  1411     BSF TMR2, 0x0
111:               return !BCLIF;
112:             }
17AA  0008     RETURN
113:           
114:             void rstart_i2c (void)
115:             {
116:               while (( SSPCON2 & 0x1F ) || R_nW );
17B3  1683     BSF STATUS, 0x5
17B4  0811     MOVF TMR2, W
17B5  391F     ANDLW 0x1F
17B6  1903     BTFSC STATUS, 0x2
17B7  1914     BTFSC SSPCON, 0x2
17B8  2FB3     GOTO 0x7B3
117:               RSEN = 1;
17B9  1491     BSF TMR2, 0x1
118:             }
17BA  0008     RETURN
119:           
120:             void stop_i2c (void)
121:             {
122:               while (( SSPCON2 & 0x1F ) || R_nW );
17AB  1683     BSF STATUS, 0x5
17AC  0811     MOVF TMR2, W
17AD  391F     ANDLW 0x1F
17AE  1903     BTFSC STATUS, 0x2
17AF  1914     BTFSC SSPCON, 0x2
17B0  2FAB     GOTO 0x7AB
123:               PEN = 1;
17B1  1511     BSF TMR2, 0x2
124:             }
17B2  0008     RETURN
125:           
126:             char write_i2c (unsigned char data)
177A  1283     BCF STATUS, 0x5
177B  00A3     MOVWF x
127:             {
128:               if (SSPM3 == 1)
177C  1D94     BTFSS SSPCON, 0x3
177D  2F8E     GOTO 0x78E
129:               {
130:                 while (( SSPCON2 & 0x1F ) || R_nW );
177E  1683     BSF STATUS, 0x5
177F  0811     MOVF TMR2, W
1780  391F     ANDLW 0x1F
1781  1903     BTFSC STATUS, 0x2
1782  1914     BTFSC SSPCON, 0x2
1783  2F7E     GOTO 0x77E
131:                 SSPBUF = data;
1784  1283     BCF STATUS, 0x5
1785  0823     MOVF x, W
1786  0093     MOVWF SSPBUF
132:                 while (R_nW == 1);
1787  1683     BSF STATUS, 0x5
1788  1914     BTFSC SSPCON, 0x2
1789  2F87     GOTO 0x787
133:                 //while(ACKSTAT==1);
134:                 return ACKSTAT;
178A  3000     MOVLW 0x0
178B  1B11     BTFSC TMR2, 0x6
178C  3001     MOVLW 0x1
178D  0008     RETURN
135:               }
136:               else
137:               {
138:                 SSPBUF = data;
178E  0823     MOVF x, W
178F  0093     MOVWF SSPBUF
139:                 CKP = 1;
1790  1614     BSF SSPCON, 0x4
140:                 return 0;
1791  3400     RETLW 0x0
141:               }
142:             }
143:           
144:             unsigned char read_i2c (unsigned char respuesta)
16CB  1283     BCF STATUS, 0x5
16CC  00A3     MOVWF x
145:             {
146:               unsigned char dato;
147:           
148:               if (SSPM3 == 1)
16CD  1D94     BTFSS SSPCON, 0x3
16CE  2EF2     GOTO 0x6F2
149:               {
150:                 while (( SSPCON2 & 0x1F ) || R_nW );
16CF  1683     BSF STATUS, 0x5
16D0  0811     MOVF TMR2, W
16D1  391F     ANDLW 0x1F
16D2  1903     BTFSC STATUS, 0x2
16D3  1914     BTFSC SSPCON, 0x2
16D4  2ECF     GOTO 0x6CF
151:                 RCEN = 1;
16D5  1591     BSF TMR2, 0x3
152:                 while (( SSPCON2 & 0x1F ) || R_nW );
16D6  0811     MOVF TMR2, W
16D7  391F     ANDLW 0x1F
16D8  1903     BTFSC STATUS, 0x2
16D9  1914     BTFSC SSPCON, 0x2
16DA  2ED6     GOTO 0x6D6
153:                 dato = SSPBUF;
16DB  1283     BCF STATUS, 0x5
16DC  0813     MOVF SSPBUF, W
16DD  00A4     MOVWF dato
154:                 while (( SSPCON2 & 0x1F ) || R_nW );
16DE  1683     BSF STATUS, 0x5
16DF  0811     MOVF TMR2, W
16E0  391F     ANDLW 0x1F
16E1  1903     BTFSC STATUS, 0x2
16E2  1914     BTFSC SSPCON, 0x2
16E3  2EDE     GOTO 0x6DE
155:                 ACKDT = respuesta;
16E4  1283     BCF STATUS, 0x5
16E5  1C23     BTFSS x, 0x0
16E6  2EEB     GOTO 0x6EB
16E7  1683     BSF STATUS, 0x5
16E8  1303     BCF STATUS, 0x6
16E9  1691     BSF TMR2, 0x5
16EA  2EEE     GOTO 0x6EE
16EB  1683     BSF STATUS, 0x5
16EC  1303     BCF STATUS, 0x6
16ED  1291     BCF TMR2, 0x5
156:                 ACKEN = 1;
16EE  1611     BSF TMR2, 0x4
157:                 return dato;
16EF  1283     BCF STATUS, 0x5
16F0  0824     MOVF dato, W
16F1  0008     RETURN
158:               }
159:               else
160:               {
161:                 dato = SSPBUF;
16F2  0813     MOVF SSPBUF, W
16F3  00A4     MOVWF dato
162:                 return dato;
163:               }
164:             }
16F4  0008     RETURN
165:           #else
166:             #error Faltan definir parametros
167:           #endif
