Disassembly Listing for Control_BOMBA_RTC_ISL1208_V6
Generated From:
/home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/dist/ISL1208_XC8_16f877a/production/Control_BOMBA_RTC_ISL1208_V6.X.production.cof
02/02/2015 01:10:49

---  /opt/microchip/xc8/v1.31/sources/pic/fldiv.c  ------------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (C) 2006 HI-TECH Software
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"flarith.h"
9:             
10:            #define	f1_as_dividend	(*(unsigned long *)&f1)
11:            #define	f2_as_divisor	(*(unsigned long *)&f2)
12:            #define	f3_as_quot	(*(unsigned long *)&f3)
13:            
14:            // floating addition
15:            #ifdef _OLDLIB
16:            #define	cntr		sign2
17:            double
18:            __fldiv(double f2, double f1)
19:            {
20:            	unsigned char	exp1, exp2, sign1, sign2;
21:            	double	f3;
22:            	
23:            	f3_as_quot = 0;
24:            	sign1 = __flunpack(&f1_as_dividend, &exp1);
25:            	if(exp1 == 0)
26:            		return f3;
27:            	sign2 = __flunpack(&f2_as_divisor, &exp2);
28:            	if(exp2 == 0)
29:            		return f3;
30:            	exp1 -= exp2-127+8;	// compute new exponent
31:            	sign1 ^= sign2;
32:            	cntr = 24+8;
33:            	do {
34:            		f3_as_quot <<= 1;
35:            		if(f1_as_dividend >= f2_as_divisor) {
36:            			f1_as_dividend -= f2_as_divisor;
37:            			f3_as_quot |= 1;
38:            		}
39:            		f1_as_dividend <<= 1;
40:            	} while(--cntr != 0);
41:            	__flpack(&f3_as_quot, exp1);
42:            	if(sign1)
43:            		f3_as_quot |= 0x80000000;
44:            	return f3;
45:            }
46:            #else
47:            #define	exp2	sign
48:            double
49:            __fldiv(double f2, double f1)
50:            {
51:            	unsigned char	exp, sign, cntr;
52:            	double	f3;
53:            	
54:            	// unpack the operands
55:            	if((exp = f1_as_dividend >> 23) == 0)
11CE  085C     MOVF f1, W
11CF  00E0     MOVWF 0x60
11D0  085D     MOVF 0x5D, W
11D1  00E1     MOVWF 0x61
11D2  085E     MOVF 0x5E, W
11D3  00E2     MOVWF 0x62
11D4  085F     MOVF 0x5F, W
11D5  00E3     MOVWF 0x63
11D6  1003     BCF STATUS, 0x0
11D7  0D62     RLF 0x62, W
11D8  0D63     RLF 0x63, W
11D9  00E9     MOVWF exp
11DA  08E9     MOVF exp, F
11DB  1D03     BTFSS STATUS, 0x2
11DC  29E2     GOTO 0x1E2
56:            		return 0.0;
11DD  01D8     CLRF width
11DE  01D9     CLRF 0x59
11DF  01DA     CLRF c
11E0  01DB     CLRF _val
11E1  0008     RETURN
57:            	if((exp2 = f2_as_divisor >> 23) == 0)
11E2  0858     MOVF width, W
11E3  00E0     MOVWF 0x60
11E4  0859     MOVF 0x59, W
11E5  00E1     MOVWF 0x61
11E6  085A     MOVF c, W
11E7  00E2     MOVWF 0x62
11E8  085B     MOVF _val, W
11E9  00E3     MOVWF 0x63
11EA  1003     BCF STATUS, 0x0
11EB  0D62     RLF 0x62, W
11EC  0D63     RLF 0x63, W
11ED  00EA     MOVWF sign
11EE  08EA     MOVF sign, F
11EF  1D03     BTFSS STATUS, 0x2
11F0  29F6     GOTO 0x1F6
58:            		return 0.0;
11F1  01D8     CLRF width
11F2  01D9     CLRF 0x59
11F3  01DA     CLRF c
11F4  01DB     CLRF _val
11F5  0008     RETURN
59:            	exp -= exp2-127+8;	// compute new exponent
11F6  3089     MOVLW 0x89
11F7  076A     ADDWF sign, W
11F8  00E0     MOVWF 0x60
11F9  02E9     SUBWF exp, F
60:            	sign = f1_as_dividend >> 24;
11FA  085F     MOVF 0x5F, W
11FB  00EA     MOVWF sign
61:            	sign ^= (unsigned char)(f2_as_divisor >> 24);
11FC  085B     MOVF _val, W
11FD  06EA     XORWF sign, F
62:            	sign &= 0x80;
11FE  3080     MOVLW 0x80
11FF  05EA     ANDWF sign, F
63:            	f1_as_dividend |= 0x800000UL;
1201  17DE     BSF 0x5E, 0x7
64:            	f1_as_dividend &= 0xFFFFFFUL;
1202  01DF     CLRF 0x5F
65:            	f2_as_divisor |= 0x800000UL;
1203  17DA     BSF c, 0x7
66:            	f2_as_divisor &= 0xFFFFFFUL;
1204  01DB     CLRF _val
67:            	cntr = 24+8;
1200  3020     MOVLW 0x20
1205  00E8     MOVWF cntr
68:            	do {
69:            		f3_as_quot <<= 1;
1206  1003     BCF STATUS, 0x0
1207  0DE4     RLF f3, F
1208  0DE5     RLF 0x65, F
1209  0DE6     RLF 0x66, F
120A  0DE7     RLF 0x67, F
70:            		if(f1_as_dividend >= f2_as_divisor) {
120B  085B     MOVF _val, W
120C  025F     SUBWF 0x5F, W
120D  1D03     BTFSS STATUS, 0x2
120E  2A19     GOTO 0x219
120F  085A     MOVF c, W
1210  025E     SUBWF 0x5E, W
1211  1D03     BTFSS STATUS, 0x2
1212  2A19     GOTO 0x219
1213  0859     MOVF 0x59, W
1214  025D     SUBWF 0x5D, W
1215  1D03     BTFSS STATUS, 0x2
1216  2A19     GOTO 0x219
1217  0858     MOVF width, W
1218  025C     SUBWF f1, W
1219  1C03     BTFSS STATUS, 0x0
121A  2A2B     GOTO 0x22B
71:            			f1_as_dividend -= f2_as_divisor;
121B  0858     MOVF width, W
121C  02DC     SUBWF f1, F
121D  0859     MOVF 0x59, W
121E  1C03     BTFSS STATUS, 0x0
121F  0F59     INCFSZ 0x59, W
1220  02DD     SUBWF 0x5D, F
1221  085A     MOVF c, W
1222  1C03     BTFSS STATUS, 0x0
1223  0F5A     INCFSZ c, W
1224  02DE     SUBWF 0x5E, F
1225  085B     MOVF _val, W
1226  1C03     BTFSS STATUS, 0x0
1227  0F5B     INCFSZ _val, W
1228  02DF     SUBWF 0x5F, F
72:            			f3_as_quot |= 1;
1229  1464     BSF f3, 0x0
73:            		}
74:            		f1_as_dividend <<= 1;
122A  1003     BCF STATUS, 0x0
122B  0DDC     RLF f1, F
122C  0DDD     RLF 0x5D, F
122D  0DDE     RLF 0x5E, F
122E  0DDF     RLF 0x5F, F
75:            	} while(--cntr != 0);
122F  0BE8     DECFSZ cntr, F
1230  2A06     GOTO 0x206
76:            	return __flpack(f3_as_quot, exp, sign);
1231  0867     MOVF 0x67, W
1232  00A7     MOVWF x
1233  0866     MOVF 0x66, W
1234  00A6     MOVWF y
1235  0865     MOVF 0x65, W
1236  00A5     MOVWF dato
1237  0864     MOVF f3, W
1238  00A4     MOVWF x
1239  0869     MOVF exp, W
123A  00A8     MOVWF i
123B  086A     MOVF sign, W
123C  00A9     MOVWF mth
123D  23BA     CALL 0x3BA
123E  0827     MOVF x, W
123F  00DB     MOVWF _val
1240  0826     MOVF y, W
1241  00DA     MOVWF c
1242  0825     MOVF dato, W
1243  00D9     MOVWF 0x59
1244  0824     MOVF x, W
1245  00D8     MOVWF width
77:            }
1246  0008     RETURN
78:            #endif
---  /opt/microchip/xc8/v1.31/sources/pic/eewrite.c  ----------------------------------------------------
1:             #include	<htc.h>
2:             
3:             #if	EEPROM_SIZE > 0
4:             
5:             void
6:             eeprom_write(unsigned char addr, unsigned char value)
1FB8  00A5     MOVWF dato
7:             {
8:             	EEPROM_WRITE(addr, value);
1FB9  1683     BSF STATUS, 0x5
1FBA  1703     BSF STATUS, 0x6
1FBB  188C     BTFSC PIR1, 0x1
1FBC  2FB9     GOTO 0x7B9
1FBD  1283     BCF STATUS, 0x5
1FBE  1303     BCF STATUS, 0x6
1FBF  0825     MOVF dato, W
1FC0  1703     BSF STATUS, 0x6
1FC1  008D     MOVWF PIR2
1FC2  1303     BCF STATUS, 0x6
1FC3  0824     MOVF x, W
1FC4  1703     BSF STATUS, 0x6
1FC5  008C     MOVWF PIR1
1FC6  303F     MOVLW 0x3F
1FC7  1683     BSF STATUS, 0x5
1FC8  058C     ANDWF PIR1, F
1FC9  1003     BCF STATUS, 0x0
1FCA  1B8B     BTFSC INTCON, 0x7
1FCB  1403     BSF STATUS, 0x0
1FCC  138B     BCF INTCON, 0x7
1FCD  150C     BSF PIR1, 0x2
1FCE  3055     MOVLW 0x55
1FCF  008D     MOVWF PIR2
1FD0  30AA     MOVLW 0xAA
1FD1  008D     MOVWF PIR2
1FD2  148C     BSF PIR1, 0x1
1FD3  110C     BCF PIR1, 0x2
1FD4  1803     BTFSC STATUS, 0x0
1FD5  178B     BSF INTCON, 0x7
9:             }
1FD6  0008     RETURN
10:            #endif
11:            
---  /opt/microchip/xc8/v1.31/sources/pic/eeread.c  -----------------------------------------------------
1:             #include	<htc.h>
2:             
3:             #if	EEPROM_SIZE > 0
4:             
5:             unsigned char
6:             eeprom_read(unsigned char addr)
1F9D  1283     BCF STATUS, 0x5
1F9E  00A4     MOVWF x
7:             {
8:             	do
9:             		CLRWDT();
1FA2  0064     CLRWDT
10:            	while(WR);
1F9F  2FA2     GOTO 0x7A2
1FA0  1283     BCF STATUS, 0x5
1FA1  1303     BCF STATUS, 0x6
1FA3  1683     BSF STATUS, 0x5
1FA4  1703     BSF STATUS, 0x6
1FA5  188C     BTFSC PIR1, 0x1
1FA6  2FA0     GOTO 0x7A0
11:            	return EEPROM_READ(addr);
1FA7  1283     BCF STATUS, 0x5
1FA8  1303     BCF STATUS, 0x6
1FA9  0824     MOVF x, W
1FAA  1703     BSF STATUS, 0x6
1FAB  008D     MOVWF PIR2
1FAC  303F     MOVLW 0x3F
1FAD  1683     BSF STATUS, 0x5
1FAE  058C     ANDWF PIR1, F
1FAF  140C     BSF PIR1, 0x0
1FB0  1003     BCF STATUS, 0x0
1FB1  180C     BTFSC PIR1, 0x0
1FB2  1403     BSF STATUS, 0x0
1FB3  1803     BTFSC STATUS, 0x0
1FB4  3001     MOVLW 0x1
1FB5  1283     BCF STATUS, 0x5
1FB6  080C     MOVF PIR1, W
12:            }
1FB7  0008     RETURN
13:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/wmul.c  ----------------------------------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             unsigned int
3:             __wmul(unsigned int multiplier, unsigned int multiplicand)
4:             {
5:                     unsigned int product;
6:             
7:             #ifdef _PIC18
8:             
9:             #define LOWBYTE(x)  (*(unsigned char *)(&x))
10:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
11:            
12:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
13:            /*
14:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
15:                   a  b
16:            *      c  d
17:            -----------
18:                 |   bd
19:                 |ad  0
20:                 |bc  0
21:            +  ac| 0  0 (we ignore this intermediate product
22:                         because it does not affect the low 16 bits of the result)
23:            ===========
24:             */
25:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
26:                    product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
27:                    product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
28:            
29:            #else
30:            
31:            	product = 0;
0F99  01A8     CLRF i
0F9A  01A9     CLRF mth
32:            	do {
33:            		if(multiplier & 1)
0F9B  1C24     BTFSS x, 0x0
0F9C  2FA3     GOTO 0x7A3
34:            			product += multiplicand;
0F9D  0826     MOVF y, W
0F9E  07A8     ADDWF i, F
0F9F  1803     BTFSC STATUS, 0x0
0FA0  0AA9     INCF mth, F
0FA1  0827     MOVF x, W
0FA2  07A9     ADDWF mth, F
35:            		multiplicand <<= 1;
0FA3  1003     BCF STATUS, 0x0
0FA4  0DA6     RLF y, F
0FA5  0DA7     RLF x, F
36:            		multiplier >>= 1;
0FA6  1003     BCF STATUS, 0x0
0FA7  0CA5     RRF dato, F
0FA8  0CA4     RRF x, F
37:            	} while(multiplier != 0);
0FA9  0825     MOVF dato, W
0FAA  0424     IORWF x, W
0FAB  1D03     BTFSS STATUS, 0x2
0FAC  2F9B     GOTO 0x79B
38:            
39:            #endif
40:                    return product;
0FAD  0829     MOVF mth, W
0FAE  00A5     MOVWF dato
0FAF  0828     MOVF i, W
0FB0  00A4     MOVWF x
41:            }
0FB1  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/strncpy.c  -------------------------------------------------
1:             #include	<string.h>
2:             
3:             #ifdef _PIC16
4:             far char *
5:             strncpy(register far char * to, register const char * from, register size_t size)
6:             #else /* _PIC16 */
7:             char *
8:             strncpy(register char * to, register const char * from, register size_t size)
1012  00CF     MOVWF to
9:             #endif /* _PIC16 */
10:            {
11:            
12:            #ifdef _PIC16
13:            	register far char *	cp;
14:            #else /* _PIC16 */
15:            	register char *	cp;
16:            #endif /* _PIC16 */
17:            
18:            	cp = to;
1013  00D0     MOVWF cp
19:            	while(size) {
1014  084B     MOVF 0x4B, W
1015  044A     IORWF f, W
1017  1903     BTFSC STATUS, 0x2
1018  283F     GOTO 0x3F
1038  2814     GOTO 0x14
20:            		size--;
1016  3001     MOVLW 0x1
1019  02CA     SUBWF f, F
101A  3000     MOVLW 0x0
101B  1C03     BTFSS STATUS, 0x0
101C  03CB     DECF 0x4B, F
101D  02CB     SUBWF 0x4B, F
21:            		if(!(*cp++ = *from++))
101E  0849     MOVF f2, W
101F  00CD     MOVWF 0x4D
1020  0848     MOVF sp, W
1021  00CC     MOVWF 0x4C
1022  0AC8     INCF sp, F
1023  1903     BTFSC STATUS, 0x2
1024  0AC9     INCF f2, F
1025  084D     MOVF 0x4D, W
1026  00FF     MOVWF 0x7F
1027  084C     MOVF 0x4C, W
1028  0084     MOVWF FSR
1029  160A     BSF PCLATH, 0x4
102A  158A     BSF PCLATH, 0x3
102B  2000     CALL 0x0
102C  160A     BSF PCLATH, 0x4
102D  118A     BCF PCLATH, 0x3
102E  00CE     MOVWF 0x4E
102F  0850     MOVF cp, W
1030  0AD0     INCF cp, F
1031  0084     MOVWF FSR
1032  084E     MOVF 0x4E, W
1033  1383     BCF STATUS, 0x7
1034  0080     MOVWF INDF
1035  0880     MOVF INDF, F
1036  1903     BTFSC STATUS, 0x2
1037  283E     GOTO 0x3E
22:            			break;
23:            	}
24:            	while(size--)
103E  3001     MOVLW 0x1
103F  02CA     SUBWF f, F
1040  3000     MOVLW 0x0
1041  1C03     BTFSS STATUS, 0x0
1042  03CB     DECF 0x4B, F
1043  02CB     SUBWF 0x4B, F
1044  0A4A     INCF f, W
1045  1903     BTFSC STATUS, 0x2
1046  0A4B     INCF 0x4B, W
1047  1903     BTFSC STATUS, 0x2
1048  0008     RETURN
1049  2839     GOTO 0x39
25:            		*cp++ = 0;
1039  0850     MOVF cp, W
26:            	return to;
27:            }
---  /opt/microchip/xc8/v1.31/sources/common/lwtofl.c  --------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"flarith.h"
9:             
10:            
11:            // Convert unsigned int to float
12:            
13:            #ifdef _OLDLIB
14:            #define	f1_as_mant1	(*(unsigned long *)&f1)
15:            double
16:            __lwtofl(unsigned int c)
17:            {
18:            	double	f1;
19:            	
20:            	if(c == 0)
21:            		return 0.0;
22:            	f1_as_mant1 = c;
23:            	__flpack(&f1_as_mant1, 127+23);
24:            	return f1;
25:            }
26:            #else
27:            double
28:            __lwtofl(unsigned int c)
29:            {
30:            	return __flpack(c, 127+23, 0);
119F  082E     MOVF day, W
11A0  00A4     MOVWF x
11A1  082F     MOVF sign, W
11A2  00A5     MOVWF dato
11A3  3096     MOVLW 0x96
11A4  01A6     CLRF y
11A5  01A7     CLRF x
11A6  00A8     MOVWF i
11A7  01A9     CLRF mth
11A8  23BA     CALL 0x3BA
11A9  0827     MOVF x, W
11AA  00B1     MOVWF 0x31
11AB  0826     MOVF y, W
11AC  00B0     MOVWF quotient
11AD  0825     MOVF dato, W
11AE  00AF     MOVWF sign
11AF  0824     MOVF x, W
11B0  00AE     MOVWF day
31:            }
11B1  0008     RETURN
32:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/lwmod.c  ---------------------------------------------------
1:             // word unsigned modulus
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwmod(unsigned int divisor, unsigned int dividend)
0FDC  082C     MOVF sec, W
1772  0871     MOVF canal, W
7:             #else
8:             __lwmod(unsigned int dividend, unsigned int divisor)
9:             #endif
10:            {
11:            	unsigned char	counter;
12:            
13:            	if(divisor != 0) {
0FDC  082C     MOVF sec, W
0FDD  042B     IORWF Data, W
0FDE  1903     BTFSC STATUS, 0x2
0FDF  2FFB     GOTO 0x7FB
1772  0871     MOVF canal, W
1773  0470     IORWF tiempo, W
1774  1903     BTFSC STATUS, 0x2
1775  2F91     GOTO 0x791
14:            		counter = 1;
0FE0  01AF     CLRF sign
1776  01F4     CLRF counter
15:            		while((divisor & 0x8000) == 0) {
0FE2  1BAC     BTFSC sec, 0x7
0FE3  2FE8     GOTO 0x7E8
0FE7  2FE1     GOTO 0x7E1
1778  1BF1     BTFSC canal, 0x7
1779  2F7E     GOTO 0x77E
177D  2F77     GOTO 0x777
16:            			divisor <<= 1;
0FE1  0AAF     INCF sign, F
0FE4  1003     BCF STATUS, 0x0
0FE5  0DAB     RLF Data, F
0FE6  0DAC     RLF sec, F
1777  0AF4     INCF counter, F
177A  1003     BCF STATUS, 0x0
177B  0DF0     RLF tiempo, F
177C  0DF1     RLF canal, F
17:            			counter++;
0FE1  0AAF     INCF sign, F
1777  0AF4     INCF counter, F
18:            		}
19:            		do {
20:            			if(divisor <= dividend)
0FE8  082C     MOVF sec, W
0FE9  022E     SUBWF day, W
0FEA  1D03     BTFSS STATUS, 0x2
0FEB  2FEE     GOTO 0x7EE
0FEC  082B     MOVF Data, W
0FED  022D     SUBWF hr, W
0FEE  1C03     BTFSS STATUS, 0x0
0FEF  2FF7     GOTO 0x7F7
177E  0871     MOVF canal, W
177F  0273     SUBWF counter, W
1780  1D03     BTFSS STATUS, 0x2
1781  2F84     GOTO 0x784
1782  0870     MOVF tiempo, W
1783  0272     SUBWF dividend, W
1784  1C03     BTFSS STATUS, 0x0
1785  2F8D     GOTO 0x78D
21:            				dividend -= divisor;
0FF0  082B     MOVF Data, W
0FF1  02AD     SUBWF hr, F
0FF2  082C     MOVF sec, W
0FF3  1C03     BTFSS STATUS, 0x0
0FF4  03AE     DECF day, F
0FF5  02AE     SUBWF day, F
1786  0870     MOVF tiempo, W
1787  02F2     SUBWF dividend, F
1788  0871     MOVF canal, W
1789  1C03     BTFSS STATUS, 0x0
178A  03F3     DECF counter, F
178B  02F3     SUBWF counter, F
22:            			divisor >>= 1;
0FF6  1003     BCF STATUS, 0x0
0FF7  0CAC     RRF sec, F
0FF8  0CAB     RRF Data, F
178C  1003     BCF STATUS, 0x0
178D  0CF1     RRF canal, F
178E  0CF0     RRF tiempo, F
23:            		} while(--counter != 0);
0FF9  0BAF     DECFSZ sign, F
0FFA  2FE8     GOTO 0x7E8
178F  0BF4     DECFSZ counter, F
1790  2F7E     GOTO 0x77E
24:            	}
25:            	return dividend;
0FFB  082E     MOVF day, W
0FFC  00AC     MOVWF sec
0FFD  082D     MOVF hr, W
0FFE  00AB     MOVWF Data
1791  0873     MOVF counter, W
1792  00F1     MOVWF canal
1793  0872     MOVF dividend, W
1794  00F0     MOVWF tiempo
26:            }
0FFF  0008     RETURN
1000  3FFF     ADDLW 0xFF
1795  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/lwdiv.c  ---------------------------------------------------
1:             // word unsigned division
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwdiv(unsigned int divisor, unsigned int dividend)
7:             #else
8:             __lwdiv(unsigned int dividend, unsigned int divisor)
9:             #endif
10:            {
11:            	unsigned int	quotient;
12:            	unsigned char	counter;
13:            
14:            	quotient = 0;
0FB2  01A9     CLRF mth
0FB3  01AA     CLRF year
15:            	if(divisor != 0) {
0FB4  0825     MOVF dato, W
0FB5  0424     IORWF x, W
0FB6  1903     BTFSC STATUS, 0x2
0FB7  2FD7     GOTO 0x7D7
16:            		counter = 1;
0FB8  01A8     CLRF i
17:            		while((divisor & 0x8000) == 0) {
0FBA  1BA5     BTFSC dato, 0x7
0FBB  2FC0     GOTO 0x7C0
0FBF  2FB9     GOTO 0x7B9
18:            			divisor <<= 1;
0FB9  0AA8     INCF i, F
0FBC  1003     BCF STATUS, 0x0
0FBD  0DA4     RLF x, F
0FBE  0DA5     RLF dato, F
19:            			counter++;
0FB9  0AA8     INCF i, F
20:            		}
21:            		do {
22:            			quotient <<= 1;
0FC0  1003     BCF STATUS, 0x0
0FC1  0DA9     RLF mth, F
0FC2  0DAA     RLF year, F
23:            			if(divisor <= dividend) {
0FC3  0825     MOVF dato, W
0FC4  0227     SUBWF x, W
0FC5  1D03     BTFSS STATUS, 0x2
0FC6  2FC9     GOTO 0x7C9
0FC7  0824     MOVF x, W
0FC8  0226     SUBWF y, W
0FC9  1C03     BTFSS STATUS, 0x0
0FCA  2FD3     GOTO 0x7D3
24:            				dividend -= divisor;
0FCB  0824     MOVF x, W
0FCC  02A6     SUBWF y, F
0FCD  0825     MOVF dato, W
0FCE  1C03     BTFSS STATUS, 0x0
0FCF  03A7     DECF x, F
0FD0  02A7     SUBWF x, F
25:            				quotient |= 1;
0FD1  1429     BSF mth, 0x0
26:            			}
27:            			divisor >>= 1;
0FD2  1003     BCF STATUS, 0x0
0FD3  0CA5     RRF dato, F
0FD4  0CA4     RRF x, F
28:            		} while(--counter != 0);
0FD5  0BA8     DECFSZ i, F
0FD6  2FC0     GOTO 0x7C0
29:            	}
30:            	return quotient;
0FD7  082A     MOVF year, W
0FD8  00A5     MOVWF dato
0FD9  0829     MOVF mth, W
0FDA  00A4     MOVWF x
31:            }
0FDB  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/lbmod.c  ---------------------------------------------------
1:             // byte unsigned modulus
2:             
3:             unsigned char
4:             __lbmod(unsigned char dividend, unsigned char divisor)
0D95  00A6     MOVWF y
17C8  00F2     MOVWF dividend
5:             {
6:             	unsigned char	rem;
7:             	unsigned char	counter;
8:             
9:             	counter = 8;
0D96  3008     MOVLW 0x8
0D97  00A7     MOVWF x
17C9  3008     MOVLW 0x8
17CA  00F3     MOVWF counter
10:            	rem = 0;
0D98  01A8     CLRF i
17CB  01F4     CLRF counter
11:            	do {
12:            		rem = (rem << 1) | (dividend >> 7);
0D99  0826     MOVF y, W
0D9A  00A5     MOVWF dato
0D9B  3007     MOVLW 0x7
0D9C  1003     BCF STATUS, 0x0
0D9D  0CA5     RRF dato, F
0D9E  3EFF     ADDLW 0xFF
0D9F  1003     BCF STATUS, 0x0
0DA0  1D03     BTFSS STATUS, 0x2
0DA1  2D9D     GOTO 0x59D
0DA2  0D28     RLF i, W
0DA3  0425     IORWF dato, W
0DA4  00A8     MOVWF i
17CC  0872     MOVF dividend, W
17CD  00F1     MOVWF canal
17CE  3007     MOVLW 0x7
17CF  1003     BCF STATUS, 0x0
17D0  0CF1     RRF canal, F
17D1  3EFF     ADDLW 0xFF
17D2  1003     BCF STATUS, 0x0
17D3  1D03     BTFSS STATUS, 0x2
17D4  2FD0     GOTO 0x7D0
17D5  0D74     RLF counter, W
17D6  0471     IORWF canal, W
17D7  00F4     MOVWF counter
13:            		dividend <<= 1;
0DA5  1003     BCF STATUS, 0x0
0DA6  0DA6     RLF y, F
17D8  1003     BCF STATUS, 0x0
17D9  0DF2     RLF dividend, F
14:            		if(divisor <= rem)
0DA7  0824     MOVF x, W
0DA8  0228     SUBWF i, W
0DA9  1C03     BTFSS STATUS, 0x0
0DAA  2DAD     GOTO 0x5AD
17DA  0870     MOVF tiempo, W
17DB  0274     SUBWF counter, W
17DC  1C03     BTFSS STATUS, 0x0
17DD  2FE0     GOTO 0x7E0
15:            			rem -= divisor;
0DAB  0824     MOVF x, W
0DAC  02A8     SUBWF i, F
17DE  0870     MOVF tiempo, W
17DF  02F4     SUBWF counter, F
16:            	} while(--counter != 0);
0DAD  0BA7     DECFSZ x, F
0DAE  2D99     GOTO 0x599
17E0  0BF3     DECFSZ counter, F
17E1  2FCC     GOTO 0x7CC
17:            	return rem;
0DAF  0828     MOVF i, W
17E2  0874     MOVF counter, W
18:            }
0DB0  0008     RETURN
17E3  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/lbdiv.c  ---------------------------------------------------
1:             // byte unsigned division
2:             
3:             unsigned char
4:             __lbdiv(unsigned char dividend, unsigned char divisor)
0D2E  00A5     MOVWF dato
5:             {
6:             	unsigned char	quotient;
7:             	unsigned char	counter;
8:             
9:             	quotient = 0;
0D2F  01A7     CLRF x
10:            	if(divisor != 0) {
0D30  0824     MOVF x, W
0D31  1903     BTFSC STATUS, 0x2
0D32  2D47     GOTO 0x547
11:            		counter = 1;
0D33  01A6     CLRF y
12:            		while((divisor & 0x80) == 0) {
0D35  1BA4     BTFSC x, 0x7
0D36  2D3A     GOTO 0x53A
0D39  2D34     GOTO 0x534
13:            			divisor <<= 1;
0D37  1003     BCF STATUS, 0x0
0D38  0DA4     RLF x, F
14:            			counter++;
0D34  0AA6     INCF y, F
15:            		}
16:            		do {
17:            			quotient <<= 1;
0D3A  1003     BCF STATUS, 0x0
0D3B  0DA7     RLF x, F
18:            			if(divisor <= dividend) {
0D3C  0824     MOVF x, W
0D3D  0225     SUBWF dato, W
0D3E  1C03     BTFSS STATUS, 0x0
0D3F  2D44     GOTO 0x544
19:            				dividend -= divisor;
0D40  0824     MOVF x, W
0D41  02A5     SUBWF dato, F
20:            				quotient |= 1;
0D42  1427     BSF x, 0x0
21:            			}
22:            			divisor >>= 1;
0D43  1003     BCF STATUS, 0x0
0D44  0CA4     RRF x, F
23:            		} while(--counter != 0);
0D45  0BA6     DECFSZ y, F
0D46  2D3A     GOTO 0x53A
24:            	}
25:            	return quotient;
0D47  0827     MOVF x, W
26:            }
0D48  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/isdigit.c  -------------------------------------------------
1:             #include	<ctype.h>
2:             
3:             #ifndef isdigit
4:             
5:             #ifdef _CTYPE_BIT_FUNCS_
6:             
7:             bit
8:             isdigit(char c)
0F8B  00A5     MOVWF dato
9:             #else
10:            int
11:            isdigit(int c)
12:            #endif
13:            {
14:            	return c <= '9' && c >= '0';
0F8C  303A     MOVLW 0x3A
0F8D  01A4     CLRF x
0F8E  0225     SUBWF dato, W
0F8F  1803     BTFSC STATUS, 0x0
0F90  2F97     GOTO 0x797
0F91  3030     MOVLW 0x30
0F92  0225     SUBWF dato, W
0F93  1C03     BTFSS STATUS, 0x0
0F94  2F97     GOTO 0x797
0F95  01A4     CLRF x
0F96  0AA4     INCF x, F
0F97  0C24     RRF x, W
15:            }
0F98  0008     RETURN
16:            
17:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/fltol.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"flarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned long *)&f1)
11:            
12:            // Convert float to long
13:            #ifdef _OLDLIB
14:            long
15:            __fltol(double f1)
16:            {
17:            	unsigned char	sign1, exp1;
18:            	unsigned long	lval;
19:            
20:            	sign1 = __flunpack(&f1_as_mant1, &exp1);
21:            	lval = f1_as_mant1;
22:            	exp1 -= 127+23;
23:            	if((signed char)exp1 < 0) {
24:            		if((signed char)exp1 < -23)
25:            			return 0;
26:            		do
27:            			lval >>= 1;
28:            		while(++exp1 != 0);
29:            	} else {
30:            		if(exp1 >= 32)
31:            			return 00;
32:            		while(exp1 != 0) {
33:            			lval <<= 1;
34:            			exp1--;
35:            		}
36:            	}
37:            	if(sign1)
38:            		lval = -lval;
39:            	return lval;
40:            }
41:            #else
42:            long
43:            __fltol(double f1)
44:            {
45:            	unsigned char	sign1, exp1;
46:            
47:            	if((exp1 = f1_as_mant1 >> 23) == 0)
0845  0824     MOVF x, W
0846  00A8     MOVWF i
0847  0825     MOVF dato, W
0848  00A9     MOVWF mth
0849  0826     MOVF y, W
084A  00AA     MOVWF year
084B  0827     MOVF x, W
084C  00AB     MOVWF Data
084D  1003     BCF STATUS, 0x0
084E  0D2A     RLF year, W
084F  0D2B     RLF Data, W
0850  00AD     MOVWF hr
0851  08AD     MOVF hr, F
0852  1D03     BTFSS STATUS, 0x2
0853  2859     GOTO 0x59
48:            		return 0;
0854  01A4     CLRF x
0855  01A5     CLRF dato
0856  01A6     CLRF y
0857  01A7     CLRF x
0858  0008     RETURN
49:            	sign1 = f1_as_mant1 >> 31;
0859  0824     MOVF x, W
085A  00A8     MOVWF i
085B  0825     MOVF dato, W
085C  00A9     MOVWF mth
085D  0826     MOVF y, W
085E  00AA     MOVWF year
085F  0827     MOVF x, W
0860  00AB     MOVWF Data
0861  301F     MOVLW 0x1F
0862  1003     BCF STATUS, 0x0
0863  0CAB     RRF Data, F
0864  0CAA     RRF year, F
0865  0CA9     RRF mth, F
0866  0CA8     RRF i, F
0867  3EFF     ADDLW 0xFF
0868  1D03     BTFSS STATUS, 0x2
0869  2862     GOTO 0x62
086A  0828     MOVF i, W
086B  00AC     MOVWF sec
50:            	f1_as_mant1 |= 0x800000UL;
086D  17A6     BSF y, 0x7
51:            	f1_as_mant1 &= 0xFFFFFFUL;
086E  01A7     CLRF x
52:            	exp1 -= 127+23;
086C  3096     MOVLW 0x96
086F  02AD     SUBWF hr, F
53:            	if((signed char)exp1 < 0) {
0870  1FAD     BTFSS hr, 0x7
0871  287F     GOTO 0x7F
54:            		if((signed char)exp1 < -23)
0872  082D     MOVF hr, W
0873  3A80     XORLW 0x80
0874  3E97     ADDLW 0x97
0875  1C03     BTFSS STATUS, 0x0
0876  2854     GOTO 0x54
55:            			return 0;
56:            		do
57:            			f1_as_mant1 >>= 1;
0877  1003     BCF STATUS, 0x0
0878  0CA7     RRF x, F
0879  0CA6     RRF y, F
087A  0CA5     RRF dato, F
087B  0CA4     RRF x, F
58:            		while(++exp1 != 0);
087C  0FAD     INCFSZ hr, F
087D  2877     GOTO 0x77
087E  288D     GOTO 0x8D
59:            	} else {
60:            		if(exp1 >= 32)
087F  3020     MOVLW 0x20
0880  022D     SUBWF hr, W
0881  1803     BTFSC STATUS, 0x0
0882  2854     GOTO 0x54
61:            			return 00;
62:            		while(exp1 != 0) {
0883  08AD     MOVF hr, F
088C  2883     GOTO 0x83
63:            			f1_as_mant1 <<= 1;
0886  1003     BCF STATUS, 0x0
0887  0DA4     RLF x, F
0888  0DA5     RLF dato, F
0889  0DA6     RLF y, F
088A  0DA7     RLF x, F
64:            			exp1--;
088B  03AD     DECF hr, F
65:            		}
0883  08AD     MOVF hr, F
0884  1903     BTFSC STATUS, 0x2
0885  288D     GOTO 0x8D
66:            	}
67:            	if(sign1)
088D  082C     MOVF sec, W
088E  1903     BTFSC STATUS, 0x2
088F  0008     RETURN
68:            		f1_as_mant1 = -f1_as_mant1;
0890  09A4     COMF x, F
0891  09A5     COMF dato, F
0892  09A6     COMF y, F
0893  09A7     COMF x, F
0894  0AA4     INCF x, F
0895  1903     BTFSC STATUS, 0x2
0896  0AA5     INCF dato, F
0897  1903     BTFSC STATUS, 0x2
0898  0AA6     INCF y, F
0899  1903     BTFSC STATUS, 0x2
089A  0AA7     INCF x, F
69:            	return f1_as_mant1;
70:            }
089B  0008     RETURN
71:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/flsub.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"flarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned long *)&f1)
11:            #define	f2_as_mant2	(*(unsigned long *)&f2)
12:            
13:            // floating addition
14:            
15:            double
16:            #ifdef __PICC__
17:            #warning TODO: update cgpic and this file to use the other prototype
18:            __flsub(double f2, double f1)
19:            #else
20:            __flsub(double f1, double f2)
21:            #endif
22:            {
23:            	f2_as_mant2 ^= 0x80000000;
11B2  3080     MOVLW 0x80
11B3  06C0     XORWF 0x40, F
24:            #ifdef __PICC__
25:            #warning TODO: update this file to use the other prototype
26:            	return __fladd(f2, f1);
11B4  0840     MOVF 0x40, W
11B5  00B1     MOVWF 0x31
11B6  083F     MOVF 0x3F, W
11B7  00B0     MOVWF quotient
11B8  083E     MOVF 0x3E, W
11B9  00AF     MOVWF sign
11BA  083D     MOVF f2, W
11BB  00AE     MOVWF day
11BC  0844     MOVF dow, W
11BD  00B5     MOVWF 0x35
11BE  0843     MOVF m, W
11BF  00B4     MOVWF dividend
11C0  0842     MOVF 0x42, W
11C1  00B3     MOVWF 0x33
11C2  0841     MOVF f1, W
11C3  00B2     MOVWF divisor
11C4  22DD     CALL 0x2DD
11C5  0831     MOVF 0x31, W
11C6  00C0     MOVWF 0x40
11C7  0830     MOVF quotient, W
11C8  00BF     MOVWF 0x3F
11C9  082F     MOVF sign, W
11CA  00BE     MOVWF 0x3E
11CB  082E     MOVF day, W
11CC  00BD     MOVWF f2
27:            #else
28:            	return __fladd(f1, f2);
29:            #endif
30:            }
11CD  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/flmul.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"flarith.h"
9:             
10:            #define	f1_as_plier	(*(unsigned long *)&f1)
11:            #define	f2_as_plicand	(*(unsigned long *)&f2)
12:            
13:            // floating addition
14:            #ifdef _OLDLIB
15:            #define	f3_as_product		(*(unsigned long *)&f3)
16:            double
17:            __flmul(double f1, double f2)
18:            {
19:            	unsigned char	exp1, sign1, cntr;
20:            	double	f3;
21:            	
22:            	f3_as_product = 0;
23:            	sign1 = __flunpack(&f1_as_plier, &exp1);
24:            	sign1 ^= __flunpack(&f2_as_plicand, &cntr);
25:            	if(cntr == 0 || exp1 == 0)
26:            		return f3;
27:            	exp1 += cntr-127-6;	// compute new exponent
28:            	cntr = 7;
29:            	do {
30:            		if(f1_as_plier & 1)
31:            			f3_as_product += f2_as_plicand;
32:            		f1_as_plier >>= 1;
33:            		f2_as_plicand <<= 1;
34:            	} while(--cntr != 0);
35:            	cntr = 17;
36:            	do {
37:            		if(f1_as_plier & 1)
38:            			f3_as_product += f2_as_plicand;
39:            		f1_as_plier >>= 1;
40:            		f3_as_product >>= 1;
41:            	} while(--cntr != 0);
42:            	__flpack(&f3_as_product, exp1);
43:            	if(sign1)
44:            		f3_as_product |= 0x80000000;
45:            	return f3;
46:            }
47:            #else
48:            #define	exp2	sign
49:            double
50:            __flmul(double f1, double f2)
51:            {
52:            	unsigned char	exp, sign, cntr;
53:            	unsigned long	f3_as_product;
54:            	
55:            	if((exp = f1_as_plier >> 23) == 0)
1247  0845     MOVF a, W
1248  00CD     MOVWF 0x4D
1249  0846     MOVF dia, W
124A  00CE     MOVWF 0x4E
124B  0847     MOVF y, W
124C  00CF     MOVWF to
124D  0848     MOVF sp, W
124E  00D0     MOVWF cp
124F  1003     BCF STATUS, 0x0
1250  0D4F     RLF to, W
1251  0D50     RLF cp, W
1252  00D1     MOVWF exp
1253  08D1     MOVF exp, F
1254  1D03     BTFSS STATUS, 0x2
1255  2A5B     GOTO 0x25B
56:            		return 0.0;
1256  01C5     CLRF a
1257  01C6     CLRF dia
1258  01C7     CLRF y
1259  01C8     CLRF sp
125A  0008     RETURN
57:            	if((exp2 = f2_as_plicand >> 23) == 0)
125B  0849     MOVF f2, W
125C  00CD     MOVWF 0x4D
125D  084A     MOVF f, W
125E  00CE     MOVWF 0x4E
125F  084B     MOVF 0x4B, W
1260  00CF     MOVWF to
1261  084C     MOVF 0x4C, W
1262  00D0     MOVWF cp
1263  1003     BCF STATUS, 0x0
1264  0D4F     RLF to, W
1265  0D50     RLF cp, W
1266  00D7     MOVWF flag
1267  08D7     MOVF flag, F
1268  1D03     BTFSS STATUS, 0x2
1269  2A6F     GOTO 0x26F
58:            		return 0.0;
126A  01C5     CLRF a
126B  01C6     CLRF dia
126C  01C7     CLRF y
126D  01C8     CLRF sp
126E  0008     RETURN
59:            	exp += exp2-127-6;	// compute new exponent
126F  0857     MOVF flag, W
1270  3E7B     ADDLW 0x7B
1271  07D1     ADDWF exp, F
60:            	sign = f1_as_plier >> 24;
1272  0848     MOVF sp, W
1273  00D7     MOVWF flag
61:            	sign ^= (unsigned char)(f2_as_plicand >> 24);
1274  084C     MOVF 0x4C, W
1275  06D7     XORWF flag, F
62:            	sign &= 0x80;
1276  3080     MOVLW 0x80
1277  05D7     ANDWF flag, F
63:            	f1_as_plier |= 0x800000UL;
1279  17C7     BSF y, 0x7
64:            	//f1_as_plier &= 0xFFFFFFUL;		// not required
65:            	f2_as_plicand |= 0x800000UL;
127A  17CB     BSF 0x4B, 0x7
66:            	f2_as_plicand &= 0xFFFFFFUL;
127B  01CC     CLRF 0x4C
67:            	f3_as_product = 0;
127C  01D2     CLRF f3_as_product
127D  01D3     CLRF 0x53
127E  01D4     CLRF 0x54
127F  01D5     CLRF prec
68:            	cntr = 7;
1278  3007     MOVLW 0x7
1280  00D6     MOVWF ap
69:            	do {
70:            		if(f1_as_plier & 1)
1281  1C45     BTFSS a, 0x0
1282  2A97     GOTO 0x297
71:            			f3_as_product += f2_as_plicand;
1283  0849     MOVF f2, W
1284  07D2     ADDWF f3_as_product, F
1285  084A     MOVF f, W
1286  1103     BCF STATUS, 0x2
1287  1803     BTFSC STATUS, 0x0
1288  3E01     ADDLW 0x1
1289  1D03     BTFSS STATUS, 0x2
128A  07D3     ADDWF 0x53, F
128B  084B     MOVF 0x4B, W
128C  1103     BCF STATUS, 0x2
128D  1803     BTFSC STATUS, 0x0
128E  3E01     ADDLW 0x1
128F  1D03     BTFSS STATUS, 0x2
1290  07D4     ADDWF 0x54, F
1291  084C     MOVF 0x4C, W
1292  1103     BCF STATUS, 0x2
1293  1803     BTFSC STATUS, 0x0
1294  3E01     ADDLW 0x1
1295  1D03     BTFSS STATUS, 0x2
1296  07D5     ADDWF prec, F
72:            		f1_as_plier >>= 1;
1297  1003     BCF STATUS, 0x0
1298  0CC8     RRF sp, F
1299  0CC7     RRF y, F
129A  0CC6     RRF dia, F
129B  0CC5     RRF a, F
73:            		f2_as_plicand <<= 1;
129C  1003     BCF STATUS, 0x0
129D  0DC9     RLF f2, F
129E  0DCA     RLF f, F
129F  0DCB     RLF 0x4B, F
12A0  0DCC     RLF 0x4C, F
74:            	} while(--cntr != 0);
12A1  0BD6     DECFSZ ap, F
12A2  2A81     GOTO 0x281
75:            	cntr = 17;
12A3  3011     MOVLW 0x11
12A4  00D6     MOVWF ap
76:            	do {
77:            		if(f1_as_plier & 1)
12A5  1C45     BTFSS a, 0x0
12A6  2ABB     GOTO 0x2BB
78:            			f3_as_product += f2_as_plicand;
12A7  0849     MOVF f2, W
12A8  07D2     ADDWF f3_as_product, F
12A9  084A     MOVF f, W
12AA  1103     BCF STATUS, 0x2
12AB  1803     BTFSC STATUS, 0x0
12AC  3E01     ADDLW 0x1
12AD  1D03     BTFSS STATUS, 0x2
12AE  07D3     ADDWF 0x53, F
12AF  084B     MOVF 0x4B, W
12B0  1103     BCF STATUS, 0x2
12B1  1803     BTFSC STATUS, 0x0
12B2  3E01     ADDLW 0x1
12B3  1D03     BTFSS STATUS, 0x2
12B4  07D4     ADDWF 0x54, F
12B5  084C     MOVF 0x4C, W
12B6  1103     BCF STATUS, 0x2
12B7  1803     BTFSC STATUS, 0x0
12B8  3E01     ADDLW 0x1
12B9  1D03     BTFSS STATUS, 0x2
12BA  07D5     ADDWF prec, F
79:            		f1_as_plier >>= 1;
12BB  1003     BCF STATUS, 0x0
12BC  0CC8     RRF sp, F
12BD  0CC7     RRF y, F
12BE  0CC6     RRF dia, F
12BF  0CC5     RRF a, F
80:            		f3_as_product >>= 1;
12C0  1003     BCF STATUS, 0x0
12C1  0CD5     RRF prec, F
12C2  0CD4     RRF 0x54, F
12C3  0CD3     RRF 0x53, F
12C4  0CD2     RRF f3_as_product, F
81:            	} while(--cntr != 0);
12C5  0BD6     DECFSZ ap, F
12C6  2AA5     GOTO 0x2A5
82:            	return __flpack(f3_as_product, exp, sign);
12C7  0855     MOVF prec, W
12C8  00A7     MOVWF x
12C9  0854     MOVF 0x54, W
12CA  00A6     MOVWF y
12CB  0853     MOVF 0x53, W
12CC  00A5     MOVWF dato
12CD  0852     MOVF f3_as_product, W
12CE  00A4     MOVWF x
12CF  0851     MOVF exp, W
12D0  00A8     MOVWF i
12D1  0857     MOVF flag, W
12D2  00A9     MOVWF mth
12D3  23BA     CALL 0x3BA
12D4  0827     MOVF x, W
12D5  00C8     MOVWF sp
12D6  0826     MOVF y, W
12D7  00C7     MOVWF y
12D8  0825     MOVF dato, W
12D9  00C6     MOVWF dia
12DA  0824     MOVF x, W
12DB  00C5     MOVWF a
83:            }
12DC  0008     RETURN
84:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/flge.c  ----------------------------------------------------
1:             #define	f1	(*(unsigned long *)&ff1)
2:             #define	f2	(*(unsigned long *)&ff2)
3:             bit
4:             __flge(double ff1, double ff2)
5:             {
6:             	if(f1 &  0x80000000UL)
104A  1FA7     BTFSS x, 0x7
104B  2867     GOTO 0x67
7:             		f1 = 0x80000000UL - f1;
104C  3080     MOVLW 0x80
104D  01AC     CLRF sec
104E  01AD     CLRF hr
104F  01AE     CLRF day
1050  00AF     MOVWF sign
1051  0824     MOVF x, W
1052  02AC     SUBWF sec, F
1053  0825     MOVF dato, W
1054  1C03     BTFSS STATUS, 0x0
1055  0F25     INCFSZ dato, W
1056  02AD     SUBWF hr, F
1057  0826     MOVF y, W
1058  1C03     BTFSS STATUS, 0x0
1059  0F26     INCFSZ y, W
105A  02AE     SUBWF day, F
105B  0827     MOVF x, W
105C  1C03     BTFSS STATUS, 0x0
105D  0F27     INCFSZ x, W
105E  02AF     SUBWF sign, F
105F  082F     MOVF sign, W
1060  00A7     MOVWF x
1061  082E     MOVF day, W
1062  00A6     MOVWF y
1063  082D     MOVF hr, W
1064  00A5     MOVWF dato
1065  082C     MOVF sec, W
1066  00A4     MOVWF x
8:             	if(f2 &  0x80000000UL)
1067  1FAB     BTFSS Data, 0x7
1068  2884     GOTO 0x84
9:             		f2 = 0x80000000UL - f2;
1069  3080     MOVLW 0x80
106A  01AC     CLRF sec
106B  01AD     CLRF hr
106C  01AE     CLRF day
106D  00AF     MOVWF sign
106E  0828     MOVF i, W
106F  02AC     SUBWF sec, F
1070  0829     MOVF mth, W
1071  1C03     BTFSS STATUS, 0x0
1072  0F29     INCFSZ mth, W
1073  02AD     SUBWF hr, F
1074  082A     MOVF year, W
1075  1C03     BTFSS STATUS, 0x0
1076  0F2A     INCFSZ year, W
1077  02AE     SUBWF day, F
1078  082B     MOVF Data, W
1079  1C03     BTFSS STATUS, 0x0
107A  0F2B     INCFSZ Data, W
107B  02AF     SUBWF sign, F
107C  082F     MOVF sign, W
107D  00AB     MOVWF Data
107E  082E     MOVF day, W
107F  00AA     MOVWF year
1080  082D     MOVF hr, W
1081  00A9     MOVWF mth
1082  082C     MOVF sec, W
1083  00A8     MOVWF i
10:            	f1 ^= 0x80000000UL;
1084  3080     MOVLW 0x80
1085  06A7     XORWF x, F
11:            	f2 ^= 0x80000000UL;
1086  06AB     XORWF Data, F
12:            	return f1 >= f2;
1087  082B     MOVF Data, W
13:            }
---  /opt/microchip/xc8/v1.31/sources/common/fladd.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"flarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned long *)&f1)
11:            #define	f2_as_mant2	(*(unsigned long *)&f2)
12:            
13:            // floating addition
14:            #ifdef _OLDLIB
15:            double
16:            __fladd(double f1, double f2)
17:            {
18:            	unsigned char	exp1, exp2, sign1, sign2, cntr;
19:            
20:            	if(sizeof(f1_as_mant1) != 4)
21:            		return 0;
22:            	sign1 = __flunpack(&f1_as_mant1, &exp1);
23:            	if(exp1 == 0)
24:            		return f2;
25:            	sign2 = __flunpack(&f2_as_mant2, &exp2);
26:            	if(exp2 != 0) {
27:            		cntr = 6;
28:            		// determine the smaller number. 
29:            		if(exp1 < exp2) {
30:            			if((unsigned char)(exp2-exp1) > sizeof(f1)*8) {
31:            				// return f2
32:            				f1_as_mant1 = 0;
33:            				exp1 = exp2;
34:            				sign1 = sign2;
35:            			} else {
36:            				// f1 has the smaller exponent - we can shift f2_as_mant2 up to 6 bits
37:            				// left, decrementing exp2.
38:            				do {
39:            					f2_as_mant2 <<= 1;
40:            					exp2--;
41:            				} while(exp2 != exp1 && --cntr != 0);
42:            				while(exp1 != exp2) {
43:            					f1_as_mant1 >>= 1;
44:            					exp1++;
45:            				}
46:            			}
47:            		} else if(exp1 != exp2) {
48:            			if((unsigned char)(exp1-exp2) > sizeof(f1)*8)	// too small to worry about
49:            				f2_as_mant2 = 0;
50:            			else {
51:            				// f2 has the smaller exponent - we can shift f1_as_mant1 up to 6 bits
52:            				// left, decrementing exp2.
53:            				do {
54:            					f1_as_mant1 <<= 1;
55:            					exp1--;
56:            				} while(exp2 != exp1 && --cntr != 0);
57:            				while(exp1 != exp2) {
58:            					f2_as_mant2 >>= 1;
59:            					exp2++;
60:            				}
61:            			}
62:            		}
63:            		if(sign1 != 0) { 
64:            			// complement and add 1
65:            			f1_as_mant1 ^= 0xFFFFFFFFUL;
66:            			f1_as_mant1++;
67:            		}
68:            		if(sign2 != 0) {
69:            			// complement and add 1
70:            			f2_as_mant2 ^= 0xFFFFFFFFUL;
71:            			f2_as_mant2++;
72:            		}
73:            		sign1 = 0;
74:            		f1_as_mant1 += f2_as_mant2;
75:            		if(f1_as_mant1 & 0x80000000UL) {
76:            			f1_as_mant1 ^= 0xFFFFFFFFUL;
77:            			f1_as_mant1++;
78:            			sign1 = 1;
79:            		}
80:            	}
81:            	__flpack(&f1_as_mant1, exp1);
82:            	if(sign1)
83:            		f1_as_mant1 ^= 0x80000000UL;
84:            	return f1;
85:            }
86:            #else
87:            double
88:            __fladd(double f1, double f2)
89:            {
90:            	unsigned char	exp1, exp2, sign;
91:            
92:            	exp1 = f1_as_mant1 >> 23;
12DD  082E     MOVF day, W
12DE  00B6     MOVWF counter
12DF  082F     MOVF sign, W
12E0  00B7     MOVWF sign
12E1  0830     MOVF quotient, W
12E2  00B8     MOVWF mes
12E3  0831     MOVF 0x31, W
12E4  00B9     MOVWF anio
12E5  1003     BCF STATUS, 0x0
12E6  0D38     RLF mes, W
12E7  0D39     RLF anio, W
12E8  00BC     MOVWF exp1
93:            	exp2 = f2_as_mant2 >> 23;
12E9  0832     MOVF divisor, W
12EA  00B6     MOVWF counter
12EB  0833     MOVF 0x33, W
12EC  00B7     MOVWF sign
12ED  0834     MOVF dividend, W
12EE  00B8     MOVWF mes
12EF  0835     MOVF 0x35, W
12F0  00B9     MOVWF anio
12F1  1003     BCF STATUS, 0x0
12F2  0D38     RLF mes, W
12F3  0D39     RLF anio, W
12F4  00BB     MOVWF exp2
94:            	if(exp1 == 0 || exp1 < exp2  && (unsigned char)(exp2-exp1) > sizeof(f1)*8)
12F5  083C     MOVF exp1, W
12F6  1903     BTFSC STATUS, 0x2
12F7  2B04     GOTO 0x304
12F8  083B     MOVF exp2, W
12F9  023C     SUBWF exp1, W
12FA  083B     MOVF exp2, W
12FB  1803     BTFSC STATUS, 0x0
12FC  2B0E     GOTO 0x30E
12FD  00B6     MOVWF counter
12FE  083C     MOVF exp1, W
12FF  02B6     SUBWF counter, F
1300  3021     MOVLW 0x21
1301  0236     SUBWF counter, W
1302  1C03     BTFSS STATUS, 0x0
1303  2B0D     GOTO 0x30D
95:            		return f2;
1304  0835     MOVF 0x35, W
1305  00B1     MOVWF 0x31
1306  0834     MOVF dividend, W
1307  00B0     MOVWF quotient
1308  0833     MOVF 0x33, W
1309  00AF     MOVWF sign
130A  0832     MOVF divisor, W
130B  00AE     MOVWF day
130C  0008     RETURN
96:            	if(exp2 == 0 || exp1 > exp2  && (unsigned char)(exp1-exp2) > sizeof(f1)*8)
130D  083B     MOVF exp2, W
130E  1903     BTFSC STATUS, 0x2
130F  0008     RETURN
1310  083C     MOVF exp1, W
1311  023B     SUBWF exp2, W
1312  1803     BTFSC STATUS, 0x0
1313  2B1C     GOTO 0x31C
1314  083C     MOVF exp1, W
1315  00B6     MOVWF counter
1316  083B     MOVF exp2, W
1317  02B6     SUBWF counter, F
1318  3021     MOVLW 0x21
1319  0236     SUBWF counter, W
131A  1803     BTFSC STATUS, 0x0
131B  0008     RETURN
97:            		return f1;
98:            	sign = 6;
131C  3006     MOVLW 0x6
131D  00BA     MOVWF sign
99:            	if(f1_as_mant1 & 0x80000000L)
131E  1BB1     BTFSC 0x31, 0x7
100:           		sign |= 0x80;
131F  17BA     BSF sign, 0x7
101:           	if(f2_as_mant2 & 0x80000000L)
1320  1BB5     BTFSC 0x35, 0x7
102:           		sign |= 0x40;
1321  173A     BSF sign, 0x6
103:           	f1_as_mant1 |= 0x800000UL;
1322  17B0     BSF quotient, 0x7
104:           	f1_as_mant1 &= 0xFFFFFFUL;
1323  01B1     CLRF 0x31
105:           	f2_as_mant2 |= 0x800000UL;
1324  17B4     BSF dividend, 0x7
106:           	f2_as_mant2 &= 0xFFFFFFUL;
1325  01B5     CLRF 0x35
107:           	// determine the smaller number. 
108:           	if(exp1 < exp2) {
1326  083B     MOVF exp2, W
1327  023C     SUBWF exp1, W
1328  1803     BTFSC STATUS, 0x0
1329  2B45     GOTO 0x345
109:           		// f1 has the smaller exponent - we can shift f2_as_mant2 up to 6 bits
110:           		// left, decrementing exp2.
111:           		do {
112:           			f2_as_mant2 <<= 1;
132A  1003     BCF STATUS, 0x0
132B  0DB2     RLF divisor, F
132C  0DB3     RLF 0x33, F
132D  0DB4     RLF dividend, F
132E  0DB5     RLF 0x35, F
113:           			exp2--;
132F  03BB     DECF exp2, F
114:           		} while(exp2 != exp1 && --sign & 7);
1330  083B     MOVF exp2, W
1331  063C     XORWF exp1, W
1332  1903     BTFSC STATUS, 0x2
1333  2B40     GOTO 0x340
1334  03BA     DECF sign, F
1335  083A     MOVF sign, W
1336  3907     ANDLW 0x7
1337  1903     BTFSC STATUS, 0x2
1338  2B40     GOTO 0x340
1339  2B2A     GOTO 0x32A
115:           		while(exp1 != exp2) {
1340  083C     MOVF exp1, W
1341  063B     XORWF exp2, W
1342  1903     BTFSC STATUS, 0x2
1343  2B63     GOTO 0x363
1344  2B3A     GOTO 0x33A
116:           			f1_as_mant1 >>= 1;
133A  1003     BCF STATUS, 0x0
133B  0CB1     RRF 0x31, F
133C  0CB0     RRF quotient, F
133D  0CAF     RRF sign, F
133E  0CAE     RRF day, F
117:           			exp1++;
133F  0ABC     INCF exp1, F
118:           		}
119:           	} else if(exp1 > exp2) {
1345  083C     MOVF exp1, W
1346  023B     SUBWF exp2, W
1347  1803     BTFSC STATUS, 0x0
1348  2B63     GOTO 0x363
120:           		// f2 has the smaller exponent - we can shift f1_as_mant1 up to 6 bits
121:           		// left, decrementing exp2.
122:           		do {
123:           			f1_as_mant1 <<= 1;
1349  1003     BCF STATUS, 0x0
134A  0DAE     RLF day, F
134B  0DAF     RLF sign, F
134C  0DB0     RLF quotient, F
134D  0DB1     RLF 0x31, F
124:           			exp1--;
134E  03BC     DECF exp1, F
125:           		} while(exp2 != exp1 && --sign & 7);
134F  083B     MOVF exp2, W
1350  063C     XORWF exp1, W
1351  1903     BTFSC STATUS, 0x2
1352  2B5F     GOTO 0x35F
1353  03BA     DECF sign, F
1354  083A     MOVF sign, W
1355  3907     ANDLW 0x7
1356  1903     BTFSC STATUS, 0x2
1357  2B5F     GOTO 0x35F
1358  2B49     GOTO 0x349
126:           		while(exp1 != exp2) {
135F  083C     MOVF exp1, W
1360  063B     XORWF exp2, W
1361  1D03     BTFSS STATUS, 0x2
1362  2B59     GOTO 0x359
127:           			f2_as_mant2 >>= 1;
1359  1003     BCF STATUS, 0x0
135A  0CB5     RRF 0x35, F
135B  0CB4     RRF dividend, F
135C  0CB3     RRF 0x33, F
135D  0CB2     RRF divisor, F
128:           			exp2++;
135E  0ABB     INCF exp2, F
129:           		}
130:           	}
131:           	if(sign & 0x80) { 
1363  1FBA     BTFSS sign, 0x7
1364  2B71     GOTO 0x371
132:           		// complement and add 1
133:           		f1_as_mant1 ^= 0xFFFFFFFFUL;
1365  30FF     MOVLW 0xFF
1366  06AE     XORWF day, F
1367  06AF     XORWF sign, F
1368  06B0     XORWF quotient, F
1369  06B1     XORWF 0x31, F
134:           		f1_as_mant1++;
136A  0AAE     INCF day, F
136B  1903     BTFSC STATUS, 0x2
136C  0AAF     INCF sign, F
136D  1903     BTFSC STATUS, 0x2
136E  0AB0     INCF quotient, F
136F  1903     BTFSC STATUS, 0x2
1370  0AB1     INCF 0x31, F
135:           	}
136:           	if(sign & 0x40) {
1371  1F3A     BTFSS sign, 0x6
1372  2B7F     GOTO 0x37F
137:           		// complement and add 1
138:           		f2_as_mant2 ^= 0xFFFFFFFFUL;
1373  30FF     MOVLW 0xFF
1374  06B2     XORWF divisor, F
1375  06B3     XORWF 0x33, F
1376  06B4     XORWF dividend, F
1377  06B5     XORWF 0x35, F
139:           		f2_as_mant2++;
1378  0AB2     INCF divisor, F
1379  1903     BTFSC STATUS, 0x2
137A  0AB3     INCF 0x33, F
137B  1903     BTFSC STATUS, 0x2
137C  0AB4     INCF dividend, F
137D  1903     BTFSC STATUS, 0x2
137E  0AB5     INCF 0x35, F
140:           	}
141:           	sign = 0;
137F  01BA     CLRF sign
142:           	f2_as_mant2 += f1_as_mant1;
1380  082E     MOVF day, W
1381  07B2     ADDWF divisor, F
1382  082F     MOVF sign, W
1383  1103     BCF STATUS, 0x2
1384  1803     BTFSC STATUS, 0x0
1385  3E01     ADDLW 0x1
1386  1D03     BTFSS STATUS, 0x2
1387  07B3     ADDWF 0x33, F
1388  0830     MOVF quotient, W
1389  1103     BCF STATUS, 0x2
138A  1803     BTFSC STATUS, 0x0
138B  3E01     ADDLW 0x1
138C  1D03     BTFSS STATUS, 0x2
138D  07B4     ADDWF dividend, F
138E  0831     MOVF 0x31, W
138F  1103     BCF STATUS, 0x2
1390  1803     BTFSC STATUS, 0x0
1391  3E01     ADDLW 0x1
1392  1D03     BTFSS STATUS, 0x2
1393  07B5     ADDWF 0x35, F
143:           	if(f2_as_mant2 & 0x80000000UL) {
1394  1FB5     BTFSS 0x35, 0x7
1395  2BA4     GOTO 0x3A4
144:           		f2_as_mant2 ^= 0xFFFFFFFFUL;
1396  30FF     MOVLW 0xFF
1397  06B2     XORWF divisor, F
1398  06B3     XORWF 0x33, F
1399  06B4     XORWF dividend, F
139A  06B5     XORWF 0x35, F
145:           		f2_as_mant2++;
139B  0AB2     INCF divisor, F
139C  1903     BTFSC STATUS, 0x2
139D  0AB3     INCF 0x33, F
139E  1903     BTFSC STATUS, 0x2
139F  0AB4     INCF dividend, F
13A0  1903     BTFSC STATUS, 0x2
13A1  0AB5     INCF 0x35, F
146:           		sign = 1;
13A2  01BA     CLRF sign
13A3  0ABA     INCF sign, F
147:           	}
148:           	return __flpack(f2_as_mant2, exp1, sign);
13A4  0835     MOVF 0x35, W
13A5  00A7     MOVWF x
13A6  0834     MOVF dividend, W
13A7  00A6     MOVWF y
13A8  0833     MOVF 0x33, W
13A9  00A5     MOVWF dato
13AA  0832     MOVF divisor, W
13AB  00A4     MOVWF x
13AC  083C     MOVF exp1, W
13AD  00A8     MOVWF i
13AE  083A     MOVF sign, W
13AF  00A9     MOVWF mth
13B0  23BA     CALL 0x3BA
13B1  0827     MOVF x, W
13B2  00B1     MOVWF 0x31
13B3  0826     MOVF y, W
13B4  00B0     MOVWF quotient
13B5  0825     MOVF dato, W
13B6  00AF     MOVWF sign
13B7  0824     MOVF x, W
13B8  00AE     MOVWF day
149:           }
13B9  0008     RETURN
150:           #endif
---  /opt/microchip/xc8/v1.31/sources/common/double.c  --------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             #include	"flarith.h"
7:             
8:             
9:             //	unpack the operand pointed to. Store the exponent into the location pointed to by exp,
10:            //	and return the sign (zero is positive)
11:            
12:            #ifdef _OLDLIB
13:            
14:            unsigned char
15:            __flunpack(unsigned long * arg, unsigned char * exp)
16:            {
17:            	unsigned char	sign;
18:            
19:            	*exp = sign = *arg >> 23;
20:            	if(sign == 0) {
21:            		*arg = 0;
22:            		return 0;
23:            	}
24:            	sign = 0;
25:            	*arg |= 0x800000UL;
26:            	if(*arg & 0x80000000UL)
27:            		sign++;
28:            	*arg &= 0xFFFFFFUL;
29:            	return sign;
30:            }
31:            #endif
32:            
33:            // normalize and pack the supplied argument into floating point format
34:            
35:            #ifdef _OLDLIB 
36:            void
37:            __flpack(unsigned long * arg, unsigned char exp)
38:            {
39:            	if(exp == 0 || *arg == 0) {
40:            		*arg = 0;
41:            		return;
42:            	}
43:            	while(*arg & ~0x1FFFFFFUL) {
44:            		exp++;
45:            		*arg >>= 1;
46:            	}
47:            	while(*arg & ~0xFFFFFFUL) {
48:            		exp++;
49:            		(*arg)++;
50:            		*arg >>= 1;
51:            	}
52:            	while(!(*arg & 0x800000UL)) {
53:            		exp--;
54:            		*arg <<= 1;
55:            	}
56:            	if(!(exp & 1))
57:            		*arg &= ~0x800000UL;
58:            	exp >>= 1;
59:            	*arg |= (unsigned long)exp << 24;
60:            }
61:            #else
62:            double
63:            __flpack(unsigned long arg, unsigned char exp, unsigned char sign)
64:            {
65:            	if(exp == 0 || arg == 0)
13BA  0828     MOVF i, W
13BB  1903     BTFSC STATUS, 0x2
13BC  2BC3     GOTO 0x3C3
13BD  0827     MOVF x, W
13BE  0426     IORWF y, W
13BF  0425     IORWF dato, W
13C0  0424     IORWF x, W
13C1  1D03     BTFSS STATUS, 0x2
13C2  2BCE     GOTO 0x3CE
66:            		return 0.0;
13C3  01A4     CLRF x
13C4  01A5     CLRF dato
13C5  01A6     CLRF y
13C6  01A7     CLRF x
13C7  0008     RETURN
67:            	while(arg & ~0x1FFFFFFUL) {
13CE  30FE     MOVLW 0xFE
13CF  0527     ANDWF x, W
13D0  1903     BTFSC STATUS, 0x2
13D1  2BE0     GOTO 0x3E0
13D2  2BC8     GOTO 0x3C8
68:            		exp++;
13C8  0AA8     INCF i, F
69:            		arg >>= 1;
13C9  1003     BCF STATUS, 0x0
13CA  0CA7     RRF x, F
13CB  0CA6     RRF y, F
13CC  0CA5     RRF dato, F
13CD  0CA4     RRF x, F
70:            	}
71:            	while(arg & ~0xFFFFFFUL) {
13E0  30FF     MOVLW 0xFF
13E1  0527     ANDWF x, W
13E2  1903     BTFSC STATUS, 0x2
13E3  2BEB     GOTO 0x3EB
13E4  2BD3     GOTO 0x3D3
72:            		exp++;
13D3  0AA8     INCF i, F
73:            		(arg)++;
13D4  0AA4     INCF x, F
13D5  1903     BTFSC STATUS, 0x2
13D6  0AA5     INCF dato, F
13D7  1903     BTFSC STATUS, 0x2
13D8  0AA6     INCF y, F
13D9  1903     BTFSC STATUS, 0x2
13DA  0AA7     INCF x, F
74:            		arg >>= 1;
13DB  1003     BCF STATUS, 0x0
13DC  0CA7     RRF x, F
13DD  0CA6     RRF y, F
13DE  0CA5     RRF dato, F
13DF  0CA4     RRF x, F
75:            	}
76:            	while(!(arg & 0x800000UL)) {
13EB  1FA6     BTFSS y, 0x7
13EC  2BE5     GOTO 0x3E5
77:            		exp--;
13E5  03A8     DECF i, F
78:            		arg <<= 1;
13E6  1003     BCF STATUS, 0x0
13E7  0DA4     RLF x, F
13E8  0DA5     RLF dato, F
13E9  0DA6     RLF y, F
13EA  0DA7     RLF x, F
79:            	}
80:            	if(!(exp & 1))
13ED  1828     BTFSC i, 0x0
13EE  2BF2     GOTO 0x3F2
81:            		arg &= ~0x800000UL;
13EF  307F     MOVLW 0x7F
13F0  05A6     ANDWF y, F
13F1  30FF     MOVLW 0xFF
82:            	exp >>= 1;
13F2  1003     BCF STATUS, 0x0
13F3  0CA8     RRF i, F
83:            	arg |= (unsigned long)exp << 24;
13F4  0828     MOVF i, W
13F5  00AD     MOVWF hr
13F6  01AC     CLRF sec
13F7  01AB     CLRF Data
13F8  01AA     CLRF year
13F9  082A     MOVF year, W
13FA  04A4     IORWF x, F
13FB  082B     MOVF Data, W
13FC  04A5     IORWF dato, F
13FD  082C     MOVF sec, W
13FE  04A6     IORWF y, F
13FF  082D     MOVF hr, W
1400  04A7     IORWF x, F
84:            	if(sign)
1401  0829     MOVF mth, W
1402  1D03     BTFSS STATUS, 0x2
85:            		arg |= 0x80000000UL;
1403  17A7     BSF x, 0x7
86:            	return *(double *)&arg;
87:            }
1404  0008     RETURN
88:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/doprnt.c  --------------------------------------------------
1:             #include	<stdio.h>
2:             #include	<ctype.h>
3:             #include	<stdlib.h>
4:             #include	<string.h>
5:             #include	<stdarg.h>
6:             #include	<conio.h>
7:             #include	<sys.h>
8:             #include	<math.h>
9:             #include	<float.h>
10:            
11:            // disable unused variable warnings
12:            // the compiler will optimize them away, so no harm is done
13:            #pragma warning disable 350
14:            
15:            /*
16:             *	doprnt - versions depends on conditional compilation.
17:             *	Can be customized with defines.
18:             *
19:             *	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
20:             *
21:             *	$Header$
22:             *
23:             */
24:            
25:            #ifndef	CUSTOM_PRINTF
26:            
27:             // define all flags, thus enabling all features
28:            
29:            #define	BASEM	0xC0
30:            #define	OPTSIGN	0x00
31:            #define	SPCSIGN	0x01
32:            #define	MANSIGN	0x02
33:            #define	NEGSIGN	0x03
34:            #define	FILL	0x04
35:            #define	LEFT	0x08
36:            #define	LONG	0x10
37:            #define	UPCASE	0x20
38:            #define	TEN		0x00
39:            #define	EIGHT	0x40
40:            #define	SIXTEEN	0x80
41:            #define	UNSIGN	0xC0
42:            #ifdef	__FLOAT
43:            #define	EFMT	0x100
44:            #define	GFMT	0x200
45:            #define	FFMT	0x400
46:            #endif	// __FLOAT
47:            #define	ALTERN	0x800
48:            #define POINTER	0x2000
49:            #define HEXUPCASE
50:            #define HEXLOWCASE
51:            
52:             // defines for ifdef only, not used as flags
53:            #define	WIDTH	1		// width used
54:            #define	STAR	1		// width or precision as an arg
55:            #define	STRING	1		// %s used
56:            #define	CHAR	1		// %c used
57:            #define	PERCPERC	1	// %% used
58:            #define	SPRINTF	1		// sprintf is used
59:            #define	PRINTF	1		// printf is used
60:            #define	MULTRAD	1		// handle multiple radices
61:            #define	RETVALUE	1	// return value is needed
62:            
63:            #else	// CUSTOM_PRINTF
64:            
65:            #if	defined(HEXUPCASE) || defined(HEXLOWCASE)
66:            #define	SIXTEEN
67:            #endif
68:            
69:            #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
70:            #ifndef UPCASE
71:            #define	UPCASE
72:            #endif
73:            #endif
74:            
75:             // make sure we have the right values for each define
76:            #ifdef	OPTSIGN
77:            #undef	OPTSIGN
78:            #define	OPTSIGN	0x00
79:            #endif
80:            #ifdef	SPCSIGN
81:            #undef	SPCSIGN
82:            #define	SPCSIGN	0x01
83:            #endif
84:            #ifdef	MANSIGN
85:            #undef	MANSIGN
86:            #define	MANSIGN	0x02
87:            #define	SPCSIGN	0x01
88:            #endif
89:            #ifdef	NEGSIGN
90:            #undef	NEGSIGN
91:            #define	NEGSIGN	0x03
92:            #endif
93:            #ifdef	FILL
94:            #define	WIDTH	1
95:            #undef	FILL
96:            #define	FILL	0x04
97:            #endif
98:            #ifdef	LEFT
99:            #undef	LEFT
100:            // LEFT without WIDTH is meaningless
101:           #ifdef	WIDTH
102:           #define	LEFT	0x08
103:           #endif
104:           #endif
105:           #ifdef	LONG
106:           #undef	LONG
107:           #define	LONG	0x10
108:           #define	__LONG	1
109:           #endif
110:           #ifdef	UPCASE
111:           #undef	UPCASE
112:           #define	UPCASE	0x20
113:           #endif
114:           #ifdef	TEN	
115:           #undef	TEN	
116:           #define	TEN		0x00
117:           #endif
118:           #ifdef	EIGHT
119:           #undef	EIGHT
120:           #define	EIGHT	0x40
121:           #endif
122:           #ifdef	SIXTEEN
123:           #undef	SIXTEEN
124:           #define	SIXTEEN	0x80
125:           #endif
126:           #ifdef	UNSIGN
127:           #undef	UNSIGN
128:           #define	UNSIGN	0xC0
129:           #endif
130:           #ifdef	EFMT
131:           #undef	EFMT
132:           #define	EFMT	0x100
133:           #endif
134:           #ifdef	GFMT
135:           #undef	GFMT
136:           #define	GFMT	0x200
137:           #endif
138:           #ifdef	FFMT
139:           #undef	FFMT
140:           #define	FFMT	0x400
141:           #endif
142:           #ifdef	ALTERN
143:           #undef	ALTERN
144:           #define	ALTERN	0x800
145:           #endif
146:           #ifdef	POINTER
147:           #undef	POINTER
148:           #define POINTER	0x2000
149:           #ifndef	SIXTEEN
150:           #define	SIXTEEN	0x80
151:           #endif
152:           #endif
153:           #ifdef	PRECISION
154:           #undef	PRECISION
155:           #define PRECISION	0x4000
156:           #endif
157:           
158:           #if	defined(TEN) && !defined(EIGHT) && !defined(SIXTEEN) && defined(UNSIGN)
159:           #undef	UNSIGN
160:           #define	UNSIGN	0x40
161:           #define	BASEM	UNSIGN
162:           #endif
163:           #if	defined(UNSIGN) && (defined(EIGHT) || defined(SIXTEEN))
164:           #define	MULTRAD	1
165:           #define	BASEM	(UNSIGN)
166:           #endif
167:           #if	defined(TEN) && !defined(SIXTEEN) && defined(EIGHT) && !defined(UNSIGN)
168:           #define	BASEM	EIGHT
169:           #define	MULTRAD	1
170:           #endif
171:           #if	defined(TEN) && defined(SIXTEEN) && !defined(EIGHT) && !defined(UNSIGN)
172:           #define	BASEM	SIXTEEN
173:           #define	MULTRAD	1
174:           #endif
175:           #if	defined(SIXTEEN) && defined(EIGHT) && !defined(BASEM)
176:           #define	BASEM	(SIXTEEN|EIGHT)
177:           #define	MULTRAD	1
178:           #endif
179:           
180:           #endif
181:           
182:            // float code needs these flags
183:           #if	defined(EFMT) || defined(GFMT) || defined(FFMT)
184:           #ifndef	__FLOAT
185:           #define	__FLOAT	1
186:           #endif
187:           #define	FLOATFORMAT	0x700
188:           #ifdef	PRECISION
189:           #define	DEFPREC	0x1000
190:           #endif
191:           #endif
192:           
193:           #ifdef	__FLOAT
194:           //#ifndef	MANSIGN
195:           //#define	MANSIGN	0x02
196:           //#endif
197:           //#ifndef	SPCSIGN
198:           //#define	SPCSIGN	0x01
199:           //#endif
200:           #ifndef	NEGSIGN
201:           #define	NEGSIGN	0x03
202:           #endif
203:           //#ifndef	WIDTH
204:           //#define	WIDTH	1
205:           //#endif
206:           #endif
207:           
208:           #ifdef	SPCSIGN
209:           #define	putsign()	pputc(flag & SPCSIGN ? '-' : '+')
210:           #else
211:           #define	putsign()	pputc('-')
212:           #endif	// SPCSIGN
213:           
214:           // were there ANY % formats defined?
215:           #if	defined(FLOATFORMAT) || defined(TEN) || defined(EIGHT) || defined(SIXTEEN) || \
216:           	defined(CHAR) || defined(POINTER) || defined(STRING) || defined(UNSIGN) || defined(PERCPERC)
217:           #define	ANYFORMAT
218:           #else
219:           #undef	ANYFORMAT
220:           #endif
221:           
222:           #ifdef	CHAR
223:           #ifndef	PERCPERC
224:           #define	PERCPERC
225:           #endif
226:           #endif
227:           
228:           #if	!defined(PRINTF) && !defined(VPRINTF) && !defined(SPRINTF) && !defined(VSPRINTF)
229:           #error	Must define at least one of PRINTF SPRINTF or VSPRINTF
230:           #endif
231:           
232:           #if	i8086 && SMALL_DATA
233:           #define	CONST	far
234:           #else
235:           #define	CONST	const
236:           #endif
237:           
238:            /* we don't need plus signs, use minus signs only if we have floats or signed ints */
239:           
240:           #if	!defined(NEGSIGN) && defined(TEN)
241:           #define	NEGSIGN	0x03
242:           #endif
243:           
244:           #ifndef	RETVALUE
245:           #define	INCR_CNT	/*nix */
246:           #else
247:           #define	INCR_CNT	,(++ccnt)
248:           #endif
249:           
250:           #if	defined(EFMT) || defined(GFMT) || defined(FFMT) || defined(ALTERN) || defined(DEFPREC) || defined(POINTER)
251:           #define	FLAG_SIZE	unsigned short
252:           #else
253:           #define	FLAG_SIZE	unsigned char
254:           #endif
255:           
256:           
257:           #if	(sizeof(long) == sizeof(int) || defined(__FLOAT)) && !defined(__LONG)
258:           #define	__LONG	1
259:           #endif
260:           
261:           #if	sizeof(double) == sizeof(long) && DBL_MAX_EXP == 128
262:           #undef	frexp
263:           #define	frexp(val, ptr) (void)(*(ptr) = (unsigned char)((*(unsigned long *)&val >> 23) & 255) - 126)
264:           #elif	defined(_PSOC_)
265:           #undef	frexp
266:           #define	frexp(val, ptr) (void)(*(ptr) = ((unsigned char)(*(unsigned short long *)&val >> 15)) - 126)
267:           #elif	sizeof(double) == 3 && DBL_MAX_EXP == 128
268:           #undef	frexp
269:           #define	frexp(val, ptr) (void)(*(ptr) = ((*(unsigned long *)&val >> 15) & 255) - 126)
270:           #endif
271:           
272:           #if	defined(__FLOAT) && sizeof(double) == 8
273:           #define	DOUBLE	1
274:           
275:           extern double	_dto64i(double);
276:           extern double	_64itod(double);
277:           extern double	_div64(double, double);
278:           extern double	_divto64i(double, double);
279:           extern unsigned	_div64ir(double, double);
280:           extern unsigned	_mod64i10(double);
281:           
282:           #else
283:           #define	DOUBLE	0
284:           #endif
285:           
286:           #ifdef	__LONG
287:           #define	value	long
288:           #define	NDIG	12		/* max number of digits to be printed */
289:           #else
290:           #define	value	int
291:           #define	NDIG	6		/* max number of digits to be printed */
292:           #endif
293:           
294:           #if	DOUBLE
295:           union {
296:           	unsigned long	ul[40];
297:           	double		db[20];
298:           }	_fdp =
299:           {
300:           #if	!defined(BIG_ENDIAN) && !defined(LITTLE_ENDIAN)
301:           #error Neither BIG_ENDIAN or LITTLE_ENDIAN has been set
302:           #endif
303:           #if	BIG_ENDIAN
304:           	0x00000000,0x00000001,
305:           	0x00000000,0x0000000A,
306:           	0x00000000,0x00000064,
307:           	0x00000000,0x000003E8,
308:           	0x00000000,0x00002710,
309:           	0x00000000,0x000186A0,
310:           	0x00000000,0x000F4240,
311:           	0x00000000,0x00989680,
312:           	0x00000000,0x05F5E100,
313:           	0x00000000,0x3B9ACA00,
314:           	0x00000002,0x540BE400,
315:           	0x00000017,0x4876E800,
316:           	0x000000E8,0xD4A51000,
317:           	0x00000918,0x4E72A000,
318:           	0x00005AF3,0x107A4000,
319:           	0x00038D7E,0xA4C68000,
320:           	0x002386F2,0x6FC10000,
321:           	0x01634578,0x5D8A0000,
322:           	0x0DE0B6B3,0xA7640000,
323:           	0x8AC72304,0x89E80000,
324:           #else
325:           	0x00000001,0x00000000,
326:           	0x0000000A,0x00000000,
327:           	0x00000064,0x00000000,
328:           	0x000003E8,0x00000000,
329:           	0x00002710,0x00000000,
330:           	0x000186A0,0x00000000,
331:           	0x000F4240,0x00000000,
332:           	0x00989680,0x00000000,
333:           	0x05F5E100,0x00000000,
334:           	0x3B9ACA00,0x00000000,
335:           	0x540BE400,0x00000002,
336:           	0x4876E800,0x00000017,
337:           	0xD4A51000,0x000000E8,
338:           	0x4E72A000,0x00000918,
339:           	0x107A4000,0x00005AF3,
340:           	0xA4C68000,0x00038D7E,
341:           	0x6FC10000,0x002386F2,
342:           	0x5D8A0000,0x01634578,
343:           	0xA7640000,0x0DE0B6B3,
344:           	0x89E80000,0x8AC72304,
345:           #endif
346:           };
347:           
348:           #define	fdpowers	_fdp.db
349:           
350:           #else
351:           #define	fdpowers	dpowers
352:           #endif
353:           #if defined(TEN) || defined(__FLOAT) || defined (UNSIGN)
354:           const static unsigned value	dpowers[] =	{1, 10, 100, 1000, 10000,
355:           #ifdef	__LONG
356:           						 100000, 1000000, 10000000, 100000000,
357:           						 1000000000
358:           #endif
359:           							 };
360:           #endif
361:           #ifdef	SIXTEEN
362:           const static unsigned value	hexpowers[] =	{1, 0x10, 0x100, 0x1000,
363:           #if	__LONG
364:           						 0x10000, 0x100000, 0x1000000, 0x10000000
365:           #endif
366:           							};
367:           #endif
368:           #ifdef	EIGHT
369:           const static unsigned value	octpowers[] =	{1, 010, 0100, 01000, 010000, 0100000,
370:           #ifdef	__LONG
371:           						01000000,
372:           						 010000000, 0100000000, 01000000000, 010000000000,
373:           						 0100000000000
374:           #endif
375:           							};
376:           #endif
377:           
378:           #ifdef	__FLOAT
379:           
380:           #define	NDDIG	(sizeof fdpowers/sizeof fdpowers[0])
381:           
382:           #if	DBL_MAX_10_EXP > 120
383:           #define	expon	int
384:           #else
385:           #define	expon	signed char
386:           #endif
387:           
388:           extern const double	_powers_[], _npowers_[];
389:           #ifdef	z80
390:           #define	_div_to_l_(a, b)	((unsigned long)((a)/(b)))
391:           #else
392:           extern unsigned long	_div_to_l_(double, double);
393:           #ifdef	_OMNI_CODE_
394:           extern unsigned long	_tdiv_to_l_(float, float);
395:           #ifdef	_HTKC_
396:           #pragma callname _div_to_l_ double
397:           #pragma callname _tdiv_to_l_ float
398:           #endif
399:           #define	div_to_l_(a,b)	((sizeof(double)== 3) ? _tdiv_to_l_(a,b) : _div_to_l_(a,b))
400:           #else
401:           #define	div_to_l_	_div_to_l_
402:           #endif
403:           #endif
404:           
405:           /* this routine returns a value to round to the number of decimal
406:           	places specified */
407:           #if __FLOAT
408:           static double
409:           fround(unsigned char prec)
410:           {
411:           	/* prec is guaranteed to be less than NDIG */
412:           
413:           	if(prec>=110)
414:           		return 0.5 * _npowers_[prec/100+18] * _npowers_[(prec%100)/10+9] * _npowers_[prec%10];
415:           	else if(prec > 10)
416:           		return 0.5 * _npowers_[prec/10+9] * _npowers_[prec%10];
417:           	return 0.5 * _npowers_[prec];
418:           }
419:           #endif
420:           
421:           /* this routine returns a scaling factor equal to 1 to the decimal
422:              power supplied */
423:           
424:           static double
425:           scale(expon scl)
426:           {
427:           
428:           	if(scl < 0) {
429:           		scl = -scl;
430:           		if(scl>=110)
431:           			return _npowers_[scl/100+18] * _npowers_[(scl%100)/10+9] * _npowers_[scl%10];
432:           		else if(scl > 10)
433:           			return _npowers_[scl/10+9] * _npowers_[scl%10];
434:           		return _npowers_[scl];
435:           	}
436:           	if(scl>=110)
437:           		return _powers_[scl/100+18] * _powers_[(scl%100)/10+9] * _powers_[scl%10];
438:           	else if(scl > 10)
439:           		return _powers_[scl/10+9] * _powers_[scl%10];
440:           	return _powers_[scl];
441:           }
442:           
443:           
444:           #endif	/* __FLOAT */
445:           
446:           
447:           
448:           #ifdef	_HOSTED
449:           #define	pputc(c)	(putc(c, fp) != EOF && ++ccnt)
450:           int
451:           vfprintf(FILE * fp, register const  char * f, register va_list ap)
452:           {
453:           	char		cbuf[2];
454:           #else	/* _HOSTED */
455:           int
456:           #if	defined(VPRINTF) || (defined(PRINTF) && (defined(SPRINTF) || defined(VSPRINTF)))
457:           #define	pputc(c)	if(pb->func) (pb->func(c))INCR_CNT; else ((*pb->ptr++ = c)INCR_CNT)
458:           _doprnt(struct __prbuf * pb, register const  char * f, register va_list ap)
459:           {
460:           #endif
461:           
462:           #if	defined(PRINTF) && !(defined(SPRINTF) || defined(VSPRINTF))
463:           #define	pputc(c)	(putch(c) INCR_CNT)
464:           printf(const char * f, ...)
465:           {
466:           	va_list	ap;
467:           #define	NEED_START
468:           #endif
469:           
470:           #if	!defined(PRINTF) && defined(VSPRINTF)
471:           
472:           #ifdef	SPRINTF
473:           sprintf(char * sp, const char * f, ...)
474:           {
475:           	va_list	ap;
476:           
477:           	va_start(ap, f);
478:           	vsprintf(sp, f, ap);
479:           	va_end(ap);
480:           }
481:           int
482:           #endif	// SPRINTF
483:           
484:           #define	pputc(c)	((*sp++ = (c))INCR_CNT)
485:           vsprintf(char * sp, register const  char * f, register va_list ap)
486:           {
487:           #define NEED_START
488:           #endif	// VSPRINTF
489:           
490:           #if	!defined(PRINTF) && defined(SPRINTF) && !defined(VSPRINTF)
491:           #define	pputc(c)	((*sp++ = (c))INCR_CNT)
492:           sprintf(char * sp, const  char * f, ...)
493:           {
494:           	va_list	ap;
495:           #define	NEED_START
496:           #endif
497:           #endif	// HOSTED
498:           
499:           	signed char		c;
500:           #if	defined(WIDTH) || defined(__FLOAT)
501:           	int		width;
502:           #endif
503:           #ifdef	__LONG
504:           	int		prec;
505:           #else
506:           	signed char	prec;
507:           #endif
508:           	FLAG_SIZE	flag;
509:           #ifdef	RETVALUE
510:           	int		ccnt = 0;
511:           #else
512:           #define	ccnt	0
513:           #endif
514:           #ifdef	__FLOAT
515:           	char	d;
516:           	double	fval, integ;
517:           	int		exp;
518:           	double		ival;
519:           	union {
520:           		unsigned value	_val;
521:           		struct {
522:           		    CONST char *	_cp;
523:           		    unsigned	_len;
524:           		}		_str;
525:           	}		_val;
526:           #else	// __FLOAT
527:           	union {
528:           		unsigned value	_val;
529:           		struct {
530:           		    CONST char *	_cp;
531:           		    unsigned	_len;
532:           		}		_str;
533:           	}		_val;
534:           #endif	// __FLOAT
535:           
536:           #define	val	_val._val
537:           #define	cp	_val._str._cp
538:           #define	len	_val._str._len
539:           
540:           	
541:           #ifdef	NEED_START
542:           	va_start(ap, f);
0DB1  304C     MOVLW 0x4C
0DB2  00D6     MOVWF ap
543:           #endif
544:           
545:           	while(c = *f++) {
0DB3  084B     MOVF 0x4B, W
0DB4  00D3     MOVWF 0x53
0DB5  084A     MOVF f, W
0DB6  00D2     MOVWF f3_as_product
0DB7  0ACA     INCF f, F
0DB8  1903     BTFSC STATUS, 0x2
0DB9  0ACB     INCF 0x4B, F
0DBA  0853     MOVF 0x53, W
0DBB  00FF     MOVWF 0x7F
0DBC  0852     MOVF f3_as_product, W
0DBD  0084     MOVWF FSR
0DBE  160A     BSF PCLATH, 0x4
0DBF  158A     BSF PCLATH, 0x3
0DC0  2000     CALL 0x0
0DC1  120A     BCF PCLATH, 0x4
0DC2  158A     BSF PCLATH, 0x3
0DC3  00DA     MOVWF c
0DC4  08DA     MOVF c, F
0DC5  1903     BTFSC STATUS, 0x2
0DC6  2F84     GOTO 0x784
0F83  2DB3     GOTO 0x5B3
546:           #ifdef	ANYFORMAT
547:           		if(c != '%')
0DC7  085A     MOVF c, W
0DC8  3A25     XORLW 0x25
0DC9  1903     BTFSC STATUS, 0x2
0DCA  2DD6     GOTO 0x5D6
548:           #endif	//ANYFORMAT
549:           		{
550:           			pputc(c);
0DCB  0848     MOVF sp, W
0DCC  0084     MOVWF FSR
0DCD  1383     BCF STATUS, 0x7
0DCE  1849     BTFSC f2, 0x0
0DCF  1783     BSF STATUS, 0x7
0DD0  085A     MOVF c, W
0DD1  0080     MOVWF INDF
0DD2  0AC8     INCF sp, F
0DD3  1903     BTFSC STATUS, 0x2
0DD4  0AC9     INCF f2, F
551:           			continue;
0DD5  2DB3     GOTO 0x5B3
552:           		}
553:           #ifdef	ANYFORMAT
554:           #ifdef	WIDTH
555:           		width = 0;
0DD6  01D8     CLRF width
0DD7  01D9     CLRF 0x59
556:           #endif
557:           		flag = 0;
0DD8  01D7     CLRF flag
0DD9  2DDE     GOTO 0x5DE
558:           #if	defined(LEFT) || defined(SPCSIGN) || defined(MANSIGN) || defined(ALTERN) || defined(FILL)
559:           		for(;;) {
560:           			switch(*f) {
0DDE  084B     MOVF 0x4B, W
0DDF  00FF     MOVWF 0x7F
0DE0  084A     MOVF f, W
0DE1  0084     MOVWF FSR
0DE2  160A     BSF PCLATH, 0x4
0DE3  158A     BSF PCLATH, 0x3
0DE4  2000     CALL 0x0
0DE5  120A     BCF PCLATH, 0x4
0DE6  158A     BSF PCLATH, 0x3
0DE7  3A30     XORLW 0x30
0DE8  1903     BTFSC STATUS, 0x2
0DE9  2DDA     GOTO 0x5DA
0DEA  2DEB     GOTO 0x5EB
561:           #ifdef	LEFT
562:           			case '-':
563:           				flag |= LEFT;
564:           				f++;
565:           				continue;
566:           #endif
567:           
568:           #ifdef	SPCSIGN
569:           			case ' ':
570:           				flag |= SPCSIGN;
571:           				f++;
572:           				continue;
573:           #endif
574:           
575:           #ifdef	MANSIGN
576:           			case '+':
577:           				flag |= MANSIGN;
578:           				f++;
579:           				continue;
580:           #endif
581:           #ifdef	ALTERN
582:           			case '#':
583:           				flag |= ALTERN;
584:           				f++;
585:           				continue;
586:           #endif
587:           #ifdef	FILL
588:           			case '0':
589:           				flag |= FILL;
0DDA  1557     BSF flag, 0x2
590:           				f++;
0DDB  0ACA     INCF f, F
0DDC  1903     BTFSC STATUS, 0x2
0DDD  0ACB     INCF 0x4B, F
591:           				continue;
592:           #endif
593:           			}
594:           			break;
595:           		}
596:           #endif
597:           #if	defined(MANSIGN) && defined(SPCSIGN)
598:           		if(flag & MANSIGN)
599:           			flag &= ~SPCSIGN;
600:           #endif
601:           #if	defined(LEFT) && defined(FILL)
602:           		if(flag & LEFT)
603:           			flag &= ~FILL;
604:           #endif
605:           #ifdef	WIDTH
606:           		if(isdigit((unsigned)*f)) {
0DEB  084B     MOVF 0x4B, W
0DEC  00FF     MOVWF 0x7F
0DED  084A     MOVF f, W
0DEE  0084     MOVWF FSR
0DEF  160A     BSF PCLATH, 0x4
0DF0  158A     BSF PCLATH, 0x3
0DF1  2000     CALL 0x0
0DF2  120A     BCF PCLATH, 0x4
0DF3  158A     BSF PCLATH, 0x3
0DF4  278B     CALL 0x78B
0DF5  120A     BCF PCLATH, 0x4
0DF6  158A     BSF PCLATH, 0x3
0DF7  1C03     BTFSS STATUS, 0x0
0DF8  2E77     GOTO 0x677
607:           			width = 0;
0DF9  01D8     CLRF width
0DFA  01D9     CLRF 0x59
608:           			do {
609:           				width *= 10;
0DFB  300A     MOVLW 0xA
0DFC  00A4     MOVWF x
0DFD  01A5     CLRF dato
0DFE  0859     MOVF 0x59, W
0DFF  00A7     MOVWF x
0E00  0858     MOVF width, W
0E01  00A6     MOVWF y
0E02  2799     CALL 0x799
0E03  0825     MOVF dato, W
0E04  00D9     MOVWF 0x59
0E05  0824     MOVF x, W
0E06  00D8     MOVWF width
610:           			   	width += *f++ - '0';
0E07  084B     MOVF 0x4B, W
0E08  00FF     MOVWF 0x7F
0E09  084A     MOVF f, W
0E0A  0084     MOVWF FSR
0E0B  160A     BSF PCLATH, 0x4
0E0C  158A     BSF PCLATH, 0x3
0E0D  2000     CALL 0x0
0E0E  120A     BCF PCLATH, 0x4
0E0F  158A     BSF PCLATH, 0x3
0E10  3ED0     ADDLW 0xD0
0E11  00D2     MOVWF f3_as_product
0E12  30FF     MOVLW 0xFF
0E13  1803     BTFSC STATUS, 0x0
0E14  3000     MOVLW 0x0
0E15  00D3     MOVWF 0x53
0E16  0852     MOVF f3_as_product, W
0E17  07D8     ADDWF width, F
0E18  1803     BTFSC STATUS, 0x0
0E19  0AD9     INCF 0x59, F
0E1A  0853     MOVF 0x53, W
0E1B  07D9     ADDWF 0x59, F
0E1C  0ACA     INCF f, F
0E1D  1903     BTFSC STATUS, 0x2
0E1E  0ACB     INCF 0x4B, F
611:           			} while(isdigit((unsigned)*f));
0E1F  084B     MOVF 0x4B, W
0E20  00FF     MOVWF 0x7F
0E21  084A     MOVF f, W
0E22  0084     MOVWF FSR
0E23  160A     BSF PCLATH, 0x4
0E24  158A     BSF PCLATH, 0x3
0E25  2000     CALL 0x0
0E26  120A     BCF PCLATH, 0x4
0E27  158A     BSF PCLATH, 0x3
0E28  278B     CALL 0x78B
0E29  120A     BCF PCLATH, 0x4
0E2A  158A     BSF PCLATH, 0x3
0E2B  1C03     BTFSS STATUS, 0x0
0E2C  2E77     GOTO 0x677
0E2D  2DFB     GOTO 0x5FB
612:           #ifdef	STAR
613:           		} else if(*f == '*') {
614:           			width = va_arg(ap, int);
615:           			f++;
616:           #endif
617:           		}
618:           #endif
619:           #ifdef	PRECISION
620:           		if(*f == '.') {
621:           			flag |= PRECISION;
622:           			f++;
623:           #ifdef	STAR
624:           			if(*f == '*') {
625:           				prec = va_arg(ap, int);
626:           				f++;
627:           			} else
628:           #endif
629:           			{
630:           				prec = 0;
631:           				while(isdigit((unsigned)*f))
632:           					prec = prec*10 + *f++ - '0';
633:           			}
634:           		} else {
635:           			prec = 0;
636:           #ifdef	DEFPREC
637:           			flag |= DEFPREC;
638:           #endif	// DEFPREC
639:           		}
640:           #endif	// PRECISION
641:           #if	defined(__LONG) && defined(LONG)
642:           loop:
643:           #endif
644:           		switch(c = *f++) {
0E77  084B     MOVF 0x4B, W
0E78  00D3     MOVWF 0x53
0E79  084A     MOVF f, W
0E7A  00D2     MOVWF f3_as_product
0E7B  0ACA     INCF f, F
0E7C  1903     BTFSC STATUS, 0x2
0E7D  0ACB     INCF 0x4B, F
0E7E  0853     MOVF 0x53, W
0E7F  00FF     MOVWF 0x7F
0E80  0852     MOVF f3_as_product, W
0E81  0084     MOVWF FSR
0E82  160A     BSF PCLATH, 0x4
0E83  158A     BSF PCLATH, 0x3
0E84  2000     CALL 0x0
0E85  120A     BCF PCLATH, 0x4
0E86  158A     BSF PCLATH, 0x3
0E87  00DA     MOVWF c
0E88  3A00     XORLW 0x0
0E89  1903     BTFSC STATUS, 0x2
0E8A  2F84     GOTO 0x784
0E8B  3A64     XORLW 0x64
0E8C  1903     BTFSC STATUS, 0x2
0E8D  2E95     GOTO 0x695
0E8E  3A0D     XORLW 0xD
0E8F  1903     BTFSC STATUS, 0x2
0E90  2E95     GOTO 0x695
0E91  3A1C     XORLW 0x1C
0E92  1903     BTFSC STATUS, 0x2
0E93  2E75     GOTO 0x675
0E94  2E6F     GOTO 0x66F
645:           
646:           		case 0:
647:           			goto alldone;
648:           
649:           #ifdef	LONG
650:           		case 'l':
651:           #ifdef	__LONG
652:           			flag |= LONG;
653:           			goto loop;
654:           #else
655:           			cp = "(non-long printf)";
656:           			goto strings;
657:           #endif
658:           #endif
659:           
660:           #ifdef	FLOATFORMAT
661:           #ifndef	__FLOAT
662:           		case 'E':
663:           		case 'f':
664:           		case 'e':
665:           		case 'G':
666:           		case 'g':
667:           			cp = "(non-float printf)";
668:           			goto strings;
669:           #else
670:           #ifdef	FFMT
671:           		case 'f':
672:           			flag |= FFMT;
673:           			break;
674:           #endif
675:           
676:           #ifdef	EFMT
677:           #ifdef	UPCASE
678:           		case 'E':
679:           			flag |= UPCASE;
680:           #endif
681:           		case 'e':
682:           			flag |= EFMT;
683:           			break;
684:           #endif
685:           
686:           #ifdef	GFMT
687:           #ifdef	UPCASE
688:           		case 'G':
689:           			flag |= UPCASE;
690:           #endif
691:           		case 'g':
692:           			flag |= GFMT;
693:           			break;
694:           #endif	// GFMT
695:           #endif
696:           #endif	// FLOATFORMAT
697:           #ifdef	EIGHT
698:           		case 'o':
699:           #ifdef	MULTRAD
700:           			flag |= EIGHT;
701:           #endif
702:           			break;
703:           #endif
704:           
705:           #ifdef	TEN
706:           		case 'd':
707:           		case 'i':
708:           			break;
709:           #endif
710:           
711:           #ifdef	POINTER
712:           		case 'p':
713:           #if	i8086 && LARGE_DATA
714:           			flag |= LONG;
715:           #elif	_PIC18 && LARGE_DATA
716:           			flag |= POINTER;
717:           #endif
718:           #endif	// POINTER
719:           #ifdef	SIXTEEN
720:           #ifdef	HEXUPCASE
721:           		case 'X':
722:           #ifdef	UPCASE
723:           			flag |= UPCASE;
724:           #endif
725:           #endif
726:           #if	defined(HEXLOWCASE) || !defined(UPCASE)
727:           		case 'x':
728:           #endif
729:           #ifdef	MULTRAD
730:           			flag |= SIXTEEN;
731:           #endif
732:           			break;
733:           #endif	// SIXTEEN
734:           
735:           #if	defined(STRING) || defined(PERCPERC)
736:           #ifdef	STRING
737:           		case 's':
738:           #if	i8086 && SMALL_DATA
739:           			if(flag & LONG)
740:           				cp = va_arg(ap, far char *);
741:           			else
742:           #endif
743:           				cp = va_arg(ap, const char *);
744:           #endif	// STRING
745:           #if	!defined(__FLOAT) && !defined(CUSTOM_PRINTF)
746:           strings:
747:           #endif
748:           #ifdef	STRING
749:           			if(!cp)
750:           				cp = "(null)";
751:           #endif
752:           #if	defined(WIDTH) || defined(PRECISION)
753:           #if	defined(STRING)
754:           			len = 0;
755:           			while(cp[len])
756:           				len++;
757:           #endif
758:           #ifdef	PERCPERC
759:           dostring:
760:           #endif
761:           #ifdef	PRECISION
762:           			if(prec && prec < len)
763:           				len = prec;
764:           #endif	// PRECISION
765:           #ifdef	WIDTH
766:           			if(width > len)
0E2E  0859     MOVF 0x59, W
0E2F  025D     SUBWF 0x5D, W
0E30  1D03     BTFSS STATUS, 0x2
0E31  2E34     GOTO 0x634
0E32  0858     MOVF width, W
0E33  025C     SUBWF f1, W
0E34  1803     BTFSC STATUS, 0x0
0E35  2E3D     GOTO 0x63D
767:           				width -= len;
0E36  085C     MOVF f1, W
0E37  02D8     SUBWF width, F
0E38  085D     MOVF 0x5D, W
0E39  1C03     BTFSS STATUS, 0x0
0E3A  03D9     DECF 0x59, F
0E3B  02D9     SUBWF 0x59, F
0E3C  2E3F     GOTO 0x63F
768:           			else
769:           				width = 0;
0E3D  01D8     CLRF width
0E3E  01D9     CLRF 0x59
770:           #ifdef	LEFT
771:           			if(!(flag & LEFT))
772:           #endif	// LEFT
773:           				while(width--)
0E3F  30FF     MOVLW 0xFF
0E40  07D8     ADDWF width, F
0E41  1C03     BTFSS STATUS, 0x0
0E42  03D9     DECF 0x59, F
0E43  0A58     INCF width, W
0E44  1903     BTFSC STATUS, 0x2
0E45  0A59     INCF 0x59, W
0E46  1903     BTFSC STATUS, 0x2
0E47  2E63     GOTO 0x663
0E52  2E3F     GOTO 0x63F
774:           					pputc(' ');
0E48  0848     MOVF sp, W
0E49  0084     MOVWF FSR
0E4A  1383     BCF STATUS, 0x7
0E4B  1849     BTFSC f2, 0x0
0E4C  1783     BSF STATUS, 0x7
0E4D  3020     MOVLW 0x20
0E4E  0080     MOVWF INDF
0E4F  0AC8     INCF sp, F
0E50  1903     BTFSC STATUS, 0x2
0E51  0AC9     INCF f2, F
775:           #endif	// WIDTH
776:           			while(len--)
0E63  3001     MOVLW 0x1
0E64  02DC     SUBWF f1, F
0E65  3000     MOVLW 0x0
0E66  1C03     BTFSS STATUS, 0x0
0E67  03DD     DECF 0x5D, F
0E68  02DD     SUBWF 0x5D, F
0E69  0A5C     INCF f1, W
0E6A  1903     BTFSC STATUS, 0x2
0E6B  0A5D     INCF 0x5D, W
0E6C  1903     BTFSC STATUS, 0x2
0E6D  2DB3     GOTO 0x5B3
0E6E  2E53     GOTO 0x653
777:           				pputc(*cp++);
0E53  085B     MOVF _val, W
0E54  0084     MOVWF FSR
0E55  1383     BCF STATUS, 0x7
0E56  0800     MOVF INDF, W
0E57  00D2     MOVWF f3_as_product
0E58  0848     MOVF sp, W
0E59  0084     MOVWF FSR
0E5A  1383     BCF STATUS, 0x7
0E5B  1849     BTFSC f2, 0x0
0E5C  1783     BSF STATUS, 0x7
0E5D  0852     MOVF f3_as_product, W
0E5E  0080     MOVWF INDF
0E5F  0ADB     INCF _val, F
0E60  0AC8     INCF sp, F
0E61  1903     BTFSC STATUS, 0x2
0E62  0AC9     INCF f2, F
778:           #ifdef	LEFT
779:           			if(flag & LEFT)
780:           				while(width--)
781:           					pputc(' ');
782:           #endif	// LEFT
783:           			continue;
784:           #else	// WIDTH || PRECISION
785:           #if	defined(STRING)
786:           			while(*cp)
787:           				pputc(*cp++);
788:           			continue;
789:           #endif
790:           #endif	// WIDTH || PRECISION
791:           #endif	// defined(STRING) || defined(PERCPERC)
792:           #ifdef	CHAR
793:           		case 'c':
794:           #if	_HOSTED
795:           			val = va_arg(ap, int);
796:           			c = val >> 8;
797:           			if(flag & LONG && c && (unsigned char)c != 0xFF) {
798:           				cbuf[0] = c;
799:           				cbuf[1] = val;
800:           				len = 2;
801:           			} else {
802:           				cbuf[0] = val;
803:           				len = 1;
804:           			}
805:           			cp = cbuf;
806:           			goto dostring;
807:           #else
808:           			c = va_arg(ap, int);
809:           #endif	// _HOSTED
810:           #endif	// CHAR
811:           		default:
812:           #ifdef	PERCPERC
813:           #if	defined(WIDTH) || defined(PRECISION)
814:           			cp = (char *)&c;
0E6F  305A     MOVLW 0x5A
0E70  00DB     MOVWF _val
815:           			len = 1;
0E71  01DC     CLRF f1
0E72  0ADC     INCF f1, F
0E73  01DD     CLRF 0x5D
816:           			goto dostring;
0E74  2E2E     GOTO 0x62E
817:           #else
818:           			pputc(c);
819:           			continue;
820:           #endif
821:           #else	// PERCPERC
822:           			continue;
823:           #endif
824:           
825:           #ifdef	UNSIGN
826:           		case 'u':
827:           			flag |= UNSIGN;
0E75  1757     BSF flag, 0x6
828:           			break;
0E76  2E95     GOTO 0x695
829:           #endif
830:           
831:           		}
832:           #endif	// ANYFORMAT
833:           #ifdef	__FLOAT
834:           		if(flag & (FLOATFORMAT)) {
835:           #ifdef	DEFPREC
836:           			if(flag & DEFPREC)
837:           #endif
838:           				prec = 6;
839:           			fval = va_arg(ap, double);	// source the floating point value
840:           			if(fval < 0.0) {
841:           				fval = -fval;		// get the absolute value
842:           				flag |= NEGSIGN;
843:           			}
844:           			exp = 0;		/* If the number is zero, the exponent is zero. */
845:           			if( fval!=0) {		/* If the number is non-zero, find the exponent. */
846:           				frexp(fval, &exp);		/* get binary exponent */
847:           				exp--;				/* adjust 0.5 -> 1.0 */
848:           				exp *= 3;
849:           				exp /= 10;			/* estimate decimal exponent */
850:           				if(exp < 0)
851:           					exp--;
852:           				// the following line can cause "recursive call" errors because scale calls
853:           				// ftmul, and is used when evaluating an argument to ftmul
854:           				//integ = fval * scale(-exp);
855:           				integ = scale(-exp);		// replaced with this
856:           				integ *= fval;
857:           				if(integ < 1.0)
858:           					exp--;
859:           				else if(integ >= 10.0)
860:           					exp++;
861:           			}
862:           #if	defined(EFMT) || defined(GFMT)
863:           			if(exp <= 0)	// value is 0.??? (neg expnt) whole characters = 1 (allow zero)
864:           				c = 1;
865:           			else
866:           				c = exp;
867:           			if(
868:           #ifdef	EFMT
869:           					flag & EFMT
870:           #ifdef	GFMT
871:           					||
872:           #endif
873:           #endif
874:           #ifdef	GFMT
875:           					flag & GFMT && (exp < -4 || exp >= (int)prec)
876:           #endif
877:           				) {	/* use e format */
878:           #ifdef	GFMT
879:           				if(prec && flag & GFMT)
880:           					prec--;		/* g format precision includes integer digit */
881:           #endif
882:           				if((unsigned)prec > NDDIG - 2)
883:           					c = NDDIG - 2;
884:           				else
885:           					c = prec;
886:           				if( fval!=0) {	/* Normalise only if the number is non-zero. */
887:           					fval /= scale(exp-c);
888:           #if	DOUBLE
889:           					ival = _dto64i(fval);
890:           					if(fval - _64itod(ival) >= 0.5) {
891:           						fval += 0.5;
892:           						ival = _dto64i(fval);
893:           					}
894:           					if(ival >= fdpowers[c+1]) {
895:           						fval *= 1e-1;
896:           						exp++;
897:           					} else if(ival < fdpowers[c]) {
898:           						fval *= 10.0;
899:           						exp--;
900:           					}
901:           #else	
902:           					if(fval - (double)(unsigned long)fval >= 0.5)
903:           						fval += 0.5;
904:           					if((unsigned long)fval >= fdpowers[c+1]) {
905:           						fval *= 1e-1;
906:           						exp++;
907:           					} else if((unsigned long)fval < fdpowers[c]) {
908:           						fval *= 10.0;
909:           						exp--;
910:           					}
911:           #endif
912:           				}
913:           #if defined(GFMT) && defined(ALTERN)
914:           				if(flag & GFMT && !(flag & ALTERN)) {		/* g format, precision means something different */
915:           					if(prec > (int)(NDDIG))
916:           						prec = NDDIG;
917:           #if	DOUBLE
918:           					ival = _dto64i(fval);
919:           					while(ival != 0.0 && _mod64i10(ival) == 0) {
920:           						prec--;
921:           						ival = _div64(ival, fdpowers[1]);
922:           					}
923:           #else
924:           					val = (unsigned long)fval;
925:           					while(val && val % 10 == 0) {
926:           						prec--;
927:           						val /= 10;
928:           					}
929:           #endif
930:           					if(prec < c) {
931:           						fval /= scale(c-prec);
932:           						c = prec;
933:           					}
934:           
935:           				}
936:           #endif
937:           #ifdef	WIDTH
938:           				width -=  prec + 5;
939:           #ifdef	ALTERN
940:           				if(prec || flag & ALTERN)
941:           					width--;
942:           #endif
943:           				if(flag & NEGSIGN)
944:           					width--;
945:           #if	DBL_MAX_10_EXP >= 100
946:           #if	DBL_MAX_10_EXP >= 1000
947:           				if(exp >= 1000 || exp <= -1000)	/* 4 digit exponent */
948:           					width--;
949:           #endif
950:           				if(exp >= 100 || exp <= -100)	/* 3 digit exponent */
951:           					width--;
952:           #endif
953:           #endif	// WIDTH
954:           #ifdef	FILL
955:           				if(flag & FILL) {
956:           #if defined(MANSIGN) && defined(SPCSIGN)
957:           					if(flag & MANSIGN)
958:           						pputc(flag & SPCSIGN ? '-' : '+');
959:           					else if(flag & SPCSIGN)
960:           						pputc(' ');
961:           #endif
962:           					while(width > 0) {
963:           						pputc('0');
964:           						width--;
965:           					}
966:           				} else
967:           #endif	// FILL
968:           				{
969:           #ifdef	WIDTH
970:           #ifdef	LEFT
971:           					if(!(flag & LEFT))
972:           #endif
973:           						while(width > 0) {
974:           							pputc(' ');
975:           							width--;
976:           						}
977:           #endif	// WIDTH
978:           #ifdef	MANSIGN
979:           					if(flag & MANSIGN)
980:           						putsign();
981:           #else
982:           					if(flag & NEGSIGN)
983:           						pputc('-');
984:           #endif	// MANSIGN
985:           #ifdef	SPCSIGN
986:           					else if(flag & SPCSIGN)
987:           						pputc(' ');
988:           #endif	// SPCSIGN
989:           				}
990:           #if	DOUBLE
991:           				ival = _dto64i(fval);
992:           				pputc(_div64ir(ival, fdpowers[c]) + '0');
993:           #else
994:           				val = (unsigned long)fval;
995:           				pputc(val/dpowers[c] + '0');
996:           				val %= dpowers[c];
997:           #endif
998:           #ifdef	ALTERN
999:           				if(prec || flag & ALTERN)
1000:          #else
1001:          				if(prec)
1002:          #endif
1003:          				{
1004:          					pputc('.');
1005:          					prec -= c;
1006:          					while(c--) {
1007:          #if	DOUBLE
1008:          						pputc('0' + _mod64i10(_div64(ival, fdpowers[c])));
1009:          #else
1010:          #ifdef	GFMT
1011:          						if(flag & GFMT && val == 0) {
1012:          							prec = c = 0;
1013:          							break;
1014:          						}
1015:          #endif
1016:          						pputc('0' + (val/dpowers[c]));
1017:          						val %= dpowers[c];
1018:          #endif
1019:          					}
1020:          					while(prec) {
1021:          						pputc('0');
1022:          						prec--;
1023:          					}
1024:          				}
1025:          #ifdef	UPCASE
1026:          				if(flag & UPCASE)
1027:          					pputc('E');
1028:          				else
1029:          #endif
1030:          					pputc('e');
1031:          				if(exp < 0) {
1032:          					exp = -exp;
1033:          					pputc('-');
1034:          				} else
1035:          					pputc('+');
1036:          #if	DBL_MAX_10_EXP >= 100
1037:          #if	DBL_MAX_10_EXP >= 1000
1038:          				if(exp >= 1000) {
1039:          					pputc(exp / 1000 + '0');
1040:          					exp %= 1000;
1041:          				}
1042:          #endif
1043:          				if(exp >= 100) {
1044:          					pputc(exp / 100 + '0');
1045:          					exp %= 100;
1046:          				}
1047:          #endif
1048:          				pputc(exp / 10 + '0');
1049:          				pputc(exp % 10 + '0');
1050:          #ifdef	LEFT
1051:          				if((flag & LEFT) && width > 0)
1052:          					do
1053:          						pputc(' ');
1054:          					while(--width);
1055:          #endif	// LEFT
1056:          					continue;
1057:          				}
1058:          #endif	// EFMT || GFMT
1059:          				/* here for f format */
1060:          #if	DOUBLE
1061:          #ifdef	GFMT
1062:          				if(flag & GFMT) {
1063:          					if(exp < 0)	// fractional part only
1064:          						prec -= exp-1;
1065:          					ival = _dto64i(fval);
1066:          					for(c = 1 ; c != NDDIG ; c++)
1067:          						if(ival < fdpowers[c])
1068:          							break;
1069:          					if(prec > NDDIG)
1070:          						prec = NDDIG;
1071:          					prec -= c;
1072:          					ival = _dto64i((fval - _64itod(ival)) * scale(prec)+0.5);
1073:          					// see how many zeros are at the end of the fractional part
1074:          					while(prec && _mod64i10(ival) == 0) {
1075:          						prec--;
1076:          						ival = _div64(ival, fdpowers[1]);
1077:          					}
1078:          				}
1079:          #endif	// GFMT
1080:          				if(prec <= (int)NDDIG)
1081:          					fval += fround(prec);
1082:          				if(exp > (int)(NDDIG)-2) {
1083:          					exp -= NDDIG-2;
1084:          					ival = _divto64i(fval, scale(exp));
1085:          					fval = 0.0;
1086:          				} else {
1087:          					ival = _dto64i(fval);
1088:          					fval -= _64itod(ival);
1089:          					exp = 0;
1090:          				}
1091:          				for(c = 1 ; c != NDDIG ; c++)
1092:          					if(ival < fdpowers[c])
1093:          						break;
1094:          #else	// DOUBLE
1095:          #ifdef	GFMT
1096:          				if(flag & GFMT) {
1097:          					if(exp < 0)	// fractional part only
1098:          						prec -= (exp+1);
1099:          					// count number of digits in the integral part (this is for %g)
1100:          					val = (unsigned long)fval;
1101:          					for(c = 0 ; c != NDDIG ; c++)
1102:          						if(val < fdpowers[c])
1103:          							break;
1104:          					prec -= c;		// reduce precision by this
1105:          					if(prec <= NDIG)
1106:          						fval += fround(prec);
1107:          					// get fractional part and count trailing zeros - reduce
1108:          					// prec as required
1109:          					{
1110:          						double	temp;
1111:          						temp = scale(prec);
1112:          						temp *= fval - (double)val;
1113:          						val = (unsigned long)temp;
1114:          					}
1115:          					while(prec && val % 10 == 0) {
1116:          						val /= 10;
1117:          						prec--;
1118:          					}
1119:          				} else
1120:          #endif	//GFMT
1121:          					if(prec <= NDIG)
1122:          						fval += fround(prec);
1123:          
1124:          				/* ~4.2e9 is the largest float that will fit into a 32-bit long */
1125:          				if((exp > 9)||(fval != 0 && (unsigned long)fval == 0 && exp > 1)) {
1126:          					// fval is > 4.2e9
1127:          					// new exp must be such that div_to_l() is < 4.2e9
1128:          					// OLD CODE:	if(fval / scale(exp) < 4.294967296){
1129:          					if(integ < 4.294967296){
1130:          						exp -= NDDIG-1;
1131:          					}else{
1132:          						exp -= NDDIG-2;
1133:          					}
1134:          					integ = scale(exp);
1135:          					val = div_to_l_(fval, integ);
1136:           					//val = _div_to_l_(integ, fval);
1137:          					//val = (long)(integ * fval);	// fit as much signifigant data into the long as it can hold
1138:          					fval = 0.0;	// There will be no fractional component
1139:          				} else {
1140:          					val = (unsigned long)fval;
1141:          					fval -= (double)val;
1142:          					exp = 0;
1143:          				}
1144:          				// count digits in integral part
1145:          				for(c = 1 ; c != NDDIG ; c++)
1146:          					if(val < fdpowers[c])
1147:          						break;
1148:          #endif	// DOUBLE
1149:          #ifdef	WIDTH
1150:          				// at this point, c contains the number of whole-number digits to print
1151:          				width -= prec + c + exp;
1152:          				if(
1153:          #ifdef	ALTERN
1154:          						flag & ALTERN ||
1155:          #endif
1156:          						prec)
1157:          					width--;		// allow for decimal point
1158:          				if(flag & NEGSIGN)
1159:          					width--;
1160:          #endif	// WIDTH
1161:          #ifdef	FILL
1162:          				if(flag & FILL) {
1163:          #ifdef	MANSIGN
1164:          					if(flag & MANSIGN)
1165:          #else
1166:          					if(flag & NEGSIGN)
1167:          #endif	// MANSIGN
1168:          						putsign();
1169:          #if defined(MANSIGN) && defined(SPCSIGN)
1170:          					else
1171:          #endif
1172:          #ifdef	SPCSIGN
1173:          					if(flag & SPCSIGN)
1174:          						pputc(' ');
1175:          #endif	// SPCSIGN
1176:          #ifdef	WIDTH
1177:          					while(width > 0) {
1178:          						pputc('0');
1179:          						width--;
1180:          					}
1181:          #endif	// WIDTH
1182:          				} else
1183:          #endif	// FILL
1184:          				{
1185:          #ifdef	LEFT
1186:          					if(!(flag & LEFT))
1187:          #endif
1188:          #ifdef	WIDTH
1189:          					while(width > 0) {
1190:          						pputc(' ');
1191:          						width--;
1192:          					}
1193:          #endif	// WIDTH
1194:          #ifdef	MANSIGN
1195:          				if(flag & MANSIGN)
1196:          #else
1197:          				if(flag & NEGSIGN)
1198:          #endif	// MANSIGN
1199:          					putsign();
1200:          #ifdef	SPCSIGN
1201:          				else if(flag & SPCSIGN)
1202:          					pputc(' ');
1203:          #endif	// SPCSIGN
1204:          			}
1205:          			while(c--) {
1206:          #if	DOUBLE
1207:          				pputc('0' + _mod64i10(_div64(ival, fdpowers[c])));
1208:          #else
1209:          				{
1210:          					unsigned long vd = val/dpowers[c];
1211:          					vd %= 10;
1212:          					pputc('0' + vd);
1213:          				}
1214:          #endif	// DOUBLE
1215:          			}
1216:          			while(exp > 0) {
1217:          				pputc('0');
1218:          				exp--;
1219:          			}
1220:          			if(prec > (int)(NDDIG-2))
1221:          				c = NDDIG-2;
1222:          			else
1223:          				c = prec;
1224:          			prec -= c;
1225:          #ifdef	ALTERN
1226:          			if(c || flag & ALTERN)
1227:          #else
1228:          			if(c)
1229:          #endif
1230:          				pputc('.');
1231:          #if	DOUBLE
1232:          			ival = _dto64i(fval * scale(c));
1233:          			while(c)
1234:          				pputc('0' + _mod64i10(_div64(ival, fdpowers[--c])));
1235:          #else	// DOUBLE
1236:          			val = (long)(fval * scale(c));
1237:          			while(c--) {
1238:          				unsigned long vd = val/dpowers[c];
1239:          				vd %= 10;
1240:          				pputc('0' + vd);
1241:          				val %= dpowers[c];
1242:          			}
1243:          #endif	// DOUBLE
1244:          			while(prec) {
1245:          				pputc('0');
1246:          				prec--;
1247:          			}
1248:          #ifdef	LEFT
1249:          			if((flag & LEFT) && width > 0)
1250:          				do
1251:          					pputc(' ');
1252:          				while(--width);
1253:          #endif
1254:          			continue;
1255:          		}
1256:          #endif	/* __FLOAT */
1257:          
1258:          #if	defined(TEN)
1259:          #ifdef	BASEM
1260:          		if((flag & BASEM) == TEN)
0E95  1B57     BTFSC flag, 0x6
0E96  2EAB     GOTO 0x6AB
1261:          #endif	//BASEM
1262:          		{
1263:          #ifdef	LONG
1264:          			if(flag & LONG)
1265:          				val = va_arg(ap, long);
1266:          			else
1267:          #endif	// LONG
1268:          				val = (value)va_arg(ap, int);
0E97  0856     MOVF ap, W
0E98  0084     MOVWF FSR
0E99  1383     BCF STATUS, 0x7
0E9A  0800     MOVF INDF, W
0E9B  00DB     MOVWF _val
0E9C  0A84     INCF FSR, F
0E9D  0800     MOVF INDF, W
0E9E  00DC     MOVWF f1
0E9F  0AD6     INCF ap, F
0EA0  0AD6     INCF ap, F
1269:          #ifdef	NEGSIGN
1270:          			if((value)val < 0) {
0EA1  1FDC     BTFSS f1, 0x7
0EA2  2EB5     GOTO 0x6B5
1271:          				flag |= NEGSIGN;
0EA3  3003     MOVLW 0x3
0EA4  04D7     IORWF flag, F
1272:          				val = -val;
0EA5  09DB     COMF _val, F
0EA6  09DC     COMF f1, F
0EA7  0ADB     INCF _val, F
0EA8  1903     BTFSC STATUS, 0x2
0EA9  0ADC     INCF f1, F
0EAA  2EB5     GOTO 0x6B5
1273:          			}
1274:          #endif
1275:          		}
1276:          #ifdef	BASEM
1277:          		else
1278:          #endif
1279:          #endif	// TEN
1280:          
1281:          #if	defined(EIGHT) || defined(SIXTEEN) || defined(UNSIGN)
1282:          		{
1283:          #ifdef	__LONG
1284:          #if	defined(_PIC18) && defined(LARGE_DATA) && defined(POINTER)
1285:          			if(flag & POINTER)
1286:          				val = (unsigned long)va_arg(ap, far char *);
1287:          			else
1288:          #endif
1289:          #ifdef	LONG
1290:          				if(flag & LONG)
1291:          				val = va_arg(ap, unsigned long);
1292:          			else
1293:          #endif	// LONG
1294:          #endif	// __LONG
1295:          				val = va_arg(ap, unsigned);
0EAB  0856     MOVF ap, W
0EAC  0084     MOVWF FSR
0EAD  1383     BCF STATUS, 0x7
0EAE  0800     MOVF INDF, W
0EAF  00DB     MOVWF _val
0EB0  0A84     INCF FSR, F
0EB1  0800     MOVF INDF, W
0EB2  00DC     MOVWF f1
0EB3  0AD6     INCF ap, F
0EB4  0AD6     INCF ap, F
1296:          		}
1297:          #endif	// EIGHT or SIXTEEN or UNSIGN
1298:          #ifdef	PRECISION
1299:          		if(prec == 0 && val == 0)
1300:          			prec++;
1301:          #endif
1302:          #ifdef	MULTRAD
1303:          		switch((unsigned char)(flag & BASEM)) {
1304:          #endif
1305:          #if	defined(TEN) || defined(UNSIGN)
1306:          #ifdef	MULTRAD
1307:          #ifdef	TEN
1308:          		case TEN:
1309:          #endif
1310:          #ifdef	UNSIGN
1311:          		case UNSIGN:
1312:          #endif
1313:          #endif	// MULTRAD
1314:          			for(c = 1 ; c != sizeof dpowers/sizeof dpowers[0] ; c++)
0EB5  01DA     CLRF c
0EB6  0ADA     INCF c, F
0EB7  085A     MOVF c, W
0EB8  3A05     XORLW 0x5
0EB9  1903     BTFSC STATUS, 0x2
0EBA  2ED6     GOTO 0x6D6
1315:          				if(val < dpowers[c])
0EBB  1003     BCF STATUS, 0x0
0EBC  0D5A     RLF c, W
0EBD  3E12     ADDLW 0x12
0EBE  0084     MOVWF FSR
0EBF  3098     MOVLW 0x98
0EC0  1803     BTFSC STATUS, 0x0
0EC1  3E01     ADDLW 0x1
0EC2  00FF     MOVWF 0x7F
0EC3  160A     BSF PCLATH, 0x4
0EC4  158A     BSF PCLATH, 0x3
0EC5  2000     CALL 0x0
0EC6  120A     BCF PCLATH, 0x4
0EC7  158A     BSF PCLATH, 0x3
0EC8  00D2     MOVWF f3_as_product
0EC9  160A     BSF PCLATH, 0x4
0ECA  158A     BSF PCLATH, 0x3
0ECB  2000     CALL 0x0
0ECC  120A     BCF PCLATH, 0x4
0ECD  158A     BSF PCLATH, 0x3
0ECE  00D3     MOVWF 0x53
0ECF  025C     SUBWF f1, W
0ED0  1D03     BTFSS STATUS, 0x2
0ED1  2ED4     GOTO 0x6D4
0ED2  0852     MOVF f3_as_product, W
0ED3  025B     SUBWF _val, W
0ED4  1803     BTFSC STATUS, 0x0
0ED5  2EB6     GOTO 0x6B6
1316:          					break;
1317:          #ifdef	MULTRAD
1318:          			break;
1319:          #endif
1320:          #endif	// TEN || UNSIGN
1321:          #ifdef	SIXTEEN
1322:          #ifdef	MULTRAD
1323:          		case SIXTEEN:
1324:          #endif	// MULTRAD
1325:          			for(c = 1 ; c != sizeof hexpowers/sizeof hexpowers[0] ; c++)
1326:          				if(val < hexpowers[c])
1327:          					break;
1328:          #ifdef	MULTRAD
1329:          			break;
1330:          #endif
1331:          #endif
1332:          
1333:          #ifdef	EIGHT
1334:          #ifdef	MULTRAD
1335:          		case EIGHT:
1336:          #endif	// MULTRAD
1337:          			for(c = 1 ; c != sizeof octpowers/sizeof octpowers[0] ; c++)
1338:          				if(val < octpowers[c])
1339:          					break;
1340:          #ifdef	MULTRAD
1341:          			break;
1342:          #endif
1343:          #endif
1344:          #ifdef	MULTRAD
1345:          		}
1346:          #endif
1347:          #ifdef	PRECISION
1348:          		if(c < prec)
1349:          			c = prec;
1350:          		else if(prec < c)
1351:          			prec = c;
1352:          #endif
1353:          #if	defined(WIDTH) && defined(NEGSIGN)
1354:          		if(width && flag & NEGSIGN)
0ED6  0859     MOVF 0x59, W
0ED7  0458     IORWF width, W
0ED8  1903     BTFSC STATUS, 0x2
0ED9  2EE2     GOTO 0x6E2
0EDA  0857     MOVF flag, W
0EDB  3903     ANDLW 0x3
0EDC  1903     BTFSC STATUS, 0x2
0EDD  2EE2     GOTO 0x6E2
1355:          			width--;
0EDE  30FF     MOVLW 0xFF
0EDF  07D8     ADDWF width, F
0EE0  1C03     BTFSS STATUS, 0x0
0EE1  03D9     DECF 0x59, F
1356:          #ifdef	PRECISION
1357:          		if(flag & PRECISION) {
1358:          			if(width > prec)
1359:          				width -= prec;
1360:          			else
1361:          				width = 0;
1362:          		}
1363:          #endif
1364:          #ifdef	ALTERN
1365:          #ifdef	EIGHT
1366:          		if((flag & (
1367:          #ifdef	FILL
1368:          						FILL|
1369:          #endif
1370:          							BASEM|ALTERN)) == (EIGHT|ALTERN)) {
1371:          			if(width)
1372:          				width--;
1373:          		} else
1374:          #endif	// EIGHT
1375:          #if	defined(SIXTEEN)
1376:          #ifdef	BASEM
1377:          		if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1378:          #else
1379:          		if(flag & ALTERN) {
1380:          #endif
1381:          			if(width > 2)
1382:          				width -= 2;
1383:          			else
1384:          				width = 0;
1385:          		}
1386:          #endif	// SIXTEEN
1387:          #endif	// ALTERN
1388:          #endif	// WIDTH
1389:          #ifdef	WIDTH
1390:          		if(width > c)
0EE2  085A     MOVF c, W
0EE3  00D2     MOVWF f3_as_product
0EE4  01D3     CLRF 0x53
0EE5  1BD2     BTFSC f3_as_product, 0x7
0EE6  03D3     DECF 0x53, F
0EE7  0853     MOVF 0x53, W
0EE8  3A80     XORLW 0x80
0EE9  00D4     MOVWF 0x54
0EEA  0859     MOVF 0x59, W
0EEB  3A80     XORLW 0x80
0EEC  0254     SUBWF 0x54, W
0EED  1D03     BTFSS STATUS, 0x2
0EEE  2EF1     GOTO 0x6F1
0EEF  0858     MOVF width, W
0EF0  0252     SUBWF f3_as_product, W
0EF1  1803     BTFSC STATUS, 0x0
0EF2  2F00     GOTO 0x700
1391:          			width -= c;
0EF3  1283     BCF STATUS, 0x5
0EF4  1303     BCF STATUS, 0x6
0EF5  085A     MOVF c, W
0EF6  00D2     MOVWF f3_as_product
0EF7  01D3     CLRF 0x53
0EF8  1BD2     BTFSC f3_as_product, 0x7
0EF9  03D3     DECF 0x53, F
0EFA  02D8     SUBWF width, F
0EFB  0853     MOVF 0x53, W
0EFC  1C03     BTFSS STATUS, 0x0
0EFD  03D9     DECF 0x59, F
0EFE  02D9     SUBWF 0x59, F
0EFF  2F04     GOTO 0x704
1392:          		else
1393:          			width = 0;
0F00  1283     BCF STATUS, 0x5
0F01  1303     BCF STATUS, 0x6
0F02  01D8     CLRF width
0F03  01D9     CLRF 0x59
1394:          #endif
1395:          #ifdef	FILL
1396:          		if(flag & FILL) {
0F04  1D57     BTFSS flag, 0x2
0F05  2F27     GOTO 0x727
1397:          #ifdef	MANSIGN
1398:          			if(flag & MANSIGN)
1399:          				putsign();
1400:          #elif defined(NEGSIGN)
1401:          			if(flag & NEGSIGN)
0F06  0857     MOVF flag, W
0F07  3903     ANDLW 0x3
0F08  1903     BTFSC STATUS, 0x2
0F09  2F14     GOTO 0x714
1402:          				pputc('-');
0F0A  0848     MOVF sp, W
0F0B  0084     MOVWF FSR
0F0C  1383     BCF STATUS, 0x7
0F0D  1849     BTFSC f2, 0x0
0F0E  1783     BSF STATUS, 0x7
0F0F  302D     MOVLW 0x2D
0F10  0080     MOVWF INDF
0F11  0AC8     INCF sp, F
0F12  1903     BTFSC STATUS, 0x2
0F13  0AC9     INCF f2, F
1403:          #endif
1404:          #if defined(MANSIGN) || defined(NEGSIGN) && defined(SPCSIGN)
1405:          			else
1406:          #endif	// MANSIGN
1407:          #ifdef	SPCSIGN
1408:          			if(flag & SPCSIGN)
1409:          				pputc(' ');
1410:          #endif
1411:          #if defined(ALTERN) && defined(SIXTEEN)
1412:          			else if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1413:          				pputc('0');
1414:          #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
1415:          				pputc(flag & UPCASE ? 'X' : 'x');
1416:          #elif defined(HEXUPCASE)
1417:          				pputc('X');
1418:          #else
1419:          				pputc('x');
1420:          #endif	// HEXUPCASE
1421:          			}
1422:          #endif	// ALTERN
1423:          #ifdef	WIDTH
1424:          			if(width)
0F14  0859     MOVF 0x59, W
0F15  0458     IORWF width, W
0F16  1903     BTFSC STATUS, 0x2
0F17  2F4B     GOTO 0x74B
1425:          				do
1426:          					pputc('0');
0F18  0848     MOVF sp, W
0F19  0084     MOVWF FSR
0F1A  1383     BCF STATUS, 0x7
0F1B  1849     BTFSC f2, 0x0
0F1C  1783     BSF STATUS, 0x7
0F1D  3030     MOVLW 0x30
0F1E  0080     MOVWF INDF
0F1F  0AC8     INCF sp, F
0F20  1903     BTFSC STATUS, 0x2
0F21  0AC9     INCF f2, F
1427:          				while(--width);
0F22  30FF     MOVLW 0xFF
0F23  07D8     ADDWF width, F
0F24  1C03     BTFSS STATUS, 0x0
0F25  03D9     DECF 0x59, F
0F26  2F14     GOTO 0x714
1428:          #endif	// WIDTH
1429:          		} else
1430:          #endif	//FILL
1431:          		{
1432:          #ifdef	WIDTH
1433:          			if(width
1434:          #ifdef	LEFT
1435:          					&& !(flag & LEFT)
1436:          #endif
1437:          					)
0F27  0859     MOVF 0x59, W
0F28  0458     IORWF width, W
0F29  1903     BTFSC STATUS, 0x2
0F2A  2F3D     GOTO 0x73D
1438:          				do
1439:          					pputc(' ');
0F2B  0848     MOVF sp, W
0F2C  0084     MOVWF FSR
0F2D  1383     BCF STATUS, 0x7
0F2E  1849     BTFSC f2, 0x0
0F2F  1783     BSF STATUS, 0x7
0F30  3020     MOVLW 0x20
0F31  0080     MOVWF INDF
0F32  0AC8     INCF sp, F
0F33  1903     BTFSC STATUS, 0x2
0F34  0AC9     INCF f2, F
1440:          				while(--width);
0F35  30FF     MOVLW 0xFF
0F36  07D8     ADDWF width, F
0F37  1C03     BTFSS STATUS, 0x0
0F38  03D9     DECF 0x59, F
0F39  0859     MOVF 0x59, W
0F3A  0458     IORWF width, W
0F3B  1D03     BTFSS STATUS, 0x2
0F3C  2F2B     GOTO 0x72B
1441:          #endif	// WIDTH
1442:          #ifdef	MANSIGN
1443:          			if(flag & MANSIGN)
1444:          				putsign();
1445:          #else
1446:          #ifdef	NEGSIGN
1447:          			if(flag & NEGSIGN)
0F3D  0857     MOVF flag, W
0F3E  3903     ANDLW 0x3
0F3F  1903     BTFSC STATUS, 0x2
0F40  2F4B     GOTO 0x74B
1448:          				pputc('-');
0F41  0848     MOVF sp, W
0F42  0084     MOVWF FSR
0F43  1383     BCF STATUS, 0x7
0F44  1849     BTFSC f2, 0x0
0F45  1783     BSF STATUS, 0x7
0F46  302D     MOVLW 0x2D
0F47  0080     MOVWF INDF
0F48  0AC8     INCF sp, F
0F49  1903     BTFSC STATUS, 0x2
0F4A  0AC9     INCF f2, F
1449:          #endif
1450:          #endif	// MANSIGN
1451:          #ifdef	SPCSIGN
1452:          			else if(flag & SPCSIGN)
1453:          				pputc(' ');
1454:          #endif
1455:          #ifdef	ALTERN
1456:          #ifdef	EIGHT
1457:          			if((flag & (BASEM|ALTERN)) == (EIGHT|ALTERN))
1458:          				pputc('0');
1459:          			else
1460:          #endif	// EIGHT
1461:          #ifdef	SIXTEEN
1462:          #ifdef	BASEM
1463:          			if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1464:          #else
1465:          			if(flag & ALTERN) {
1466:          #endif
1467:          				pputc('0');
1468:          #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
1469:          				pputc(flag & UPCASE ? 'X' : 'x');
1470:          #elif defined(HEXUPCASE)
1471:          				pputc('X');
1472:          #else
1473:          				pputc('x');
1474:          #endif
1475:          			}
1476:          #endif	// SIXTEEN
1477:          #endif	// ALTERN
1478:          		}
1479:          #if	defined(SIXTEEN) || defined(TEN) || defined(EIGHT) || defined(UNSIGN)
1480:          #ifndef	PRECISION
1481:          		prec = c;
0F4B  085A     MOVF c, W
0F4C  00D5     MOVWF prec
1482:          #endif
1483:          		while(prec--) {
0F4D  2F80     GOTO 0x780
0F80  03D5     DECF prec, F
0F81  0F55     INCFSZ prec, W
0F82  2F4E     GOTO 0x74E
1484:          #ifdef	MULTRAD
1485:          			switch((unsigned char)(flag & BASEM))
1486:          #endif
1487:          			{
1488:          
1489:          #if	defined(TEN) || defined(UNSIGN)
1490:          #ifdef	MULTRAD
1491:          #ifdef	TEN
1492:          		case TEN:
1493:          #endif
1494:          #ifdef	UNSIGN
1495:          		case UNSIGN:
1496:          #endif
1497:          #endif	// MULTRAD
1498:          				c = (val / dpowers[prec]) % 10 + '0';
0F4E  300A     MOVLW 0xA
0F4F  00AB     MOVWF Data
0F50  01AC     CLRF sec
0F51  1003     BCF STATUS, 0x0
0F52  0D55     RLF prec, W
0F53  3E12     ADDLW 0x12
0F54  0084     MOVWF FSR
0F55  3098     MOVLW 0x98
0F56  1803     BTFSC STATUS, 0x0
0F57  3E01     ADDLW 0x1
0F58  00FF     MOVWF 0x7F
0F59  160A     BSF PCLATH, 0x4
0F5A  158A     BSF PCLATH, 0x3
0F5B  2000     CALL 0x0
0F5C  120A     BCF PCLATH, 0x4
0F5D  158A     BSF PCLATH, 0x3
0F5E  00A4     MOVWF x
0F5F  160A     BSF PCLATH, 0x4
0F60  158A     BSF PCLATH, 0x3
0F61  2000     CALL 0x0
0F62  120A     BCF PCLATH, 0x4
0F63  158A     BSF PCLATH, 0x3
0F64  00A5     MOVWF dato
0F65  085C     MOVF f1, W
0F66  00A7     MOVWF x
0F67  085B     MOVF _val, W
0F68  00A6     MOVWF y
0F69  27B2     CALL 0x7B2
0F6A  120A     BCF PCLATH, 0x4
0F6B  158A     BSF PCLATH, 0x3
0F6C  0825     MOVF dato, W
0F6D  00AE     MOVWF day
0F6E  0824     MOVF x, W
0F6F  00AD     MOVWF hr
0F70  27DC     CALL 0x7DC
0F71  120A     BCF PCLATH, 0x4
0F72  158A     BSF PCLATH, 0x3
0F73  082B     MOVF Data, W
0F74  3E30     ADDLW 0x30
0F75  00DA     MOVWF c
1499:          #ifdef	MULTRAD
1500:          				break;
1501:          #endif
1502:          #endif	// TEN || UNSIGN
1503:          
1504:          #ifdef	SIXTEEN
1505:          #ifdef	MULTRAD
1506:          			case SIXTEEN:
1507:          #endif
1508:          			{
1509:          				unsigned char idx = (val / hexpowers[prec]) & 0xF;
1510:          #if	defined(HEXLOWCASE) && defined(HEXUPCASE)
1511:          				c = (flag & UPCASE ? "0123456789ABCDEF" : "0123456789abcdef")[idx];
1512:          #elif	defined(HEXUPCASE)
1513:          				c = "0123456789ABCDEF"[idx];
1514:          #else
1515:          				c = "0123456789abcdef"[idx];
1516:          #endif	//HEXCASE
1517:          			}
1518:          #ifdef	MULTRAD
1519:          				break;
1520:          #endif
1521:          #endif
1522:          
1523:          #ifdef	EIGHT
1524:          #ifdef	MULTRAD
1525:          			case EIGHT:
1526:          #endif	// MULTRAD
1527:          				c = ((val / octpowers[prec]) & 07) + '0';
1528:          #ifdef	MULTRAD
1529:          				break;
1530:          #endif	// MULTRAD
1531:          #endif	// EIGHT
1532:          			}
1533:          			pputc(c);
0F76  0848     MOVF sp, W
0F77  0084     MOVWF FSR
0F78  1383     BCF STATUS, 0x7
0F79  1849     BTFSC f2, 0x0
0F7A  1783     BSF STATUS, 0x7
0F7B  085A     MOVF c, W
0F7C  0080     MOVWF INDF
0F7D  0AC8     INCF sp, F
0F7E  1903     BTFSC STATUS, 0x2
0F7F  0AC9     INCF f2, F
1534:          		}
1535:          #endif	// 16 or 10 or 8
1536:          #ifdef	LEFT
1537:          		if((flag & LEFT) && width > 0)
1538:          			do
1539:          				pputc(' ');
1540:          			while(--width);
1541:          #endif	// LEFT
1542:          	}
1543:          #ifdef	ANYFORMAT
1544:          alldone:
1545:          #endif	// ANYFORMAT
1546:          #if	!defined(PRINTF) && (defined(SPRINTF) || defined(VSPRINTF))
1547:          	*sp = 0;
0F84  0848     MOVF sp, W
0F85  0084     MOVWF FSR
0F86  1783     BSF STATUS, 0x7
0F87  1C49     BTFSS f2, 0x0
0F88  1383     BCF STATUS, 0x7
0F89  0180     CLRF INDF
1548:          #endif
1549:          	return ccnt;
1550:          }
0F8A  0008     RETURN
1551:          
---  /opt/microchip/xc8/v1.31/sources/common/bmul.c  ----------------------------------------------------
1:             // 8 x 8 bit multiplication with 8 bit result
2:             
3:             unsigned char
4:             __bmul(unsigned char multiplier, unsigned char multiplicand)
0D49  1283     BCF STATUS, 0x5
0D4A  00A6     MOVWF y
5:             {
6:             	unsigned char product;
7:             
8:             	product = 0;
0D4B  01A5     CLRF dato
9:             	do {
10:            		if(multiplier & 1)
0D4C  0824     MOVF x, W
0D4D  1826     BTFSC y, 0x0
11:            			product += multiplicand;
0D4C  0824     MOVF x, W
0D4E  07A5     ADDWF dato, F
12:            		multiplicand <<= 1;
0D4F  1003     BCF STATUS, 0x0
0D50  0DA4     RLF x, F
13:            		multiplier >>= 1;
0D51  1003     BCF STATUS, 0x0
0D52  0CA6     RRF y, F
14:            	} while(multiplier != 0);
0D53  08A6     MOVF y, F
0D54  1D03     BTFSS STATUS, 0x2
0D55  2D4C     GOTO 0x54C
15:            	return product;
0D56  0825     MOVF dato, W
16:            }
0D57  0008     RETURN
17:            
---  /opt/microchip/xc8/v1.31/sources/common/awmod.c  ---------------------------------------------------
1:             // integer signed unsigned modulus
2:             
3:             signed int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __awmod(signed int divisor, signed int dividend)
0808  01F5     CLRF Pin
0D58  01B7     CLRF sign
7:             #else
8:             __awmod(signed int dividend, signed int divisor)
9:             #endif
10:            {
11:            	unsigned char	counter, sign;
12:            
13:            	sign = 0;
0808  01F5     CLRF Pin
0D58  01B7     CLRF sign
14:            	if(dividend < 0) {
0809  1FF3     BTFSS counter, 0x7
080A  2812     GOTO 0x12
0D59  1FB5     BTFSS 0x35, 0x7
0D5A  2D62     GOTO 0x562
15:            		dividend = -dividend;
080B  09F2     COMF dividend, F
080C  09F3     COMF counter, F
080D  0AF2     INCF dividend, F
080E  1903     BTFSC STATUS, 0x2
080F  0AF3     INCF counter, F
0D5B  09B4     COMF dividend, F
0D5C  09B5     COMF 0x35, F
0D5D  0AB4     INCF dividend, F
0D5E  1903     BTFSC STATUS, 0x2
0D5F  0AB5     INCF 0x35, F
16:            		sign = 1;
0810  01F5     CLRF Pin
0811  0AF5     INCF Pin, F
0D60  01B7     CLRF sign
0D61  0AB7     INCF sign, F
17:            	}
18:            	if(divisor < 0)
0812  1FF1     BTFSS canal, 0x7
0813  2819     GOTO 0x19
0D62  1FB3     BTFSS 0x33, 0x7
0D63  2D69     GOTO 0x569
19:            		divisor = -divisor;
0814  09F0     COMF tiempo, F
0815  09F1     COMF canal, F
0816  0AF0     INCF tiempo, F
0817  1903     BTFSC STATUS, 0x2
0818  0AF1     INCF canal, F
0D64  09B2     COMF divisor, F
0D65  09B3     COMF 0x33, F
0D66  0AB2     INCF divisor, F
0D67  1903     BTFSC STATUS, 0x2
0D68  0AB3     INCF 0x33, F
20:            	if(divisor != 0) {
0819  0871     MOVF canal, W
081A  0470     IORWF tiempo, W
081B  1903     BTFSC STATUS, 0x2
081C  2838     GOTO 0x38
0D69  0833     MOVF 0x33, W
0D6A  0432     IORWF divisor, W
0D6B  1903     BTFSC STATUS, 0x2
0D6C  2D88     GOTO 0x588
21:            		counter = 1;
081D  01F4     CLRF counter
0D6D  01B6     CLRF counter
22:            		while(((unsigned int)divisor & 0x8000U) == 0) {
081F  1BF1     BTFSC canal, 0x7
0820  2825     GOTO 0x25
0824  281E     GOTO 0x1E
0D6F  1BB3     BTFSC 0x33, 0x7
0D70  2D75     GOTO 0x575
0D74  2D6E     GOTO 0x56E
23:            			divisor <<= 1;
081E  0AF4     INCF counter, F
0821  1003     BCF STATUS, 0x0
0822  0DF0     RLF tiempo, F
0823  0DF1     RLF canal, F
0D6E  0AB6     INCF counter, F
0D71  1003     BCF STATUS, 0x0
0D72  0DB2     RLF divisor, F
0D73  0DB3     RLF 0x33, F
24:            			counter++;
081E  0AF4     INCF counter, F
0D6E  0AB6     INCF counter, F
25:            		}
26:            		do {
27:            			if((unsigned int)divisor <= (unsigned int)dividend)
0825  0871     MOVF canal, W
0826  0273     SUBWF counter, W
0827  1D03     BTFSS STATUS, 0x2
0828  282B     GOTO 0x2B
0829  0870     MOVF tiempo, W
082A  0272     SUBWF dividend, W
082B  1C03     BTFSS STATUS, 0x0
082C  2834     GOTO 0x34
0D75  0833     MOVF 0x33, W
0D76  0235     SUBWF 0x35, W
0D77  1D03     BTFSS STATUS, 0x2
0D78  2D7B     GOTO 0x57B
0D79  0832     MOVF divisor, W
0D7A  0234     SUBWF dividend, W
0D7B  1C03     BTFSS STATUS, 0x0
0D7C  2D84     GOTO 0x584
28:            				dividend -= divisor;
082D  0870     MOVF tiempo, W
082E  02F2     SUBWF dividend, F
082F  0871     MOVF canal, W
0830  1C03     BTFSS STATUS, 0x0
0831  03F3     DECF counter, F
0832  02F3     SUBWF counter, F
0D7D  0832     MOVF divisor, W
0D7E  02B4     SUBWF dividend, F
0D7F  0833     MOVF 0x33, W
0D80  1C03     BTFSS STATUS, 0x0
0D81  03B5     DECF 0x35, F
0D82  02B5     SUBWF 0x35, F
29:            			*(unsigned int *)&divisor >>= 1;
0833  1003     BCF STATUS, 0x0
0834  0CF1     RRF canal, F
0835  0CF0     RRF tiempo, F
0D83  1003     BCF STATUS, 0x0
0D84  0CB3     RRF 0x33, F
0D85  0CB2     RRF divisor, F
30:            		} while(--counter != 0);
0836  0BF4     DECFSZ counter, F
0837  2825     GOTO 0x25
0D86  0BB6     DECFSZ counter, F
0D87  2D75     GOTO 0x575
31:            	}
32:            	if(sign)
0838  0875     MOVF Pin, W
0839  1903     BTFSC STATUS, 0x2
083A  2840     GOTO 0x40
0D88  0837     MOVF sign, W
0D89  1903     BTFSC STATUS, 0x2
0D8A  2D90     GOTO 0x590
33:            		dividend = -dividend;
083B  09F2     COMF dividend, F
083C  09F3     COMF counter, F
083D  0AF2     INCF dividend, F
083E  1903     BTFSC STATUS, 0x2
083F  0AF3     INCF counter, F
0D8B  09B4     COMF dividend, F
0D8C  09B5     COMF 0x35, F
0D8D  0AB4     INCF dividend, F
0D8E  1903     BTFSC STATUS, 0x2
0D8F  0AB5     INCF 0x35, F
34:            	return dividend;
0840  0873     MOVF counter, W
0841  00F1     MOVWF canal
0842  0872     MOVF dividend, W
0843  00F0     MOVWF tiempo
0D90  0835     MOVF 0x35, W
0D91  00B3     MOVWF 0x33
0D92  0834     MOVF dividend, W
0D93  00B2     MOVWF divisor
35:            }
0844  0008     RETURN
0D94  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/awdiv.c  ---------------------------------------------------
1:             // integer signed division
2:             
3:             signed int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __awdiv(signed int divisor, signed int dividend)
7:             #else
8:             __awdiv(signed int dividend, signed int divisor)
9:             #endif
10:            {
11:            	signed int	quotient;
12:            	unsigned char	counter, sign;
13:            
14:            	sign = 0;
0A94  01AF     CLRF sign
15:            	if(divisor < 0) {
0A95  1FAB     BTFSS Data, 0x7
0A96  2A9E     GOTO 0x29E
16:            		divisor = -divisor;
0A97  09AA     COMF year, F
0A98  09AB     COMF Data, F
0A99  0AAA     INCF year, F
0A9A  1903     BTFSC STATUS, 0x2
0A9B  0AAB     INCF Data, F
17:            		sign = 1;
0A9C  01AF     CLRF sign
0A9D  0AAF     INCF sign, F
18:            	}
19:            	if(dividend < 0) {
0A9E  1FAD     BTFSS hr, 0x7
0A9F  2AA7     GOTO 0x2A7
20:            		dividend = -dividend;
0AA0  09AC     COMF sec, F
0AA1  09AD     COMF hr, F
0AA2  0AAC     INCF sec, F
0AA3  1903     BTFSC STATUS, 0x2
0AA4  0AAD     INCF hr, F
21:            		sign ^= 1;
0AA5  3001     MOVLW 0x1
0AA6  06AF     XORWF sign, F
22:            	}
23:            	quotient = 0;
0AA7  01B0     CLRF quotient
0AA8  01B1     CLRF 0x31
24:            	if(divisor != 0) {
0AA9  082B     MOVF Data, W
0AAA  042A     IORWF year, W
0AAB  1903     BTFSC STATUS, 0x2
0AAC  2ACC     GOTO 0x2CC
25:            		counter = 1;
0AAD  01AE     CLRF day
26:            		while((divisor & 0x8000U) == 0) {
0AAF  1BAB     BTFSC Data, 0x7
0AB0  2AB5     GOTO 0x2B5
0AB4  2AAE     GOTO 0x2AE
27:            			divisor <<= 1;
0AAE  0AAE     INCF day, F
0AB1  1003     BCF STATUS, 0x0
0AB2  0DAA     RLF year, F
0AB3  0DAB     RLF Data, F
28:            			counter++;
0AAE  0AAE     INCF day, F
29:            		}
30:            		do {
31:            			quotient <<= 1;
0AB5  1003     BCF STATUS, 0x0
0AB6  0DB0     RLF quotient, F
0AB7  0DB1     RLF 0x31, F
32:            			if((unsigned int)divisor <= (unsigned int)dividend) {
0AB8  082B     MOVF Data, W
0AB9  022D     SUBWF hr, W
0ABA  1D03     BTFSS STATUS, 0x2
0ABB  2ABE     GOTO 0x2BE
0ABC  082A     MOVF year, W
0ABD  022C     SUBWF sec, W
0ABE  1C03     BTFSS STATUS, 0x0
0ABF  2AC8     GOTO 0x2C8
33:            				dividend -= divisor;
0AC0  082A     MOVF year, W
0AC1  02AC     SUBWF sec, F
0AC2  082B     MOVF Data, W
0AC3  1C03     BTFSS STATUS, 0x0
0AC4  03AD     DECF hr, F
0AC5  02AD     SUBWF hr, F
34:            				quotient |= 1;
0AC6  1430     BSF quotient, 0x0
35:            			}
36:            			*(unsigned int *)&divisor >>= 1;
0AC7  1003     BCF STATUS, 0x0
0AC8  0CAB     RRF Data, F
0AC9  0CAA     RRF year, F
37:            		} while(--counter != 0);
0ACA  0BAE     DECFSZ day, F
0ACB  2AB5     GOTO 0x2B5
38:            	}
39:            	if(sign)
0ACC  082F     MOVF sign, W
0ACD  1903     BTFSC STATUS, 0x2
0ACE  2AD4     GOTO 0x2D4
40:            		quotient = -quotient;
0ACF  09B0     COMF quotient, F
0AD0  09B1     COMF 0x31, F
0AD1  0AB0     INCF quotient, F
0AD2  1903     BTFSC STATUS, 0x2
0AD3  0AB1     INCF 0x31, F
41:            	return quotient;
0AD4  0831     MOVF 0x31, W
0AD5  00AB     MOVWF Data
0AD6  0830     MOVF quotient, W
0AD7  00AA     MOVWF year
42:            }
0AD8  0008     RETURN
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/pwm.c  --------------------------------
1:             #include <xc.h>
2:             #include <stdint.h>         /* For uint8_t definition */
3:             #include <stdbool.h>        /* For true/false definition */
4:             #include "system.h"
5:             #include "pwm.h"
6:             #include "user.h"
7:             /*The following steps should be taken when configuring
8:             the CCP module for PWM operation:
9:             1. Set the PWM period by writing to the PR2 register.
10:            2. Set the PWM duty cycle by writing to the
11:            CCPR1L register and CCP1CON<5:4> bits.
12:            3. Make the CCP1 pin an output by clearing the
13:            TRISC<2> bit.
14:            4. Set the TMR2 prescale value and enable Timer2
15:            by writing to T2CON.
16:            5. Configure the CCP1 module for PWM operation.*/
17:            #define FrecuenciaPWM 4880UL
18:            #define PeriodoPWM 1/FrecuenciaPWM
19:            #define PRESCALERTIMER2 4
20:            #define asignaPR2 _XTAL_FREQ/PRESCALERTIMER2/4*PeriodoPWM-1
21:            
22:            void set_periodo_buzzer(void) {
23:                //PWM Period = [(PR2) + 1] * 4 * TOSC *(TMR2 Prescale Value)
24:                //PR2=PWM PERIOD/(4*TOSC*TMR2 Prescale Value)-1
25:                //para una frecuencia de __XTAL_FREQ/4=5Mhz
26:                PR2 = asignaPR2; //periodo;;//periodo; //asigno el periodo
1FD7  30FF     MOVLW 0xFF
1FD8  1683     BSF STATUS, 0x5
1FD9  0092     MOVWF T2CON
27:                T2CONbits.TMR2ON = 1; //Habilito el timer2
1FDA  1283     BCF STATUS, 0x5
1FDB  1512     BSF T2CON, 0x2
28:                T2CONbits.T2CKPS = 1; //prescaler en 4
1FDC  0812     MOVF T2CON, W
1FDD  39FC     ANDLW 0xFC
1FDE  3801     IORLW 0x1
1FDF  0092     MOVWF T2CON
29:                // CCP1CONbits.CCP1M=0b1100; //Configuro el CCp1 como PWM
30:                RB2 = 0;
1FE0  1106     BCF PORTB, 0x2
31:                TRISC2 = 0; //pongo el pin RC2/PWM1 como salida
1FE1  1683     BSF STATUS, 0x5
1FE2  1107     BCF PORTC, 0x2
32:            #warning No olvidar que si el PWM_duty > PWM_period no queda bien definida la frecuencia
33:                set_duty(512);
1FE3  1283     BCF STATUS, 0x5
34:            }
35:            
36:            /*/PWM Duty Cycle =(CCPR1L:CCP1CON<5:4>)*TOSC*(TMR2 Prescale Value)*/
37:            void set_duty(unsigned int duty) {
38:            
39:            #define PWM10Bits
40:                //pwm modo 10bits
41:            #ifdef PWM10Bits
42:                CCPR1L = duty >> 2;
1FE8  0825     MOVF dato, W
1FE9  00A7     MOVWF x
1FEA  0824     MOVF x, W
1FEB  00A6     MOVWF y
1FEC  1003     BCF STATUS, 0x0
1FED  0CA7     RRF x, F
1FEE  0CA6     RRF y, F
1FEF  1003     BCF STATUS, 0x0
1FF0  0CA7     RRF x, F
1FF1  0CA6     RRF y, F
1FF2  0826     MOVF y, W
1FF3  0095     MOVWF CCPR1
43:            #endif
44:                CCP1CON = (CCP1CON & 0xCF) | ((duty << 4) & 0x30);
1FF4  0824     MOVF x, W
1FF5  00A6     MOVWF y
1FF6  0E26     SWAPF y, W
1FF7  39F0     ANDLW 0xF0
1FF8  00A6     MOVWF y
1FF9  3930     ANDLW 0x30
1FFA  00A7     MOVWF x
1FFB  0817     MOVF CCP1CON, W
1FFC  39CF     ANDLW 0xCF
1FFD  0427     IORWF x, W
1FFE  0097     MOVWF CCP1CON
45:            
46:            
47:            
48:            }
49:            
50:            void buzzer_off(void) {
1001  30F0     MOVLW 0xF0
17EE  30F0     MOVLW 0xF0
51:                //activapor=0;
52:                CCP1CONbits.CCP1M = 0; //desactiva pwm
1001  30F0     MOVLW 0xF0
1002  1283     BCF STATUS, 0x5
1003  1303     BCF STATUS, 0x6
1004  0597     ANDWF CCP1CON, F
17EE  30F0     MOVLW 0xF0
17EF  1283     BCF STATUS, 0x5
17F0  0597     ANDWF CCP1CON, F
53:                PORTCbits.RC2 = 0; //pongo el pin de reloj en bajo
1005  1107     BCF PORTC, 0x2
17F1  1107     BCF PORTC, 0x2
54:            
55:            }
1006  0008     RETURN
17F2  0008     RETURN
56:            
57:            void buzzer_on(unsigned char tiempo) {//tiempo especifica en multiplos de 40ms cuanto tiempo est encendido el buzzer
17BE  00F0     MOVWF tiempo
1F7D  1283     BCF STATUS, 0x5
1F7E  1303     BCF STATUS, 0x6
1F7F  00A4     MOVWF x
58:                activapwmpor = tiempo;
17BF  1683     BSF STATUS, 0x5
17C0  1303     BCF STATUS, 0x6
17C1  00AD     MOVWF hr
1F80  1683     BSF STATUS, 0x5
1F81  00AD     MOVWF hr
59:                CCP1CONbits.CCP1M = 0b1100; //activa pwm
17C2  1283     BCF STATUS, 0x5
17C3  0817     MOVF CCP1CON, W
17C4  39F0     ANDLW 0xF0
17C5  380C     IORLW 0xC
17C6  0097     MOVWF CCP1CON
1F82  1283     BCF STATUS, 0x5
1F83  0817     MOVF CCP1CON, W
1F84  39F0     ANDLW 0xF0
1F85  380C     IORLW 0xC
1F86  0097     MOVWF CCP1CON
60:            }
17C7  0008     RETURN
1F87  0008     RETURN
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/main.c  -------------------------------
1:             /******************************************************************************/
2:             /* Files to Include                                                           */
3:             /******************************************************************************/
4:             // Real Time Clock & NVRAM
5:             // Hardware isl1208 of Dallas Maxim
6:             // With interface I2C
7:             #ifndef __PICCPRO__
8:             #define __PICCPRO__
9:             #endif
10:            
11:            #if defined(__XC)
12:            #include <xc.h>         /* XC8 General Include File */
13:            #elif defined(HI_TECH_C)
14:            #include <htc.h>        /* HiTech General Include File */
15:            #endif
16:            #include <stdint.h>        /* For uint8_t definition */
17:            #include <stdbool.h>       /* For true/false definition */
18:            #include <stdio.h>
19:            #include "system.h"        /* System funct/params, like osc/peripheral config */
20:            #include "user.h"          /* User funct/params, such as InitApp */
21:            #include "Pulsadores.h"
22:            #include "pwm.h"
23:            #include "adcPic16.h"
24:            #include <string.h>
25:            #include "_isl1208.h"
26:            #include "HardI2C.h"
27:            #include "usart1.h"
28:            #include "LCDGeneric.h"
29:            
30:            #define USE_INTERRUPTS 1
31:            
32:            ///////////////////////////////////////////////////////////////////////////////
33:            
34:            void lee_y_transmite_date_and_time(void) {
35:                isl1208_get_date(&fecha.day, &fecha.month, &fecha.yr, &fecha.dow);
0A07  306D     MOVLW 0x6D
0A08  1283     BCF STATUS, 0x5
0A09  00A9     MOVWF mth
0A0A  306E     MOVLW 0x6E
0A0B  00AA     MOVWF year
0A0C  306F     MOVLW 0x6F
0A0D  00AB     MOVWF Data
0A0E  306C     MOVLW 0x6C
0A0F  23C4     CALL 0x3C4
0A10  120A     BCF PCLATH, 0x4
0A11  158A     BSF PCLATH, 0x3
36:                isl1208_get_time(&horarioactual.hrs, &horarioactual.min, &horarioactual.sec);
0A12  30DC     MOVLW 0xDC
37:            }
38:            
39:            void main() {
40:                TMR1IE = 0; //   disable_interrupts(int_timer1);
1096  1683     BSF STATUS, 0x5
1097  100C     BCF PIR1, 0x0
41:                RCIE = 0; //    disable_interrupts(int_rda);
1098  128C     BCF PIR1, 0x5
42:                RBIE = 0;
1099  118B     BCF INTCON, 0x3
43:                INTE = 0; //disable_interrupts(int_ext);
109A  120B     BCF INTCON, 0x4
44:                ADCON1 = 0x06; //todos puertos digitales
109B  3006     MOVLW 0x6
109C  009F     MOVWF ADCON0
45:                T0CS = 0; // TMR0 Clock Source Select bit: internal
109D  1281     BCF TMR0, 0x5
46:                PSA = 0; //Prescaler is assigned to the Timer0 module
109E  1181     BCF TMR0, 0x3
47:                OPTION_REGbits.PS = 0b101; //: Prescaler Rate Select bits 1/64
109F  0801     MOVF TMR0, W
10A0  39F8     ANDLW 0xF8
10A1  3805     IORLW 0x5
10A2  0081     MOVWF TMR0
48:                //setup_timer_1(T1_INTERNAL | T1_DIV_BY_1);
49:                T1CON = 1;
10A3  3001     MOVLW 0x1
10A4  1283     BCF STATUS, 0x5
10A5  0090     MOVWF T1CON
50:                CCP1CONbits.CCP1M = 0;
10A6  30F0     MOVLW 0xF0
10A7  0597     ANDWF CCP1CON, F
51:                //configura_USART();
52:                setup_i2c(I2C_MASTER);
10A8  3038     MOVLW 0x38
10A9  120A     BCF PCLATH, 0x4
10AA  118A     BCF PCLATH, 0x3
10AB  27EE     CALL 0x7EE
10AC  160A     BSF PCLATH, 0x4
10AD  118A     BCF PCLATH, 0x3
53:            
54:                TRISB = 0b00111111; //Configuro las entradas de las teclas y la entrada del reloj
10AE  303F     MOVLW 0x3F
10AF  1683     BSF STATUS, 0x5
10B0  0086     MOVWF PORTB
55:                PORTB = 0;
10B1  1283     BCF STATUS, 0x5
10B2  0186     CLRF PORTB
56:                TRISC0 = 0; //Configuro el pin de activacion de la bomba como salida
10B3  1683     BSF STATUS, 0x5
10B4  1007     BCF PORTC, 0x0
57:                TRISD = 0x00;
10B5  0188     CLRF PORTD
58:                PORTD = 0;
10B6  1283     BCF STATUS, 0x5
10B7  0188     CLRF PORTD
59:                TRISE = 0b00000000;
10B8  1683     BSF STATUS, 0x5
10B9  0189     CLRF PORTE
60:                PORTE = 0;
10BA  1283     BCF STATUS, 0x5
10BB  0189     CLRF PORTE
61:            
62:                vInitLCD();
10BC  120A     BCF PCLATH, 0x4
10BD  158A     BSF PCLATH, 0x3
10BE  20E7     CALL 0xE7
10BF  160A     BSF PCLATH, 0x4
10C0  118A     BCF PCLATH, 0x3
63:                static char * cadena;
64:                set_periodo_buzzer(); //configuro el pwm para una frecuencia de 3khz
10C1  160A     BSF PCLATH, 0x4
10C2  158A     BSF PCLATH, 0x3
10C3  27D7     CALL 0x7D7
10C4  160A     BSF PCLATH, 0x4
10C5  118A     BCF PCLATH, 0x3
65:                buzzer_on(3);
10C6  3003     MOVLW 0x3
10C7  160A     BSF PCLATH, 0x4
10C8  158A     BSF PCLATH, 0x3
10C9  277D     CALL 0x77D
10CA  160A     BSF PCLATH, 0x4
10CB  118A     BCF PCLATH, 0x3
66:                __delay_ms(200);
10CC  3006     MOVLW 0x6
10CD  1683     BSF STATUS, 0x5
10CE  00E6     MOVWF 0x66
10CF  3013     MOVLW 0x13
10D0  00E5     MOVWF 0x65
10D1  30B1     MOVLW 0xB1
10D2  00E4     MOVWF f3
10D3  0BE4     DECFSZ f3, F
10D4  28D3     GOTO 0xD3
10D5  0BE5     DECFSZ 0x65, F
10D6  28D3     GOTO 0xD3
10D7  0BE6     DECFSZ 0x66, F
10D8  28D3     GOTO 0xD3
10D9  28DA     GOTO 0xDA
67:                buzzer_off();
10DA  160A     BSF PCLATH, 0x4
10DB  118A     BCF PCLATH, 0x3
10DC  2001     CALL 0x1
10DD  160A     BSF PCLATH, 0x4
10DE  118A     BCF PCLATH, 0x3
68:                __delay_ms(200);
10DF  3006     MOVLW 0x6
10E0  1683     BSF STATUS, 0x5
10E1  00E6     MOVWF 0x66
10E2  3013     MOVLW 0x13
10E3  00E5     MOVWF 0x65
10E4  30B1     MOVLW 0xB1
10E5  00E4     MOVWF f3
10E6  0BE4     DECFSZ f3, F
10E7  28E6     GOTO 0xE6
10E8  0BE5     DECFSZ 0x65, F
10E9  28E6     GOTO 0xE6
10EA  0BE6     DECFSZ 0x66, F
10EB  28E6     GOTO 0xE6
10EC  28ED     GOTO 0xED
69:                buzzer_on(3);
10ED  3003     MOVLW 0x3
10EE  160A     BSF PCLATH, 0x4
10EF  158A     BSF PCLATH, 0x3
10F0  277D     CALL 0x77D
10F1  160A     BSF PCLATH, 0x4
10F2  118A     BCF PCLATH, 0x3
70:                __delay_ms(200);
10F3  3006     MOVLW 0x6
10F4  1683     BSF STATUS, 0x5
10F5  00E6     MOVWF 0x66
10F6  3013     MOVLW 0x13
10F7  00E5     MOVWF 0x65
10F8  30B1     MOVLW 0xB1
10F9  00E4     MOVWF f3
10FA  0BE4     DECFSZ f3, F
10FB  28FA     GOTO 0xFA
10FC  0BE5     DECFSZ 0x65, F
10FD  28FA     GOTO 0xFA
10FE  0BE6     DECFSZ 0x66, F
10FF  28FA     GOTO 0xFA
1100  2901     GOTO 0x101
71:                buzzer_off();
1101  160A     BSF PCLATH, 0x4
1102  118A     BCF PCLATH, 0x3
1103  2001     CALL 0x1
1104  160A     BSF PCLATH, 0x4
1105  118A     BCF PCLATH, 0x3
72:            
73:                setADCChannel(MIDECORRIENTE);
1106  3000     MOVLW 0x0
1107  160A     BSF PCLATH, 0x4
1108  118A     BCF PCLATH, 0x3
1109  2007     CALL 0x7
110A  160A     BSF PCLATH, 0x4
110B  118A     BCF PCLATH, 0x3
74:                __delay_us(20);
110C  3021     MOVLW 0x21
110D  1683     BSF STATUS, 0x5
110E  00E4     MOVWF f3
110F  0BE4     DECFSZ f3, F
1110  290F     GOTO 0x10F
75:                openADC();
1111  160A     BSF PCLATH, 0x4
1112  158A     BSF PCLATH, 0x3
1113  2788     CALL 0x788
1114  160A     BSF PCLATH, 0x4
1115  118A     BCF PCLATH, 0x3
76:            
77:                // <editor-fold defaultstate="collapsed" desc="Lectura del estado actual del RTC">
78:            
79:                if (ISL1208_ready()) {
1116  120A     BCF PCLATH, 0x4
1117  158A     BSF PCLATH, 0x3
1118  22D9     CALL 0x2D9
1119  160A     BSF PCLATH, 0x4
111A  118A     BCF PCLATH, 0x3
111B  3A00     XORLW 0x0
1120  1903     BTFSC STATUS, 0x2
1121  2926     GOTO 0x126
80:                    sprintf(cadenaamostrar, "RTC OK");
111C  30A6     MOVLW 0xA6
111D  00C8     MOVWF sp
111E  3001     MOVLW 0x1
111F  00C9     MOVWF f2
1122  3040     MOVLW 0x40
1123  00CA     MOVWF f
1124  3099     MOVLW 0x99
1125  2929     GOTO 0x129
81:            
82:                } else {
83:                    sprintf(cadenaamostrar, "RTC ERRO");
1126  301C     MOVLW 0x1C
1127  00CA     MOVWF f
1128  3099     MOVLW 0x99
1129  00CB     MOVWF 0x4B
112A  120A     BCF PCLATH, 0x4
112B  158A     BSF PCLATH, 0x3
112C  25B1     CALL 0x5B1
112D  160A     BSF PCLATH, 0x4
112E  118A     BCF PCLATH, 0x3
84:                };
85:                vGotoxyLCD(1, 1);
112F  3001     MOVLW 0x1
1130  01A6     CLRF y
1131  0AA6     INCF y, F
1132  120A     BCF PCLATH, 0x4
1133  158A     BSF PCLATH, 0x3
1134  209C     CALL 0x9C
1135  160A     BSF PCLATH, 0x4
1136  118A     BCF PCLATH, 0x3
86:                cadena = cadenaamostrar;
1137  30A6     MOVLW 0xA6
1138  1683     BSF STATUS, 0x5
1139  00A9     MOVWF mth
113A  3001     MOVLW 0x1
113B  00AA     MOVWF year
87:                while (*cadena != '\0')
113C  0829     MOVF mth, W
113D  0084     MOVWF FSR
113E  1783     BSF STATUS, 0x7
113F  1C2A     BTFSS year, 0x0
1140  1383     BCF STATUS, 0x7
1141  0880     MOVF INDF, F
1142  1903     BTFSC STATUS, 0x2
1143  2955     GOTO 0x155
1154  293C     GOTO 0x13C
88:                    vLCD_Putc(*cadena++);
1144  0829     MOVF mth, W
1145  0084     MOVWF FSR
1146  1783     BSF STATUS, 0x7
1147  1C2A     BTFSS year, 0x0
1148  1383     BCF STATUS, 0x7
1149  0800     MOVF INDF, W
114A  120A     BCF PCLATH, 0x4
114B  158A     BSF PCLATH, 0x3
114C  20BF     CALL 0xBF
114D  160A     BSF PCLATH, 0x4
114E  118A     BCF PCLATH, 0x3
114F  1683     BSF STATUS, 0x5
1150  1303     BCF STATUS, 0x6
1151  0AA9     INCF mth, F
1152  1903     BTFSC STATUS, 0x2
1153  0AAA     INCF year, F
89:            
90:                __delay_ms(500);
1155  300D     MOVLW 0xD
1156  00E6     MOVWF 0x66
1157  30AF     MOVLW 0xAF
1158  00E5     MOVWF 0x65
1159  30C1     MOVLW 0xC1
115A  00E4     MOVWF f3
115B  0BE4     DECFSZ f3, F
115C  295B     GOTO 0x15B
115D  0BE5     DECFSZ 0x65, F
115E  295B     GOTO 0x15B
115F  0BE6     DECFSZ 0x66, F
1160  295B     GOTO 0x15B
1161  0000     NOP
91:                __delay_ms(500);
1162  300D     MOVLW 0xD
1163  1683     BSF STATUS, 0x5
1164  1303     BCF STATUS, 0x6
1165  00E6     MOVWF 0x66
1166  30AF     MOVLW 0xAF
1167  00E5     MOVWF 0x65
1168  30C1     MOVLW 0xC1
1169  00E4     MOVWF f3
116A  0BE4     DECFSZ f3, F
116B  296A     GOTO 0x16A
116C  0BE5     DECFSZ 0x65, F
116D  296A     GOTO 0x16A
116E  0BE6     DECFSZ 0x66, F
116F  296A     GOTO 0x16A
1170  0000     NOP
92:                __delay_ms(500);
1171  300D     MOVLW 0xD
1172  1683     BSF STATUS, 0x5
1173  1303     BCF STATUS, 0x6
1174  00E6     MOVWF 0x66
1175  30AF     MOVLW 0xAF
1176  00E5     MOVWF 0x65
1177  30C1     MOVLW 0xC1
1178  00E4     MOVWF f3
1179  0BE4     DECFSZ f3, F
117A  2979     GOTO 0x179
117B  0BE5     DECFSZ 0x65, F
117C  2979     GOTO 0x179
117D  0BE6     DECFSZ 0x66, F
117E  2979     GOTO 0x179
117F  0000     NOP
93:            
94:                fecha.day = 1;
1180  1283     BCF STATUS, 0x5
1181  1303     BCF STATUS, 0x6
1183  01EC     CLRF fecha
1184  0AEC     INCF fecha, F
95:                fecha.month = 1;
1185  01ED     CLRF 0x6D
1186  0AED     INCF 0x6D, F
96:                fecha.yr = 15;
1182  300F     MOVLW 0xF
1187  00EE     MOVWF 0x6E
97:                fecha.dow = 4;
1188  3004     MOVLW 0x4
1189  00EF     MOVWF 0x6F
98:            
99:                isl1208SR.Valor = 0x00;
118A  1683     BSF STATUS, 0x5
118B  01E2     CLRF 0x62
100:               isl1208SR.Valor = ISL1208_Read_status();
118C  120A     BCF PCLATH, 0x4
118D  158A     BSF PCLATH, 0x3
118E  2315     CALL 0x315
118F  160A     BSF PCLATH, 0x4
1190  118A     BCF PCLATH, 0x3
1191  1683     BSF STATUS, 0x5
1192  00E2     MOVWF 0x62
101:               if (isl1208SR.RTCF) {//Si se reseteo el RTC, envio directamente a configurar la hora
1193  120A     BCF PCLATH, 0x4
1194  118A     BCF PCLATH, 0x3
1195  1C62     BTFSS 0x62, 0x0
1196  2835     GOTO 0x35
102:                   isl1208_init();
1197  120A     BCF PCLATH, 0x4
1198  158A     BSF PCLATH, 0x3
1199  21FF     CALL 0x1FF
103:                   menuactual = MENU_CONFIGURAHORARIO;
119A  3003     MOVLW 0x3
119B  00C9     MOVWF f2
104:           
105:               } else {
119C  120A     BCF PCLATH, 0x4
119D  118A     BCF PCLATH, 0x3
119E  284B     GOTO 0x4B
106:           
107:                   lee_y_transmite_date_and_time();
0035  120A     BCF PCLATH, 0x4
0036  158A     BSF PCLATH, 0x3
0037  2207     CALL 0x207
0038  120A     BCF PCLATH, 0x4
0039  118A     BCF PCLATH, 0x3
108:                   isl1208_get_time_enc(&horarioenc.hrs, &horarioenc.min, &horarioenc.sec);
003A  30DF     MOVLW 0xDF
003B  1283     BCF STATUS, 0x5
003C  00A9     MOVWF mth
003D  30DE     MOVLW 0xDE
003E  00AA     MOVWF year
003F  30E0     MOVLW 0xE0
0040  120A     BCF PCLATH, 0x4
0041  158A     BSF PCLATH, 0x3
0042  238B     CALL 0x38B
0043  120A     BCF PCLATH, 0x4
0044  118A     BCF PCLATH, 0x3
109:                   isl1208_get_dow_enc(&fechaenc.dow);
0045  30DA     MOVLW 0xDA
0046  120A     BCF PCLATH, 0x4
0047  158A     BSF PCLATH, 0x3
0048  2330     CALL 0x330
0049  120A     BCF PCLATH, 0x4
004A  118A     BCF PCLATH, 0x3
110:           
111:                   if (isl1208SR.ALM) {
112:                       //TODO se activo la alarma cuando estaba apagado, procesar
113:           
114:                   }
115:               }
116:               // </editor-fold>
117:           
118:               // <editor-fold defaultstate="collapsed" desc="Lectura de datos guardados en EEPROM">
119:               periodoencendido = eeprom_read(0);
004B  3000     MOVLW 0x0
004C  160A     BSF PCLATH, 0x4
004D  158A     BSF PCLATH, 0x3
004E  279D     CALL 0x79D
004F  120A     BCF PCLATH, 0x4
0050  118A     BCF PCLATH, 0x3
0051  1683     BSF STATUS, 0x5
0052  1303     BCF STATUS, 0x6
0053  00EE     MOVWF 0x6E
120:               if (periodoencendido > TIEMPOMAXIMOPERIODO) periodoencendido = 1;
0054  3008     MOVLW 0x8
0055  026E     SUBWF 0x6E, W
0056  1C03     BTFSS STATUS, 0x0
0057  285A     GOTO 0x5A
0058  01EE     CLRF 0x6E
0059  0AEE     INCF 0x6E, F
121:               tiempoencendido = eeprom_read(1);
005A  3001     MOVLW 0x1
005B  160A     BSF PCLATH, 0x4
005C  158A     BSF PCLATH, 0x3
005D  279D     CALL 0x79D
005E  120A     BCF PCLATH, 0x4
005F  118A     BCF PCLATH, 0x3
0060  1683     BSF STATUS, 0x5
0061  1303     BCF STATUS, 0x6
0062  00CC     MOVWF 0x4C
122:               if (tiempoencendido > TIEMPOMAXIMOENCENDIDO) tiempoencendido = 15;
0063  303D     MOVLW 0x3D
0064  024C     SUBWF 0x4C, W
0065  1C03     BTFSS STATUS, 0x0
0066  2869     GOTO 0x69
0067  300F     MOVLW 0xF
0068  00CC     MOVWF 0x4C
123:               usa_falla_de_corriente = eeprom_read(2);
0069  3002     MOVLW 0x2
006A  160A     BSF PCLATH, 0x4
006B  158A     BSF PCLATH, 0x3
006C  279D     CALL 0x79D
006D  120A     BCF PCLATH, 0x4
006E  118A     BCF PCLATH, 0x3
006F  1683     BSF STATUS, 0x5
0070  1303     BCF STATUS, 0x6
0071  00E3     MOVWF 0x63
124:               if (usa_falla_de_corriente > 1) usa_falla_de_corriente = 1;
0072  3002     MOVLW 0x2
0073  0263     SUBWF 0x63, W
0074  1C03     BTFSS STATUS, 0x0
0075  2878     GOTO 0x78
0076  01E3     CLRF 0x63
0077  0AE3     INCF 0x63, F
125:               tiempofalla = eeprom_read(3);
0078  3003     MOVLW 0x3
0079  160A     BSF PCLATH, 0x4
007A  158A     BSF PCLATH, 0x3
007B  279D     CALL 0x79D
007C  120A     BCF PCLATH, 0x4
007D  118A     BCF PCLATH, 0x3
007E  1683     BSF STATUS, 0x5
007F  1303     BCF STATUS, 0x6
0080  00CD     MOVWF 0x4D
126:               if (tiempofalla > TIEMPOMAXIMOFALLA)tiempofalla = 5;
0081  300B     MOVLW 0xB
0082  024D     SUBWF 0x4D, W
0083  1C03     BTFSS STATUS, 0x0
0084  2887     GOTO 0x87
0085  3005     MOVLW 0x5
0086  00CD     MOVWF 0x4D
127:               //si se produjo un error en la EEPROM, asigno valores predefinidos
128:               // </editor-fold>
129:           
130:               // <editor-fold defaultstate="collapsed" desc="Habilita Interrupciones">
131:           
132:               interruptADC_on();
0087  160A     BSF PCLATH, 0x4
0088  158A     BSF PCLATH, 0x3
0089  277B     CALL 0x77B
008A  120A     BCF PCLATH, 0x4
008B  118A     BCF PCLATH, 0x3
133:               INTEDG = 0;
008C  1301     BCF TMR0, 0x6
134:               INTE = 1; // enable_interrupts(int_ext2);
008D  160B     BSF INTCON, 0x4
135:               TMR0IE = 1;
008E  168B     BSF INTCON, 0x5
136:               ADIF = 0;
008F  1283     BCF STATUS, 0x5
0090  130C     BCF PIR1, 0x6
137:               INTF = 0; // borro las banderas de interrupcion
0091  108B     BCF INTCON, 0x1
138:               TMR0IF = 0;
0092  110B     BCF INTCON, 0x2
139:               PEIE = 1;
0093  170B     BSF INTCON, 0x6
140:               ei(); //enable_interrupts(global);
0094  178B     BSF INTCON, 0x7
0095  2C1C     GOTO 0x41C
141:               // </editor-fold>
142:           
143:               while (1) {
144:                   // <editor-fold defaultstate="collapsed" desc="Inicia Procesa los men">
145:           
146:                   ////////////////////////////////////////
147:                   switch (menuactual) {
041C  1683     BSF STATUS, 0x5
041D  1303     BCF STATUS, 0x6
041E  0849     MOVF f2, W
041F  0084     MOVWF FSR
0420  3011     MOVLW 0x11
0421  0204     SUBWF FSR, W
0422  1803     BTFSC STATUS, 0x0
0423  2C2B     GOTO 0x42B
0424  3019     MOVLW 0x19
0425  008A     MOVWF PCLATH
0426  1003     BCF STATUS, 0x0
0427  0D04     RLF FSR, W
0428  0704     ADDWF FSR, W
0429  3E51     ADDLW 0x51
042A  0082     MOVWF PCL
1951  120A     BCF PCLATH, 0x4
1952  118A     BCF PCLATH, 0x3
1953  2896     GOTO 0x96
1954  120A     BCF PCLATH, 0x4
1955  118A     BCF PCLATH, 0x3
1956  28E4     GOTO 0xE4
1957  120A     BCF PCLATH, 0x4
1958  118A     BCF PCLATH, 0x3
1959  2B46     GOTO 0x346
195A  120A     BCF PCLATH, 0x4
195B  118A     BCF PCLATH, 0x3
195C  2930     GOTO 0x130
195D  120A     BCF PCLATH, 0x4
195E  118A     BCF PCLATH, 0x3
195F  293C     GOTO 0x13C
1960  120A     BCF PCLATH, 0x4
1961  118A     BCF PCLATH, 0x3
1962  2967     GOTO 0x167
1963  120A     BCF PCLATH, 0x4
1964  118A     BCF PCLATH, 0x3
1965  298C     GOTO 0x18C
1966  120A     BCF PCLATH, 0x4
1967  118A     BCF PCLATH, 0x3
1968  2998     GOTO 0x198
1969  120A     BCF PCLATH, 0x4
196A  118A     BCF PCLATH, 0x3
196B  29C3     GOTO 0x1C3
196C  120A     BCF PCLATH, 0x4
196D  118A     BCF PCLATH, 0x3
196E  29D5     GOTO 0x1D5
196F  120A     BCF PCLATH, 0x4
1970  118A     BCF PCLATH, 0x3
1971  2A1F     GOTO 0x21F
1972  120A     BCF PCLATH, 0x4
1973  118A     BCF PCLATH, 0x3
1974  2A38     GOTO 0x238
1975  120A     BCF PCLATH, 0x4
1976  118A     BCF PCLATH, 0x3
1977  2A4C     GOTO 0x24C
1978  120A     BCF PCLATH, 0x4
1979  118A     BCF PCLATH, 0x3
197A  2A74     GOTO 0x274
197B  120A     BCF PCLATH, 0x4
197C  118A     BCF PCLATH, 0x3
197D  2AA7     GOTO 0x2A7
197E  120A     BCF PCLATH, 0x4
197F  118A     BCF PCLATH, 0x3
1980  2ADA     GOTO 0x2DA
1981  120A     BCF PCLATH, 0x4
1982  118A     BCF PCLATH, 0x3
1983  2B13     GOTO 0x313
148:                       case MENU_MUESTRAHORA:
149:                       {
150:                           horario = &horarioactual;
0096  30DB     MOVLW 0xDB
0097  00FD     MOVWF horario
151:                           //Se actualiza lo que se muestra en el display, solamente cuando hay cambios en lo que mostrar
152:           
153:                           if (flanco) {
0098  087C     MOVF flanco, W
009A  1903     BTFSC STATUS, 0x2
009B  28C0     GOTO 0xC0
154:                               // lee_y_transmite_date_and_time();
155:                               sprintf(cadenaamostrar, "%02d:%02d   ", horarioactual.hrs, horarioactual.min);
0099  30A6     MOVLW 0xA6
009C  1283     BCF STATUS, 0x5
009D  00C8     MOVWF sp
009E  3001     MOVLW 0x1
009F  00C9     MOVWF f2
00A0  3056     MOVLW 0x56
00A1  00CA     MOVWF f
00A2  3098     MOVLW 0x98
00A3  00CB     MOVWF 0x4B
00A4  1683     BSF STATUS, 0x5
00A5  085D     MOVF 0x5D, W
00A6  1283     BCF STATUS, 0x5
00A7  00CC     MOVWF 0x4C
00A8  01CD     CLRF 0x4D
00A9  1683     BSF STATUS, 0x5
00AA  085C     MOVF f1, W
00AB  1283     BCF STATUS, 0x5
00AC  00CE     MOVWF 0x4E
00AD  01CF     CLRF to
00AE  120A     BCF PCLATH, 0x4
00AF  158A     BSF PCLATH, 0x3
00B0  25B1     CALL 0x5B1
00B1  120A     BCF PCLATH, 0x4
00B2  118A     BCF PCLATH, 0x3
156:                               sprintf(cadenaamostrar2, cadena_esp);
00B3  30CE     MOVLW 0xCE
00B4  00C8     MOVWF sp
00B5  3031     MOVLW 0x31
00B6  01C9     CLRF f2
00B7  00CA     MOVWF f
00B8  3098     MOVLW 0x98
00B9  00CB     MOVWF 0x4B
00BA  120A     BCF PCLATH, 0x4
00BB  158A     BSF PCLATH, 0x3
00BC  25B1     CALL 0x5B1
00BD  120A     BCF PCLATH, 0x4
00BE  118A     BCF PCLATH, 0x3
157:                           } else {
00BF  2C2B     GOTO 0x42B
158:                               sprintf(cadenaamostrar, "%02d %02d   ", horarioactual.hrs, horarioactual.min);
00C0  1283     BCF STATUS, 0x5
00C1  00C8     MOVWF sp
00C2  3001     MOVLW 0x1
00C3  00C9     MOVWF f2
00C4  3049     MOVLW 0x49
00C5  00CA     MOVWF f
00C6  3098     MOVLW 0x98
00C7  00CB     MOVWF 0x4B
00C8  1683     BSF STATUS, 0x5
00C9  085D     MOVF 0x5D, W
00CA  1283     BCF STATUS, 0x5
00CB  00CC     MOVWF 0x4C
00CC  01CD     CLRF 0x4D
00CD  1683     BSF STATUS, 0x5
00CE  085C     MOVF f1, W
00CF  1283     BCF STATUS, 0x5
00D0  00CE     MOVWF 0x4E
00D1  01CF     CLRF to
00D2  120A     BCF PCLATH, 0x4
00D3  158A     BSF PCLATH, 0x3
00D4  25B1     CALL 0x5B1
00D5  120A     BCF PCLATH, 0x4
00D6  118A     BCF PCLATH, 0x3
159:                               sprintf(cadenaamostrar2, cadena_esp);
00D7  30CE     MOVLW 0xCE
00D8  00C8     MOVWF sp
00D9  3031     MOVLW 0x31
00DA  01C9     CLRF f2
00DB  00CA     MOVWF f
00DC  3098     MOVLW 0x98
00DD  00CB     MOVWF 0x4B
00DE  120A     BCF PCLATH, 0x4
00DF  158A     BSF PCLATH, 0x3
00E0  25B1     CALL 0x5B1
00E1  120A     BCF PCLATH, 0x4
00E2  118A     BCF PCLATH, 0x3
00E3  2C2B     GOTO 0x42B
160:                           }
161:                           break;
162:                       }
163:                       case MENU_MUESTRAFECHA:
164:                       {
165:           
166:                           if (flanco) {
00E4  087C     MOVF flanco, W
00E5  1903     BTFSC STATUS, 0x2
00E6  2C2B     GOTO 0x42B
167:                               //lee_y_transmite_date_and_time();
168:                               sprintf(cadenaamostrar, "%02d/%02d/%02d", fecha.day, fecha.month, fecha.yr);
00E7  30A6     MOVLW 0xA6
00E8  1283     BCF STATUS, 0x5
00E9  00C8     MOVWF sp
00EA  3001     MOVLW 0x1
00EB  00C9     MOVWF f2
00EC  303A     MOVLW 0x3A
00ED  00CA     MOVWF f
00EE  3098     MOVLW 0x98
00EF  00CB     MOVWF 0x4B
00F0  086C     MOVF fecha, W
00F1  00CC     MOVWF 0x4C
00F2  01CD     CLRF 0x4D
00F3  086D     MOVF 0x6D, W
00F4  00CE     MOVWF 0x4E
00F5  01CF     CLRF to
00F6  086E     MOVF 0x6E, W
00F7  00D0     MOVWF cp
00F8  01D1     CLRF exp
00F9  120A     BCF PCLATH, 0x4
00FA  158A     BSF PCLATH, 0x3
00FB  25B1     CALL 0x5B1
00FC  120A     BCF PCLATH, 0x4
00FD  118A     BCF PCLATH, 0x3
169:                               sprintf(cadenaamostrar2, cadena_esp);
00FE  30CE     MOVLW 0xCE
00FF  00C8     MOVWF sp
0100  3031     MOVLW 0x31
0101  01C9     CLRF f2
0102  00CA     MOVWF f
0103  3098     MOVLW 0x98
0104  00CB     MOVWF 0x4B
0105  120A     BCF PCLATH, 0x4
0106  158A     BSF PCLATH, 0x3
0107  25B1     CALL 0x5B1
0108  120A     BCF PCLATH, 0x4
0109  118A     BCF PCLATH, 0x3
170:                               strncpy(cadenaamostrar2, days_of_week[dia_de_la_semana(&fecha.day, &fecha.month, &fecha.yr)], 2);
010A  306E     MOVLW 0x6E
010B  00B9     MOVWF anio
010C  306D     MOVLW 0x6D
010D  00B8     MOVWF mes
010E  306C     MOVLW 0x6C
010F  120A     BCF PCLATH, 0x4
0110  158A     BSF PCLATH, 0x3
0111  2219     CALL 0x219
0112  120A     BCF PCLATH, 0x4
0113  118A     BCF PCLATH, 0x3
0114  1683     BSF STATUS, 0x5
0115  00EB     MOVWF maximodia
0116  3003     MOVLW 0x3
0117  1283     BCF STATUS, 0x5
0118  00A4     MOVWF x
0119  1683     BSF STATUS, 0x5
011A  086B     MOVF maximodia, W
011B  120A     BCF PCLATH, 0x4
011C  158A     BSF PCLATH, 0x3
011D  2549     CALL 0x549
011E  120A     BCF PCLATH, 0x4
011F  118A     BCF PCLATH, 0x3
0120  3E1C     ADDLW 0x1C
0121  00C8     MOVWF sp
0122  3098     MOVLW 0x98
0123  1803     BTFSC STATUS, 0x0
0124  3E01     ADDLW 0x1
0125  00C9     MOVWF f2
0126  3002     MOVLW 0x2
0127  00CA     MOVWF f
0128  30CE     MOVLW 0xCE
0129  01CB     CLRF 0x4B
012A  160A     BSF PCLATH, 0x4
012B  118A     BCF PCLATH, 0x3
012C  2012     CALL 0x12
012D  120A     BCF PCLATH, 0x4
012E  118A     BCF PCLATH, 0x3
012F  2C1A     GOTO 0x41A
171:                           }
172:           
173:           
174:                           break;
175:                       }
176:                       case MENU_CONFIGURAHORARIO:
177:                       {
178:           
179:                           if (flanco) {
0130  087C     MOVF flanco, W
0131  1903     BTFSC STATUS, 0x2
0132  2C2B     GOTO 0x42B
180:                               sprintf(cadenaamostrar, "SET HORA");
0133  30A6     MOVLW 0xA6
0134  1283     BCF STATUS, 0x5
0135  00C8     MOVWF sp
0136  3001     MOVLW 0x1
0137  00C9     MOVWF f2
0138  30F8     MOVLW 0xF8
0139  00CA     MOVWF f
013A  3098     MOVLW 0x98
013B  2A2A     GOTO 0x22A
181:                               sprintf(cadenaamostrar2, cadena_esp);
182:                           }
183:           
184:                           break;
185:                       }
186:                       case SUBMENU_CONFIGURAHORA:
187:                       {
188:                           modificafecha = HORA;
013C  30DB     MOVLW 0xDB
013D  01ED     CLRF 0x6D
189:                           horario = &horarioactual;
013C  30DB     MOVLW 0xDB
013E  00FD     MOVWF horario
190:                           if (flanco || haycambio) {
013F  08FC     MOVF flanco, F
0140  1903     BTFSC STATUS, 0x2
0141  0846     MOVF dia, W
0143  1D03     BTFSS STATUS, 0x2
191:                               sprintf(cadenaamostrar, "%02d:%02d   ", horarioactual.hrs, horarioactual.min);
0144  2971     GOTO 0x171
192:                               sprintf(cadenaamostrar2, cadena_esp);
193:                               //haycambio = 0;
194:                           } else {
195:                               sprintf(cadenaamostrar, "  :%02d   ", horarioactual.min);
0142  30A6     MOVLW 0xA6
0145  1283     BCF STATUS, 0x5
0146  00C8     MOVWF sp
0147  3001     MOVLW 0x1
0148  00C9     MOVWF f2
0149  30A0     MOVLW 0xA0
014A  00CA     MOVWF f
014B  3098     MOVLW 0x98
014C  00CB     MOVWF 0x4B
014D  1683     BSF STATUS, 0x5
014E  085C     MOVF f1, W
014F  1283     BCF STATUS, 0x5
0150  00CC     MOVWF 0x4C
0151  01CD     CLRF 0x4D
0152  120A     BCF PCLATH, 0x4
0153  158A     BSF PCLATH, 0x3
0154  25B1     CALL 0x5B1
0155  120A     BCF PCLATH, 0x4
0156  118A     BCF PCLATH, 0x3
196:                               sprintf(cadenaamostrar2, cadena_esp);
0157  30CE     MOVLW 0xCE
0158  00C8     MOVWF sp
0159  3031     MOVLW 0x31
015A  01C9     CLRF f2
015B  00CA     MOVWF f
015C  3098     MOVLW 0x98
015D  00CB     MOVWF 0x4B
015E  120A     BCF PCLATH, 0x4
015F  158A     BSF PCLATH, 0x3
0160  25B1     CALL 0x5B1
0161  120A     BCF PCLATH, 0x4
0162  118A     BCF PCLATH, 0x3
197:                           }
198:                           bandera_graba_hora = 1;
0163  1683     BSF STATUS, 0x5
0164  01B2     CLRF divisor
0165  0AB2     INCF divisor, F
199:                           break;
0166  2C2B     GOTO 0x42B
200:                       }
201:                       case SUBMENU_CONFIGURAMINUTOS:
0167  30DB     MOVLW 0xDB
202:                       {
203:                           modificafecha = MINUTOS;
0168  01ED     CLRF 0x6D
0169  0AED     INCF 0x6D, F
204:                           horario = &horarioactual;
0167  30DB     MOVLW 0xDB
016A  00FD     MOVWF horario
205:                           if (flanco || haycambio) {
016B  08FC     MOVF flanco, F
016C  1903     BTFSC STATUS, 0x2
016D  0846     MOVF dia, W
016F  1903     BTFSC STATUS, 0x2
0170  2981     GOTO 0x181
206:                               sprintf(cadenaamostrar, "%02d:%02d   ", horarioactual.hrs, horarioactual.min);
016E  30A6     MOVLW 0xA6
0171  1283     BCF STATUS, 0x5
0172  00C8     MOVWF sp
0173  3001     MOVLW 0x1
0174  00C9     MOVWF f2
0175  3056     MOVLW 0x56
0176  00CA     MOVWF f
0177  3098     MOVLW 0x98
0178  00CB     MOVWF 0x4B
0179  1683     BSF STATUS, 0x5
017A  085D     MOVF 0x5D, W
017B  1283     BCF STATUS, 0x5
017C  00CC     MOVWF 0x4C
017D  01CD     CLRF 0x4D
017E  1683     BSF STATUS, 0x5
017F  085C     MOVF f1, W
0180  2A65     GOTO 0x265
207:                               sprintf(cadenaamostrar2, cadena_esp);
208:                               //haycambio = 0;
209:                           } else {
210:                               sprintf(cadenaamostrar, "%02d:     ", horarioactual.hrs);
0181  1283     BCF STATUS, 0x5
0182  00C8     MOVWF sp
0183  3001     MOVLW 0x1
0184  00C9     MOVWF f2
0185  308A     MOVLW 0x8A
0186  00CA     MOVWF f
0187  3098     MOVLW 0x98
0188  00CB     MOVWF 0x4B
0189  1683     BSF STATUS, 0x5
018A  085D     MOVF 0x5D, W
018B  294F     GOTO 0x14F
211:                               sprintf(cadenaamostrar2, cadena_esp);
212:                           }
213:                           bandera_graba_hora = 1;
214:                           break;
215:                       }
216:                       case MENU_CONFIGURAFECHA:
217:                       {
218:           
219:                           if (flanco) {
018C  087C     MOVF flanco, W
018D  1903     BTFSC STATUS, 0x2
018E  2C2B     GOTO 0x42B
220:                               sprintf(cadenaamostrar, "SET FECH");
018F  30A6     MOVLW 0xA6
0190  1283     BCF STATUS, 0x5
0191  00C8     MOVWF sp
0192  3001     MOVLW 0x1
0193  00C9     MOVWF f2
0194  3001     MOVLW 0x1
0195  00CA     MOVWF f
0196  3099     MOVLW 0x99
0197  2A2A     GOTO 0x22A
221:                               sprintf(cadenaamostrar2, cadena_esp);
222:                           }
223:                           break;
224:                       }
225:                       case SUBMENU_CONFIGURADIA:
226:                       {
227:                           modificafecha = DIA;
0198  3002     MOVLW 0x2
0199  00ED     MOVWF 0x6D
228:           
229:                           if (flanco || haycambio) {
019A  08FC     MOVF flanco, F
019B  1903     BTFSC STATUS, 0x2
019C  0846     MOVF dia, W
019E  1D03     BTFSS STATUS, 0x2
019F  29DD     GOTO 0x1DD
230:                               sprintf(cadenaamostrar, "%02d/%02d/%02d", fecha.day, fecha.month, fecha.yr);
231:                               sprintf(cadenaamostrar2, days_of_week[dia_de_la_semana(&fecha.day, &fecha.month, &fecha.yr)]);
232:                               //sprintf(cadenaamostrar2, "             ");
233:                               //haycambio = 0;
234:                           } else {
235:                               sprintf(cadenaamostrar, "  /%02d/%02d", fecha.month, fecha.yr);
019D  30A6     MOVLW 0xA6
01A0  1283     BCF STATUS, 0x5
01A1  00C8     MOVWF sp
01A2  3001     MOVLW 0x1
01A3  00C9     MOVWF f2
01A4  307D     MOVLW 0x7D
01A5  00CA     MOVWF f
01A6  3098     MOVLW 0x98
01A7  00CB     MOVWF 0x4B
01A8  086D     MOVF 0x6D, W
01A9  00CC     MOVWF 0x4C
01AA  01CD     CLRF 0x4D
01AB  086E     MOVF 0x6E, W
01AC  00CE     MOVWF 0x4E
01AD  01CF     CLRF to
01AE  120A     BCF PCLATH, 0x4
01AF  158A     BSF PCLATH, 0x3
01B0  25B1     CALL 0x5B1
01B1  120A     BCF PCLATH, 0x4
01B2  118A     BCF PCLATH, 0x3
236:                               sprintf(cadenaamostrar2, cadena_esp);
01B3  30CE     MOVLW 0xCE
01B4  00C8     MOVWF sp
01B5  3031     MOVLW 0x31
01B6  01C9     CLRF f2
01B7  00CA     MOVWF f
01B8  3098     MOVLW 0x98
01B9  00CB     MOVWF 0x4B
01BA  120A     BCF PCLATH, 0x4
01BB  158A     BSF PCLATH, 0x3
01BC  25B1     CALL 0x5B1
01BD  120A     BCF PCLATH, 0x4
01BE  118A     BCF PCLATH, 0x3
237:                           }
238:                           bandera_graba_fecha = 1;
01BF  1683     BSF STATUS, 0x5
01C0  01B0     CLRF quotient
01C1  0AB0     INCF quotient, F
239:                           break;
01C2  2C2B     GOTO 0x42B
240:                       }
241:                       case SUBMENU_CONFIGURAMES:
242:                       {
243:                           modificafecha = MES;
01C3  3003     MOVLW 0x3
01C4  00ED     MOVWF 0x6D
244:           
245:                           if (flanco || haycambio) {
01C5  08FC     MOVF flanco, F
01C6  1903     BTFSC STATUS, 0x2
01C7  0846     MOVF dia, W
01C9  1D03     BTFSS STATUS, 0x2
01CA  29DD     GOTO 0x1DD
246:                               sprintf(cadenaamostrar, "%02d/%02d/%02d", fecha.day, fecha.month, fecha.yr);
247:                               sprintf(cadenaamostrar2, days_of_week[dia_de_la_semana(&fecha.day, &fecha.month, &fecha.yr)]);
248:                               //haycambio = 0;
249:                           } else {
250:                               sprintf(cadenaamostrar, "%02d/  /%02d", fecha.day, fecha.yr);
01C8  30A6     MOVLW 0xA6
01CB  1283     BCF STATUS, 0x5
01CC  00C8     MOVWF sp
01CD  3001     MOVLW 0x1
01CE  00C9     MOVWF f2
01CF  3070     MOVLW 0x70
01D0  00CA     MOVWF f
01D1  3098     MOVLW 0x98
01D2  00CB     MOVWF 0x4B
01D3  086C     MOVF fecha, W
01D4  29A9     GOTO 0x1A9
251:                               sprintf(cadenaamostrar2, cadena_esp);
252:                           }
253:                           bandera_graba_fecha = 1;
254:                           break;
255:                       }
256:                       case SUBMENU_CONFIGURAANIO:
257:                       {
258:                           modificafecha = ANIO;
01D5  3004     MOVLW 0x4
01D6  00ED     MOVWF 0x6D
259:           
260:                           if (flanco || haycambio) {
01D7  08FC     MOVF flanco, F
01D8  1903     BTFSC STATUS, 0x2
01D9  0846     MOVF dia, W
01DB  1903     BTFSC STATUS, 0x2
01DC  2A12     GOTO 0x212
261:                               sprintf(cadenaamostrar, "%02d/%02d/%02d", fecha.day, fecha.month, fecha.yr);
01DA  30A6     MOVLW 0xA6
01DD  1283     BCF STATUS, 0x5
01DE  00C8     MOVWF sp
01DF  3001     MOVLW 0x1
01E0  00C9     MOVWF f2
01E1  303A     MOVLW 0x3A
01E2  00CA     MOVWF f
01E3  3098     MOVLW 0x98
01E4  00CB     MOVWF 0x4B
01E5  086C     MOVF fecha, W
01E6  00CC     MOVWF 0x4C
01E7  01CD     CLRF 0x4D
01E8  086D     MOVF 0x6D, W
01E9  00CE     MOVWF 0x4E
01EA  01CF     CLRF to
01EB  086E     MOVF 0x6E, W
01EC  00D0     MOVWF cp
01ED  01D1     CLRF exp
01EE  120A     BCF PCLATH, 0x4
01EF  158A     BSF PCLATH, 0x3
01F0  25B1     CALL 0x5B1
01F1  120A     BCF PCLATH, 0x4
01F2  118A     BCF PCLATH, 0x3
262:                               sprintf(cadenaamostrar2, days_of_week[dia_de_la_semana(&fecha.day, &fecha.month, &fecha.yr)]);
01F3  306E     MOVLW 0x6E
01F4  00B9     MOVWF anio
01F5  306D     MOVLW 0x6D
01F6  00B8     MOVWF mes
01F7  306C     MOVLW 0x6C
01F8  120A     BCF PCLATH, 0x4
01F9  158A     BSF PCLATH, 0x3
01FA  2219     CALL 0x219
01FB  120A     BCF PCLATH, 0x4
01FC  118A     BCF PCLATH, 0x3
01FD  1683     BSF STATUS, 0x5
01FE  00EB     MOVWF maximodia
01FF  30CE     MOVLW 0xCE
0200  1283     BCF STATUS, 0x5
0201  00C8     MOVWF sp
0202  3003     MOVLW 0x3
0203  01C9     CLRF f2
0204  00A4     MOVWF x
0205  1683     BSF STATUS, 0x5
0206  086B     MOVF maximodia, W
0207  120A     BCF PCLATH, 0x4
0208  158A     BSF PCLATH, 0x3
0209  2549     CALL 0x549
020A  120A     BCF PCLATH, 0x4
020B  118A     BCF PCLATH, 0x3
020C  3E1C     ADDLW 0x1C
020D  00CA     MOVWF f
020E  3098     MOVLW 0x98
020F  1803     BTFSC STATUS, 0x0
0210  3E01     ADDLW 0x1
0211  29B9     GOTO 0x1B9
263:                               //haycambio = 0;
264:                           } else {
265:                               sprintf(cadenaamostrar, "%02d/%02d/  ", fecha.day, fecha.month);
0212  1283     BCF STATUS, 0x5
0213  00C8     MOVWF sp
0214  3001     MOVLW 0x1
0215  00C9     MOVWF f2
0216  3063     MOVLW 0x63
0217  00CA     MOVWF f
0218  3098     MOVLW 0x98
0219  00CB     MOVWF 0x4B
021A  086C     MOVF fecha, W
021B  00CC     MOVWF 0x4C
021C  01CD     CLRF 0x4D
021D  086D     MOVF 0x6D, W
021E  29AC     GOTO 0x1AC
266:                               sprintf(cadenaamostrar2, cadena_esp);
267:                           }
268:                           bandera_graba_fecha = 1;
269:                           break;
270:                       }
271:                       case MENU_CONFIGURAENCENDIDO:
272:                       {
273:           
274:                           if (flanco) {
021F  087C     MOVF flanco, W
0220  1903     BTFSC STATUS, 0x2
0221  2C2B     GOTO 0x42B
275:                               sprintf(cadenaamostrar, "SET ENC ");
0222  30A6     MOVLW 0xA6
0223  1283     BCF STATUS, 0x5
0224  00C8     MOVWF sp
0225  3001     MOVLW 0x1
0226  00C9     MOVWF f2
0227  30EF     MOVLW 0xEF
0228  00CA     MOVWF f
0229  3098     MOVLW 0x98
022A  00CB     MOVWF 0x4B
022B  120A     BCF PCLATH, 0x4
022C  158A     BSF PCLATH, 0x3
022D  25B1     CALL 0x5B1
022E  120A     BCF PCLATH, 0x4
022F  118A     BCF PCLATH, 0x3
276:                               sprintf(cadenaamostrar2, cadena_esp);
0230  30CE     MOVLW 0xCE
0231  00C8     MOVWF sp
0232  3031     MOVLW 0x31
0233  01C9     CLRF f2
0234  00CA     MOVWF f
0235  3098     MOVLW 0x98
0236  00CB     MOVWF 0x4B
0237  2C15     GOTO 0x415
277:                           }
278:           
279:                           break;
280:                       }
281:                       case SUBMENU_CONFIGURAHORAENCENDIDO:
282:                       {
283:                           modificafecha = HORA;
0238  30DE     MOVLW 0xDE
0239  01ED     CLRF 0x6D
284:                           horario = &horarioenc;
0238  30DE     MOVLW 0xDE
023A  00FD     MOVWF horario
285:                           if (flanco || haycambio) {
023B  08FC     MOVF flanco, F
023C  1903     BTFSC STATUS, 0x2
023D  0846     MOVF dia, W
023F  1D03     BTFSS STATUS, 0x2
0240  2A56     GOTO 0x256
286:                               sprintf(cadenaamostrar, "%02d:%02d   ", horarioenc.hrs, horarioenc.min);
287:                               sprintf(cadenaamostrar2, cadena_esp);
288:                               //haycambio = 0;
289:                           } else {
290:                               sprintf(cadenaamostrar, "  :%02d   ", horarioenc.min);
023E  30A6     MOVLW 0xA6
0241  1283     BCF STATUS, 0x5
0242  00C8     MOVWF sp
0243  3001     MOVLW 0x1
0244  00C9     MOVWF f2
0245  30A0     MOVLW 0xA0
0246  00CA     MOVWF f
0247  3098     MOVLW 0x98
0248  00CB     MOVWF 0x4B
0249  1683     BSF STATUS, 0x5
024A  085F     MOVF 0x5F, W
024B  294F     GOTO 0x14F
291:                               sprintf(cadenaamostrar2, cadena_esp);
292:                           }
293:                           bandera_graba_hora = 1;
294:                           break;
295:                       }
296:                       case SUBMENU_CONFIGURAMINUTOSENCENDIDO:
024C  30DE     MOVLW 0xDE
297:                       {
298:                           modificafecha = MINUTOS;
024D  01ED     CLRF 0x6D
024E  0AED     INCF 0x6D, F
299:                           horario = &horarioenc;
024C  30DE     MOVLW 0xDE
024F  00FD     MOVWF horario
300:                           if (flanco || haycambio) {
0250  08FC     MOVF flanco, F
0251  1903     BTFSC STATUS, 0x2
0252  0846     MOVF dia, W
0254  1903     BTFSC STATUS, 0x2
0255  2A69     GOTO 0x269
301:                               sprintf(cadenaamostrar, "%02d:%02d   ", horarioenc.hrs, horarioenc.min);
0253  30A6     MOVLW 0xA6
0256  1283     BCF STATUS, 0x5
0257  00C8     MOVWF sp
0258  3001     MOVLW 0x1
0259  00C9     MOVWF f2
025A  3056     MOVLW 0x56
025B  00CA     MOVWF f
025C  3098     MOVLW 0x98
025D  00CB     MOVWF 0x4B
025E  1683     BSF STATUS, 0x5
025F  0860     MOVF 0x60, W
0260  1283     BCF STATUS, 0x5
0261  00CC     MOVWF 0x4C
0262  01CD     CLRF 0x4D
0263  1683     BSF STATUS, 0x5
0264  085F     MOVF 0x5F, W
0265  1283     BCF STATUS, 0x5
0266  00CE     MOVWF 0x4E
0267  01CF     CLRF to
0268  2952     GOTO 0x152
302:                               sprintf(cadenaamostrar2, cadena_esp);
303:                               //haycambio = 0;
304:                           } else {
305:                               sprintf(cadenaamostrar, "%02d:     ", horarioenc.hrs);
0269  1283     BCF STATUS, 0x5
026A  00C8     MOVWF sp
026B  3001     MOVLW 0x1
026C  00C9     MOVWF f2
026D  308A     MOVLW 0x8A
026E  00CA     MOVWF f
026F  3098     MOVLW 0x98
0270  00CB     MOVWF 0x4B
0271  1683     BSF STATUS, 0x5
0272  0860     MOVF 0x60, W
0273  294F     GOTO 0x14F
306:                               sprintf(cadenaamostrar2, cadena_esp);
307:                           }
308:                           bandera_graba_hora = 1;
309:                           break;
310:                       }
311:                       case SUBMENU_CONFIGURAPERIODOENCENDIDO:
312:                       {
313:                           modificafecha = PERIODOENCENDIDO;
0274  3009     MOVLW 0x9
0275  00ED     MOVWF 0x6D
314:           
315:                           if (flanco || haycambio) {
0276  08FC     MOVF flanco, F
0277  1903     BTFSC STATUS, 0x2
0278  0846     MOVF dia, W
027A  1903     BTFSC STATUS, 0x2
027B  2A8A     GOTO 0x28A
316:                               sprintf(cadenaamostrar, "c/%u dias", periodoencendido);
0279  30A6     MOVLW 0xA6
027C  1283     BCF STATUS, 0x5
027D  00C8     MOVWF sp
027E  3001     MOVLW 0x1
027F  00C9     MOVWF f2
0280  30C1     MOVLW 0xC1
0281  00CA     MOVWF f
0282  3098     MOVLW 0x98
0283  00CB     MOVWF 0x4B
0284  1683     BSF STATUS, 0x5
0285  086E     MOVF 0x6E, W
0286  1283     BCF STATUS, 0x5
0287  00CC     MOVWF 0x4C
0288  01CD     CLRF 0x4D
0289  2A92     GOTO 0x292
317:                               sprintf(cadenaamostrar2, cadena_esp);
318:                               //haycambio = 0;
319:                           } else {
320:                               sprintf(cadenaamostrar, "c/  dias");
028A  1283     BCF STATUS, 0x5
028B  00C8     MOVWF sp
028C  3001     MOVLW 0x1
028D  00C9     MOVWF f2
028E  3037     MOVLW 0x37
028F  00CA     MOVWF f
0290  3099     MOVLW 0x99
0291  00CB     MOVWF 0x4B
0292  120A     BCF PCLATH, 0x4
0293  158A     BSF PCLATH, 0x3
0294  25B1     CALL 0x5B1
0295  120A     BCF PCLATH, 0x4
0296  118A     BCF PCLATH, 0x3
321:                               sprintf(cadenaamostrar2, cadena_esp);
0297  30CE     MOVLW 0xCE
0298  00C8     MOVWF sp
0299  3031     MOVLW 0x31
029A  01C9     CLRF f2
029B  00CA     MOVWF f
029C  3098     MOVLW 0x98
029D  00CB     MOVWF 0x4B
029E  120A     BCF PCLATH, 0x4
029F  158A     BSF PCLATH, 0x3
02A0  25B1     CALL 0x5B1
02A1  120A     BCF PCLATH, 0x4
02A2  118A     BCF PCLATH, 0x3
322:                           }
323:                           bandera_graba_periodoencendido = 1;
02A3  1683     BSF STATUS, 0x5
02A4  01B3     CLRF 0x33
02A5  0AB3     INCF 0x33, F
324:                           break;
02A6  2C2B     GOTO 0x42B
325:                       }
326:           
327:                       case SUBMENU_CONFIGURATIEMPOENCENDIDO:
328:                       {
329:                           modificafecha = TIEMPOENCENDIDO;
02A7  3007     MOVLW 0x7
02A8  00ED     MOVWF 0x6D
330:           
331:                           if (flanco || haycambio) {
02A9  08FC     MOVF flanco, F
02AA  1903     BTFSC STATUS, 0x2
02AB  0846     MOVF dia, W
02AD  1903     BTFSC STATUS, 0x2
02AE  2ABD     GOTO 0x2BD
332:                               sprintf(cadenaamostrar, "ENCEN:%02d", tiempoencendido);
02AC  30A6     MOVLW 0xA6
02AF  1283     BCF STATUS, 0x5
02B0  00C8     MOVWF sp
02B1  3001     MOVLW 0x1
02B2  00C9     MOVWF f2
02B3  30B6     MOVLW 0xB6
02B4  00CA     MOVWF f
02B5  3098     MOVLW 0x98
02B6  00CB     MOVWF 0x4B
02B7  1683     BSF STATUS, 0x5
02B8  084C     MOVF 0x4C, W
02B9  1283     BCF STATUS, 0x5
02BA  00CC     MOVWF 0x4C
02BB  01CD     CLRF 0x4D
02BC  2AC5     GOTO 0x2C5
333:                               sprintf(cadenaamostrar2, cadena_esp);
334:                               //haycambio = 0;
335:                           } else {
336:                               sprintf(cadenaamostrar, "ENCEN:  ");
02BD  1283     BCF STATUS, 0x5
02BE  00C8     MOVWF sp
02BF  3001     MOVLW 0x1
02C0  00C9     MOVWF f2
02C1  30E6     MOVLW 0xE6
02C2  00CA     MOVWF f
02C3  3098     MOVLW 0x98
02C4  00CB     MOVWF 0x4B
02C5  120A     BCF PCLATH, 0x4
02C6  158A     BSF PCLATH, 0x3
02C7  25B1     CALL 0x5B1
02C8  120A     BCF PCLATH, 0x4
02C9  118A     BCF PCLATH, 0x3
337:                               sprintf(cadenaamostrar2, cadena_esp);
02CA  30CE     MOVLW 0xCE
02CB  00C8     MOVWF sp
02CC  3031     MOVLW 0x31
02CD  01C9     CLRF f2
02CE  00CA     MOVWF f
02CF  3098     MOVLW 0x98
02D0  00CB     MOVWF 0x4B
02D1  120A     BCF PCLATH, 0x4
02D2  158A     BSF PCLATH, 0x3
02D3  25B1     CALL 0x5B1
02D4  120A     BCF PCLATH, 0x4
02D5  118A     BCF PCLATH, 0x3
338:                           }
339:                           bandera_graba_tiempoencendido = 1;
02D6  1683     BSF STATUS, 0x5
02D7  01B4     CLRF dividend
02D8  0AB4     INCF dividend, F
340:                           break;
02D9  2C2B     GOTO 0x42B
341:                       }
342:                       case MENU_CONFIGURAFALLACORRIENTE:
343:                       {
344:                           modificafecha = SINO;
02DA  3006     MOVLW 0x6
02DB  00ED     MOVWF 0x6D
345:                           banderasino = &usa_falla_de_corriente;
02DC  30E3     MOVLW 0xE3
02DD  00B9     MOVWF anio
346:                           if (flanco)
02DE  087C     MOVF flanco, W
02DF  1903     BTFSC STATUS, 0x2
02E0  2AF5     GOTO 0x2F5
347:                               if (usa_falla_de_corriente) {
02E1  0863     MOVF 0x63, W
02E3  1903     BTFSC STATUS, 0x2
02E4  2AED     GOTO 0x2ED
348:                                   sprintf(cadenaamostrar, "FC:   SI");
02E2  30A6     MOVLW 0xA6
02E5  1283     BCF STATUS, 0x5
02E6  00C8     MOVWF sp
02E7  3001     MOVLW 0x1
02E8  00C9     MOVWF f2
02E9  300A     MOVLW 0xA
02EA  00CA     MOVWF f
02EB  3099     MOVLW 0x99
02EC  2AFD     GOTO 0x2FD
349:                                   sprintf(cadenaamostrar2, cadena_esp);
350:                               } else {
351:                                   sprintf(cadenaamostrar, "FC:   NO");
02ED  1283     BCF STATUS, 0x5
02EE  00C8     MOVWF sp
02EF  3001     MOVLW 0x1
02F0  00C9     MOVWF f2
02F1  3013     MOVLW 0x13
02F2  00CA     MOVWF f
02F3  3099     MOVLW 0x99
02F4  2AFD     GOTO 0x2FD
352:                                   sprintf(cadenaamostrar2, cadena_esp);
353:                               } else {
354:                               sprintf(cadenaamostrar, "FC:     ");
02F5  30A6     MOVLW 0xA6
02F6  1283     BCF STATUS, 0x5
02F7  00C8     MOVWF sp
02F8  3001     MOVLW 0x1
02F9  00C9     MOVWF f2
02FA  30CB     MOVLW 0xCB
02FB  00CA     MOVWF f
02FC  3098     MOVLW 0x98
02FD  00CB     MOVWF 0x4B
02FE  120A     BCF PCLATH, 0x4
02FF  158A     BSF PCLATH, 0x3
0300  25B1     CALL 0x5B1
0301  120A     BCF PCLATH, 0x4
0302  118A     BCF PCLATH, 0x3
355:                               sprintf(cadenaamostrar2, cadena_esp);
0303  30CE     MOVLW 0xCE
0304  00C8     MOVWF sp
0305  3031     MOVLW 0x31
0306  01C9     CLRF f2
0307  00CA     MOVWF f
0308  3098     MOVLW 0x98
0309  00CB     MOVWF 0x4B
030A  120A     BCF PCLATH, 0x4
030B  158A     BSF PCLATH, 0x3
030C  25B1     CALL 0x5B1
030D  120A     BCF PCLATH, 0x4
030E  118A     BCF PCLATH, 0x3
356:                           }
357:                           bandera_graba_usa_falla_de_corriente = 1;
030F  1683     BSF STATUS, 0x5
0310  01B6     CLRF counter
0311  0AB6     INCF counter, F
358:                           break;
0312  2C2B     GOTO 0x42B
359:                       }
360:                       case MENU_CONFIGURATIEMPOFALLACORRIENTE:
361:                       {
362:                           modificafecha = TIEMPOFALLA;
0313  3008     MOVLW 0x8
0314  00ED     MOVWF 0x6D
363:           
364:                           if (flanco || haycambio) {
0315  08FC     MOVF flanco, F
0316  1903     BTFSC STATUS, 0x2
0317  0846     MOVF dia, W
0319  1903     BTFSC STATUS, 0x2
031A  2B29     GOTO 0x329
365:                               sprintf(cadenaamostrar, "TFC:  %02d", tiempofalla);
0318  30A6     MOVLW 0xA6
031B  1283     BCF STATUS, 0x5
031C  00C8     MOVWF sp
031D  3001     MOVLW 0x1
031E  00C9     MOVWF f2
031F  30AB     MOVLW 0xAB
0320  00CA     MOVWF f
0321  3098     MOVLW 0x98
0322  00CB     MOVWF 0x4B
0323  1683     BSF STATUS, 0x5
0324  084D     MOVF 0x4D, W
0325  1283     BCF STATUS, 0x5
0326  00CC     MOVWF 0x4C
0327  01CD     CLRF 0x4D
0328  2B31     GOTO 0x331
366:                               sprintf(cadenaamostrar2, cadena_esp);
367:                               //haycambio = 0;
368:                           } else {
369:                               sprintf(cadenaamostrar, "TFC:    ");
0329  1283     BCF STATUS, 0x5
032A  00C8     MOVWF sp
032B  3001     MOVLW 0x1
032C  00C9     MOVWF f2
032D  30D4     MOVLW 0xD4
032E  00CA     MOVWF f
032F  3098     MOVLW 0x98
0330  00CB     MOVWF 0x4B
0331  120A     BCF PCLATH, 0x4
0332  158A     BSF PCLATH, 0x3
0333  25B1     CALL 0x5B1
0334  120A     BCF PCLATH, 0x4
0335  118A     BCF PCLATH, 0x3
370:                               sprintf(cadenaamostrar2, cadena_esp);
0336  30CE     MOVLW 0xCE
0337  00C8     MOVWF sp
0338  3031     MOVLW 0x31
0339  01C9     CLRF f2
033A  00CA     MOVWF f
033B  3098     MOVLW 0x98
033C  00CB     MOVWF 0x4B
033D  120A     BCF PCLATH, 0x4
033E  158A     BSF PCLATH, 0x3
033F  25B1     CALL 0x5B1
0340  120A     BCF PCLATH, 0x4
0341  118A     BCF PCLATH, 0x3
371:                           }
372:                           bandera_graba_tiempofalla = 1;
0342  1683     BSF STATUS, 0x5
0343  01B5     CLRF 0x35
0344  0AB5     INCF 0x35, F
373:                           break;
0345  2C2B     GOTO 0x42B
374:                       }
375:           
376:                       case MENU_MUESTRAMEDICIONES:
377:                       {
378:                           //convierto el valor decimal a float
379:                           //para una entrada de 3.3V la lectura es 1023
380:                           //para 0 V la lectura es 0
381:                           //para una maxima lectura quiero que en el display se observe 50A
382:                           //Deseo que tambien me muestre 1 decimal, separo la parte entera y la decimal
383:                           //como la resolucion es 1024, cada bit corresponde a 50A/1024=0.048828125A
384:                           //cada 20 muestras tengo aproximdamente 1A
385:           
386:                           adcenteroI = (unsigned int) mediciondecorriente;
0346  0823     MOVF 0x23, W
0347  1283     BCF STATUS, 0x5
0348  00A7     MOVWF x
0349  1683     BSF STATUS, 0x5
034A  0822     MOVF 0x22, W
034B  1283     BCF STATUS, 0x5
034C  00A6     MOVWF y
034D  1683     BSF STATUS, 0x5
034E  0821     MOVF 0x21, W
034F  1283     BCF STATUS, 0x5
0350  00A5     MOVWF dato
0351  1683     BSF STATUS, 0x5
0352  0820     MOVF 0x20, W
0353  1283     BCF STATUS, 0x5
0354  00A4     MOVWF x
0355  120A     BCF PCLATH, 0x4
0356  158A     BSF PCLATH, 0x3
0357  2045     CALL 0x45
0358  120A     BCF PCLATH, 0x4
0359  118A     BCF PCLATH, 0x3
035A  0825     MOVF dato, W
035B  1683     BSF STATUS, 0x5
035C  1703     BSF STATUS, 0x6
035D  00A1     MOVWF 0x21
035E  1283     BCF STATUS, 0x5
035F  1303     BCF STATUS, 0x6
0360  0824     MOVF x, W
0361  1683     BSF STATUS, 0x5
0362  1703     BSF STATUS, 0x6
0363  00A0     MOVWF 0x20
387:                           adcdecimalI = (unsigned int) ((mediciondecorriente - (unsigned int) mediciondecorriente)*10);
0364  1303     BCF STATUS, 0x6
0365  0823     MOVF 0x23, W
0366  1283     BCF STATUS, 0x5
0367  00C4     MOVWF dow
0368  1683     BSF STATUS, 0x5
0369  0822     MOVF 0x22, W
036A  1283     BCF STATUS, 0x5
036B  00C3     MOVWF m
036C  1683     BSF STATUS, 0x5
036D  0821     MOVF 0x21, W
036E  1283     BCF STATUS, 0x5
036F  00C2     MOVWF 0x42
0370  1683     BSF STATUS, 0x5
0371  0820     MOVF 0x20, W
0372  1283     BCF STATUS, 0x5
0373  00C1     MOVWF f1
0374  1683     BSF STATUS, 0x5
0375  0823     MOVF 0x23, W
0376  1283     BCF STATUS, 0x5
0377  00A7     MOVWF x
0378  1683     BSF STATUS, 0x5
0379  0822     MOVF 0x22, W
037A  1283     BCF STATUS, 0x5
037B  00A6     MOVWF y
037C  1683     BSF STATUS, 0x5
037D  0821     MOVF 0x21, W
037E  1283     BCF STATUS, 0x5
037F  00A5     MOVWF dato
0380  1683     BSF STATUS, 0x5
0381  0820     MOVF 0x20, W
0382  1283     BCF STATUS, 0x5
0383  00A4     MOVWF x
0384  120A     BCF PCLATH, 0x4
0385  158A     BSF PCLATH, 0x3
0386  2045     CALL 0x45
0387  120A     BCF PCLATH, 0x4
0388  118A     BCF PCLATH, 0x3
0389  0825     MOVF dato, W
038A  00AF     MOVWF sign
038B  0824     MOVF x, W
038C  00AE     MOVWF day
038D  160A     BSF PCLATH, 0x4
038E  118A     BCF PCLATH, 0x3
038F  219F     CALL 0x19F
0390  120A     BCF PCLATH, 0x4
0391  118A     BCF PCLATH, 0x3
0392  0831     MOVF 0x31, W
0393  00C0     MOVWF 0x40
0394  0830     MOVF quotient, W
0395  00BF     MOVWF 0x3F
0396  082F     MOVF sign, W
0397  00BE     MOVWF 0x3E
0398  082E     MOVF day, W
0399  00BD     MOVWF f2
039A  160A     BSF PCLATH, 0x4
039B  118A     BCF PCLATH, 0x3
039C  21B2     CALL 0x1B2
039D  120A     BCF PCLATH, 0x4
039E  118A     BCF PCLATH, 0x3
039F  0840     MOVF 0x40, W
03A0  00CC     MOVWF 0x4C
03A1  083F     MOVF 0x3F, W
03A2  00CB     MOVWF 0x4B
03A3  083E     MOVF 0x3E, W
03A4  00CA     MOVWF f
03A5  083D     MOVF f2, W
03A6  00C9     MOVWF f2
03A7  3041     MOVLW 0x41
03A8  00C8     MOVWF sp
03A9  3020     MOVLW 0x20
03AA  00C7     MOVWF y
03AB  01C6     CLRF dia
03AC  01C5     CLRF a
03AD  160A     BSF PCLATH, 0x4
03AE  118A     BCF PCLATH, 0x3
03AF  2247     CALL 0x247
03B0  120A     BCF PCLATH, 0x4
03B1  118A     BCF PCLATH, 0x3
03B2  0848     MOVF sp, W
03B3  1683     BSF STATUS, 0x5
03B4  00EA     MOVWF sign
03B5  1283     BCF STATUS, 0x5
03B6  0847     MOVF y, W
03B7  1683     BSF STATUS, 0x5
03B8  00E9     MOVWF exp
03B9  1283     BCF STATUS, 0x5
03BA  0846     MOVF dia, W
03BB  1683     BSF STATUS, 0x5
03BC  00E8     MOVWF cntr
03BD  1283     BCF STATUS, 0x5
03BE  0845     MOVF a, W
03BF  1683     BSF STATUS, 0x5
03C0  00E7     MOVWF 0x67
03C1  086A     MOVF sign, W
03C2  1283     BCF STATUS, 0x5
03C3  00A7     MOVWF x
03C4  1683     BSF STATUS, 0x5
03C5  0869     MOVF exp, W
03C6  1283     BCF STATUS, 0x5
03C7  00A6     MOVWF y
03C8  1683     BSF STATUS, 0x5
03C9  0868     MOVF cntr, W
03CA  1283     BCF STATUS, 0x5
03CB  00A5     MOVWF dato
03CC  1683     BSF STATUS, 0x5
03CD  0867     MOVF 0x67, W
03CE  1283     BCF STATUS, 0x5
03CF  00A4     MOVWF x
03D0  120A     BCF PCLATH, 0x4
03D1  158A     BSF PCLATH, 0x3
03D2  2045     CALL 0x45
03D3  120A     BCF PCLATH, 0x4
03D4  118A     BCF PCLATH, 0x3
03D5  0825     MOVF dato, W
03D6  1683     BSF STATUS, 0x5
03D7  1703     BSF STATUS, 0x6
03D8  009F     MOVWF ADCON0
03D9  1283     BCF STATUS, 0x5
03DA  1303     BCF STATUS, 0x6
03DB  0824     MOVF x, W
03DC  1683     BSF STATUS, 0x5
03DD  1703     BSF STATUS, 0x6
03DE  009E     MOVWF ADRESH
388:                           sprintf(cadenaamostrar, "%2u.%uA   ", (unsigned int) adcenteroI, (unsigned int) adcdecimalI);
03DF  30A6     MOVLW 0xA6
03E0  1283     BCF STATUS, 0x5
03E1  1303     BCF STATUS, 0x6
03E2  00C8     MOVWF sp
03E3  3001     MOVLW 0x1
03E4  00C9     MOVWF f2
03E5  3095     MOVLW 0x95
03E6  00CA     MOVWF f
03E7  3098     MOVLW 0x98
03E8  00CB     MOVWF 0x4B
03E9  1683     BSF STATUS, 0x5
03EA  1703     BSF STATUS, 0x6
03EB  0821     MOVF 0x21, W
03EC  1283     BCF STATUS, 0x5
03ED  1303     BCF STATUS, 0x6
03EE  00CD     MOVWF 0x4D
03EF  1683     BSF STATUS, 0x5
03F0  1703     BSF STATUS, 0x6
03F1  0820     MOVF 0x20, W
03F2  1283     BCF STATUS, 0x5
03F3  1303     BCF STATUS, 0x6
03F4  00CC     MOVWF 0x4C
03F5  1683     BSF STATUS, 0x5
03F6  1703     BSF STATUS, 0x6
03F7  081F     MOVF ADCON0, W
03F8  1283     BCF STATUS, 0x5
03F9  1303     BCF STATUS, 0x6
03FA  00CF     MOVWF to
03FB  1683     BSF STATUS, 0x5
03FC  1703     BSF STATUS, 0x6
03FD  081E     MOVF ADRESH, W
03FE  1283     BCF STATUS, 0x5
03FF  1303     BCF STATUS, 0x6
0400  00CE     MOVWF 0x4E
0401  120A     BCF PCLATH, 0x4
0402  158A     BSF PCLATH, 0x3
0403  25B1     CALL 0x5B1
0404  120A     BCF PCLATH, 0x4
0405  118A     BCF PCLATH, 0x3
389:                           sprintf(cadenaamostrar2, "%3uV    ", (unsigned int) adcenteroV);
0406  30CE     MOVLW 0xCE
0407  00C8     MOVWF sp
0408  30DD     MOVLW 0xDD
0409  01C9     CLRF f2
040A  00CA     MOVWF f
040B  3098     MOVLW 0x98
040C  00CB     MOVWF 0x4B
040D  1683     BSF STATUS, 0x5
040E  0828     MOVF i, W
040F  1283     BCF STATUS, 0x5
0410  00CD     MOVWF 0x4D
0411  1683     BSF STATUS, 0x5
0412  0827     MOVF x, W
0413  1283     BCF STATUS, 0x5
0414  00CC     MOVWF 0x4C
0415  120A     BCF PCLATH, 0x4
0416  158A     BSF PCLATH, 0x3
0417  25B1     CALL 0x5B1
0418  120A     BCF PCLATH, 0x4
0419  118A     BCF PCLATH, 0x3
390:                           break;
041A  1683     BSF STATUS, 0x5
041B  2C2B     GOTO 0x42B
391:                       }
392:                       default:
393:                           break;
394:                   };
395:                   //////////////////////////////////////////////////////////
396:                   //Finaliza Procesa los men
397:                   // </editor-fold>
398:           
399:                   // <editor-fold defaultstate="collapsed" desc="Muestra estado de la bomba">
400:                   /////////////////////////////////////////////////////////
401:                   if (menuactual != MENU_MUESTRAMEDICIONES && menuactual != MENU_MUESTRAFECHA && (menuactual < SUBMENU_CONFIGURADIA || menuactual > SUBMENU_CONFIGURAANIO)) {
042B  1683     BSF STATUS, 0x5
042C  0849     MOVF f2, W
042D  3A02     XORLW 0x2
042E  1903     BTFSC STATUS, 0x2
042F  2C87     GOTO 0x487
0430  0349     DECF f2, W
0431  1903     BTFSC STATUS, 0x2
0432  2C87     GOTO 0x487
0433  3007     MOVLW 0x7
0434  0249     SUBWF f2, W
0435  1C03     BTFSS STATUS, 0x0
0436  2C58     GOTO 0x458
0437  300A     MOVLW 0xA
0438  0249     SUBWF f2, W
0439  1803     BTFSC STATUS, 0x0
043A  2C58     GOTO 0x458
043B  2C87     GOTO 0x487
402:                       switch (estadobomba) {
0458  0842     MOVF 0x42, W
0459  3A00     XORLW 0x0
045A  1903     BTFSC STATUS, 0x2
045B  2C3C     GOTO 0x43C
045C  3A01     XORLW 0x1
045D  1903     BTFSC STATUS, 0x2
045E  2C4A     GOTO 0x44A
045F  2C7E     GOTO 0x47E
403:                           case BOMBAAPAGADA:
404:                           {
405:                               sprintf(cadenaamostrar2, "     off");
043C  30CE     MOVLW 0xCE
043D  1283     BCF STATUS, 0x5
043E  00C8     MOVWF sp
043F  3025     MOVLW 0x25
0440  01C9     CLRF f2
0441  00CA     MOVWF f
0442  3099     MOVLW 0x99
0443  00CB     MOVWF 0x4B
0444  120A     BCF PCLATH, 0x4
0445  158A     BSF PCLATH, 0x3
0446  25B1     CALL 0x5B1
0447  120A     BCF PCLATH, 0x4
0448  118A     BCF PCLATH, 0x3
406:                               break;
0449  2C7E     GOTO 0x47E
407:                           }
408:                           case BOMBAENCENDIDA:
409:                           {
410:                               sprintf(cadenaamostrar2, "      on");
044A  30CE     MOVLW 0xCE
044B  1283     BCF STATUS, 0x5
044C  00C8     MOVWF sp
044D  302E     MOVLW 0x2E
044E  01C9     CLRF f2
044F  00CA     MOVWF f
0450  3099     MOVLW 0x99
0451  00CB     MOVWF 0x4B
0452  120A     BCF PCLATH, 0x4
0453  158A     BSF PCLATH, 0x3
0454  25B1     CALL 0x5B1
0455  120A     BCF PCLATH, 0x4
0456  118A     BCF PCLATH, 0x3
411:                               break;
0457  2C7E     GOTO 0x47E
412:                           }
413:                           default:
414:                               break;
415:                       }
416:                       switch (manual_automatico) {
047E  1683     BSF STATUS, 0x5
047F  086C     MOVF fecha, W
0480  3A00     XORLW 0x0
0481  1903     BTFSC STATUS, 0x2
0482  2C60     GOTO 0x460
0483  3A01     XORLW 0x1
0484  1903     BTFSC STATUS, 0x2
0485  2C6F     GOTO 0x46F
0486  2C87     GOTO 0x487
417:                           case MANUAL:
418:                           {
419:                               strncpy(cadenaamostrar2, "MAN:", 4);
0460  3047     MOVLW 0x47
0461  1283     BCF STATUS, 0x5
0462  00C8     MOVWF sp
0463  3099     MOVLW 0x99
0464  00C9     MOVWF f2
0465  3004     MOVLW 0x4
0466  00CA     MOVWF f
0467  30CE     MOVLW 0xCE
0468  01CB     CLRF 0x4B
0469  160A     BSF PCLATH, 0x4
046A  118A     BCF PCLATH, 0x3
046B  2012     CALL 0x12
046C  120A     BCF PCLATH, 0x4
046D  118A     BCF PCLATH, 0x3
420:                               break;
046E  2C87     GOTO 0x487
421:                           }
422:                           case AUTOMATICO:
423:                           {
424:                               strncpy(cadenaamostrar2, "AUT:", 4);
046F  304C     MOVLW 0x4C
0470  1283     BCF STATUS, 0x5
0471  00C8     MOVWF sp
0472  3099     MOVLW 0x99
0473  00C9     MOVWF f2
0474  3004     MOVLW 0x4
0475  00CA     MOVWF f
0476  30CE     MOVLW 0xCE
0477  01CB     CLRF 0x4B
0478  160A     BSF PCLATH, 0x4
0479  118A     BCF PCLATH, 0x3
047A  2012     CALL 0x12
047B  120A     BCF PCLATH, 0x4
047C  118A     BCF PCLATH, 0x3
425:                               break;
047D  2C87     GOTO 0x487
426:                           }
427:                           default:
428:                               break;
429:                       }
430:                   }
431:                   // </editor-fold>
432:           
433:                   // <editor-fold defaultstate="collapsed" desc="Verifica estados de falla">
434:           
435:           
436:                   if ((estadonivel == NIVELNORMAL) && (estadofallacorriente == CORRIENTENORMAL) && (estadofallavoltaje == VOLTAJENORMAL)) {
0487  1683     BSF STATUS, 0x5
0488  0B45     DECFSZ a, W
0489  2C8F     GOTO 0x48F
048A  0B43     DECFSZ m, W
048B  2C8F     GOTO 0x48F
048C  0B44     DECFSZ dow, W
048D  2C8F     GOTO 0x48F
048E  2C90     GOTO 0x490
437:           
438:           
439:                   } else {
440:                       activabomba = APAGABOMBA;
048F  01AC     CLRF sec
441:                   }
442:                   //////////////////////////////////////////////////////
443:                   //Fin Verifica estados de falla
444:                   // </editor-fold>
445:           
446:                   // <editor-fold defaultstate="collapsed" desc="Inicio de procesamiento de medicion de voltaje, corriente">
447:                   //Inicio de procesamiento de medicion de voltaje, corriente
448:                   /////////////////////////////////////////////////////////////
449:                   //convierto el valor decimal a float
450:                   //para una entrada de 3.3V la lectura es 1023
451:                   //para 0 V la lectura es 0
452:                   //para una maxima lectura quiero que en el display se observe 50A
453:                   //Deseo que tambien me muestre 1 decimal, separo la parte entera y la decimal
454:                   //como la resolucion es 1024, cada bit corresponde a 50A/1024=0.048828125A
455:                   //cada 20 muestras tengo aproximdamente 1A
456:                   mediciondevoltaje = (float) medidaV_adc * 440 / 1024;
0490  3044     MOVLW 0x44
0491  1283     BCF STATUS, 0x5
0492  00DB     MOVWF _val
0493  3080     MOVLW 0x80
0494  00DA     MOVWF c
0495  3043     MOVLW 0x43
0496  01D9     CLRF 0x59
0497  01D8     CLRF width
0498  00C8     MOVWF sp
0499  30DC     MOVLW 0xDC
049A  00C7     MOVWF y
049B  01C6     CLRF dia
049C  01C5     CLRF a
049D  1683     BSF STATUS, 0x5
049E  1703     BSF STATUS, 0x6
049F  0825     MOVF dato, W
04A0  1283     BCF STATUS, 0x5
04A1  1303     BCF STATUS, 0x6
04A2  00AF     MOVWF sign
04A3  1683     BSF STATUS, 0x5
04A4  1703     BSF STATUS, 0x6
04A5  0824     MOVF x, W
04A6  1283     BCF STATUS, 0x5
04A7  1303     BCF STATUS, 0x6
04A8  00AE     MOVWF day
04A9  160A     BSF PCLATH, 0x4
04AA  118A     BCF PCLATH, 0x3
04AB  219F     CALL 0x19F
04AC  120A     BCF PCLATH, 0x4
04AD  118A     BCF PCLATH, 0x3
04AE  0831     MOVF 0x31, W
04AF  00CC     MOVWF 0x4C
04B0  0830     MOVF quotient, W
04B1  00CB     MOVWF 0x4B
04B2  082F     MOVF sign, W
04B3  00CA     MOVWF f
04B4  082E     MOVF day, W
04B5  00C9     MOVWF f2
04B6  160A     BSF PCLATH, 0x4
04B7  118A     BCF PCLATH, 0x3
04B8  2247     CALL 0x247
04B9  120A     BCF PCLATH, 0x4
04BA  118A     BCF PCLATH, 0x3
04BB  0848     MOVF sp, W
04BC  00DF     MOVWF 0x5F
04BD  0847     MOVF y, W
04BE  00DE     MOVWF 0x5E
04BF  0846     MOVF dia, W
04C0  00DD     MOVWF 0x5D
04C1  0845     MOVF a, W
04C2  00DC     MOVWF f1
04C3  160A     BSF PCLATH, 0x4
04C4  118A     BCF PCLATH, 0x3
04C5  21CE     CALL 0x1CE
04C6  120A     BCF PCLATH, 0x4
04C7  118A     BCF PCLATH, 0x3
04C8  085B     MOVF _val, W
04C9  1683     BSF STATUS, 0x5
04CA  1703     BSF STATUS, 0x6
04CB  009D     MOVWF CCP2CON
04CC  1283     BCF STATUS, 0x5
04CD  1303     BCF STATUS, 0x6
04CE  085A     MOVF c, W
04CF  1683     BSF STATUS, 0x5
04D0  1703     BSF STATUS, 0x6
04D1  009C     MOVWF CCPR2H
04D2  1283     BCF STATUS, 0x5
04D3  1303     BCF STATUS, 0x6
04D4  0859     MOVF 0x59, W
04D5  1683     BSF STATUS, 0x5
04D6  1703     BSF STATUS, 0x6
04D7  009B     MOVWF CCPR2
04D8  1283     BCF STATUS, 0x5
04D9  1303     BCF STATUS, 0x6
04DA  0858     MOVF width, W
04DB  1683     BSF STATUS, 0x5
04DC  1703     BSF STATUS, 0x6
04DD  009A     MOVWF RCREG
457:                   adcenteroV = (unsigned int) mediciondevoltaje;
04DE  081D     MOVF CCP2CON, W
04DF  1283     BCF STATUS, 0x5
04E0  1303     BCF STATUS, 0x6
04E1  00A7     MOVWF x
04E2  1683     BSF STATUS, 0x5
04E3  1703     BSF STATUS, 0x6
04E4  081C     MOVF CCPR2H, W
04E5  1283     BCF STATUS, 0x5
04E6  1303     BCF STATUS, 0x6
04E7  00A6     MOVWF y
04E8  1683     BSF STATUS, 0x5
04E9  1703     BSF STATUS, 0x6
04EA  081B     MOVF CCPR2, W
04EB  1283     BCF STATUS, 0x5
04EC  1303     BCF STATUS, 0x6
04ED  00A5     MOVWF dato
04EE  1683     BSF STATUS, 0x5
04EF  1703     BSF STATUS, 0x6
04F0  081A     MOVF RCREG, W
04F1  1283     BCF STATUS, 0x5
04F2  1303     BCF STATUS, 0x6
04F3  00A4     MOVWF x
04F4  120A     BCF PCLATH, 0x4
04F5  158A     BSF PCLATH, 0x3
04F6  2045     CALL 0x45
04F7  120A     BCF PCLATH, 0x4
04F8  118A     BCF PCLATH, 0x3
04F9  0825     MOVF dato, W
04FA  1683     BSF STATUS, 0x5
04FB  00A8     MOVWF i
04FC  1283     BCF STATUS, 0x5
04FD  0824     MOVF x, W
04FE  1683     BSF STATUS, 0x5
04FF  00A7     MOVWF x
458:                   //Se lee el voltaje de alimentacin constantemente
459:                   if (adcenteroV <= VOLTAJEMAXIMO && adcenteroV >= VOLTAJEMINIMO) {
0500  3000     MOVLW 0x0
0501  0228     SUBWF i, W
0502  30F1     MOVLW 0xF1
0503  1903     BTFSC STATUS, 0x2
0504  0227     SUBWF x, W
0505  1803     BTFSC STATUS, 0x0
0506  2D11     GOTO 0x511
0507  3000     MOVLW 0x0
0508  0228     SUBWF i, W
0509  30BE     MOVLW 0xBE
050A  1903     BTFSC STATUS, 0x2
050B  0227     SUBWF x, W
050D  1C03     BTFSS STATUS, 0x0
050E  2D12     GOTO 0x512
460:                       estadofallavoltaje = VOLTAJENORMAL;
050C  01C4     CLRF dow
050F  0AC4     INCF dow, F
461:                   } else {
0510  2D12     GOTO 0x512
462:                       estadofallavoltaje = FALLAVOLTAJE;
0511  01C4     CLRF dow
463:                   }
464:                   mediciondecorriente = (float) medidaI_adc * 50 / 1024;
0512  3044     MOVLW 0x44
0513  1283     BCF STATUS, 0x5
0514  00DB     MOVWF _val
0515  3080     MOVLW 0x80
0516  00DA     MOVWF c
0517  3042     MOVLW 0x42
0518  01D9     CLRF 0x59
0519  01D8     CLRF width
051A  00C8     MOVWF sp
051B  3048     MOVLW 0x48
051C  00C7     MOVWF y
051D  01C6     CLRF dia
051E  01C5     CLRF a
051F  1683     BSF STATUS, 0x5
0520  1703     BSF STATUS, 0x6
0521  0823     MOVF 0x23, W
0522  1283     BCF STATUS, 0x5
0523  1303     BCF STATUS, 0x6
0524  00AF     MOVWF sign
0525  1683     BSF STATUS, 0x5
0526  1703     BSF STATUS, 0x6
0527  0822     MOVF 0x22, W
0528  1283     BCF STATUS, 0x5
0529  1303     BCF STATUS, 0x6
052A  00AE     MOVWF day
052B  160A     BSF PCLATH, 0x4
052C  118A     BCF PCLATH, 0x3
052D  219F     CALL 0x19F
052E  120A     BCF PCLATH, 0x4
052F  118A     BCF PCLATH, 0x3
0530  0831     MOVF 0x31, W
0531  00CC     MOVWF 0x4C
0532  0830     MOVF quotient, W
0533  00CB     MOVWF 0x4B
0534  082F     MOVF sign, W
0535  00CA     MOVWF f
0536  082E     MOVF day, W
0537  00C9     MOVWF f2
0538  160A     BSF PCLATH, 0x4
0539  118A     BCF PCLATH, 0x3
053A  2247     CALL 0x247
053B  120A     BCF PCLATH, 0x4
053C  118A     BCF PCLATH, 0x3
053D  0848     MOVF sp, W
053E  00DF     MOVWF 0x5F
053F  0847     MOVF y, W
0540  00DE     MOVWF 0x5E
0541  0846     MOVF dia, W
0542  00DD     MOVWF 0x5D
0543  0845     MOVF a, W
0544  00DC     MOVWF f1
0545  160A     BSF PCLATH, 0x4
0546  118A     BCF PCLATH, 0x3
0547  21CE     CALL 0x1CE
0548  120A     BCF PCLATH, 0x4
0549  118A     BCF PCLATH, 0x3
054A  085B     MOVF _val, W
054B  1683     BSF STATUS, 0x5
054C  00A3     MOVWF 0x23
054D  1283     BCF STATUS, 0x5
054E  085A     MOVF c, W
054F  1683     BSF STATUS, 0x5
0550  00A2     MOVWF 0x22
0551  1283     BCF STATUS, 0x5
0552  0859     MOVF 0x59, W
0553  1683     BSF STATUS, 0x5
0554  00A1     MOVWF 0x21
0555  1283     BCF STATUS, 0x5
0556  0858     MOVF width, W
0557  1683     BSF STATUS, 0x5
0558  00A0     MOVWF 0x20
465:                   /////////////////////////////////////////////////////////////
466:                   //Fin de procesamiento de medicion de voltaje, corriente
467:                   // </editor-fold>
468:           
469:                   // <editor-fold defaultstate="collapsed" desc="Activa o desactiva la Bomba">
470:                   //Activa o desactiva la Bomba
471:                   ///////////////////////////////////////////////////////
472:                   switch (activabomba) {
0559  2D65     GOTO 0x565
0565  082C     MOVF sec, W
0566  3A00     XORLW 0x0
0567  1903     BTFSC STATUS, 0x2
0568  2D60     GOTO 0x560
0569  3A01     XORLW 0x1
056A  1903     BTFSC STATUS, 0x2
056B  2D5A     GOTO 0x55A
056C  2DC4     GOTO 0x5C4
473:                       case ENCIENDEBOMBA:
474:                       {
475:                           salidabomba = 1;
055A  1283     BCF STATUS, 0x5
055B  1407     BSF PORTC, 0x0
476:                           estadobomba = 1;
055C  1683     BSF STATUS, 0x5
055D  01C2     CLRF 0x42
055E  0AC2     INCF 0x42, F
477:                           // vBackLightLCD_On();
478:                           break;
055F  2DC4     GOTO 0x5C4
479:                       }
480:                       case APAGABOMBA:
481:                       {
482:                           salidabomba = 0;
0560  1283     BCF STATUS, 0x5
0561  1007     BCF PORTC, 0x0
483:                           estadobomba = 0;
0562  1683     BSF STATUS, 0x5
0563  01C2     CLRF 0x42
484:                           // vBackLightLCD_Off();
485:                           break;
0564  2DC4     GOTO 0x5C4
486:                       }
487:                       default:
488:                           break;
489:                   }
490:                   //////////////////////////////////////////////////////
491:                   //Fin Activa o desactiva la Bomba
492:                   // </editor-fold>
493:           
494:                   // <editor-fold defaultstate="collapsed" desc="Procesa Alarma">
495:                   //Inicio Procesa Alarma
496:                   ///////////////////////////////////////////////////////
497:                   switch (alarma_encendido) {
05C4  082F     MOVF sign, W
05C5  3A00     XORLW 0x0
05C6  1903     BTFSC STATUS, 0x2
05C7  2DCC     GOTO 0x5CC
05C8  3A01     XORLW 0x1
05C9  1903     BTFSC STATUS, 0x2
05CA  2D6D     GOTO 0x56D
05CB  2DCC     GOTO 0x5CC
498:                       case NOALARMA:
499:                       {
500:                           break;
501:                       }
502:                       case SIALARMA:
503:                       {
504:                           if (manual_automatico == AUTOMATICO) {
056D  0B6C     DECFSZ fecha, W
056E  2D78     GOTO 0x578
505:                               bandera_orden_Alarma_bomba = 1;
0570  01B7     CLRF sign
0571  0AB7     INCF sign, F
506:                               buzzer_on(3);
056F  3003     MOVLW 0x3
0572  160A     BSF PCLATH, 0x4
0573  158A     BSF PCLATH, 0x3
0574  277D     CALL 0x77D
0575  120A     BCF PCLATH, 0x4
0576  118A     BCF PCLATH, 0x3
507:                           } else {
0577  2D79     GOTO 0x579
508:                               bandera_orden_Alarma_bomba = 0;
0578  01B7     CLRF sign
509:                           }
510:                           alarma_encendido = NOALARMA;
0579  1683     BSF STATUS, 0x5
057A  01AF     CLRF sign
511:                           isl1208SR.Valor = ISL1208_Read_status();
057B  120A     BCF PCLATH, 0x4
057C  158A     BSF PCLATH, 0x3
057D  2315     CALL 0x315
057E  120A     BCF PCLATH, 0x4
057F  118A     BCF PCLATH, 0x3
0580  1683     BSF STATUS, 0x5
0581  00E2     MOVWF 0x62
512:                           isl1208SR.ALM = 0; //reseteo la indicacion de alarma del RTC
0583  1162     BCF 0x62, 0x2
513:                           ISL1208_Set_status(&isl1208SR.Valor);
0582  30E2     MOVLW 0xE2
0584  120A     BCF PCLATH, 0x4
0585  158A     BSF PCLATH, 0x3
0586  22FF     CALL 0x2FF
0587  120A     BCF PCLATH, 0x4
0588  118A     BCF PCLATH, 0x3
514:                           //Leo el valor de la alarma
515:                           isl1208_get_time_enc(&horarioenc.hrs, &horarioenc.min, &horarioenc.sec);
0589  30DF     MOVLW 0xDF
058A  1283     BCF STATUS, 0x5
058B  00A9     MOVWF mth
058C  30DE     MOVLW 0xDE
058D  00AA     MOVWF year
058E  30E0     MOVLW 0xE0
058F  120A     BCF PCLATH, 0x4
0590  158A     BSF PCLATH, 0x3
0591  238B     CALL 0x38B
0592  120A     BCF PCLATH, 0x4
0593  118A     BCF PCLATH, 0x3
516:                           isl1208_get_dow_enc(&fechaenc.dow);
0594  30DA     MOVLW 0xDA
0595  120A     BCF PCLATH, 0x4
0596  158A     BSF PCLATH, 0x3
0597  2330     CALL 0x330
0598  120A     BCF PCLATH, 0x4
0599  118A     BCF PCLATH, 0x3
517:                           horarioapagado.Valor = horarioenc.Valor;
059A  085E     MOVF 0x5E, W
059B  00A4     MOVWF x
059C  085F     MOVF 0x5F, W
059D  00A5     MOVWF dato
059E  0860     MOVF 0x60, W
059F  00A6     MOVWF y
518:                           if (horarioapagado.min + tiempoencendido >= 60) {
05A0  0825     MOVF dato, W
05A1  074C     ADDWF 0x4C, W
05A2  00E4     MOVWF f3
05A3  01E5     CLRF 0x65
05A4  0DE5     RLF 0x65, F
05A5  0865     MOVF 0x65, W
05A6  3A80     XORLW 0x80
05A7  00FF     MOVWF 0x7F
05A8  3080     MOVLW 0x80
05A9  027F     SUBWF 0x7F, W
05AA  1D03     BTFSS STATUS, 0x2
05AB  2DAE     GOTO 0x5AE
05AC  303C     MOVLW 0x3C
05AD  0264     SUBWF f3, W
05AE  1C03     BTFSS STATUS, 0x0
05AF  2DBE     GOTO 0x5BE
519:                               horarioapagado.min = horarioapagado.min + tiempoencendido - 60;
05B0  1683     BSF STATUS, 0x5
05B1  1303     BCF STATUS, 0x6
05B2  084C     MOVF 0x4C, W
05B3  0725     ADDWF dato, W
05B4  3EC4     ADDLW 0xC4
05B5  00A5     MOVWF dato
520:                               if (horarioapagado.hrs == 23) {
05B6  0826     MOVF y, W
05B7  3A17     XORLW 0x17
05B8  1D03     BTFSS STATUS, 0x2
05B9  2DBC     GOTO 0x5BC
521:                                   horarioapagado.hrs = 0;
05BA  01A6     CLRF y
522:                               } else {
05BB  2DCC     GOTO 0x5CC
523:                                   horarioapagado.hrs++;
05BC  0AA6     INCF y, F
05BD  2DCC     GOTO 0x5CC
524:                               }
525:                           } else {
526:                               horarioapagado.min = horarioapagado.min + tiempoencendido;
05BE  1683     BSF STATUS, 0x5
05BF  1303     BCF STATUS, 0x6
05C0  084C     MOVF 0x4C, W
05C1  0725     ADDWF dato, W
05C2  00A5     MOVWF dato
05C3  2DCC     GOTO 0x5CC
527:                           }
528:                           break;
529:                       }
530:                       default:
531:                           break;
532:                   }
533:                   //////////////////////////////////////////////////////
534:                   //Fin Procesa Alarma
535:                   // </editor-fold>
536:           
537:                   // <editor-fold defaultstate="collapsed" desc="Verifica secuencia de arranque">
538:                   /*para que el motor arranque se debe cumplir que:
539:                    * el voltaje sea normal,
540:                    * si est en manual, se haya pulsado el boton on_off
541:                    * si est en automatico se haya activado la alarma por interrupcion
542:                    * el nivel no sea bajo,
543:                    * la corriente sea normal, por lo menos despues de un tiempo despues del arranque
544:                    */
545:                   if (estadofallavoltaje == VOLTAJENORMAL) {
05CC  0B44     DECFSZ dow, W
05CD  2ECD     GOTO 0x6CD
546:                       if (manual_automatico == MANUAL) {
05CE  08EC     MOVF fecha, F
05CF  1D03     BTFSS STATUS, 0x2
05D0  2E63     GOTO 0x663
547:                           if (bandera_orden_on_off_bomba) {
05D1  0838     MOVF mes, W
05D2  1903     BTFSC STATUS, 0x2
05D3  2E60     GOTO 0x660
548:                               if (indica_secuencia_arranque == 0) {
05D4  08C7     MOVF y, F
05D5  1D03     BTFSS STATUS, 0x2
05D6  2E08     GOTO 0x608
549:                                   if (tiempo_secuencia_arranque == 0) {
05D7  08CB     MOVF 0x4B, F
05D8  1D03     BTFSS STATUS, 0x2
05D9  2DE3     GOTO 0x5E3
550:                                       activabomba = ENCIENDEBOMBA; //Enciendo la bomba para empezar a medir la corriente
05DB  01AC     CLRF sec
05DC  0AAC     INCF sec, F
551:                                       estadofallacorriente = CORRIENTENORMAL;
05DD  01C3     CLRF m
05DE  0AC3     INCF m, F
552:                                       estadonivel = NIVELNORMAL;
05DF  01C5     CLRF a
05E0  0AC5     INCF a, F
553:                                       tiempo_secuencia_arranque = TIEMPOSECUENCIAARRANQUE; //TODO ajustar el tiempo de secuencia de arranque
05DA  300F     MOVLW 0xF
05E1  00CB     MOVWF 0x4B
554:                                   } else {
05E2  2ECD     GOTO 0x6CD
555:                                       // Una vez que se activo la bomba debo ver el estado de la corriente  para ver si no se pasa de los valores normales
556:                                       if (mediciondecorriente <= CORRIENTEMAXIMA) {
05E3  3042     MOVLW 0x42
05E4  1283     BCF STATUS, 0x5
05E5  00A7     MOVWF x
05E6  3034     MOVLW 0x34
05E7  00A6     MOVWF y
05E8  01A5     CLRF dato
05E9  01A4     CLRF x
05EA  1683     BSF STATUS, 0x5
05EB  0823     MOVF 0x23, W
05EC  1283     BCF STATUS, 0x5
05ED  00AB     MOVWF Data
05EE  1683     BSF STATUS, 0x5
05EF  0822     MOVF 0x22, W
05F0  1283     BCF STATUS, 0x5
05F1  00AA     MOVWF year
05F2  1683     BSF STATUS, 0x5
05F3  0821     MOVF 0x21, W
05F4  1283     BCF STATUS, 0x5
05F5  00A9     MOVWF mth
05F6  1683     BSF STATUS, 0x5
05F7  0820     MOVF 0x20, W
05F8  1283     BCF STATUS, 0x5
05F9  00A8     MOVWF i
05FA  160A     BSF PCLATH, 0x4
05FB  118A     BCF PCLATH, 0x3
05FC  204A     CALL 0x4A
05FD  120A     BCF PCLATH, 0x4
05FE  118A     BCF PCLATH, 0x3
05FF  1C03     BTFSS STATUS, 0x0
0600  2E05     GOTO 0x605
557:                                           estadofallacorriente = CORRIENTENORMAL;
0601  1683     BSF STATUS, 0x5
0602  01C3     CLRF m
0603  0AC3     INCF m, F
558:                                       } else {
0604  2ECD     GOTO 0x6CD
559:                                           estadofallacorriente = FALLACORRIENTE;
0605  1683     BSF STATUS, 0x5
0606  01C3     CLRF m
0607  2ECD     GOTO 0x6CD
560:                                       }
561:           
562:                                   }
563:                               } else {
564:                                   //ya finalizo la secuencia de arranque, entonces veo si se estabiliz la corriente
565:                                   if (mediciondecorriente <= CORRIENTENORMALMAXIMA) {
0608  3041     MOVLW 0x41
0609  1283     BCF STATUS, 0x5
060A  00A7     MOVWF x
060B  3020     MOVLW 0x20
060C  00A6     MOVWF y
060D  01A5     CLRF dato
060E  01A4     CLRF x
060F  1683     BSF STATUS, 0x5
0610  0823     MOVF 0x23, W
0611  1283     BCF STATUS, 0x5
0612  00AB     MOVWF Data
0613  1683     BSF STATUS, 0x5
0614  0822     MOVF 0x22, W
0615  1283     BCF STATUS, 0x5
0616  00AA     MOVWF year
0617  1683     BSF STATUS, 0x5
0618  0821     MOVF 0x21, W
0619  1283     BCF STATUS, 0x5
061A  00A9     MOVWF mth
061B  1683     BSF STATUS, 0x5
061C  0820     MOVF 0x20, W
061D  1283     BCF STATUS, 0x5
061E  00A8     MOVWF i
061F  160A     BSF PCLATH, 0x4
0620  118A     BCF PCLATH, 0x3
0621  204A     CALL 0x4A
0622  120A     BCF PCLATH, 0x4
0623  118A     BCF PCLATH, 0x3
0624  1C03     BTFSS STATUS, 0x0
0625  2E2B     GOTO 0x62B
566:                                       estadofallacorriente = CORRIENTENORMAL;
0626  1683     BSF STATUS, 0x5
0627  01C3     CLRF m
0628  0AC3     INCF m, F
567:                                       cuenta_tiempofalla = 0;
0629  01BD     CLRF f2
568:                                   } else {
062A  2E3B     GOTO 0x63B
569:                                       //aca verifica si la falla est presente mucho tiempo con tiempofalla
570:                                       if (indica_tiempo_falla == 0) {
062B  1683     BSF STATUS, 0x5
062C  08C8     MOVF sp, F
062D  1D03     BTFSS STATUS, 0x2
062E  2E35     GOTO 0x635
571:                                           if (cuenta_tiempofalla == 0) {
062F  08BD     MOVF f2, F
0630  1D03     BTFSS STATUS, 0x2
0631  2E3B     GOTO 0x63B
572:                                               cuenta_tiempofalla = tiempofalla;
0632  084D     MOVF 0x4D, W
0633  00BD     MOVWF f2
0634  2E3B     GOTO 0x63B
573:                                           }
574:                                       } else {
575:                                           //Expiro el tiempo de falla con una falla de sobrecorriente, debo apagar la bomba
576:                                           estadofallacorriente = FALLACORRIENTE;
0635  01C3     CLRF m
577:                                           indica_tiempo_falla = 0;
0636  01C8     CLRF sp
578:                                           cuenta_tiempofalla = 0;
0637  01BD     CLRF f2
579:                                           indica_secuencia_arranque = 0;
0638  01C7     CLRF y
580:                                           tiempo_secuencia_arranque = 0;
0639  01CB     CLRF 0x4B
581:                                           bandera_orden_on_off_bomba = 0; //cambia la bandera de orden de encendido de bomba
063A  01B8     CLRF mes
582:                                       }
583:           
584:           
585:                                   }
586:                                   if (mediciondecorriente >= CORRIENTENORMALMINIMA) {
063B  0823     MOVF 0x23, W
063C  1283     BCF STATUS, 0x5
063D  00A7     MOVWF x
063E  1683     BSF STATUS, 0x5
063F  0822     MOVF 0x22, W
0640  1283     BCF STATUS, 0x5
0641  00A6     MOVWF y
0642  1683     BSF STATUS, 0x5
0643  0821     MOVF 0x21, W
0644  1283     BCF STATUS, 0x5
0645  00A5     MOVWF dato
0646  1683     BSF STATUS, 0x5
0647  0820     MOVF 0x20, W
0648  1283     BCF STATUS, 0x5
0649  00A4     MOVWF x
064A  303F     MOVLW 0x3F
064B  00AB     MOVWF Data
064C  3080     MOVLW 0x80
064D  00AA     MOVWF year
064E  01A9     CLRF mth
064F  01A8     CLRF i
0650  160A     BSF PCLATH, 0x4
0651  118A     BCF PCLATH, 0x3
0652  204A     CALL 0x4A
0653  120A     BCF PCLATH, 0x4
0654  118A     BCF PCLATH, 0x3
0655  1C03     BTFSS STATUS, 0x0
0656  2E5B     GOTO 0x65B
587:                                       estadonivel = NIVELNORMAL;
0657  1683     BSF STATUS, 0x5
0658  01C5     CLRF a
0659  0AC5     INCF a, F
588:           
589:                                   } else {
065A  2ECD     GOTO 0x6CD
590:                                       indica_secuencia_arranque = 0;
065B  1683     BSF STATUS, 0x5
065C  01C7     CLRF y
591:                                       tiempo_secuencia_arranque = 0;
065D  01CB     CLRF 0x4B
592:                                       bandera_orden_on_off_bomba = 0;
065E  01B8     CLRF mes
065F  2ECC     GOTO 0x6CC
593:                                       estadonivel = NIVELBAJO;
594:                                   }
595:                               }
596:                           } else {
597:                               indica_secuencia_arranque = 0;
0660  01C7     CLRF y
598:                               tiempo_secuencia_arranque = 0;
0661  01CB     CLRF 0x4B
0662  2EC6     GOTO 0x6C6
599:                               activabomba = APAGABOMBA;
600:                           }
601:                       } else {
602:                           if (bandera_orden_Alarma_bomba) {
0663  0837     MOVF sign, W
0664  1903     BTFSC STATUS, 0x2
0665  2E60     GOTO 0x660
603:                               if (indica_secuencia_arranque == 0) {
0666  08C7     MOVF y, F
0667  1903     BTFSC STATUS, 0x2
0668  2DD7     GOTO 0x5D7
604:                                   if (tiempo_secuencia_arranque == 0) {
605:                                       activabomba = ENCIENDEBOMBA; //Enciendo la bomba para empezar a medir la corriente
606:                                       estadofallacorriente = CORRIENTENORMAL;
607:                                       estadonivel = NIVELNORMAL;
608:                                       tiempo_secuencia_arranque = TIEMPOSECUENCIAARRANQUE; //TODO ajustar el tiempo de secuencia de arranque
609:                                   } else {
610:                                       //Una vez que se activo la bomba debo ver el estado de la corriente  para ver si no se pasa de los valores normales
611:                                       if (mediciondecorriente <= CORRIENTEMAXIMA) {
612:                                           estadofallacorriente = CORRIENTENORMAL;
613:                                       } else {
614:                                           estadofallacorriente = FALLACORRIENTE;
615:                                       }
616:           
617:                                   }
618:                               } else {
619:                                   // ya finalizo la secuencia de arranque, entonces veo si se estabiliz la corriente
620:                                   if (mediciondecorriente <= CORRIENTENORMALMAXIMA) {
0669  3041     MOVLW 0x41
066A  1283     BCF STATUS, 0x5
066B  00A7     MOVWF x
066C  3020     MOVLW 0x20
066D  00A6     MOVWF y
066E  01A5     CLRF dato
066F  01A4     CLRF x
0670  1683     BSF STATUS, 0x5
0671  0823     MOVF 0x23, W
0672  1283     BCF STATUS, 0x5
0673  00AB     MOVWF Data
0674  1683     BSF STATUS, 0x5
0675  0822     MOVF 0x22, W
0676  1283     BCF STATUS, 0x5
0677  00AA     MOVWF year
0678  1683     BSF STATUS, 0x5
0679  0821     MOVF 0x21, W
067A  1283     BCF STATUS, 0x5
067B  00A9     MOVWF mth
067C  1683     BSF STATUS, 0x5
067D  0820     MOVF 0x20, W
067E  1283     BCF STATUS, 0x5
067F  00A8     MOVWF i
0680  160A     BSF PCLATH, 0x4
0681  118A     BCF PCLATH, 0x3
0682  204A     CALL 0x4A
0683  120A     BCF PCLATH, 0x4
0684  118A     BCF PCLATH, 0x3
0685  1C03     BTFSS STATUS, 0x0
0686  2E8C     GOTO 0x68C
621:                                       estadofallacorriente = CORRIENTENORMAL;
0687  1683     BSF STATUS, 0x5
0688  01C3     CLRF m
0689  0AC3     INCF m, F
622:                                       cuenta_tiempofalla = 0;
068A  01BD     CLRF f2
623:                                   } else {
068B  2E9C     GOTO 0x69C
624:                                       //aca verifica si la falla est presente mucho tiempo con tiempofalla
625:                                       if (indica_tiempo_falla == 0) {
068C  1683     BSF STATUS, 0x5
068D  08C8     MOVF sp, F
068E  1D03     BTFSS STATUS, 0x2
068F  2E96     GOTO 0x696
626:                                           if (cuenta_tiempofalla == 0) {
0690  08BD     MOVF f2, F
0691  1D03     BTFSS STATUS, 0x2
0692  2E9C     GOTO 0x69C
627:                                               cuenta_tiempofalla = tiempofalla;
0693  084D     MOVF 0x4D, W
0694  00BD     MOVWF f2
0695  2E9C     GOTO 0x69C
628:                                           }
629:                                       } else {
630:                                           //Expiro el tiempo de falla con una falla de sobrecorriente, debo apagar la bomba
631:                                           estadofallacorriente = FALLACORRIENTE;
0696  01C3     CLRF m
632:                                           indica_tiempo_falla = 0;
0697  01C8     CLRF sp
633:                                           cuenta_tiempofalla = 0;
0698  01BD     CLRF f2
634:                                           indica_secuencia_arranque = 0;
0699  01C7     CLRF y
635:                                           tiempo_secuencia_arranque = 0;
069A  01CB     CLRF 0x4B
636:                                           bandera_orden_Alarma_bomba = 0; //cambia la bandera de orden de encendido de bomba
069B  01B7     CLRF sign
637:                                       }
638:           
639:           
640:                                   }
641:                                   if (mediciondecorriente >= CORRIENTENORMALMINIMA) {
069C  0823     MOVF 0x23, W
069D  1283     BCF STATUS, 0x5
069E  00A7     MOVWF x
069F  1683     BSF STATUS, 0x5
06A0  0822     MOVF 0x22, W
06A1  1283     BCF STATUS, 0x5
06A2  00A6     MOVWF y
06A3  1683     BSF STATUS, 0x5
06A4  0821     MOVF 0x21, W
06A5  1283     BCF STATUS, 0x5
06A6  00A5     MOVWF dato
06A7  1683     BSF STATUS, 0x5
06A8  0820     MOVF 0x20, W
06A9  1283     BCF STATUS, 0x5
06AA  00A4     MOVWF x
06AB  303F     MOVLW 0x3F
06AC  00AB     MOVWF Data
06AD  3080     MOVLW 0x80
06AE  00AA     MOVWF year
06AF  01A9     CLRF mth
06B0  01A8     CLRF i
06B1  160A     BSF PCLATH, 0x4
06B2  118A     BCF PCLATH, 0x3
06B3  204A     CALL 0x4A
06B4  120A     BCF PCLATH, 0x4
06B5  118A     BCF PCLATH, 0x3
06B6  1C03     BTFSS STATUS, 0x0
06B7  2EC8     GOTO 0x6C8
642:                                       estadonivel = NIVELNORMAL;
06B8  1683     BSF STATUS, 0x5
06B9  01C5     CLRF a
06BA  0AC5     INCF a, F
643:                                       //Ac debo apagar la bomba cuando pase el tiempo de encendido de la bomba
644:                                       if (horarioapagado.hrs == horarioactual.hrs && horarioapagado.min == horarioactual.min) {
06BB  0826     MOVF y, W
06BC  065D     XORWF 0x5D, W
06BD  1D03     BTFSS STATUS, 0x2
06BE  2ECD     GOTO 0x6CD
06BF  0825     MOVF dato, W
06C0  065C     XORWF f1, W
06C1  1D03     BTFSS STATUS, 0x2
06C2  2ECD     GOTO 0x6CD
645:                                           indica_secuencia_arranque = 0;
06C3  01C7     CLRF y
646:                                           tiempo_secuencia_arranque = 0;
06C4  01CB     CLRF 0x4B
647:                                           bandera_orden_Alarma_bomba = 0;
06C5  01B7     CLRF sign
648:                                           activabomba = APAGABOMBA;
06C6  01AC     CLRF sec
06C7  2ECD     GOTO 0x6CD
649:                                       }
650:                                   } else {
651:           
652:                                       indica_secuencia_arranque = 0;
06C8  1683     BSF STATUS, 0x5
06C9  01C7     CLRF y
653:                                       tiempo_secuencia_arranque = 0;
06CA  01CB     CLRF 0x4B
654:                                       bandera_orden_Alarma_bomba = 0;
06CB  01B7     CLRF sign
655:                                       estadonivel = NIVELBAJO;
06CC  01C5     CLRF a
656:           
657:                                   }
658:                               }
659:                           } else {
660:                               indica_secuencia_arranque = 0;
661:                               tiempo_secuencia_arranque = 0;
662:                               activabomba = APAGABOMBA;
663:                           }
664:                       }
665:           
666:           
667:                   }
668:           
669:           
670:           
671:                   // </editor-fold>
672:           
673:                   // <editor-fold defaultstate="collapsed" desc="Actualiza Display">
674:                   //Actualiza Display
675:                   /////////////////////////////////////////////
676:                   if (refrescadisplay) {
06CD  084A     MOVF f, W
06CE  1903     BTFSC STATUS, 0x2
06CF  2F1F     GOTO 0x71F
677:                       vGotoxyLCD(1, 1);
06D0  1283     BCF STATUS, 0x5
06D1  3001     MOVLW 0x1
06D2  01A6     CLRF y
06D3  0AA6     INCF y, F
06D4  120A     BCF PCLATH, 0x4
06D5  158A     BSF PCLATH, 0x3
06D6  209C     CALL 0x9C
06D7  120A     BCF PCLATH, 0x4
06D8  118A     BCF PCLATH, 0x3
678:                       cadena = cadenaamostrar;
06D9  30A6     MOVLW 0xA6
06DA  1683     BSF STATUS, 0x5
06DB  00A9     MOVWF mth
06DC  3001     MOVLW 0x1
06DD  00AA     MOVWF year
679:                       while (*cadena != '\0')
06DE  0829     MOVF mth, W
06DF  0084     MOVWF FSR
06E0  1783     BSF STATUS, 0x7
06E1  1C2A     BTFSS year, 0x0
06E2  1383     BCF STATUS, 0x7
06E3  0880     MOVF INDF, F
06E4  1903     BTFSC STATUS, 0x2
06E5  2EF7     GOTO 0x6F7
06F6  2EDE     GOTO 0x6DE
680:                           vLCD_Putc(*cadena++);
06E6  0829     MOVF mth, W
06E7  0084     MOVWF FSR
06E8  1783     BSF STATUS, 0x7
06E9  1C2A     BTFSS year, 0x0
06EA  1383     BCF STATUS, 0x7
06EB  0800     MOVF INDF, W
06EC  120A     BCF PCLATH, 0x4
06ED  158A     BSF PCLATH, 0x3
06EE  20BF     CALL 0xBF
06EF  120A     BCF PCLATH, 0x4
06F0  118A     BCF PCLATH, 0x3
06F1  1683     BSF STATUS, 0x5
06F2  1303     BCF STATUS, 0x6
06F3  0AA9     INCF mth, F
06F4  1903     BTFSC STATUS, 0x2
06F5  0AAA     INCF year, F
681:                       vGotoxyLCD(1, 2);
06F7  3002     MOVLW 0x2
06F8  1283     BCF STATUS, 0x5
06F9  00A6     MOVWF y
06FA  3001     MOVLW 0x1
06FB  120A     BCF PCLATH, 0x4
06FC  158A     BSF PCLATH, 0x3
06FD  209C     CALL 0x9C
06FE  120A     BCF PCLATH, 0x4
06FF  118A     BCF PCLATH, 0x3
682:                       cadena = cadenaamostrar2;
0700  30CE     MOVLW 0xCE
0701  1683     BSF STATUS, 0x5
0702  00A9     MOVWF mth
0703  01AA     CLRF year
683:                       while (*cadena != '\0')
0704  0829     MOVF mth, W
0705  0084     MOVWF FSR
0706  1783     BSF STATUS, 0x7
0707  1C2A     BTFSS year, 0x0
0708  1383     BCF STATUS, 0x7
0709  0880     MOVF INDF, F
070A  1903     BTFSC STATUS, 0x2
070B  2F1D     GOTO 0x71D
071C  2F04     GOTO 0x704
684:                           vLCD_Putc(*cadena++);
070C  0829     MOVF mth, W
070D  0084     MOVWF FSR
070E  1783     BSF STATUS, 0x7
070F  1C2A     BTFSS year, 0x0
0710  1383     BCF STATUS, 0x7
0711  0800     MOVF INDF, W
0712  120A     BCF PCLATH, 0x4
0713  158A     BSF PCLATH, 0x3
0714  20BF     CALL 0xBF
0715  120A     BCF PCLATH, 0x4
0716  118A     BCF PCLATH, 0x3
0717  1683     BSF STATUS, 0x5
0718  1303     BCF STATUS, 0x6
0719  0AA9     INCF mth, F
071A  1903     BTFSC STATUS, 0x2
071B  0AAA     INCF year, F
685:                       haycambio = 0;
071D  01C6     CLRF dia
686:                       refrescadisplay = 0;
071E  01CA     CLRF f
687:                   }
688:                   ////////////////////////////////////////////////
689:                   //Fin Actualiza Display
690:                   // </editor-fold>
691:           
692:                   // <editor-fold defaultstate="collapsed" desc="Graba datos">
693:                   // <editor-fold defaultstate="collapsed" desc="Graba Nuevos datos en el RTC">
694:                   //Graba Nuevos datos en el RC
695:                   /////////////////////////////////////////////////
696:                   if (bandera_graba_global) {
071F  0831     MOVF 0x31, W
0720  1903     BTFSC STATUS, 0x2
0721  2F72     GOTO 0x772
697:                       if (bandera_graba_hora) {
0722  0832     MOVF divisor, W
0723  1903     BTFSC STATUS, 0x2
0724  2F5B     GOTO 0x75B
698:                           if (horario == &horarioactual) {
0725  087D     MOVF horario, W
0726  3ADB     XORLW 0xDB
0727  1D03     BTFSS STATUS, 0x2
0728  2F3F     GOTO 0x73F
699:                               isl1208_set_time((*horario).hrs, (*horario).min, 00);
0729  0A7D     INCF horario, W
072A  0084     MOVWF FSR
072B  1383     BCF STATUS, 0x7
072C  0800     MOVF INDF, W
072D  1283     BCF STATUS, 0x5
072E  00AB     MOVWF Data
072F  01AC     CLRF sec
0730  087D     MOVF horario, W
0731  3E02     ADDLW 0x2
0732  0084     MOVWF FSR
0733  0800     MOVF INDF, W
0734  120A     BCF PCLATH, 0x4
0735  158A     BSF PCLATH, 0x3
0736  245B     CALL 0x45B
0737  120A     BCF PCLATH, 0x4
0738  118A     BCF PCLATH, 0x3
700:                               buzzer_on(3);
0739  3003     MOVLW 0x3
073A  160A     BSF PCLATH, 0x4
073B  158A     BSF PCLATH, 0x3
073C  277D     CALL 0x77D
073D  120A     BCF PCLATH, 0x4
073E  118A     BCF PCLATH, 0x3
701:                           }
702:                           if (horario == &horarioenc) {
073F  087D     MOVF horario, W
0740  3ADE     XORLW 0xDE
0741  1903     BTFSC STATUS, 0x2
0742  2F45     GOTO 0x745
0743  1683     BSF STATUS, 0x5
0744  2F5B     GOTO 0x75B
703:                               isl1208_set_time_enc((*horario).hrs, (*horario).min, 00);
0745  0A7D     INCF horario, W
0746  0084     MOVWF FSR
0747  1383     BCF STATUS, 0x7
0748  0800     MOVF INDF, W
0749  1283     BCF STATUS, 0x5
074A  00AB     MOVWF Data
074B  01AC     CLRF sec
074C  087D     MOVF horario, W
074D  3E02     ADDLW 0x2
074E  0084     MOVWF FSR
074F  0800     MOVF INDF, W
0750  120A     BCF PCLATH, 0x4
0751  158A     BSF PCLATH, 0x3
0752  2432     CALL 0x432
0753  120A     BCF PCLATH, 0x4
0754  118A     BCF PCLATH, 0x3
704:                               //TODO isl1208_set_dow_enc(&fechaenc.dow);
705:                               buzzer_on(3);
0755  3003     MOVLW 0x3
0756  160A     BSF PCLATH, 0x4
0757  158A     BSF PCLATH, 0x3
0758  277D     CALL 0x77D
0759  120A     BCF PCLATH, 0x4
075A  118A     BCF PCLATH, 0x3
706:                           }
707:                       }
708:                       if (bandera_graba_fecha) {
075B  1683     BSF STATUS, 0x5
075C  0830     MOVF quotient, W
075D  1903     BTFSC STATUS, 0x2
075E  2F72     GOTO 0x772
709:                           isl1208_set_date(&fecha.day, &fecha.month, &fecha.yr, &fecha.dow);
075F  306D     MOVLW 0x6D
0760  1283     BCF STATUS, 0x5
0761  00AB     MOVWF Data
0762  306E     MOVLW 0x6E
0763  00AC     MOVWF sec
0764  306F     MOVLW 0x6F
0765  00AD     MOVWF hr
0766  306C     MOVLW 0x6C
0767  120A     BCF PCLATH, 0x4
0768  158A     BSF PCLATH, 0x3
0769  2497     CALL 0x497
076A  120A     BCF PCLATH, 0x4
076B  118A     BCF PCLATH, 0x3
710:                           buzzer_on(3);
076C  3003     MOVLW 0x3
076D  160A     BSF PCLATH, 0x4
076E  158A     BSF PCLATH, 0x3
076F  277D     CALL 0x77D
0770  120A     BCF PCLATH, 0x4
0771  118A     BCF PCLATH, 0x3
711:                       }
712:                   }
713:                   //Si no hay datos para grabar en hora y fecha actualizo la hora y la fecha del RTC
714:                   if (actualizo_datos_rtc && bandera_graba_hora == 0 && bandera_graba_fecha == 0) {
0772  1683     BSF STATUS, 0x5
0773  082E     MOVF day, W
0774  1903     BTFSC STATUS, 0x2
0775  2F93     GOTO 0x793
0776  08B2     MOVF divisor, F
0777  1D03     BTFSS STATUS, 0x2
0778  2F93     GOTO 0x793
0779  08B0     MOVF quotient, F
077A  1D03     BTFSS STATUS, 0x2
077B  2F93     GOTO 0x793
715:                       lee_y_transmite_date_and_time();
077C  120A     BCF PCLATH, 0x4
077D  158A     BSF PCLATH, 0x3
077E  2207     CALL 0x207
077F  120A     BCF PCLATH, 0x4
0780  118A     BCF PCLATH, 0x3
716:                       isl1208_get_time_enc(&horarioenc.hrs, &horarioenc.min, &horarioenc.sec);
0781  30DF     MOVLW 0xDF
0782  1283     BCF STATUS, 0x5
0783  00A9     MOVWF mth
0784  30DE     MOVLW 0xDE
0785  00AA     MOVWF year
0786  30E0     MOVLW 0xE0
0787  120A     BCF PCLATH, 0x4
0788  158A     BSF PCLATH, 0x3
0789  238B     CALL 0x38B
078A  120A     BCF PCLATH, 0x4
078B  118A     BCF PCLATH, 0x3
717:                       isl1208_get_dow_enc(&fechaenc.dow);
078C  30DA     MOVLW 0xDA
078D  120A     BCF PCLATH, 0x4
078E  158A     BSF PCLATH, 0x3
078F  2330     CALL 0x330
0790  120A     BCF PCLATH, 0x4
0791  118A     BCF PCLATH, 0x3
718:                       actualizo_datos_rtc = 0;
0792  01AE     CLRF day
719:                   }
720:                   bandera_graba_hora = 0;
0793  01B2     CLRF divisor
721:                   bandera_graba_fecha = 0;
0794  01B0     CLRF quotient
722:                   //////////////////////////////////////////////////////////////////
723:                   //Finaliza Graba Nuevos datos en el RTC
724:                   // </editor-fold>
725:           
726:                   // <editor-fold defaultstate="collapsed" desc="Graba Nuevos datos en la EEPROM DEL PIC">
727:                   //DIRECCION 0: periodoencendido(cada cuanto se enciende la bomba en automatico), de 0 a 6 dias,
728:                   //DIRECCION 1: tiempoencendido (cuanto tiempo permanece encendida la bomba en automatico) 0 a 60 minutos
729:                   //DIRECCION 2: usa_falla_de_corriente (dice si se usa falla de corriente o no)
730:                   //DIRECCION 3: tiempofalla (cuanto tiempo puede estar en falla de corriente antes de apagar la bomba por seguridad) 0 a 10 segundos
731:           
732:                   if (bandera_graba_global) {
0795  0831     MOVF 0x31, W
0796  1903     BTFSC STATUS, 0x2
0797  2FE5     GOTO 0x7E5
733:                       di();
0798  138B     BCF INTCON, 0x7
734:                       if (bandera_graba_periodoencendido) {
0799  0833     MOVF 0x33, W
079A  1903     BTFSC STATUS, 0x2
079B  2FAB     GOTO 0x7AB
735:                           eeprom_write(0, periodoencendido);
079C  086E     MOVF 0x6E, W
079D  1283     BCF STATUS, 0x5
079E  00A4     MOVWF x
079F  3000     MOVLW 0x0
07A0  160A     BSF PCLATH, 0x4
07A1  158A     BSF PCLATH, 0x3
07A2  27B8     CALL 0x7B8
07A3  120A     BCF PCLATH, 0x4
07A4  118A     BCF PCLATH, 0x3
736:                           buzzer_on(3);
07A5  3003     MOVLW 0x3
07A6  160A     BSF PCLATH, 0x4
07A7  158A     BSF PCLATH, 0x3
07A8  277D     CALL 0x77D
07A9  120A     BCF PCLATH, 0x4
07AA  118A     BCF PCLATH, 0x3
737:                       }
738:                       if (bandera_graba_tiempoencendido) {
07AB  1683     BSF STATUS, 0x5
07AC  0834     MOVF dividend, W
07AD  1903     BTFSC STATUS, 0x2
07AE  2FBE     GOTO 0x7BE
739:                           eeprom_write(1, tiempoencendido);
07AF  084C     MOVF 0x4C, W
07B0  1283     BCF STATUS, 0x5
07B1  00A4     MOVWF x
07B2  3001     MOVLW 0x1
07B3  160A     BSF PCLATH, 0x4
07B4  158A     BSF PCLATH, 0x3
07B5  27B8     CALL 0x7B8
07B6  120A     BCF PCLATH, 0x4
07B7  118A     BCF PCLATH, 0x3
740:                           buzzer_on(3);
07B8  3003     MOVLW 0x3
07B9  160A     BSF PCLATH, 0x4
07BA  158A     BSF PCLATH, 0x3
07BB  277D     CALL 0x77D
07BC  120A     BCF PCLATH, 0x4
07BD  118A     BCF PCLATH, 0x3
741:                       }
742:                       if (bandera_graba_usa_falla_de_corriente) {
07BE  1683     BSF STATUS, 0x5
07BF  0836     MOVF counter, W
07C0  1903     BTFSC STATUS, 0x2
07C1  2FD1     GOTO 0x7D1
743:                           eeprom_write(2, usa_falla_de_corriente);
07C2  0863     MOVF 0x63, W
07C3  1283     BCF STATUS, 0x5
07C4  00A4     MOVWF x
07C5  3002     MOVLW 0x2
07C6  160A     BSF PCLATH, 0x4
07C7  158A     BSF PCLATH, 0x3
07C8  27B8     CALL 0x7B8
07C9  120A     BCF PCLATH, 0x4
07CA  118A     BCF PCLATH, 0x3
744:                           buzzer_on(3);
07CB  3003     MOVLW 0x3
07CC  160A     BSF PCLATH, 0x4
07CD  158A     BSF PCLATH, 0x3
07CE  277D     CALL 0x77D
07CF  120A     BCF PCLATH, 0x4
07D0  118A     BCF PCLATH, 0x3
745:                       }
746:                       if (bandera_graba_tiempofalla) {
07D1  1683     BSF STATUS, 0x5
07D2  0835     MOVF 0x35, W
07D3  1903     BTFSC STATUS, 0x2
07D4  2FE4     GOTO 0x7E4
747:                           eeprom_write(3, tiempofalla);
07D5  084D     MOVF 0x4D, W
07D6  1283     BCF STATUS, 0x5
07D7  00A4     MOVWF x
07D8  3003     MOVLW 0x3
07D9  160A     BSF PCLATH, 0x4
07DA  158A     BSF PCLATH, 0x3
07DB  27B8     CALL 0x7B8
07DC  120A     BCF PCLATH, 0x4
07DD  118A     BCF PCLATH, 0x3
748:                           buzzer_on(3);
07DE  3003     MOVLW 0x3
07DF  160A     BSF PCLATH, 0x4
07E0  158A     BSF PCLATH, 0x3
07E1  277D     CALL 0x77D
07E2  120A     BCF PCLATH, 0x4
07E3  118A     BCF PCLATH, 0x3
749:                       }
750:                       ei();
07E4  178B     BSF INTCON, 0x7
751:                   }
752:                   bandera_graba_global = 0;
07E5  1683     BSF STATUS, 0x5
07E6  01B1     CLRF 0x31
753:                   bandera_graba_periodoencendido = 0;
07E7  01B3     CLRF 0x33
754:                   bandera_graba_tiempoencendido = 0;
07E8  01B4     CLRF dividend
755:                   bandera_graba_usa_falla_de_corriente = 0;
07E9  01B6     CLRF counter
756:                   bandera_graba_tiempofalla = 0;
07EA  01B5     CLRF 0x35
757:                   // </editor-fold>
758:                   // </editor-fold>
759:                   NOP();
07EB  0000     NOP
760:                   NOP();
07EC  0000     NOP
761:               }
762:           }
763:           
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/interrupts.c  -------------------------
1:             
2:             /******************************************************************************/
3:             /*Files to Include                                                            */
4:             /******************************************************************************/
5:             
6:             #if defined(__XC)
7:             #include <xc.h>         /* XC8 General Include File */
8:             #elif defined(HI_TECH_C)
9:             #include <htc.h>        /* HiTech General Include File */
10:            #endif
11:            #include <stdbool.h>        /* For true/false definition */
12:            #include <stdint.h>
13:            #include "user.h"
14:            #include "system.h"
15:            
16:            #include "Pulsadores.h"
17:            #include "pwm.h"
18:            #include "adcPic16.h"
19:            #include "_isl1208.h"
20:            /* Interrupt Routines                                                         */
21:            
22:            /******************************************************************************/
23:            
24:            void interrupt isr(void) {
0004  00FE     MOVWF 0x7E
0005  0E03     SWAPF STATUS, W
0006  1283     BCF STATUS, 0x5
0007  1303     BCF STATUS, 0x6
0008  00A1     MOVWF 0x21
0009  0804     MOVF FSR, W
000A  00A2     MOVWF 0x22
000B  080A     MOVF PCLATH, W
000C  00A3     MOVWF 0x23
000D  160A     BSF PCLATH, 0x4
000E  118A     BCF PCLATH, 0x3
000F  2C05     GOTO 0x405
0010  120A     BCF PCLATH, 0x4
0011  118A     BCF PCLATH, 0x3
0012  2813     GOTO 0x13
25:                if (ADIF && ADIE) {
1405  1F0C     BTFSS PIR1, 0x6
1406  2C2B     GOTO 0x42B
1407  1683     BSF STATUS, 0x5
1408  1F0C     BTFSS PIR1, 0x6
1409  2C2B     GOTO 0x42B
26:                    // <editor-fold defaultstate="collapsed" desc="interrupcion adc">
27:                    if (getADCChannel() == MIDECORRIENTE) {
140A  27E4     CALL 0x7E4
140B  160A     BSF PCLATH, 0x4
140C  118A     BCF PCLATH, 0x3
140D  3800     IORLW 0x0
140E  1D03     BTFSS STATUS, 0x2
140F  2C1A     GOTO 0x41A
28:                        medidaI_adc = adcRead();
1410  2796     CALL 0x796
1411  160A     BSF PCLATH, 0x4
1412  118A     BCF PCLATH, 0x3
1413  0871     MOVF canal, W
1414  1703     BSF STATUS, 0x6
1415  00A3     MOVWF 0x23
1416  0870     MOVF tiempo, W
1417  00A2     MOVWF 0x22
29:                        setADCChannel(MIDETENSION);
1418  3001     MOVLW 0x1
1419  2C23     GOTO 0x423
30:                    } else {
31:                        medidaV_adc = adcRead();
141A  2796     CALL 0x796
141B  160A     BSF PCLATH, 0x4
141C  118A     BCF PCLATH, 0x3
141D  0871     MOVF canal, W
141E  1703     BSF STATUS, 0x6
141F  00A5     MOVWF dato
1420  0870     MOVF tiempo, W
1421  00A4     MOVWF x
32:                        /*TODO debo realizar un promedio en las mediciones para filtrar las
33:                        variaciones rpidas de tensin*/
34:                        setADCChannel(MIDECORRIENTE);
1422  3000     MOVLW 0x0
1423  27F3     CALL 0x7F3
1424  160A     BSF PCLATH, 0x4
1425  118A     BCF PCLATH, 0x3
35:                    }
36:                    ADIF = 0;
1426  130C     BCF PIR1, 0x6
37:                    cambio_de_canal = 1;
1427  1683     BSF STATUS, 0x5
1428  01BA     CLRF sign
1429  0ABA     INCF sign, F
38:                    // </editor-fold>
39:                } else if (INTF && INTE) { // INTERRUPCION por EXT2 Clock Out --------------------------------------------
142A  2EC5     GOTO 0x6C5
142B  188B     BTFSC INTCON, 0x1
142C  1E0B     BTFSS INTCON, 0x4
142D  2C33     GOTO 0x433
40:                    // <editor-fold defaultstate="collapsed" desc="interrupcion intf">
41:                    alarma_encendido = SIALARMA;
142E  1683     BSF STATUS, 0x5
142F  01AF     CLRF sign
1430  0AAF     INCF sign, F
42:                    INTF = 0;
1431  108B     BCF INTCON, 0x1
43:                    // </editor-fold>
44:                } else if (T0IF && T0IE) {
1432  2EC5     GOTO 0x6C5
1433  190B     BTFSC INTCON, 0x2
1434  1E8B     BTFSS INTCON, 0x5
1435  2EC5     GOTO 0x6C5
45:                    // <editor-fold defaultstate="collapsed" desc="interrupcion timer0">
46:                    //Interrupcion por desborde del timer0. Tal como esta configurado, se el timer desborda cada
47:                    //0.0032768seg o sea 3.2768 ms, por lo tanto para que pase alrededor de 0.5segundo, se debe entrar 150 veces
48:                    //como con un unsigned int no funciona uso unsigned char y solo hasta 150
49:                    //cada 3ms realizamos una conversion analogica para obtener la medida de corriente
50:                    if (cambio_de_canal)
1436  1683     BSF STATUS, 0x5
1437  083A     MOVF sign, W
1438  1903     BTFSC STATUS, 0x2
1439  2C3C     GOTO 0x43C
51:                        cambio_de_canal = 0;
143A  01BA     CLRF sign
143B  2C3F     GOTO 0x43F
52:                    else
53:                        startADC();
143C  27EB     CALL 0x7EB
143D  160A     BSF PCLATH, 0x4
143E  118A     BCF PCLATH, 0x3
54:                    if (cuenta40ms < 12) {
143F  300C     MOVLW 0xC
1440  1683     BSF STATUS, 0x5
1441  023B     SUBWF exp2, W
1442  1803     BTFSC STATUS, 0x0
1443  2C46     GOTO 0x446
55:                        cuenta40ms++;
1444  0ABB     INCF exp2, F
56:                    } else {
1445  2C9B     GOTO 0x49B
57:                        cuenta40ms = 0;
1446  01BB     CLRF exp2
58:                        if (activapwmpor > 0) {
1447  082D     MOVF hr, W
1448  1903     BTFSC STATUS, 0x2
1449  2C4C     GOTO 0x44C
59:                            activapwmpor--;
144A  03AD     DECF hr, F
60:                        } else {
144B  2C51     GOTO 0x451
61:                            buzzer_off();
144C  27EE     CALL 0x7EE
144D  160A     BSF PCLATH, 0x4
144E  118A     BCF PCLATH, 0x3
62:                            activapwmpor = 0;
144F  1683     BSF STATUS, 0x5
1450  01AD     CLRF hr
63:                        }
64:                        if (cuenta500ms < 11) {
1451  300B     MOVLW 0xB
1452  023C     SUBWF exp1, W
1453  1803     BTFSC STATUS, 0x0
1454  2C57     GOTO 0x457
65:                            cuenta500ms++;
1455  0ABC     INCF exp1, F
66:            
67:            
68:                        } else {
1456  2C9B     GOTO 0x49B
69:                            cuenta500ms = 0;
1457  3000     MOVLW 0x0
1458  01BC     CLRF exp1
70:                            flanco = !flanco;
1457  3000     MOVLW 0x0
1459  08FC     MOVF flanco, F
145A  1903     BTFSC STATUS, 0x2
145B  3001     MOVLW 0x1
145C  00FC     MOVWF flanco
71:            
72:                            //para que entre a lo que sigue cada 1 segundo aprovecho a leer el valor de flanco
73:                            if (flanco) {
145D  087C     MOVF flanco, W
145E  1903     BTFSC STATUS, 0x2
145F  2C7B     GOTO 0x47B
74:                                if (indica_secuencia_arranque) {
1460  0847     MOVF y, W
1461  1903     BTFSC STATUS, 0x2
1462  2C6C     GOTO 0x46C
75:                                    if (cuenta_tiempofalla > 0) {
1463  083D     MOVF f2, W
1464  1903     BTFSC STATUS, 0x2
1465  2C67     GOTO 0x467
76:                                        cuenta_tiempofalla--;
1466  03BD     DECF f2, F
77:                                    }
78:                                    if (cuenta_tiempofalla == 0) {
1467  08BD     MOVF f2, F
1468  1D03     BTFSS STATUS, 0x2
1469  2C6C     GOTO 0x46C
79:                                        indica_tiempo_falla = 1;
146A  01C8     CLRF sp
146B  0AC8     INCF sp, F
80:                                    }
81:                                }
82:                                if (bandera_orden_on_off_bomba || bandera_orden_Alarma_bomba) {
146C  08B8     MOVF mes, F
146D  1903     BTFSC STATUS, 0x2
146E  0837     MOVF sign, W
146F  1903     BTFSC STATUS, 0x2
1470  2C7D     GOTO 0x47D
83:                                    if (tiempo_secuencia_arranque > 0) {
1471  084B     MOVF 0x4B, W
1472  1903     BTFSC STATUS, 0x2
1473  2C75     GOTO 0x475
84:                                        tiempo_secuencia_arranque--;
1474  03CB     DECF 0x4B, F
85:                                    }
86:                                    if (tiempo_secuencia_arranque == 0) {
1475  08CB     MOVF 0x4B, F
1476  1D03     BTFSS STATUS, 0x2
1477  2C7D     GOTO 0x47D
87:                                        indica_secuencia_arranque = 1;
1478  01C7     CLRF y
1479  0AC7     INCF y, F
147A  2C7D     GOTO 0x47D
88:                                    }
89:                                }
90:                            } else {
91:                                actualizo_datos_rtc = 1;
147B  01AE     CLRF day
147C  0AAE     INCF day, F
92:                            }
147D  303C     MOVLW 0x3C
93:            
94:                            refrescadisplay = 1;
147E  01CA     CLRF f
147F  0ACA     INCF f, F
95:                            if (cuentasegundos < 60) {
147D  303C     MOVLW 0x3C
1480  0241     SUBWF f1, W
1481  1803     BTFSC STATUS, 0x0
1482  2C85     GOTO 0x485
96:            
97:                                cuentasegundos++;
1483  0AC1     INCF f1, F
98:                            } else {
1484  2C9B     GOTO 0x49B
99:                                cuentasegundos = 0;
1485  303C     MOVLW 0x3C
1486  01C1     CLRF f1
100:                               if (cuentaminutos < 60) {
1485  303C     MOVLW 0x3C
1487  0240     SUBWF 0x40, W
1488  1803     BTFSC STATUS, 0x0
1489  2C8C     GOTO 0x48C
101:                                   cuentaminutos++;
148A  0AC0     INCF 0x40, F
102:                               } else {
148B  2C9B     GOTO 0x49B
103:                                   cuentaminutos = 0;
148C  3018     MOVLW 0x18
148D  01C0     CLRF 0x40
104:                                   if (cuentahoras < 24) {
148C  3018     MOVLW 0x18
148E  023F     SUBWF 0x3F, W
148F  1803     BTFSC STATUS, 0x0
1490  2C93     GOTO 0x493
105:                                       cuentahoras++;
1491  0ABF     INCF 0x3F, F
106:                                   } else
1492  2C94     GOTO 0x494
107:                                       cuentahoras = 0;
1493  01BF     CLRF 0x3F
108:                                   if (cuentadias < 30) {
1494  301E     MOVLW 0x1E
1495  023E     SUBWF 0x3E, W
1496  1803     BTFSC STATUS, 0x0
1497  2C9A     GOTO 0x49A
109:                                       cuentadias++;
1498  0ABE     INCF 0x3E, F
110:                                   } else {
1499  2C9B     GOTO 0x49B
111:                                       cuentadias = 0;
149A  01BE     CLRF 0x3E
112:                                   }
113:                               }
114:           
115:                           }
116:                       }
117:                   }
118:                   // <editor-fold defaultstate="collapsed" desc="boton subir">
119:                   static char maximodia;
120:                   if (Pulsacion(0, BOTON_Subir, CON_REPETICION, LOGICA_INVERSA)) {
149B  3000     MOVLW 0x0
149C  1283     BCF STATUS, 0x5
149D  1906     BTFSC PORTB, 0x2
149E  3001     MOVLW 0x1
149F  00F5     MOVWF Pin
14A0  3000     MOVLW 0x0
14A1  01F6     CLRF TipoPin
14A2  0AF6     INCF TipoPin, F
14A3  01F7     CLRF Logica
14A4  0AF7     INCF Logica, F
14A5  26D0     CALL 0x6D0
14A6  160A     BSF PCLATH, 0x4
14A7  118A     BCF PCLATH, 0x3
14A8  3A00     XORLW 0x0
14A9  1903     BTFSC STATUS, 0x2
14AA  2D88     GOTO 0x588
121:                       haycambio = 1;
14AB  1683     BSF STATUS, 0x5
14AC  1303     BCF STATUS, 0x6
14AD  01C6     CLRF dia
14AE  0AC6     INCF dia, F
122:                       refrescadisplay = 1;
14AF  01CA     CLRF f
14B0  0ACA     INCF f, F
123:                       switch (modificafecha) {
14B1  2D31     GOTO 0x531
1531  086D     MOVF 0x6D, W
1532  0084     MOVWF FSR
1533  300A     MOVLW 0xA
1534  0204     SUBWF FSR, W
1535  1803     BTFSC STATUS, 0x0
1536  2D3E     GOTO 0x53E
1537  3019     MOVLW 0x19
1538  008A     MOVWF PCLATH
1539  1003     BCF STATUS, 0x0
153A  0D04     RLF FSR, W
153B  0704     ADDWF FSR, W
153C  3E84     ADDLW 0x84
153D  0082     MOVWF PCL
1984  160A     BSF PCLATH, 0x4
1985  118A     BCF PCLATH, 0x3
1986  2CC1     GOTO 0x4C1
1987  160A     BSF PCLATH, 0x4
1988  118A     BCF PCLATH, 0x3
1989  2CB2     GOTO 0x4B2
198A  160A     BSF PCLATH, 0x4
198B  118A     BCF PCLATH, 0x3
198C  2CD9     GOTO 0x4D9
198D  160A     BSF PCLATH, 0x4
198E  118A     BCF PCLATH, 0x3
198F  2CE5     GOTO 0x4E5
1990  160A     BSF PCLATH, 0x4
1991  118A     BCF PCLATH, 0x3
1992  2CF1     GOTO 0x4F1
1993  160A     BSF PCLATH, 0x4
1994  118A     BCF PCLATH, 0x3
1995  2D3E     GOTO 0x53E
1996  160A     BSF PCLATH, 0x4
1997  118A     BCF PCLATH, 0x3
1998  2CFE     GOTO 0x4FE
1999  160A     BSF PCLATH, 0x4
199A  118A     BCF PCLATH, 0x3
199B  2D0E     GOTO 0x50E
199C  160A     BSF PCLATH, 0x4
199D  118A     BCF PCLATH, 0x3
199E  2D1A     GOTO 0x51A
199F  160A     BSF PCLATH, 0x4
19A0  118A     BCF PCLATH, 0x3
19A1  2D26     GOTO 0x526
124:                           case MINUTOS:
125:                               //haycambio = 1;
126:                               if ((*horario).min < 59) (*horario).min++;
14B2  0A7D     INCF horario, W
14B3  0084     MOVWF FSR
14B4  303B     MOVLW 0x3B
14B5  1383     BCF STATUS, 0x7
14B6  0200     SUBWF INDF, W
14B7  0A7D     INCF horario, W
14B9  1C03     BTFSS STATUS, 0x0
14BA  2CCC     GOTO 0x4CC
127:                               else
128:                                   if ((*horario).min == 59) (*horario).min = 0;
14B8  0084     MOVWF FSR
14BB  0800     MOVF INDF, W
14BC  3A3B     XORLW 0x3B
14BD  1D03     BTFSS STATUS, 0x2
14BE  2D3E     GOTO 0x53E
14BF  0A7D     INCF horario, W
14C0  2CD6     GOTO 0x4D6
129:                               break;
130:                           case HORA:
131:                               //haycambio = 1;
132:                               if ((*horario).hrs < 23) (*horario).hrs++;
14C1  087D     MOVF horario, W
14C2  3E02     ADDLW 0x2
14C3  0084     MOVWF FSR
14C4  3017     MOVLW 0x17
14C5  1383     BCF STATUS, 0x7
14C6  0200     SUBWF INDF, W
14C7  087D     MOVF horario, W
14C8  1803     BTFSC STATUS, 0x0
14C9  2CCE     GOTO 0x4CE
14CA  3E02     ADDLW 0x2
14CB  0084     MOVWF FSR
14CC  0A80     INCF INDF, F
14CD  2D3E     GOTO 0x53E
133:                               else
134:                                   if ((*horario).hrs == 23) (*horario).hrs = 0;
14CE  3E02     ADDLW 0x2
14CF  0084     MOVWF FSR
14D0  0800     MOVF INDF, W
14D1  3A17     XORLW 0x17
14D2  1D03     BTFSS STATUS, 0x2
14D3  2D3E     GOTO 0x53E
14D4  087D     MOVF horario, W
14D5  3E02     ADDLW 0x2
14D6  0084     MOVWF FSR
14D7  0180     CLRF INDF
14D8  2D3E     GOTO 0x53E
135:                               break;
136:                           case DIA:
137:                               //haycambio = 1;
138:                               if (fecha.day < maximodia) fecha.day++;
14D9  1283     BCF STATUS, 0x5
14DA  086B     MOVF maximodia, W
14DB  026C     SUBWF fecha, W
14DC  1C03     BTFSS STATUS, 0x0
14DD  2CE3     GOTO 0x4E3
139:                               else
140:                                   if (fecha.day == maximodia) fecha.day = 1;
14DE  086C     MOVF fecha, W
14DF  066B     XORWF maximodia, W
14E0  1D03     BTFSS STATUS, 0x2
14E1  2D3E     GOTO 0x53E
14E2  01EC     CLRF fecha
14E3  0AEC     INCF fecha, F
14E4  2D3E     GOTO 0x53E
141:                               break;
142:                           case MES:
143:                               //haycambio = 1;
144:                               if (fecha.month < 12) fecha.month++;
14E5  300C     MOVLW 0xC
14E6  1283     BCF STATUS, 0x5
14E7  026D     SUBWF 0x6D, W
14E8  1C03     BTFSS STATUS, 0x0
14E9  2CEF     GOTO 0x4EF
145:                               else
146:                                   if (fecha.month == 12) fecha.month = 1;
14EA  086D     MOVF 0x6D, W
14EB  3A0C     XORLW 0xC
14EC  1D03     BTFSS STATUS, 0x2
14ED  2D3E     GOTO 0x53E
14EE  01ED     CLRF 0x6D
14EF  0AED     INCF 0x6D, F
14F0  2D3E     GOTO 0x53E
147:                               break;
148:                           case ANIO:
149:                               //haycambio = 1;
150:                               if (fecha.yr < 99) fecha.yr++; //solamente vamos hasta el ao 00
14F1  3063     MOVLW 0x63
14F2  1283     BCF STATUS, 0x5
14F3  026E     SUBWF 0x6E, W
14F4  1803     BTFSC STATUS, 0x0
14F5  2CF8     GOTO 0x4F8
14F6  0AEE     INCF 0x6E, F
14F7  2D3E     GOTO 0x53E
151:                               else
152:                                   if (fecha.yr == 99) fecha.yr = 0; //solamente contamos desde el ao 99
14F8  086E     MOVF 0x6E, W
14F9  3A63     XORLW 0x63
14FA  1D03     BTFSS STATUS, 0x2
14FB  2D3E     GOTO 0x53E
14FC  01EE     CLRF 0x6E
14FD  2D3E     GOTO 0x53E
153:                               break;
154:                           case SINO:
155:                               *banderasino = !*banderasino;
14FE  0839     MOVF anio, W
14FF  0084     MOVWF FSR
1500  3000     MOVLW 0x0
1501  1383     BCF STATUS, 0x7
1502  0880     MOVF INDF, F
1503  1903     BTFSC STATUS, 0x2
1504  3001     MOVLW 0x1
1505  1283     BCF STATUS, 0x5
1506  00A0     MOVWF 0x20
1507  1683     BSF STATUS, 0x5
1508  0839     MOVF anio, W
1509  0084     MOVWF FSR
150A  1283     BCF STATUS, 0x5
150B  0820     MOVF 0x20, W
150C  0080     MOVWF INDF
156:                               break;
150D  2D3E     GOTO 0x53E
157:                           case TIEMPOENCENDIDO:
158:                               //haycambio = 1;
159:                               if (tiempoencendido < TIEMPOMAXIMOENCENDIDO) tiempoencendido++; //
150E  303C     MOVLW 0x3C
150F  024C     SUBWF 0x4C, W
1510  1803     BTFSC STATUS, 0x0
1511  2D14     GOTO 0x514
1512  0ACC     INCF 0x4C, F
1513  2D3E     GOTO 0x53E
160:                               else
161:                                   if (tiempoencendido == TIEMPOMAXIMOENCENDIDO) tiempoencendido = 0;
1514  084C     MOVF 0x4C, W
1515  3A3C     XORLW 0x3C
1516  1D03     BTFSS STATUS, 0x2
1517  2D3E     GOTO 0x53E
1518  01CC     CLRF 0x4C
1519  2D3E     GOTO 0x53E
162:                               break;
163:                           case TIEMPOFALLA:
164:                               //haycambio = 1;
165:                               if (tiempofalla < TIEMPOMAXIMOFALLA) tiempofalla++; //
151A  300A     MOVLW 0xA
151B  024D     SUBWF 0x4D, W
151C  1803     BTFSC STATUS, 0x0
151D  2D20     GOTO 0x520
151E  0ACD     INCF 0x4D, F
151F  2D3E     GOTO 0x53E
166:                               else
167:                                   if (tiempofalla == TIEMPOMAXIMOFALLA) tiempofalla = 0;
1520  084D     MOVF 0x4D, W
1521  3A0A     XORLW 0xA
1522  1D03     BTFSS STATUS, 0x2
1523  2D3E     GOTO 0x53E
1524  01CD     CLRF 0x4D
1525  2D3E     GOTO 0x53E
168:                               break;
169:                           case PERIODOENCENDIDO:
170:                               //haycambio = 1;
171:                               if (periodoencendido < TIEMPOMAXIMOPERIODO) periodoencendido++; //
1526  3007     MOVLW 0x7
1527  026E     SUBWF 0x6E, W
1528  1C03     BTFSS STATUS, 0x0
1529  2D2F     GOTO 0x52F
172:                               else
173:                                   if (periodoencendido == TIEMPOMAXIMOPERIODO) periodoencendido = 1;
152A  086E     MOVF 0x6E, W
152B  3A07     XORLW 0x7
152C  1D03     BTFSS STATUS, 0x2
152D  2D3E     GOTO 0x53E
152E  01EE     CLRF 0x6E
152F  0AEE     INCF 0x6E, F
1530  2D3E     GOTO 0x53E
174:                               break;
175:                           default:
176:                               break;
177:                       }
178:                       if (aniobisiesto(fecha.yr) && fecha.month == 2) {
153E  1283     BCF STATUS, 0x5
153F  086E     MOVF 0x6E, W
1540  279D     CALL 0x79D
1541  160A     BSF PCLATH, 0x4
1542  118A     BCF PCLATH, 0x3
1543  0877     MOVF Logica, W
1544  0476     IORWF TipoPin, W
1545  1903     BTFSC STATUS, 0x2
1546  2D4D     GOTO 0x54D
1547  086D     MOVF 0x6D, W
1548  3A02     XORLW 0x2
1549  1D03     BTFSS STATUS, 0x2
154A  2D4D     GOTO 0x54D
179:                           maximodia = 29;
154B  301D     MOVLW 0x1D
154C  2D52     GOTO 0x552
180:                       } else if (fecha.month == 2)
154D  086D     MOVF 0x6D, W
154E  3A02     XORLW 0x2
154F  1D03     BTFSS STATUS, 0x2
1550  2D53     GOTO 0x553
181:                           maximodia = 28;
1551  301C     MOVLW 0x1C
1552  00EB     MOVWF maximodia
182:                       if (fecha.month == 4 || fecha.month == 6 || fecha.month == 9 || fecha.month == 11) {
1553  086D     MOVF 0x6D, W
1554  3A04     XORLW 0x4
1555  1903     BTFSC STATUS, 0x2
1556  2D63     GOTO 0x563
1557  086D     MOVF 0x6D, W
1558  3A06     XORLW 0x6
1559  1903     BTFSC STATUS, 0x2
155A  2D63     GOTO 0x563
155B  086D     MOVF 0x6D, W
155C  3A09     XORLW 0x9
155D  1903     BTFSC STATUS, 0x2
155E  2D63     GOTO 0x563
155F  086D     MOVF 0x6D, W
1560  3A0B     XORLW 0xB
1561  1D03     BTFSS STATUS, 0x2
1562  2D65     GOTO 0x565
183:                           maximodia = 30;
1563  301E     MOVLW 0x1E
1564  00EB     MOVWF maximodia
184:                       }
185:                       if (fecha.month == 1 || fecha.month == 3 || fecha.month == 5 || fecha.month == 7 || fecha.month == 8 || fecha.month == 10 || fecha.month == 12) {
1565  036D     DECF 0x6D, W
1566  1903     BTFSC STATUS, 0x2
1567  2D80     GOTO 0x580
1568  086D     MOVF 0x6D, W
1569  3A03     XORLW 0x3
156A  1903     BTFSC STATUS, 0x2
156B  2D80     GOTO 0x580
156C  086D     MOVF 0x6D, W
156D  3A05     XORLW 0x5
156E  1903     BTFSC STATUS, 0x2
156F  2D80     GOTO 0x580
1570  086D     MOVF 0x6D, W
1571  3A07     XORLW 0x7
1572  1903     BTFSC STATUS, 0x2
1573  2D80     GOTO 0x580
1574  086D     MOVF 0x6D, W
1575  3A08     XORLW 0x8
1576  1903     BTFSC STATUS, 0x2
1577  2D80     GOTO 0x580
1578  086D     MOVF 0x6D, W
1579  3A0A     XORLW 0xA
157A  1903     BTFSC STATUS, 0x2
157B  2D80     GOTO 0x580
157C  086D     MOVF 0x6D, W
157D  3A0C     XORLW 0xC
157E  1D03     BTFSS STATUS, 0x2
157F  2D82     GOTO 0x582
186:                           maximodia = 31;
1580  301F     MOVLW 0x1F
1581  00EB     MOVWF maximodia
187:                       }
188:                       if (fecha.day > maximodia)
1582  086C     MOVF fecha, W
1583  026B     SUBWF maximodia, W
1584  1803     BTFSC STATUS, 0x0
1585  2D88     GOTO 0x588
189:                           fecha.day = maximodia;
1586  086B     MOVF maximodia, W
1587  00EC     MOVWF fecha
190:                   }
191:                   // </editor-fold>
192:                   // <editor-fold defaultstate="collapsed" desc="boton bajar">
193:                   if (Pulsacion(1, BOTON_Bajar, CON_REPETICION, LOGICA_INVERSA)) {
1588  3000     MOVLW 0x0
1589  1283     BCF STATUS, 0x5
158A  1303     BCF STATUS, 0x6
158B  1886     BTFSC PORTB, 0x1
158C  3001     MOVLW 0x1
158D  00F5     MOVWF Pin
158E  3001     MOVLW 0x1
158F  01F6     CLRF TipoPin
1590  0AF6     INCF TipoPin, F
1591  01F7     CLRF Logica
1592  0AF7     INCF Logica, F
1593  26D0     CALL 0x6D0
1594  160A     BSF PCLATH, 0x4
1595  118A     BCF PCLATH, 0x3
1596  3A00     XORLW 0x0
1597  1903     BTFSC STATUS, 0x2
1598  2E74     GOTO 0x674
194:                       haycambio = 1;
1599  1683     BSF STATUS, 0x5
159A  1303     BCF STATUS, 0x6
159B  01C6     CLRF dia
159C  0AC6     INCF dia, F
195:                       refrescadisplay = 1;
159D  01CA     CLRF f
159E  0ACA     INCF f, F
196:                       switch (modificafecha) {
159F  2E1D     GOTO 0x61D
161D  086D     MOVF 0x6D, W
161E  0084     MOVWF FSR
161F  300A     MOVLW 0xA
1620  0204     SUBWF FSR, W
1621  1803     BTFSC STATUS, 0x0
1622  2E2A     GOTO 0x62A
1623  3019     MOVLW 0x19
1624  008A     MOVWF PCLATH
1625  1003     BCF STATUS, 0x0
1626  0D04     RLF FSR, W
1627  0704     ADDWF FSR, W
1628  3EA2     ADDLW 0xA2
1629  0082     MOVWF PCL
19A2  160A     BSF PCLATH, 0x4
197:                           case MINUTOS:
198:                               //haycambio = 1;
199:                               if ((*horario).min > 0) (*horario).min--;
15A0  0A7D     INCF horario, W
15A1  0084     MOVWF FSR
15A2  1383     BCF STATUS, 0x7
15A3  0880     MOVF INDF, F
15A4  1903     BTFSC STATUS, 0x2
15A5  2DA8     GOTO 0x5A8
15A6  0A7D     INCF horario, W
15A7  2DBA     GOTO 0x5BA
200:                               else
201:                                   if ((*horario).min == 0) (*horario).min = 59;
15A8  0A7D     INCF horario, W
15A9  0084     MOVWF FSR
15AA  0880     MOVF INDF, F
15AB  1D03     BTFSS STATUS, 0x2
15AC  2E2A     GOTO 0x62A
15AD  0A7D     INCF horario, W
15AE  0084     MOVWF FSR
15AF  303B     MOVLW 0x3B
15B0  2DFA     GOTO 0x5FA
202:                               break;
203:                           case HORA:
204:                               //haycambio = 1;
205:                               if ((*horario).hrs > 0) (*horario).hrs--;
15B1  087D     MOVF horario, W
15B2  3E02     ADDLW 0x2
15B3  0084     MOVWF FSR
15B4  1383     BCF STATUS, 0x7
15B5  0880     MOVF INDF, F
15B6  1903     BTFSC STATUS, 0x2
15B7  2DBD     GOTO 0x5BD
15B8  087D     MOVF horario, W
15B9  3E02     ADDLW 0x2
15BA  0084     MOVWF FSR
15BB  0380     DECF INDF, F
15BC  2E2A     GOTO 0x62A
206:                               else
207:                                   if ((*horario).hrs == 0) (*horario).hrs = 23;
15BD  087D     MOVF horario, W
15BE  3E02     ADDLW 0x2
15BF  0084     MOVWF FSR
15C0  0880     MOVF INDF, F
15C1  1D03     BTFSS STATUS, 0x2
15C2  2E2A     GOTO 0x62A
15C3  087D     MOVF horario, W
15C4  3E02     ADDLW 0x2
15C5  0084     MOVWF FSR
15C6  3017     MOVLW 0x17
15C7  2DFA     GOTO 0x5FA
208:                               break;
209:                           case DIA:
210:                               //haycambio = 1;
211:                               if (fecha.day > 1) fecha.day--;
15C8  3002     MOVLW 0x2
15C9  1283     BCF STATUS, 0x5
15CA  026C     SUBWF fecha, W
15CB  1C03     BTFSS STATUS, 0x0
15CC  2DCF     GOTO 0x5CF
15CD  03EC     DECF fecha, F
15CE  2E2A     GOTO 0x62A
212:                               else
213:                                   if (fecha.day == 1) fecha.day = maximodia;
15CF  0B6C     DECFSZ fecha, W
15D0  2E2A     GOTO 0x62A
15D1  086B     MOVF maximodia, W
15D2  00EC     MOVWF fecha
15D3  2E2A     GOTO 0x62A
214:                               break;
215:                           case MES:
216:                               //haycambio = 1;
217:                               if (fecha.month > 1) fecha.month--;
15D4  3002     MOVLW 0x2
15D5  1283     BCF STATUS, 0x5
15D6  026D     SUBWF 0x6D, W
15D7  1C03     BTFSS STATUS, 0x0
15D8  2DDB     GOTO 0x5DB
15D9  03ED     DECF 0x6D, F
15DA  2E2A     GOTO 0x62A
218:                               else
219:                                   if (fecha.month == 1) fecha.month = 12;
15DB  0B6D     DECFSZ 0x6D, W
15DC  2E2A     GOTO 0x62A
15DD  300C     MOVLW 0xC
15DE  00ED     MOVWF 0x6D
15DF  2E2A     GOTO 0x62A
220:                               break;
221:                           case ANIO:
222:                               //haycambio = 1;
223:                               if (fecha.yr > 0) fecha.yr--; //solamente vamos hasta el ao 00
15E0  1283     BCF STATUS, 0x5
15E1  086E     MOVF 0x6E, W
15E2  1903     BTFSC STATUS, 0x2
15E3  2DE6     GOTO 0x5E6
15E4  03EE     DECF 0x6E, F
15E5  2E2A     GOTO 0x62A
224:                               else
225:                                   if (fecha.yr == 0) fecha.yr = 99; //solamente contamos desde el ao 99
15E6  08EE     MOVF 0x6E, F
15E7  1D03     BTFSS STATUS, 0x2
15E8  2E2A     GOTO 0x62A
15E9  3063     MOVLW 0x63
15EA  00EE     MOVWF 0x6E
15EB  2E2A     GOTO 0x62A
226:                               break;
227:                           case SINO:
228:                               *banderasino = !*banderasino;
15EC  0839     MOVF anio, W
15ED  0084     MOVWF FSR
15EE  3000     MOVLW 0x0
15EF  1383     BCF STATUS, 0x7
15F0  0880     MOVF INDF, F
15F1  1903     BTFSC STATUS, 0x2
15F2  3001     MOVLW 0x1
15F3  1283     BCF STATUS, 0x5
15F4  00A0     MOVWF 0x20
15F5  1683     BSF STATUS, 0x5
15F6  0839     MOVF anio, W
15F7  0084     MOVWF FSR
15F8  1283     BCF STATUS, 0x5
15F9  0820     MOVF 0x20, W
15FA  0080     MOVWF INDF
229:                               break;
15FB  2E2A     GOTO 0x62A
230:                           case TIEMPOENCENDIDO:
231:                               //haycambio = 1;
232:                               if (tiempoencendido > 0) tiempoencendido--; //
15FC  084C     MOVF 0x4C, W
15FD  1903     BTFSC STATUS, 0x2
15FE  2E01     GOTO 0x601
15FF  03CC     DECF 0x4C, F
1600  2E2A     GOTO 0x62A
233:                               else
234:                                   if (tiempoencendido == 0) tiempoencendido = TIEMPOMAXIMOENCENDIDO;
1601  08CC     MOVF 0x4C, F
1602  1D03     BTFSS STATUS, 0x2
1603  2E2A     GOTO 0x62A
1604  303C     MOVLW 0x3C
1605  00CC     MOVWF 0x4C
1606  2E2A     GOTO 0x62A
235:                               break;
236:                           case TIEMPOFALLA:
237:                               //haycambio = 1;
238:                               if (tiempofalla > 0) tiempofalla--; //
1607  084D     MOVF 0x4D, W
1608  1903     BTFSC STATUS, 0x2
1609  2E0C     GOTO 0x60C
160A  03CD     DECF 0x4D, F
160B  2E2A     GOTO 0x62A
239:                               else
240:                                   if (tiempofalla == 0) tiempofalla = TIEMPOMAXIMOFALLA;
160C  08CD     MOVF 0x4D, F
160D  1D03     BTFSS STATUS, 0x2
160E  2E2A     GOTO 0x62A
160F  300A     MOVLW 0xA
1610  00CD     MOVWF 0x4D
1611  2E2A     GOTO 0x62A
241:                               break;
242:                           case PERIODOENCENDIDO:
243:                               //haycambio = 1;
244:                               if (periodoencendido > 1) periodoencendido--; //
1612  3002     MOVLW 0x2
1613  026E     SUBWF 0x6E, W
1614  1C03     BTFSS STATUS, 0x0
1615  2E18     GOTO 0x618
1616  03EE     DECF 0x6E, F
1617  2E2A     GOTO 0x62A
245:                               else
246:                                   if (periodoencendido == 1) periodoencendido = TIEMPOMAXIMOPERIODO;
1618  0B6E     DECFSZ 0x6E, W
1619  2E2A     GOTO 0x62A
161A  3007     MOVLW 0x7
161B  00EE     MOVWF 0x6E
161C  2E2A     GOTO 0x62A
247:                               break;
248:                           default:
249:                               break;
250:                       }
251:                       if (aniobisiesto(fecha.yr) && fecha.month == 2) {
162A  1283     BCF STATUS, 0x5
162B  086E     MOVF 0x6E, W
162C  279D     CALL 0x79D
162D  160A     BSF PCLATH, 0x4
162E  118A     BCF PCLATH, 0x3
162F  0877     MOVF Logica, W
1630  0476     IORWF TipoPin, W
1631  1903     BTFSC STATUS, 0x2
1632  2E39     GOTO 0x639
1633  086D     MOVF 0x6D, W
1634  3A02     XORLW 0x2
1635  1D03     BTFSS STATUS, 0x2
1636  2E39     GOTO 0x639
252:                           maximodia = 29;
1637  301D     MOVLW 0x1D
1638  2E3E     GOTO 0x63E
253:                       } else if (fecha.month == 2)
1639  086D     MOVF 0x6D, W
163A  3A02     XORLW 0x2
163B  1D03     BTFSS STATUS, 0x2
163C  2E3F     GOTO 0x63F
254:                           maximodia = 28;
163D  301C     MOVLW 0x1C
163E  00EB     MOVWF maximodia
255:                       if (fecha.month == 4 || fecha.month == 6 || fecha.month == 9 || fecha.month == 11) {
163F  086D     MOVF 0x6D, W
1640  3A04     XORLW 0x4
1641  1903     BTFSC STATUS, 0x2
1642  2E4F     GOTO 0x64F
1643  086D     MOVF 0x6D, W
1644  3A06     XORLW 0x6
1645  1903     BTFSC STATUS, 0x2
1646  2E4F     GOTO 0x64F
1647  086D     MOVF 0x6D, W
1648  3A09     XORLW 0x9
1649  1903     BTFSC STATUS, 0x2
164A  2E4F     GOTO 0x64F
164B  086D     MOVF 0x6D, W
164C  3A0B     XORLW 0xB
164D  1D03     BTFSS STATUS, 0x2
164E  2E51     GOTO 0x651
256:                           maximodia = 30;
164F  301E     MOVLW 0x1E
1650  00EB     MOVWF maximodia
257:                       }
258:                       if (fecha.month == 1 || fecha.month == 3 || fecha.month == 5 || fecha.month == 7 || fecha.month == 8 || fecha.month == 10 || fecha.month == 12) {
1651  036D     DECF 0x6D, W
1652  1903     BTFSC STATUS, 0x2
1653  2E6C     GOTO 0x66C
1654  086D     MOVF 0x6D, W
1655  3A03     XORLW 0x3
1656  1903     BTFSC STATUS, 0x2
1657  2E6C     GOTO 0x66C
1658  086D     MOVF 0x6D, W
1659  3A05     XORLW 0x5
165A  1903     BTFSC STATUS, 0x2
165B  2E6C     GOTO 0x66C
165C  086D     MOVF 0x6D, W
165D  3A07     XORLW 0x7
165E  1903     BTFSC STATUS, 0x2
165F  2E6C     GOTO 0x66C
1660  086D     MOVF 0x6D, W
1661  3A08     XORLW 0x8
1662  1903     BTFSC STATUS, 0x2
1663  2E6C     GOTO 0x66C
1664  086D     MOVF 0x6D, W
1665  3A0A     XORLW 0xA
1666  1903     BTFSC STATUS, 0x2
1667  2E6C     GOTO 0x66C
1668  086D     MOVF 0x6D, W
1669  3A0C     XORLW 0xC
166A  1D03     BTFSS STATUS, 0x2
166B  2E6E     GOTO 0x66E
259:                           maximodia = 31;
166C  301F     MOVLW 0x1F
166D  00EB     MOVWF maximodia
260:                       }
261:                       if (fecha.day > maximodia)
166E  086C     MOVF fecha, W
166F  026B     SUBWF maximodia, W
1670  1803     BTFSC STATUS, 0x0
1671  2E74     GOTO 0x674
262:                           fecha.day = maximodia;
1672  086B     MOVF maximodia, W
1673  00EC     MOVWF fecha
263:                   }
264:                   // </editor-fold>
265:                   // <editor-fold defaultstate="collapsed" desc="boton onoff">
266:           
267:           
268:                   //bandera_graba_global = 0;
269:                   if (Pulsacion(2, BOTON_ONOFF, SIN_REPETICION, LOGICA_INVERSA)) {
1674  3000     MOVLW 0x0
1675  1283     BCF STATUS, 0x5
1676  1303     BCF STATUS, 0x6
1677  1A86     BTFSC PORTB, 0x5
1678  3001     MOVLW 0x1
1679  00F5     MOVWF Pin
167A  3002     MOVLW 0x2
167B  01F6     CLRF TipoPin
167C  01F7     CLRF Logica
167D  0AF7     INCF Logica, F
167E  26D0     CALL 0x6D0
167F  160A     BSF PCLATH, 0x4
1680  118A     BCF PCLATH, 0x3
1681  3A00     XORLW 0x0
1682  1903     BTFSC STATUS, 0x2
1683  2E8D     GOTO 0x68D
270:                       bandera_graba_global = 1;
1684  1683     BSF STATUS, 0x5
1685  1303     BCF STATUS, 0x6
1687  01B1     CLRF 0x31
1688  0AB1     INCF 0x31, F
271:                       bandera_orden_on_off_bomba = !bandera_orden_on_off_bomba;
1686  3000     MOVLW 0x0
1689  08B8     MOVF mes, F
168A  1903     BTFSC STATUS, 0x2
168B  3001     MOVLW 0x1
168C  00B8     MOVWF mes
272:                   }
273:                   // </editor-fold>
274:                   // <editor-fold defaultstate="collapsed" desc="boton menu">
275:                   if (Pulsacion(3, BOTON_MENU, SIN_REPETICION, LOGICA_INVERSA)) {
168D  3000     MOVLW 0x0
168E  1283     BCF STATUS, 0x5
168F  1303     BCF STATUS, 0x6
1690  1986     BTFSC PORTB, 0x3
1691  3001     MOVLW 0x1
1692  00F5     MOVWF Pin
1693  3003     MOVLW 0x3
1694  01F6     CLRF TipoPin
1695  01F7     CLRF Logica
1696  0AF7     INCF Logica, F
1697  26D0     CALL 0x6D0
1698  160A     BSF PCLATH, 0x4
1699  118A     BCF PCLATH, 0x3
169A  3A00     XORLW 0x0
169B  1903     BTFSC STATUS, 0x2
169C  2EA9     GOTO 0x6A9
276:           
277:                       buzzer_on(3);
169D  3003     MOVLW 0x3
169E  27BE     CALL 0x7BE
169F  160A     BSF PCLATH, 0x4
16A0  118A     BCF PCLATH, 0x3
278:                       if (menuactual < ULTIMOMENU)
16A1  3010     MOVLW 0x10
16A2  1683     BSF STATUS, 0x5
16A3  0249     SUBWF f2, W
16A4  1803     BTFSC STATUS, 0x0
16A5  2EA8     GOTO 0x6A8
279:                           menuactual++;
16A6  0AC9     INCF f2, F
16A7  2EA9     GOTO 0x6A9
280:                       else
281:                           menuactual = 0;
16A8  01C9     CLRF f2
282:                   }
283:                   // </editor-fold>
284:                   // <editor-fold defaultstate="collapsed" desc="boton manaut">
285:                   if (Pulsacion(4, BOTON_MANAUT, SIN_REPETICION, LOGICA_INVERSA)) {
16A9  3000     MOVLW 0x0
16AA  1283     BCF STATUS, 0x5
16AB  1303     BCF STATUS, 0x6
16AC  1A06     BTFSC PORTB, 0x4
16AD  3001     MOVLW 0x1
16AE  00F5     MOVWF Pin
16AF  3004     MOVLW 0x4
16B0  01F6     CLRF TipoPin
16B1  01F7     CLRF Logica
16B2  0AF7     INCF Logica, F
16B3  26D0     CALL 0x6D0
16B4  160A     BSF PCLATH, 0x4
16B5  118A     BCF PCLATH, 0x3
16B6  3A00     XORLW 0x0
16B7  1903     BTFSC STATUS, 0x2
16B8  2EC4     GOTO 0x6C4
286:                       bandera_orden_on_off_bomba = 0;
16B9  1683     BSF STATUS, 0x5
16BA  1303     BCF STATUS, 0x6
16BC  01B8     CLRF mes
287:                       bandera_orden_Alarma_bomba = 0;
16BD  01B7     CLRF sign
288:                       manual_automatico = !manual_automatico;
16BB  3000     MOVLW 0x0
16BE  08EC     MOVF fecha, F
16BF  1903     BTFSC STATUS, 0x2
16C0  3001     MOVLW 0x1
16C1  00EC     MOVWF fecha
289:                       buzzer_on(3);
16C2  3003     MOVLW 0x3
16C3  27BE     CALL 0x7BE
290:           
291:                   }
292:                   // </editor-fold>
293:                   T0IF = 0;
16C4  110B     BCF INTCON, 0x2
294:                   // </editor-fold>
295:               } else {
296:                   ///interrupciones no contempladas
297:               }
298:           }
16C5  1283     BCF STATUS, 0x5
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/adcPic16.c  ---------------------------
1:             #include <xc.h>
2:             #include <stdint.h>
3:             #include <stdbool.h>
4:             #include "system.h"
5:             #include "user.h"
6:             #include "adcPic16.h"
7:             
8:             void setADCChannel(char canal) {
1007  00A5     MOVWF dato
17F3  00F1     MOVWF canal
9:                 ADCON0bits.CHS = canal; //Selecciono el canal AD0
1008  00A4     MOVWF x
1009  0DA4     RLF x, F
100A  0DA4     RLF x, F
100B  0DA4     RLF x, F
100C  081F     MOVF ADCON0, W
100D  0624     XORWF x, W
100E  39C7     ANDLW 0xC7
100F  0624     XORWF x, W
1010  009F     MOVWF ADCON0
17F4  00F0     MOVWF tiempo
17F5  0DF0     RLF tiempo, F
17F6  0DF0     RLF tiempo, F
17F7  0DF0     RLF tiempo, F
17F8  1283     BCF STATUS, 0x5
17F9  1303     BCF STATUS, 0x6
17FA  081F     MOVF ADCON0, W
17FB  0670     XORWF tiempo, W
17FC  39C7     ANDLW 0xC7
17FD  0670     XORWF tiempo, W
17FE  009F     MOVWF ADCON0
10:            };
1011  0008     RETURN
17FF  0008     RETURN
11:            
12:            char getADCChannel(void) {
13:                return ADCON0bits.CHS; //Selecciono el canal AD0
17E4  1283     BCF STATUS, 0x5
17E5  0C1F     RRF ADCON0, W
17E6  00F0     MOVWF tiempo
17E7  0CF0     RRF tiempo, F
17E8  0C70     RRF tiempo, W
17E9  3907     ANDLW 0x7
14:            };
17EA  0008     RETURN
15:            
16:            void openADC(void) {
17:            
18:                TRISA0 = 1; //configuro como entrada para el ADC0
1F88  1683     BSF STATUS, 0x5
1F89  1303     BCF STATUS, 0x6
1F8A  1405     BSF PORTA, 0x0
19:                TRISA1 = 1; //configuro como entrada para el ADC1
1F8B  1485     BSF PORTA, 0x1
20:                TRISA3 = 1; //Configuro como entrada para Vref+
1F8C  1585     BSF PORTA, 0x3
21:                TRISA2 = 0; //No usado
1F8D  1105     BCF PORTA, 0x2
22:                TRISA4 = 0;//No usado
1F8E  1205     BCF PORTA, 0x4
23:                TRISA5 = 0;//No usado
1F8F  1285     BCF PORTA, 0x5
24:                ADCON1bits.PCFG = 0b101; //An3 como VREF+ , AN0 y AN1 como entrada analogica, AN0 Corriente, AN1 Tension de red
1F90  081F     MOVF ADCON0, W
1F91  39F0     ANDLW 0xF0
1F92  3805     IORLW 0x5
1F93  009F     MOVWF ADCON0
25:                ADCON1bits.ADFM = 1; //justificado a la derecha
1F94  179F     BSF ADCON0, 0x7
26:                ADCON1bits.ADCS2 = 1;
1F95  171F     BSF ADCON0, 0x6
27:                ADCON0bits.ADCS = 0b10; //Tosc/64
1F96  1283     BCF STATUS, 0x5
1F97  081F     MOVF ADCON0, W
1F98  393F     ANDLW 0x3F
1F99  3880     IORLW 0x80
1F9A  009F     MOVWF ADCON0
28:                ADCON0bits.ADON = 1; //Activo el ADC
1F9B  141F     BSF ADCON0, 0x0
29:            
30:            }
1F9C  0008     RETURN
31:            
32:            unsigned int adcRead(void) {
33:            
34:                return ((unsigned int) ADRESH << 8) | ADRESL;
1796  081E     MOVF ADRESH, W
1797  00F1     MOVWF canal
1798  01F0     CLRF tiempo
1799  1683     BSF STATUS, 0x5
179A  081E     MOVF ADRESH, W
179B  04F0     IORWF tiempo, F
35:            }
179C  0008     RETURN
36:            
37:            void startADC(void) {
38:                ADCON0bits.GO_DONE = 1;
17EB  1283     BCF STATUS, 0x5
17EC  151F     BSF ADCON0, 0x2
39:            }
17ED  0008     RETURN
40:            
41:            void interruptADC_on(void) {
42:                ADIE = 1;
1F7B  170C     BSF PIR1, 0x6
43:            }
1F7C  0008     RETURN
44:            
45:            void interruptADC_off(void) {
46:                ADIE = 0;
47:            }
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/_isl1208.c  ---------------------------
1:             //Cdigo original bajado de: http://picmania.garcia-cuervo.net/proyectos_aux_rtc.php
2:             //Gracias RedRaven
3:             ////////////////////////////////////////////////////////////////////////////////////////
4:             ///                               isl1208.C                                          ///
5:             ///                     Driver for Real Time Clock                                   ///
6:             ///                     modified by Pablo Fernando Manieri - Enero 2015              ///
7:             ///                                                                                  ///
8:             /// bool ISL1208_ready(void) - Testea si el RTC est presente                        ///
9:             /// void isl1208_init(val)                                                           ///
10:            ///                  - Enable oscillator without clearing the seconds register       ///
11:            ///                    used when PIC loses power and isl1208 run from 3V BAT         ///
12:            ///                  - Config Control Register with next parameters:                 ///
13:            ///                     isl1208_ALL_DISABLED          All disabled                   ///
14:            ///                     isl1208_OUT_ON_DISABLED_HIHG  Out to Hight on Disable Out    ///
15:            ///                     isl1208_OUT_ENABLED           Out Enabled                    ///
16:            ///                     isl1208_OUT_1_HZ              Freq. Out to 1 Hz              ///
17:            ///                     isl1208_OUT_4_KHZ             Freq. Out to 4.096 Khz         ///
18:            ///                     isl1208_OUT_8_KHZ             Freq. Out to 8.192 Khz         ///
19:            ///                     isl1208_OUT_32_KHZ            Freq. Out to 32.768 Khz        ///
20:            ///                                                                                  ///
21:            ///                     Example init:                                                ///
22:            ///                     isl1208_init(isl1208_ALL_DISABLED);                          ///
23:            ///                     isl1208_init(isl1208_OUT_ENABLED | isl1208_OUT_1_HZ);        ///
24:            ///                                                                                  ///
25:            /// void isl1208_set_date_time(day,mth,year,dow,hour,min,sec) - Set the date/time    ///
26:            ///                                                                                  ///
27:            /// void isl1208_get_date(day,mth,year,dow) - Get the date                           ///
28:            ///                                                                                  ///
29:            /// void isl1208_get_time(hr,min,sec) - Get the time                                 ///
30:            ///                                                                                  ///
31:            /// char isl1208_read_nvram_unsigned char(char addr) - Read unsigned char in address ///
32:            ///                                                                                  ///
33:            /// void isl1208_write_nvram_unsigned char(char addr, char value) - Write unsigned   ///
34:            ///                                                                  char in address ///
35:            ///                                                                                  ///
36:            /// void isl1208_get_day_of_week(char* ptr) - Get string Day Of Week                 ///
37:            ///                                                                                  ///
38:            ///                                                                                  ///
39:            ////////////////////////////////////////////////////////////////////////////////////////
40:            
41:            #include <xc.h>
42:            #include <stdio.h>
43:            #include <stdbool.h>       /* For true/false definition */
44:            #include "system.h"        /* System funct/params, like osc/peripheral config */
45:            #include "HardI2C.h"
46:            #include "_isl1208.h"
47:            #include "user.h"
48:            
49:            bool ISL1208_ready(void) {
50:                bool ack;
51:            
52:                start_i2c(); // If the write command is acknowledged,
0AD9  250C     CALL 0x50C
0ADA  120A     BCF PCLATH, 0x4
0ADB  158A     BSF PCLATH, 0x3
53:                ack = write_i2c(isl1208_Write); // then the device is ready.
0ADC  30DE     MOVLW 0xDE
0ADD  24E2     CALL 0x4E2
0ADE  120A     BCF PCLATH, 0x4
0ADF  158A     BSF PCLATH, 0x3
0AE0  1283     BCF STATUS, 0x5
0AE1  00A5     MOVWF dato
54:                stop_i2c();
0AE2  251E     CALL 0x51E
55:                return !ack; // Invert ACK returned so TRUE = ACK OK
0AE3  1283     BCF STATUS, 0x5
0AE4  3000     MOVLW 0x0
0AE5  08A5     MOVF dato, F
0AE6  1903     BTFSC STATUS, 0x2
0AE7  3001     MOVLW 0x1
56:            }
0AE8  0008     RETURN
57:            
58:            void ISL1208_Set_status(unsigned char *SR) {
0AFF  1283     BCF STATUS, 0x5
0B00  00A5     MOVWF dato
59:            
60:                start_i2c(); // If the write command is acknowledged,
0B01  250C     CALL 0x50C
0B02  120A     BCF PCLATH, 0x4
0B03  158A     BSF PCLATH, 0x3
61:                write_i2c(isl1208_Write); // then the device is ready.
0B04  30DE     MOVLW 0xDE
0B05  24E2     CALL 0x4E2
0B06  120A     BCF PCLATH, 0x4
0B07  158A     BSF PCLATH, 0x3
62:                write_i2c(0x07);
0B08  3007     MOVLW 0x7
0B09  24E2     CALL 0x4E2
0B0A  120A     BCF PCLATH, 0x4
0B0B  158A     BSF PCLATH, 0x3
63:                write_i2c(*SR);
0B0C  1283     BCF STATUS, 0x5
0B0D  0825     MOVF dato, W
0B0E  0084     MOVWF FSR
0B0F  1383     BCF STATUS, 0x7
0B10  0800     MOVF INDF, W
0B11  24E2     CALL 0x4E2
0B12  120A     BCF PCLATH, 0x4
0B13  158A     BSF PCLATH, 0x3
64:                stop_i2c();
0B14  2D1E     GOTO 0x51E
65:            
66:            }
67:            
68:            
69:            unsigned char ISL1208_Read_status(void) {
70:                char SR;
71:                start_i2c(); // If the write command is acknowledged,
0B15  250C     CALL 0x50C
0B16  120A     BCF PCLATH, 0x4
0B17  158A     BSF PCLATH, 0x3
72:                write_i2c(isl1208_Write); // then the device is ready.
0B18  30DE     MOVLW 0xDE
0B19  24E2     CALL 0x4E2
0B1A  120A     BCF PCLATH, 0x4
0B1B  158A     BSF PCLATH, 0x3
73:                write_i2c(0x07);
0B1C  3007     MOVLW 0x7
0B1D  24E2     CALL 0x4E2
0B1E  120A     BCF PCLATH, 0x4
0B1F  158A     BSF PCLATH, 0x3
74:                rstart_i2c(); 
0B20  2526     CALL 0x526
0B21  120A     BCF PCLATH, 0x4
0B22  158A     BSF PCLATH, 0x3
75:                write_i2c(isl1208_Read);
0B23  30DF     MOVLW 0xDF
0B24  24E2     CALL 0x4E2
0B25  120A     BCF PCLATH, 0x4
0B26  158A     BSF PCLATH, 0x3
76:                SR = read_i2c(NOACK);
0B27  3001     MOVLW 0x1
0B28  2408     CALL 0x408
0B29  120A     BCF PCLATH, 0x4
0B2A  158A     BSF PCLATH, 0x3
0B2B  00A6     MOVWF y
77:                stop_i2c();
0B2C  251E     CALL 0x51E
78:                return SR;
0B2D  1283     BCF STATUS, 0x5
0B2E  0826     MOVF y, W
79:            }
0B2F  0008     RETURN
80:            
81:            unsigned char ISL1208_Read_Int(void) {
82:                char Int;
83:                start_i2c(); // If the write command is acknowledged,
84:                write_i2c(isl1208_Write); // then the device is ready.
85:                write_i2c(0x08);
86:                rstart_i2c();
87:                write_i2c(isl1208_Read);
88:                Int = read_i2c(NOACK);
89:                stop_i2c();
90:                return Int;
91:            }
92:            
93:            void ISL1208_Set_Int(unsigned char *Int) {
0AE9  1283     BCF STATUS, 0x5
0AEA  00A5     MOVWF dato
94:            
95:                start_i2c(); // If the write command is acknowledged,
0AEB  250C     CALL 0x50C
0AEC  120A     BCF PCLATH, 0x4
0AED  158A     BSF PCLATH, 0x3
96:                write_i2c(isl1208_Write); // then the device is ready.
0AEE  30DE     MOVLW 0xDE
0AEF  24E2     CALL 0x4E2
0AF0  120A     BCF PCLATH, 0x4
0AF1  158A     BSF PCLATH, 0x3
97:                write_i2c(0x08);
0AF2  3008     MOVLW 0x8
0AF3  24E2     CALL 0x4E2
0AF4  120A     BCF PCLATH, 0x4
0AF5  158A     BSF PCLATH, 0x3
98:                write_i2c(*Int);
0AF6  1283     BCF STATUS, 0x5
0AF7  0825     MOVF dato, W
0AF8  0084     MOVWF FSR
0AF9  1383     BCF STATUS, 0x7
0AFA  0800     MOVF INDF, W
0AFB  24E2     CALL 0x4E2
0AFC  120A     BCF PCLATH, 0x4
0AFD  158A     BSF PCLATH, 0x3
99:                stop_i2c();
0AFE  2D1E     GOTO 0x51E
100:              
101:           }
102:           
103:           
104:           
105:           void isl1208_init() {
09FF  30F0     MOVLW 0xF0
106:           
107:           isl1208INT.ALME=1;//habilita la alarma
0A00  1761     BSF 0x61, 0x6
108:           isl1208INT.FO=0;//deshabilita la salida de frecuencia
09FF  30F0     MOVLW 0xF0
0A01  05E1     ANDWF 0x61, F
109:           isl1208INT.FOBATB=1;//deshabilita la salida de fout/irq en modo backup
0A03  1661     BSF 0x61, 0x4
110:           isl1208INT.IM=1;//alarma en modo irq
0A04  17E1     BSF 0x61, 0x7
111:           isl1208INT.LPMODE=1;//deshabilita comunicacion en modo backup
0A05  16E1     BSF 0x61, 0x5
112:           ISL1208_Set_Int(&isl1208INT.Valor);
0A02  30E1     MOVLW 0xE1
0A06  2AE9     GOTO 0x2E9
113:           }
114:           
115:           void isl1208_set_time(unsigned char hr, unsigned char min, unsigned char sec) {
0C5B  00AD     MOVWF hr
116:           
117:           #ifndef USE_INTERRUPTS
118:               //di();
119:           #endif
120:           
121:               sec &= 0x7F;
0C5D  13AC     BCF sec, 0x7
122:               min &= 0x7F;
0C5E  13AB     BCF Data, 0x7
123:               hr &= 0x3F;
0C5C  303F     MOVLW 0x3F
0C5F  05AD     ANDWF hr, F
124:               start_i2c();
0C60  250C     CALL 0x50C
0C61  120A     BCF PCLATH, 0x4
0C62  158A     BSF PCLATH, 0x3
125:               write_i2c(isl1208_Write);
0C63  30DE     MOVLW 0xDE
0C64  24E2     CALL 0x4E2
0C65  120A     BCF PCLATH, 0x4
0C66  158A     BSF PCLATH, 0x3
126:               write_i2c(0x07);
0C67  3007     MOVLW 0x7
0C68  24E2     CALL 0x4E2
0C69  120A     BCF PCLATH, 0x4
0C6A  158A     BSF PCLATH, 0x3
127:               write_i2c(0b00010000);
0C6B  3010     MOVLW 0x10
0C6C  24E2     CALL 0x4E2
0C6D  120A     BCF PCLATH, 0x4
0C6E  158A     BSF PCLATH, 0x3
128:               stop_i2c();
0C6F  251E     CALL 0x51E
0C70  120A     BCF PCLATH, 0x4
0C71  158A     BSF PCLATH, 0x3
129:               start_i2c();
0C72  250C     CALL 0x50C
0C73  120A     BCF PCLATH, 0x4
0C74  158A     BSF PCLATH, 0x3
130:               write_i2c(isl1208_Write);
0C75  30DE     MOVLW 0xDE
0C76  24E2     CALL 0x4E2
0C77  120A     BCF PCLATH, 0x4
0C78  158A     BSF PCLATH, 0x3
131:               write_i2c(0x00);
0C79  3000     MOVLW 0x0
0C7A  24E2     CALL 0x4E2
0C7B  120A     BCF PCLATH, 0x4
0C7C  158A     BSF PCLATH, 0x3
132:               write_i2c(isl1208_bin2bcd(sec));
0C7D  1283     BCF STATUS, 0x5
0C7E  082C     MOVF sec, W
0C7F  24FA     CALL 0x4FA
0C80  120A     BCF PCLATH, 0x4
0C81  158A     BSF PCLATH, 0x3
0C82  24E2     CALL 0x4E2
0C83  120A     BCF PCLATH, 0x4
0C84  158A     BSF PCLATH, 0x3
133:               write_i2c(isl1208_bin2bcd(min));
0C85  1283     BCF STATUS, 0x5
0C86  082B     MOVF Data, W
0C87  24FA     CALL 0x4FA
0C88  120A     BCF PCLATH, 0x4
0C89  158A     BSF PCLATH, 0x3
0C8A  24E2     CALL 0x4E2
0C8B  120A     BCF PCLATH, 0x4
0C8C  158A     BSF PCLATH, 0x3
134:               write_i2c(isl1208_bin2bcd(hr) | 0b10000000);
0C8D  1283     BCF STATUS, 0x5
0C8E  082D     MOVF hr, W
0C8F  24FA     CALL 0x4FA
0C90  120A     BCF PCLATH, 0x4
0C91  158A     BSF PCLATH, 0x3
0C92  3880     IORLW 0x80
0C93  24E2     CALL 0x4E2
0C94  120A     BCF PCLATH, 0x4
0C95  158A     BSF PCLATH, 0x3
135:               stop_i2c();
0C96  2D1E     GOTO 0x51E
136:           
137:           #ifndef USE_INTERRUPTS
138:               //  ei();
139:           #endif
140:           
141:           }
142:           
143:           void isl1208_set_date(unsigned char* day, unsigned char* mth, unsigned char* year, unsigned char* dow) {
0C97  00AE     MOVWF day
144:           
145:           #ifndef USE_INTERRUPTS
146:               //di();
147:           #endif
148:           
149:               start_i2c();
0C98  250C     CALL 0x50C
0C99  120A     BCF PCLATH, 0x4
0C9A  158A     BSF PCLATH, 0x3
150:               write_i2c(isl1208_Write);
0C9B  30DE     MOVLW 0xDE
0C9C  24E2     CALL 0x4E2
0C9D  120A     BCF PCLATH, 0x4
0C9E  158A     BSF PCLATH, 0x3
151:               write_i2c(0x07);
0C9F  3007     MOVLW 0x7
0CA0  24E2     CALL 0x4E2
0CA1  120A     BCF PCLATH, 0x4
0CA2  158A     BSF PCLATH, 0x3
152:               write_i2c(0b00010000);
0CA3  3010     MOVLW 0x10
0CA4  24E2     CALL 0x4E2
0CA5  120A     BCF PCLATH, 0x4
0CA6  158A     BSF PCLATH, 0x3
153:               stop_i2c();
0CA7  251E     CALL 0x51E
0CA8  120A     BCF PCLATH, 0x4
0CA9  158A     BSF PCLATH, 0x3
154:               start_i2c();
0CAA  250C     CALL 0x50C
0CAB  120A     BCF PCLATH, 0x4
0CAC  158A     BSF PCLATH, 0x3
155:               write_i2c(isl1208_Write);
0CAD  30DE     MOVLW 0xDE
0CAE  24E2     CALL 0x4E2
0CAF  120A     BCF PCLATH, 0x4
0CB0  158A     BSF PCLATH, 0x3
156:               write_i2c(0x03);
0CB1  3003     MOVLW 0x3
0CB2  24E2     CALL 0x4E2
0CB3  120A     BCF PCLATH, 0x4
0CB4  158A     BSF PCLATH, 0x3
157:               write_i2c(isl1208_bin2bcd(*day));
0CB5  1283     BCF STATUS, 0x5
0CB6  082E     MOVF day, W
0CB7  0084     MOVWF FSR
0CB8  1383     BCF STATUS, 0x7
0CB9  0800     MOVF INDF, W
0CBA  24FA     CALL 0x4FA
0CBB  120A     BCF PCLATH, 0x4
0CBC  158A     BSF PCLATH, 0x3
0CBD  24E2     CALL 0x4E2
0CBE  120A     BCF PCLATH, 0x4
0CBF  158A     BSF PCLATH, 0x3
158:               write_i2c(isl1208_bin2bcd(*mth));
0CC0  1283     BCF STATUS, 0x5
0CC1  082B     MOVF Data, W
0CC2  0084     MOVWF FSR
0CC3  1383     BCF STATUS, 0x7
0CC4  0800     MOVF INDF, W
0CC5  24FA     CALL 0x4FA
0CC6  120A     BCF PCLATH, 0x4
0CC7  158A     BSF PCLATH, 0x3
0CC8  24E2     CALL 0x4E2
0CC9  120A     BCF PCLATH, 0x4
0CCA  158A     BSF PCLATH, 0x3
159:               write_i2c(isl1208_bin2bcd(*year));
0CCB  1283     BCF STATUS, 0x5
0CCC  082C     MOVF sec, W
0CCD  0084     MOVWF FSR
0CCE  1383     BCF STATUS, 0x7
0CCF  0800     MOVF INDF, W
0CD0  24FA     CALL 0x4FA
0CD1  120A     BCF PCLATH, 0x4
0CD2  158A     BSF PCLATH, 0x3
0CD3  24E2     CALL 0x4E2
0CD4  120A     BCF PCLATH, 0x4
0CD5  158A     BSF PCLATH, 0x3
160:               write_i2c(isl1208_bin2bcd(*dow));
0CD6  1283     BCF STATUS, 0x5
0CD7  082D     MOVF hr, W
0CD8  0084     MOVWF FSR
0CD9  1383     BCF STATUS, 0x7
0CDA  0800     MOVF INDF, W
0CDB  24FA     CALL 0x4FA
0CDC  120A     BCF PCLATH, 0x4
0CDD  158A     BSF PCLATH, 0x3
0CDE  24E2     CALL 0x4E2
0CDF  120A     BCF PCLATH, 0x4
0CE0  158A     BSF PCLATH, 0x3
161:               stop_i2c();
0CE1  2D1E     GOTO 0x51E
162:           
163:           #ifndef USE_INTERRUPTS
164:               //  ei();
165:           #endif
166:           
167:           }
168:           
169:           void isl1208_get_date(unsigned char* day, unsigned char* mth, unsigned char* year, unsigned char *dow) {
0BC4  00AC     MOVWF sec
170:           
171:           #ifndef USE_INTERRUPTS
172:               // di();
173:           #endif
174:           
175:               start_i2c();
0BC5  250C     CALL 0x50C
0BC6  120A     BCF PCLATH, 0x4
0BC7  158A     BSF PCLATH, 0x3
176:               write_i2c(isl1208_Write);
0BC8  30DE     MOVLW 0xDE
0BC9  24E2     CALL 0x4E2
0BCA  120A     BCF PCLATH, 0x4
0BCB  158A     BSF PCLATH, 0x3
177:               write_i2c(0x03);
0BCC  3003     MOVLW 0x3
0BCD  24E2     CALL 0x4E2
0BCE  120A     BCF PCLATH, 0x4
0BCF  158A     BSF PCLATH, 0x3
178:               rstart_i2c();
0BD0  2526     CALL 0x526
0BD1  120A     BCF PCLATH, 0x4
0BD2  158A     BSF PCLATH, 0x3
179:               write_i2c(isl1208_Read);
0BD3  30DF     MOVLW 0xDF
0BD4  24E2     CALL 0x4E2
0BD5  120A     BCF PCLATH, 0x4
0BD6  158A     BSF PCLATH, 0x3
180:               *day = isl1208_bcd2bin(read_i2c(ACK) & 0x3f);
0BD7  1283     BCF STATUS, 0x5
0BD8  082C     MOVF sec, W
0BD9  0084     MOVWF FSR
0BDA  3000     MOVLW 0x0
0BDB  2408     CALL 0x408
0BDC  120A     BCF PCLATH, 0x4
0BDD  158A     BSF PCLATH, 0x3
0BDE  393F     ANDLW 0x3F
0BDF  2514     CALL 0x514
0BE0  120A     BCF PCLATH, 0x4
0BE1  158A     BSF PCLATH, 0x3
0BE2  1383     BCF STATUS, 0x7
0BE3  0080     MOVWF INDF
181:               *mth = isl1208_bcd2bin(read_i2c(ACK) & 0x1f);
0BE4  0829     MOVF mth, W
0BE5  0084     MOVWF FSR
0BE6  3000     MOVLW 0x0
0BE7  2408     CALL 0x408
0BE8  120A     BCF PCLATH, 0x4
0BE9  158A     BSF PCLATH, 0x3
0BEA  391F     ANDLW 0x1F
0BEB  2514     CALL 0x514
0BEC  120A     BCF PCLATH, 0x4
0BED  158A     BSF PCLATH, 0x3
0BEE  1383     BCF STATUS, 0x7
0BEF  0080     MOVWF INDF
182:               *year = isl1208_bcd2bin(read_i2c(ACK));
0BF0  082A     MOVF year, W
0BF1  0084     MOVWF FSR
0BF2  3000     MOVLW 0x0
0BF3  2408     CALL 0x408
0BF4  120A     BCF PCLATH, 0x4
0BF5  158A     BSF PCLATH, 0x3
0BF6  2514     CALL 0x514
0BF7  120A     BCF PCLATH, 0x4
0BF8  158A     BSF PCLATH, 0x3
0BF9  1383     BCF STATUS, 0x7
0BFA  0080     MOVWF INDF
183:               *dow = isl1208_bcd2bin(read_i2c(NOACK) & 0x07);
0BFB  082B     MOVF Data, W
0BFC  0084     MOVWF FSR
0BFD  3001     MOVLW 0x1
0BFE  2408     CALL 0x408
0BFF  120A     BCF PCLATH, 0x4
0C00  158A     BSF PCLATH, 0x3
0C01  3907     ANDLW 0x7
0C02  2514     CALL 0x514
0C03  120A     BCF PCLATH, 0x4
0C04  158A     BSF PCLATH, 0x3
0C05  1383     BCF STATUS, 0x7
0C06  0080     MOVWF INDF
184:               stop_i2c();
0C07  2D1E     GOTO 0x51E
185:           #ifndef USE_INTERRUPTS
186:               // ei();
187:           #endif
188:           
189:           }
190:           
191:           void isl1208_get_time(unsigned char *hr, unsigned char* min, unsigned char *sec) {
0B52  00AB     MOVWF Data
192:           
193:           #ifndef USE_INTERRUPTS
194:               // di();
195:           #endif
196:           
197:               start_i2c();
0B53  250C     CALL 0x50C
0B54  120A     BCF PCLATH, 0x4
0B55  158A     BSF PCLATH, 0x3
198:               write_i2c(isl1208_Write);
0B56  30DE     MOVLW 0xDE
0B57  24E2     CALL 0x4E2
0B58  120A     BCF PCLATH, 0x4
0B59  158A     BSF PCLATH, 0x3
199:               write_i2c(0x00);
0B5A  3000     MOVLW 0x0
0B5B  24E2     CALL 0x4E2
0B5C  120A     BCF PCLATH, 0x4
0B5D  158A     BSF PCLATH, 0x3
200:           
201:               rstart_i2c();
0B5E  2526     CALL 0x526
0B5F  120A     BCF PCLATH, 0x4
0B60  158A     BSF PCLATH, 0x3
202:               write_i2c(isl1208_Read);
0B61  30DF     MOVLW 0xDF
0B62  24E2     CALL 0x4E2
0B63  120A     BCF PCLATH, 0x4
0B64  158A     BSF PCLATH, 0x3
203:               *sec = isl1208_bcd2bin(read_i2c(ACK) & 0x7f);
0B65  1283     BCF STATUS, 0x5
0B66  082A     MOVF year, W
0B67  0084     MOVWF FSR
0B68  3000     MOVLW 0x0
0B69  2408     CALL 0x408
0B6A  120A     BCF PCLATH, 0x4
0B6B  158A     BSF PCLATH, 0x3
0B6C  397F     ANDLW 0x7F
0B6D  2514     CALL 0x514
0B6E  120A     BCF PCLATH, 0x4
0B6F  158A     BSF PCLATH, 0x3
0B70  1383     BCF STATUS, 0x7
0B71  0080     MOVWF INDF
204:               * min = isl1208_bcd2bin(read_i2c(ACK) & 0x7f);
0B72  0829     MOVF mth, W
0B73  0084     MOVWF FSR
0B74  3000     MOVLW 0x0
0B75  2408     CALL 0x408
0B76  120A     BCF PCLATH, 0x4
0B77  158A     BSF PCLATH, 0x3
0B78  397F     ANDLW 0x7F
0B79  2514     CALL 0x514
0B7A  120A     BCF PCLATH, 0x4
0B7B  158A     BSF PCLATH, 0x3
0B7C  1383     BCF STATUS, 0x7
0B7D  0080     MOVWF INDF
205:               * hr = isl1208_bcd2bin(read_i2c(NOACK) & 0x3f);
0B7E  082B     MOVF Data, W
0B7F  0084     MOVWF FSR
0B80  3001     MOVLW 0x1
0B81  2408     CALL 0x408
0B82  120A     BCF PCLATH, 0x4
0B83  158A     BSF PCLATH, 0x3
0B84  393F     ANDLW 0x3F
0B85  2514     CALL 0x514
0B86  120A     BCF PCLATH, 0x4
0B87  158A     BSF PCLATH, 0x3
0B88  1383     BCF STATUS, 0x7
0B89  0080     MOVWF INDF
206:               stop_i2c();
0B8A  2D1E     GOTO 0x51E
207:           
208:           #ifndef USE_INTERRUPTS
209:               // ei();
210:           #endif
211:           
212:           }
213:           
214:           void isl1208_set_time_enc(unsigned char hr, unsigned char min, unsigned char sec) {
0C32  00AD     MOVWF hr
215:           #ifndef USE_INTERRUPTS
216:               //di();
217:           #endif
218:               min &=0x7F;
0C34  13AB     BCF Data, 0x7
219:               hr &= 0x3F;
0C33  303F     MOVLW 0x3F
0C35  05AD     ANDWF hr, F
220:               
221:               start_i2c();
0C36  250C     CALL 0x50C
0C37  120A     BCF PCLATH, 0x4
0C38  158A     BSF PCLATH, 0x3
222:               write_i2c(isl1208_Write);
0C39  30DE     MOVLW 0xDE
0C3A  24E2     CALL 0x4E2
0C3B  120A     BCF PCLATH, 0x4
0C3C  158A     BSF PCLATH, 0x3
223:               write_i2c(0x0C);
0C3D  300C     MOVLW 0xC
0C3E  24E2     CALL 0x4E2
0C3F  120A     BCF PCLATH, 0x4
0C40  158A     BSF PCLATH, 0x3
224:               write_i2c(isl1208_bin2bcd(0));
0C41  3000     MOVLW 0x0
0C42  24FA     CALL 0x4FA
0C43  120A     BCF PCLATH, 0x4
0C44  158A     BSF PCLATH, 0x3
0C45  24E2     CALL 0x4E2
0C46  120A     BCF PCLATH, 0x4
0C47  158A     BSF PCLATH, 0x3
225:               write_i2c(isl1208_bin2bcd(min)| 0b10000000); //habilita la alarma de minutos
0C48  1283     BCF STATUS, 0x5
0C49  082B     MOVF Data, W
0C4A  24FA     CALL 0x4FA
0C4B  120A     BCF PCLATH, 0x4
0C4C  158A     BSF PCLATH, 0x3
0C4D  3880     IORLW 0x80
0C4E  24E2     CALL 0x4E2
0C4F  120A     BCF PCLATH, 0x4
0C50  158A     BSF PCLATH, 0x3
226:               write_i2c(isl1208_bin2bcd(hr) | 0b10000000); //habilita la alarma de horas
0C51  1283     BCF STATUS, 0x5
0C52  082D     MOVF hr, W
0C53  24FA     CALL 0x4FA
0C54  120A     BCF PCLATH, 0x4
0C55  158A     BSF PCLATH, 0x3
0C56  3880     IORLW 0x80
0C57  24E2     CALL 0x4E2
0C58  120A     BCF PCLATH, 0x4
0C59  158A     BSF PCLATH, 0x3
227:               stop_i2c();
0C5A  2D1E     GOTO 0x51E
228:           
229:           #ifndef USE_INTERRUPTS
230:               //  ei();
231:           #endif
232:           
233:           }
234:           void isl1208_set_dow_enc(unsigned char *dow) {
235:           //TODO terminar de implementar la funcion de escritura de dow.
236:           #ifndef USE_INTERRUPTS
237:               //di();
238:           #endif
239:               *dow &=0x07;
240:               start_i2c();
241:               write_i2c(isl1208_Write);
242:               write_i2c(0x11);
243:               write_i2c(isl1208_bin2bcd(*dow)| 0b10000000); //habilita la alarma de dow
244:               stop_i2c();
245:           
246:           #ifndef USE_INTERRUPTS
247:               //  ei();
248:           #endif
249:           
250:           }
251:           
252:           void isl1208_get_dow_enc(unsigned char *dow) {
0B30  1283     BCF STATUS, 0x5
0B31  00A9     MOVWF mth
253:           //TODO terminar de implementar la funcion de escritura de dow.
254:           #ifndef USE_INTERRUPTS
255:               //di();
256:           #endif
257:           
258:               start_i2c();
0B32  250C     CALL 0x50C
0B33  120A     BCF PCLATH, 0x4
0B34  158A     BSF PCLATH, 0x3
259:               write_i2c(isl1208_Write);
0B35  30DE     MOVLW 0xDE
0B36  24E2     CALL 0x4E2
0B37  120A     BCF PCLATH, 0x4
0B38  158A     BSF PCLATH, 0x3
260:               write_i2c(0x11);
0B39  3011     MOVLW 0x11
0B3A  24E2     CALL 0x4E2
0B3B  120A     BCF PCLATH, 0x4
0B3C  158A     BSF PCLATH, 0x3
261:               rstart_i2c();
0B3D  2526     CALL 0x526
0B3E  120A     BCF PCLATH, 0x4
0B3F  158A     BSF PCLATH, 0x3
262:               write_i2c(isl1208_Read);
0B40  30DF     MOVLW 0xDF
0B41  24E2     CALL 0x4E2
0B42  120A     BCF PCLATH, 0x4
0B43  158A     BSF PCLATH, 0x3
263:               *dow = isl1208_bcd2bin(read_i2c(NOACK) & 0x07);
0B44  1283     BCF STATUS, 0x5
0B45  0829     MOVF mth, W
0B46  0084     MOVWF FSR
0B47  3001     MOVLW 0x1
0B48  2408     CALL 0x408
0B49  120A     BCF PCLATH, 0x4
0B4A  158A     BSF PCLATH, 0x3
0B4B  3907     ANDLW 0x7
0B4C  2514     CALL 0x514
0B4D  120A     BCF PCLATH, 0x4
0B4E  158A     BSF PCLATH, 0x3
0B4F  1383     BCF STATUS, 0x7
0B50  0080     MOVWF INDF
264:               stop_i2c();
0B51  2D1E     GOTO 0x51E
265:           
266:           #ifndef USE_INTERRUPTS
267:               //  ei();
268:           #endif
269:           
270:           }
271:           void isl1208_get_time_enc(unsigned char *hr, unsigned char* min, unsigned char *sec) {
0B8B  00AB     MOVWF Data
272:           
273:           #ifndef USE_INTERRUPTS
274:               // di();
275:           #endif
276:           
277:               start_i2c();
0B8C  250C     CALL 0x50C
0B8D  120A     BCF PCLATH, 0x4
0B8E  158A     BSF PCLATH, 0x3
278:               write_i2c(isl1208_Write);
0B8F  30DE     MOVLW 0xDE
0B90  24E2     CALL 0x4E2
0B91  120A     BCF PCLATH, 0x4
0B92  158A     BSF PCLATH, 0x3
279:               write_i2c(0x0C);
0B93  300C     MOVLW 0xC
0B94  24E2     CALL 0x4E2
0B95  120A     BCF PCLATH, 0x4
0B96  158A     BSF PCLATH, 0x3
280:           
281:               rstart_i2c();
0B97  2526     CALL 0x526
0B98  120A     BCF PCLATH, 0x4
0B99  158A     BSF PCLATH, 0x3
282:               write_i2c(isl1208_Read);
0B9A  30DF     MOVLW 0xDF
0B9B  24E2     CALL 0x4E2
0B9C  120A     BCF PCLATH, 0x4
0B9D  158A     BSF PCLATH, 0x3
283:               *sec = isl1208_bcd2bin(read_i2c(ACK) & 0x7f);
0B9E  1283     BCF STATUS, 0x5
0B9F  082A     MOVF year, W
0BA0  0084     MOVWF FSR
0BA1  3000     MOVLW 0x0
0BA2  2408     CALL 0x408
0BA3  120A     BCF PCLATH, 0x4
0BA4  158A     BSF PCLATH, 0x3
0BA5  397F     ANDLW 0x7F
0BA6  2514     CALL 0x514
0BA7  120A     BCF PCLATH, 0x4
0BA8  158A     BSF PCLATH, 0x3
0BA9  1383     BCF STATUS, 0x7
0BAA  0080     MOVWF INDF
284:               * min = isl1208_bcd2bin(read_i2c(ACK) & 0x7f);
0BAB  0829     MOVF mth, W
0BAC  0084     MOVWF FSR
0BAD  3000     MOVLW 0x0
0BAE  2408     CALL 0x408
0BAF  120A     BCF PCLATH, 0x4
0BB0  158A     BSF PCLATH, 0x3
0BB1  397F     ANDLW 0x7F
0BB2  2514     CALL 0x514
0BB3  120A     BCF PCLATH, 0x4
0BB4  158A     BSF PCLATH, 0x3
0BB5  1383     BCF STATUS, 0x7
0BB6  0080     MOVWF INDF
285:               * hr = isl1208_bcd2bin(read_i2c(NOACK) & 0x3f);
0BB7  082B     MOVF Data, W
0BB8  0084     MOVWF FSR
0BB9  3001     MOVLW 0x1
0BBA  2408     CALL 0x408
0BBB  120A     BCF PCLATH, 0x4
0BBC  158A     BSF PCLATH, 0x3
0BBD  393F     ANDLW 0x3F
0BBE  2514     CALL 0x514
0BBF  120A     BCF PCLATH, 0x4
0BC0  158A     BSF PCLATH, 0x3
0BC1  1383     BCF STATUS, 0x7
0BC2  0080     MOVWF INDF
286:               stop_i2c();
0BC3  2D1E     GOTO 0x51E
287:           
288:           #ifndef USE_INTERRUPTS
289:               // ei();
290:           #endif
291:           
292:           }
293:           
294:           char isl1208_read_nvram_byte(char addr) {
295:           
296:               char retval;
297:           
298:           #ifndef USE_INTERRUPTS
299:               // di();
300:           #endif
301:           
302:               start_i2c();
303:               write_i2c(isl1208_Write);
304:               write_i2c(addr);
305:           
306:               start_i2c();
307:               write_i2c(isl1208_Read);
308:               retval = read_i2c(NOACK);
309:               stop_i2c();
310:           
311:           
312:           
313:           #ifndef USE_INTERRUPTS
314:               // ei();
315:           #endif
316:               return (retval);
317:           }
318:           
319:           void isl1208_write_nvram_byte(char addr, char value) {
320:           
321:           #ifndef USE_INTERRUPTS
322:               //di();
323:           #endif
324:           
325:               start_i2c();
326:               write_i2c(isl1208_Write);
327:               write_i2c(addr);
328:               write_i2c(value);
329:               stop_i2c();
330:           
331:           #ifndef USE_INTERRUPTS
332:               // ei();
333:           #endif
334:           
335:           }
336:           int aniobisiesto(unsigned char year)
179D  00FA     MOVWF j
337:           {
338:               return ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0);
179E  01F9     CLRF Indice
179F  0AF9     INCF Indice, F
17A0  3903     ANDLW 0x3
17A1  1D03     BTFSS STATUS, 0x2
17A2  2FAC     GOTO 0x7AC
17A3  3064     MOVLW 0x64
17A4  00F0     MOVWF tiempo
17A5  087A     MOVF j, W
17A6  27C8     CALL 0x7C8
17A7  160A     BSF PCLATH, 0x4
17A8  118A     BCF PCLATH, 0x3
17A9  3800     IORLW 0x0
17AA  1D03     BTFSS STATUS, 0x2
17AB  2FBA     GOTO 0x7BA
17AC  3090     MOVLW 0x90
17AD  00F0     MOVWF tiempo
17AE  3001     MOVLW 0x1
17AF  00F1     MOVWF canal
17B0  087A     MOVF j, W
17B1  00F2     MOVWF dividend
17B2  01F3     CLRF counter
17B3  120A     BCF PCLATH, 0x4
17B4  158A     BSF PCLATH, 0x3
17B5  2008     CALL 0x8
17B6  0871     MOVF canal, W
17B7  0470     IORWF tiempo, W
17B8  1D03     BTFSS STATUS, 0x2
17B9  01F9     CLRF Indice
17BA  0879     MOVF Indice, W
17BB  00F6     MOVWF TipoPin
17BC  01F7     CLRF Logica
339:           }
17BD  0008     RETURN
340:           unsigned char dia_de_la_semana(unsigned char *dia, unsigned char *mes, unsigned char *anio){
0A19  00C6     MOVWF dia
341:           //se usa el algoritmo de Zeller
342:              unsigned char a,y,m,dow;
343:           
344:              a = (14 -*mes) / 12;
0A1A  300E     MOVLW 0xE
0A1B  00AC     MOVWF sec
0A1C  01AD     CLRF hr
0A1D  0838     MOVF mes, W
0A1E  0084     MOVWF FSR
0A1F  1383     BCF STATUS, 0x7
0A20  0800     MOVF INDF, W
0A21  02AC     SUBWF sec, F
0A22  1C03     BTFSS STATUS, 0x0
0A23  03AD     DECF hr, F
0A24  300C     MOVLW 0xC
0A25  00AA     MOVWF year
0A26  01AB     CLRF Data
0A27  2294     CALL 0x294
0A28  120A     BCF PCLATH, 0x4
0A29  158A     BSF PCLATH, 0x3
0A2A  082A     MOVF year, W
0A2B  00C5     MOVWF a
345:           y = *anio - a;
0A2C  0839     MOVF anio, W
0A2D  0084     MOVWF FSR
0A2E  0845     MOVF a, W
0A2F  1383     BCF STATUS, 0x7
0A30  0200     SUBWF INDF, W
0A31  00C7     MOVWF y
346:           m = *mes + 12 * a - 2;
0A32  0838     MOVF mes, W
0A33  0084     MOVWF FSR
0A34  300C     MOVLW 0xC
0A35  00A4     MOVWF x
0A36  0845     MOVF a, W
0A37  2549     CALL 0x549
0A38  120A     BCF PCLATH, 0x4
0A39  158A     BSF PCLATH, 0x3
0A3A  1383     BCF STATUS, 0x7
0A3B  0700     ADDWF INDF, W
0A3C  3EFE     ADDLW 0xFE
0A3D  00C3     MOVWF m
347:           
348:           //Para el calendario Juliano:
349:           //d = (5 + dia + y + y/4 + (31*m)/12) mod 7
350:           
351:           //Para el calendario Gregoriano:
352:            dow = (*dia + y + y/4 - y/100 + y/400 + (31*m)/12) % 7;
0A3E  3007     MOVLW 0x7
0A3F  00B2     MOVWF divisor
0A40  3090     MOVLW 0x90
0A41  01B3     CLRF 0x33
0A42  00AA     MOVWF year
0A43  3001     MOVLW 0x1
0A44  00AB     MOVWF Data
0A45  0847     MOVF y, W
0A46  00AC     MOVWF sec
0A47  01AD     CLRF hr
0A48  2294     CALL 0x294
0A49  120A     BCF PCLATH, 0x4
0A4A  158A     BSF PCLATH, 0x3
0A4B  0847     MOVF y, W
0A4C  00BA     MOVWF sign
0A4D  1003     BCF STATUS, 0x0
0A4E  0CBA     RRF sign, F
0A4F  1003     BCF STATUS, 0x0
0A50  0CBA     RRF sign, F
0A51  0846     MOVF dia, W
0A52  0084     MOVWF FSR
0A53  1383     BCF STATUS, 0x7
0A54  0800     MOVF INDF, W
0A55  0747     ADDWF y, W
0A56  00BB     MOVWF exp2
0A57  01BC     CLRF exp1
0A58  0DBC     RLF exp1, F
0A59  083A     MOVF sign, W
0A5A  073B     ADDWF exp2, W
0A5B  00BD     MOVWF f2
0A5C  3000     MOVLW 0x0
0A5D  1803     BTFSC STATUS, 0x0
0A5E  3001     MOVLW 0x1
0A5F  073C     ADDWF exp1, W
0A60  00BE     MOVWF 0x3E
0A61  082A     MOVF year, W
0A62  073D     ADDWF f2, W
0A63  00BF     MOVWF 0x3F
0A64  082B     MOVF Data, W
0A65  1803     BTFSC STATUS, 0x0
0A66  0A2B     INCF Data, W
0A67  073E     ADDWF 0x3E, W
0A68  00C0     MOVWF 0x40
0A69  300C     MOVLW 0xC
0A6A  00AA     MOVWF year
0A6B  01AB     CLRF Data
0A6C  0843     MOVF m, W
0A6D  00A4     MOVWF x
0A6E  301F     MOVLW 0x1F
0A6F  01A5     CLRF dato
0A70  00A6     MOVWF y
0A71  01A7     CLRF x
0A72  2799     CALL 0x799
0A73  120A     BCF PCLATH, 0x4
0A74  158A     BSF PCLATH, 0x3
0A75  0825     MOVF dato, W
0A76  00AD     MOVWF hr
0A77  0824     MOVF x, W
0A78  00AC     MOVWF sec
0A79  2294     CALL 0x294
0A7A  120A     BCF PCLATH, 0x4
0A7B  158A     BSF PCLATH, 0x3
0A7C  082A     MOVF year, W
0A7D  073F     ADDWF 0x3F, W
0A7E  00C1     MOVWF f1
0A7F  082B     MOVF Data, W
0A80  1803     BTFSC STATUS, 0x0
0A81  0A2B     INCF Data, W
0A82  0740     ADDWF 0x40, W
0A83  00C2     MOVWF 0x42
0A84  3064     MOVLW 0x64
0A85  00A4     MOVWF x
0A86  0847     MOVF y, W
0A87  252E     CALL 0x52E
0A88  120A     BCF PCLATH, 0x4
0A89  158A     BSF PCLATH, 0x3
0A8A  0241     SUBWF f1, W
0A8B  00B4     MOVWF dividend
0A8C  0842     MOVF 0x42, W
0A8D  1C03     BTFSS STATUS, 0x0
0A8E  0342     DECF 0x42, W
0A8F  00B5     MOVWF 0x35
0A90  2558     CALL 0x558
0A91  0832     MOVF divisor, W
0A92  00C4     MOVWF dow
353:           
354:           //El resultado es un cero (0) para el domingo, 1 para el lunes? 6 para el sbado
355:           
356:            return (dow);
357:           }
0A93  0008     RETURN
358:           ///////////////////////////////////////////////////////////////////////////////
359:           
360:           unsigned char isl1208_bin2bcd(unsigned char binary_value) {
0CFA  1283     BCF STATUS, 0x5
0CFB  00AA     MOVWF year
361:               return ((binary_value / 10) << 4) +binary_value % 10;
0CFC  300A     MOVLW 0xA
0CFD  00A4     MOVWF x
0CFE  082A     MOVF year, W
0CFF  252E     CALL 0x52E
0D00  120A     BCF PCLATH, 0x4
0D01  158A     BSF PCLATH, 0x3
0D02  00A9     MOVWF mth
0D03  0E29     SWAPF mth, W
0D04  39F0     ANDLW 0xF0
0D05  00A9     MOVWF mth
0D06  300A     MOVLW 0xA
0D07  00A4     MOVWF x
0D08  082A     MOVF year, W
0D09  2595     CALL 0x595
0D0A  0729     ADDWF mth, W
362:           
363:           }
0D0B  0008     RETURN
364:           
365:           unsigned char isl1208_bcd2bin(unsigned char bcd_value) {
0D14  00A8     MOVWF i
366:               return (bcd_value & 0x0F) + (bcd_value >> 4) * 10;
0D15  390F     ANDLW 0xF
0D16  00A7     MOVWF x
0D17  300A     MOVLW 0xA
0D18  00A4     MOVWF x
0D19  0E28     SWAPF i, W
0D1A  390F     ANDLW 0xF
0D1B  2549     CALL 0x549
0D1C  0727     ADDWF x, W
367:           }
0D1D  0008     RETURN
368:           
369:           
370:           /*unsigned int ISL1208::bcd2bin(unsigned char val)
371:           {
372:               return (val & 0x0F) + (val >> 4) * 10;
373:           }
374:           
375:           char ISL1208::bin2bcd(unsigned int val)
376:           {
377:               return ((val / 10) << 4) + val % 10;
378:           }*/
379:           ///////////////////////////////////////////////////////////////////////////////
380:           
381:           
382:           
383:           
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/Pulsadores.c  -------------------------
1:             //Programa de gestin de pulsadores por Nocturno adaptado a xc8 por Pablo F. Manieri
2:             //Cdigo original bajado de: http://www.micropic.es/mpblog/2014/05/gestion-de-pulsadores/
3:             // Gracias Nocturno
4:             #include <xc.h>
5:             #include <stdint.h>
6:             #include <stdbool.h>
7:             #include "system.h"
8:             #include "user.h"
9:             #include "Pulsadores.h"
10:            
11:            /****** HARDWARE ********
12:            BOTON_Subir       	RB2
13:            BOTON_Bajar       	RB1
14:            BOTON_MENU       	RB3
15:            BOTON_MANAUT     	RB4
16:            BOTON_ONOFF		RB5
17:            **************************/
18:            
19:            bool Pulsacion(unsigned char Indice, unsigned char Pin, unsigned char TipoPin, bool Logica) {
16D0  00F9     MOVWF Indice
20:               /*
21:                  Esta funcin gestiona las entradas de pulsador, mediante el control de un retardo
22:                  antirrebotes y con la opcin de autorrepeticin de hasta 4 velocidades
23:                  
24:                  Para que funcione, hay que dimensionar la variable Entradas con el n de pulsadores
25:                  que queramos controlar.
26:                  
27:                  ENTRADAS
28:                     Indice: hace referencia al n de pulsador a chequear
29:                     Pin: indica el estado del pin del pulsador (lgica inversa)
30:                     TipoPIN:
31:                        TipoPin=0   -> No tiene autorrepeticin
32:                        TipoPin=1   -> Pin con autorrepeticin
33:                     
34:                  SALIDA
35:                     La funcin devuelve un 1 si el pulsador est en condiciones de ser procesado
36:                     y un 0 en caso contrario.
37:                  
38:               */
39:               static unsigned int Entradas[5]={0,0,0,0,0};  // Dimensionar en funcin del n de pulsadores
40:               unsigned int j;
41:              bool resultado=0;
16D1  01F8     CLRF resultado
42:               
43:               j=Entradas[Indice];  // Como leemos muchas veces el array, lo pasamos a variable local para 
16D2  1003     BCF STATUS, 0x0
16D3  0D79     RLF Indice, W
16D4  3E90     ADDLW 0x90
16D5  0084     MOVWF FSR
16D6  1783     BSF STATUS, 0x7
16D7  0800     MOVF INDF, W
16D8  00FA     MOVWF j
16D9  0A84     INCF FSR, F
16DA  0800     MOVF INDF, W
16DB  00FB     MOVWF 0x7B
44:                                    // incrementar la velocidad de ejecucin
45:                                    
46:               // Si se detecta pulsacin y antes no haba, devolvemos un 1 en resultado
47:               if ((((!Pin && Logica==LOGICA_INVERSA) || (Pin && Logica==LOGICA_DIRECTA)) && (j==0))) {
16DC  08F5     MOVF Pin, F
16DD  1903     BTFSC STATUS, 0x2
16DE  0377     DECF Logica, W
16DF  1903     BTFSC STATUS, 0x2
16E0  2EE7     GOTO 0x6E7
16E1  0875     MOVF Pin, W
16E2  1903     BTFSC STATUS, 0x2
16E3  2EF0     GOTO 0x6F0
16E4  08F7     MOVF Logica, F
16E5  1D03     BTFSS STATUS, 0x2
16E6  2EF0     GOTO 0x6F0
16E7  087B     MOVF 0x7B, W
16E8  047A     IORWF j, W
16E9  1D03     BTFSS STATUS, 0x2
16EA  2EF0     GOTO 0x6F0
48:                     resultado=1;
16EB  01F8     CLRF resultado
16EC  0AF8     INCF resultado, F
49:                     j=1;
16ED  01FA     CLRF j
16EE  0AFA     INCF j, F
16EF  01FB     CLRF 0x7B
50:               };
51:               
52:               // Cada vez que se entra a la funcin se incrementa una unidad el array
53:               if (j>0) 
16F0  087B     MOVF 0x7B, W
16F1  047A     IORWF j, W
16F2  1903     BTFSC STATUS, 0x2
16F3  2EFD     GOTO 0x6FD
54:                     Entradas[Indice]++;
16F4  1003     BCF STATUS, 0x0
16F5  0D79     RLF Indice, W
16F6  3E90     ADDLW 0x90
16F7  0084     MOVWF FSR
16F8  3001     MOVLW 0x1
16F9  0780     ADDWF INDF, F
16FA  0A84     INCF FSR, F
16FB  1803     BTFSC STATUS, 0x0
16FC  0A80     INCF INDF, F
55:               
56:               // Si se detecta que ya no se est pulsando, inicializamos a 0 el array
57:               if (((Pin && Logica==LOGICA_INVERSA) || (!Pin && Logica==LOGICA_DIRECTA)) && j>ANTIRREBOTES)
16FD  0875     MOVF Pin, W
16FE  1903     BTFSC STATUS, 0x2
16FF  2F03     GOTO 0x703
1700  0377     DECF Logica, W
1701  1903     BTFSC STATUS, 0x2
1702  2F09     GOTO 0x709
1703  08F5     MOVF Pin, F
1704  1D03     BTFSS STATUS, 0x2
1705  2F17     GOTO 0x717
1706  08F7     MOVF Logica, F
1707  1D03     BTFSS STATUS, 0x2
1708  2F17     GOTO 0x717
1709  3000     MOVLW 0x0
170A  027B     SUBWF 0x7B, W
170B  3033     MOVLW 0x33
170C  1903     BTFSC STATUS, 0x2
170D  027A     SUBWF j, W
170E  1C03     BTFSS STATUS, 0x0
170F  2F17     GOTO 0x717
58:                  Entradas[Indice]=0;
1710  1003     BCF STATUS, 0x0
1711  0D79     RLF Indice, W
1712  3E90     ADDLW 0x90
1713  0084     MOVWF FSR
1714  0180     CLRF INDF
1715  0A84     INCF FSR, F
1716  0180     CLRF INDF
59:                  
60:               if (TipoPin) { // Si el pulsador tiene autorrepeticin
1717  0876     MOVF TipoPin, W
1718  1903     BTFSC STATUS, 0x2
1719  2F66     GOTO 0x766
61:                 // Cuando se supera el n de ciclos 4, devolveremos un 1 con la frecuencia VELOCIDAD4
62:                   if ((j>=CAMBIO4) && !(j%VELOCIDAD4)){
171A  300F     MOVLW 0xF
171B  027B     SUBWF 0x7B, W
171C  30A0     MOVLW 0xA0
171D  1903     BTFSC STATUS, 0x2
171E  027A     SUBWF j, W
171F  1803     BTFSC STATUS, 0x0
1720  187A     BTFSC j, 0x0
1721  2F27     GOTO 0x727
63:                       resultado=1;
1722  01F8     CLRF resultado
1723  0AF8     INCF resultado, F
64:                  }else
1724  1283     BCF STATUS, 0x5
1725  1303     BCF STATUS, 0x6
1726  2F66     GOTO 0x766
65:                   // Cuando se supera el n de ciclos 3, devolveremos un 1 con la frecuencia VELOCIDAD3
66:                  if ((j>=CAMBIO3) && !(j%VELOCIDAD3)){           
1727  3007     MOVLW 0x7
1728  027B     SUBWF 0x7B, W
1729  30D0     MOVLW 0xD0
172A  1903     BTFSC STATUS, 0x2
172B  027A     SUBWF j, W
172C  1C03     BTFSS STATUS, 0x0
172D  2F3C     GOTO 0x73C
172E  300A     MOVLW 0xA
172F  00F0     MOVWF tiempo
1730  01F1     CLRF canal
1731  087B     MOVF 0x7B, W
1732  00F3     MOVWF counter
1733  087A     MOVF j, W
1734  00F2     MOVWF dividend
1735  2772     CALL 0x772
1736  160A     BSF PCLATH, 0x4
1737  118A     BCF PCLATH, 0x3
1738  0871     MOVF canal, W
1739  0470     IORWF tiempo, W
173A  1903     BTFSC STATUS, 0x2
173B  2F22     GOTO 0x722
67:                     resultado=1;
68:                  } else 
69:                     // Cuando se supera el n de ciclos 2, devolveremos un 1 con la frecuencia VELOCIDAD2
70:                     if ((j>=CAMBIO2) && !(j%VELOCIDAD2)){
173C  3001     MOVLW 0x1
173D  027B     SUBWF 0x7B, W
173E  30F4     MOVLW 0xF4
173F  1903     BTFSC STATUS, 0x2
1740  027A     SUBWF j, W
1741  1C03     BTFSS STATUS, 0x0
1742  2F51     GOTO 0x751
1743  3032     MOVLW 0x32
1744  00F0     MOVWF tiempo
1745  01F1     CLRF canal
1746  087B     MOVF 0x7B, W
1747  00F3     MOVWF counter
1748  087A     MOVF j, W
1749  00F2     MOVWF dividend
174A  2772     CALL 0x772
174B  160A     BSF PCLATH, 0x4
174C  118A     BCF PCLATH, 0x3
174D  0871     MOVF canal, W
174E  0470     IORWF tiempo, W
174F  1903     BTFSC STATUS, 0x2
1750  2F22     GOTO 0x722
71:                        resultado=1;
72:                  } else
73:                     // Cuando se supera el n de ciclos 1, devolveremos un 1 con la frecuencia VELOCIDAD1
74:                     if ((j>CAMBIO1) && !(j%VELOCIDAD1)){
1751  3000     MOVLW 0x0
1752  027B     SUBWF 0x7B, W
1753  3065     MOVLW 0x65
1754  1903     BTFSC STATUS, 0x2
1755  027A     SUBWF j, W
1756  1C03     BTFSS STATUS, 0x0
1757  2F66     GOTO 0x766
1758  3064     MOVLW 0x64
1759  00F0     MOVWF tiempo
175A  01F1     CLRF canal
175B  087B     MOVF 0x7B, W
175C  00F3     MOVWF counter
175D  087A     MOVF j, W
175E  00F2     MOVWF dividend
175F  2772     CALL 0x772
1760  160A     BSF PCLATH, 0x4
1761  118A     BCF PCLATH, 0x3
1762  0871     MOVF canal, W
1763  0470     IORWF tiempo, W
1764  1903     BTFSC STATUS, 0x2
1765  2F22     GOTO 0x722
75:                        resultado=1;
76:                  };
77:               }
78:               if ((TipoPin==INMEDIATO)&&(j>=1))
1766  0876     MOVF TipoPin, W
1767  3A02     XORLW 0x2
1768  1D03     BTFSS STATUS, 0x2
1769  2F70     GOTO 0x770
176A  087B     MOVF 0x7B, W
176B  047A     IORWF j, W
176C  1903     BTFSC STATUS, 0x2
176D  2F70     GOTO 0x770
79:                   resultado=1;
176E  01F8     CLRF resultado
176F  0AF8     INCF resultado, F
80:               return (resultado);
1770  0878     MOVF resultado, W
81:            }
1771  0008     RETURN
82:            
83:            
84:               
85:            
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/LCDGeneric.c  -------------------------
1:             //Cdigo original bajado de: https://github.com/AleSuky/SkP32v1.1/blob/master/SW/Ejemplos/Micros-Designs/Source/LCDGeneric.c
2:             //Gracias Suky
3:             /**
4:                \version: 1.0
5:             
6:                
7:                \author Suky (Casanova Alejandro) 
8:                \web www.infopic.comlu.com
9:                \date 16/08/10
10:            
11:            
12:            ///////////////////////////////////////////////////////////////////////////
13:            ////                                                                   ////
14:            ////                                                                   ////
15:            ////        (C) Copyright 2010 www.infopic.comlu.com                   ////
16:            //// Este cdigo puede ser usado, modificado y distribuido libremente  ////
17:            //// sin eliminar esta cabecera y  sin garanta de ningn tipo.        ////
18:            ////                                                                   ////
19:            ////                                                                   ////
20:            /////////////////////////////////////////////////////////////////////////// 
21:               
22:             *- Version Log --------------------------------------------------------------*
23:             *   Fecha       Autor                Comentarios                             *
24:             *----------------------------------------------------------------------------*
25:             * 16/08/10      Suky               Original (Rev 1.0)                        *
26:             * 20/08/10      Suky               Se incluye CodeVisionAVR                  *
27:             *----------------------------------------------------------------------------* */
28:            #include "xc.h"
29:            #include "system.h"
30:            #include "LCDGeneric.h"
31:            
32:            UINT8 NLinea;
33:            
34:            UINT8 ui8BusyLCD(void){
35:            
36:            #ifdef LCD_USE_RW
37:            	 LCD_DATA_PIN_7 = 0;
09CD  1388     BCF PORTD, 0x7
38:            	 LCD_DATA_PIN_6 = 0;
09CE  1308     BCF PORTD, 0x6
39:            	 LCD_DATA_PIN_5 = 0;
09CF  1288     BCF PORTD, 0x5
40:            	 LCD_DATA_PIN_4 = 0;
09D0  1208     BCF PORTD, 0x4
41:            
42:                 LCD_TRIS_DATA_PIN_7 = CONFIG_INPUT;
09D1  1683     BSF STATUS, 0x5
09D2  1788     BSF PORTD, 0x7
43:                 LCD_TRIS_DATA_PIN_6 = CONFIG_INPUT;
09D3  1708     BSF PORTD, 0x6
44:                 LCD_TRIS_DATA_PIN_5 = CONFIG_INPUT;
09D4  1688     BSF PORTD, 0x5
45:                 LCD_TRIS_DATA_PIN_4 = CONFIG_INPUT;
09D5  1608     BSF PORTD, 0x4
46:            
47:                 LCD_RW_PIN = 1;    
09D6  1283     BCF STATUS, 0x5
09D7  1488     BSF PORTD, 0x1
48:                 LCD_RS_PIN = 0; 
09D8  1008     BCF PORTD, 0x0
49:            	 LCD_E_PIN=1;         
09D9  1508     BSF PORTD, 0x2
50:                 __delay_1us();
09DA  29DB     GOTO 0x1DB
09DB  29DC     GOTO 0x1DC
09DC  0000     NOP
51:            
52:                 if(LCD_READ_PIN_7==1){
09DD  1283     BCF STATUS, 0x5
09DE  1303     BCF STATUS, 0x6
09DF  1F88     BTFSS PORTD, 0x7
09E0  29F0     GOTO 0x1F0
53:                      LCD_E_PIN = 0; 
09E1  1108     BCF PORTD, 0x2
54:            		  __delay_1us();
09E2  29E3     GOTO 0x1E3
09E3  29E4     GOTO 0x1E4
09E4  0000     NOP
55:            		  LCD_E_PIN = 1;
09E5  1283     BCF STATUS, 0x5
09E6  1303     BCF STATUS, 0x6
09E7  1508     BSF PORTD, 0x2
56:            		  __delay_1us();
09E8  29E9     GOTO 0x1E9
09E9  29EA     GOTO 0x1EA
09EA  0000     NOP
57:            		  LCD_E_PIN = 0;
09EB  1283     BCF STATUS, 0x5
09EC  1303     BCF STATUS, 0x6
09ED  1108     BCF PORTD, 0x2
58:                  	  LCD_RW_PIN = 0; 
09EE  1088     BCF PORTD, 0x1
59:                      return 1;
09EF  3401     RETLW 0x1
60:                 }else{
61:                      LCD_E_PIN = 0;
09F0  1108     BCF PORTD, 0x2
62:            		  __delay_1us();
09F1  29F2     GOTO 0x1F2
09F2  29F3     GOTO 0x1F3
09F3  0000     NOP
63:            		  LCD_E_PIN = 1;
09F4  1283     BCF STATUS, 0x5
09F5  1303     BCF STATUS, 0x6
09F6  1508     BSF PORTD, 0x2
64:            		  __delay_1us();
09F7  29F8     GOTO 0x1F8
09F8  29F9     GOTO 0x1F9
09F9  0000     NOP
65:            		  LCD_E_PIN = 0;
09FA  1283     BCF STATUS, 0x5
09FB  1303     BCF STATUS, 0x6
09FC  1108     BCF PORTD, 0x2
66:            		  LCD_RW_PIN = 0;       
09FD  1088     BCF PORTD, 0x1
67:                      return 0;
09FE  3400     RETLW 0x0
68:                 }
69:            #else
70:            	 __delay_100us();
71:            	 return 0;
72:            #endif
73:            }
74:            
75:            void vWriteLCD(UINT8 Data,UINT8 Type){
095C  00A5     MOVWF dato
76:            
77:            #ifdef LCD_USE_3PINES
78:            	UINT8 i, data_temp;
79:            #endif
80:            
81:            	while(ui8BusyLCD());
095D  21CD     CALL 0x1CD
095E  120A     BCF PCLATH, 0x4
095F  158A     BSF PCLATH, 0x3
0960  3800     IORLW 0x0
0961  1D03     BTFSS STATUS, 0x2
0962  295D     GOTO 0x15D
82:            
83:            	#ifndef LCD_USE_3PINES
84:            		#ifdef LCD_USE_RW
85:            			LCD_RW_PIN = 0;
0963  1088     BCF PORTD, 0x1
86:            		#endif   
87:            		if(Type){
0964  0824     MOVF x, W
0965  1903     BTFSC STATUS, 0x2
0966  2969     GOTO 0x169
88:            			LCD_RS_PIN=1;
0967  1408     BSF PORTD, 0x0
89:            		}else{
0968  296A     GOTO 0x16A
90:            			LCD_RS_PIN = 0;
0969  1008     BCF PORTD, 0x0
91:            		}	  
92:            		LCD_TRIS_DATA_PIN_7 = CONFIG_OUTPUT;
096A  1683     BSF STATUS, 0x5
096B  1388     BCF PORTD, 0x7
93:            		LCD_TRIS_DATA_PIN_6 = CONFIG_OUTPUT;
096C  1308     BCF PORTD, 0x6
94:            		LCD_TRIS_DATA_PIN_5 = CONFIG_OUTPUT;
096D  1288     BCF PORTD, 0x5
95:            		LCD_TRIS_DATA_PIN_4 = CONFIG_OUTPUT;
096E  1208     BCF PORTD, 0x4
96:            		
97:            		LCD_DATA_PIN_7 = !!(Data & 0x80);
096F  1283     BCF STATUS, 0x5
0970  1FA5     BTFSS dato, 0x7
0971  2976     GOTO 0x176
0972  1283     BCF STATUS, 0x5
0973  1303     BCF STATUS, 0x6
0974  1788     BSF PORTD, 0x7
0975  2979     GOTO 0x179
0976  1283     BCF STATUS, 0x5
0977  1303     BCF STATUS, 0x6
0978  1388     BCF PORTD, 0x7
98:            		LCD_DATA_PIN_6 = !!(Data & 0x40);
0979  1F25     BTFSS dato, 0x6
097A  297F     GOTO 0x17F
097B  1283     BCF STATUS, 0x5
097C  1303     BCF STATUS, 0x6
097D  1708     BSF PORTD, 0x6
097E  2982     GOTO 0x182
097F  1283     BCF STATUS, 0x5
0980  1303     BCF STATUS, 0x6
0981  1308     BCF PORTD, 0x6
99:            		LCD_DATA_PIN_5 = !!(Data & 0x20);
0982  1EA5     BTFSS dato, 0x5
0983  2988     GOTO 0x188
0984  1283     BCF STATUS, 0x5
0985  1303     BCF STATUS, 0x6
0986  1688     BSF PORTD, 0x5
0987  298B     GOTO 0x18B
0988  1283     BCF STATUS, 0x5
0989  1303     BCF STATUS, 0x6
098A  1288     BCF PORTD, 0x5
100:           		LCD_DATA_PIN_4 = !!(Data & 0x10);
098B  1E25     BTFSS dato, 0x4
098C  2991     GOTO 0x191
098D  1283     BCF STATUS, 0x5
098E  1303     BCF STATUS, 0x6
098F  1608     BSF PORTD, 0x4
0990  2994     GOTO 0x194
0991  1283     BCF STATUS, 0x5
0992  1303     BCF STATUS, 0x6
0993  1208     BCF PORTD, 0x4
101:           	#else
102:           		data_temp=(Data>>4);  // Rs es bit 4
103:           		if(Type){
104:           			data_temp|=0x10;
105:           		}
106:           		for(i=0;i<8;i++){
107:           			LCD_DATA_PIN=!!(data_temp & 0x80);
108:           			data_temp<<=1;
109:           			LCD_CLOCK_PIN=1;
110:           			__delay_1us();
111:           			LCD_CLOCK_PIN=0;
112:           		}
113:           	#endif
114:           	__delay_1Cycle();
0994  0000     NOP
115:           	LCD_E_PIN = 1;
0995  1283     BCF STATUS, 0x5
0996  1303     BCF STATUS, 0x6
0997  1508     BSF PORTD, 0x2
116:           	__delay_1us();
0998  2999     GOTO 0x199
0999  299A     GOTO 0x19A
099A  0000     NOP
117:           	LCD_E_PIN = 0;
099B  1283     BCF STATUS, 0x5
099C  1303     BCF STATUS, 0x6
099D  1108     BCF PORTD, 0x2
118:           	#ifndef LCD_USE_3PINES	
119:           		LCD_DATA_PIN_7 = !!(Data & 0x08);
099E  1DA5     BTFSS dato, 0x3
099F  29A4     GOTO 0x1A4
09A0  1283     BCF STATUS, 0x5
09A1  1303     BCF STATUS, 0x6
09A2  1788     BSF PORTD, 0x7
09A3  29A7     GOTO 0x1A7
09A4  1283     BCF STATUS, 0x5
09A5  1303     BCF STATUS, 0x6
09A6  1388     BCF PORTD, 0x7
120:           		LCD_DATA_PIN_6 = !!(Data & 0x04);
09A7  1D25     BTFSS dato, 0x2
09A8  29AD     GOTO 0x1AD
09A9  1283     BCF STATUS, 0x5
09AA  1303     BCF STATUS, 0x6
09AB  1708     BSF PORTD, 0x6
09AC  29B0     GOTO 0x1B0
09AD  1283     BCF STATUS, 0x5
09AE  1303     BCF STATUS, 0x6
09AF  1308     BCF PORTD, 0x6
121:           		LCD_DATA_PIN_5 = !!(Data & 0x02);
09B0  1CA5     BTFSS dato, 0x1
09B1  29B6     GOTO 0x1B6
09B2  1283     BCF STATUS, 0x5
09B3  1303     BCF STATUS, 0x6
09B4  1688     BSF PORTD, 0x5
09B5  29B9     GOTO 0x1B9
09B6  1283     BCF STATUS, 0x5
09B7  1303     BCF STATUS, 0x6
09B8  1288     BCF PORTD, 0x5
122:           		LCD_DATA_PIN_4 = !!(Data & 0x01);
09B9  1C25     BTFSS dato, 0x0
09BA  29BF     GOTO 0x1BF
09BB  1283     BCF STATUS, 0x5
09BC  1303     BCF STATUS, 0x6
09BD  1608     BSF PORTD, 0x4
09BE  29C2     GOTO 0x1C2
09BF  1283     BCF STATUS, 0x5
09C0  1303     BCF STATUS, 0x6
09C1  1208     BCF PORTD, 0x4
123:           	#else
124:           		data_temp=(Data&0x0F);  // Rs es bit 4
125:           		if(Type){
126:           			data_temp|=0x10;
127:           		}
128:           		for(i=0;i<8;i++){
129:           			LCD_DATA_PIN=!!(data_temp & 0x80);
130:           			data_temp<<=1;
131:           			LCD_CLOCK_PIN=1;
132:           			__delay_1us();
133:           			LCD_CLOCK_PIN=0;
134:           		}
135:           	#endif
136:           	__delay_1Cycle();	
09C2  0000     NOP
137:           	LCD_E_PIN = 1;
09C3  1283     BCF STATUS, 0x5
09C4  1303     BCF STATUS, 0x6
09C5  1508     BSF PORTD, 0x2
138:           	__delay_1us();
09C6  29C7     GOTO 0x1C7
09C7  29C8     GOTO 0x1C8
09C8  0000     NOP
139:           	LCD_E_PIN = 0;
09C9  1283     BCF STATUS, 0x5
09CA  1303     BCF STATUS, 0x6
09CB  1108     BCF PORTD, 0x2
140:           	
141:           } 
09CC  0008     RETURN
142:           
143:           void vInitLCD(){
144:           UINT8 i;
145:           #ifdef LCD_USE_3PINES
146:           	UINT8 temp;
147:           #endif
148:           
149:           	for(i=0;i<8;i++){__delay_2ms();}
08E7  01A8     CLRF i
08E8  300D     MOVLW 0xD
08E9  00A7     MOVWF x
08EA  30FB     MOVLW 0xFB
08EB  00A6     MOVWF y
08EC  0BA6     DECFSZ y, F
08ED  28EC     GOTO 0xEC
08EE  0BA7     DECFSZ x, F
08EF  28EC     GOTO 0xEC
08F0  28F1     GOTO 0xF1
08F1  1283     BCF STATUS, 0x5
08F2  1303     BCF STATUS, 0x6
08F3  3008     MOVLW 0x8
08F4  0AA8     INCF i, F
08F5  0228     SUBWF i, W
08F6  1C03     BTFSS STATUS, 0x0
08F7  28E8     GOTO 0xE8
150:           	NLinea=1;
08F8  1683     BSF STATUS, 0x5
08F9  01AB     CLRF Data
08FA  0AAB     INCF Data, F
151:           	
152:           #ifndef LCD_USE_3PINES
153:           /* ** Configuracin de pines ** */	
154:           	LCD_DATA_PIN_7 = 0;
08FB  1283     BCF STATUS, 0x5
08FC  1388     BCF PORTD, 0x7
155:           	LCD_DATA_PIN_6 = 0;
08FD  1308     BCF PORTD, 0x6
156:           	LCD_DATA_PIN_5 = 0;
08FE  1288     BCF PORTD, 0x5
157:           	LCD_DATA_PIN_4 = 0;
08FF  1208     BCF PORTD, 0x4
158:           	#ifdef LCD_USE_RW
159:           		LCD_RW_PIN = 0;
0900  1088     BCF PORTD, 0x1
160:           	#endif
161:           	LCD_RS_PIN = 0;
0901  1008     BCF PORTD, 0x0
162:           	LCD_E_PIN = 0;
0902  1108     BCF PORTD, 0x2
163:           	
164:           	LCD_TRIS_DATA_PIN_7 = CONFIG_OUTPUT;
0903  1683     BSF STATUS, 0x5
0904  1388     BCF PORTD, 0x7
165:           	LCD_TRIS_DATA_PIN_6 = CONFIG_OUTPUT;
0905  1308     BCF PORTD, 0x6
166:           	LCD_TRIS_DATA_PIN_5 = CONFIG_OUTPUT;
0906  1288     BCF PORTD, 0x5
167:           	LCD_TRIS_DATA_PIN_4 = CONFIG_OUTPUT;
0907  1208     BCF PORTD, 0x4
168:           	#ifdef LCD_USE_RW	
169:           		LCD_TRIS_RW = CONFIG_OUTPUT;
0908  1088     BCF PORTD, 0x1
170:           	#endif
171:           	LCD_TRIS_RS = CONFIG_OUTPUT;
0909  1008     BCF PORTD, 0x0
172:           	LCD_TRIS_E = CONFIG_OUTPUT;
090A  1108     BCF PORTD, 0x2
173:           #else
174:           	LCD_DATA_PIN = 0;
175:           	LCD_CLOCK_PIN = 0;
176:           	LCD_E_PIN = 0;
177:           
178:           	LCD_TRIS_DATA = CONFIG_OUTPUT;
179:           	LCD_TRIS_CLOCK = CONFIG_OUTPUT;
180:           	LCD_TRIS_E = CONFIG_OUTPUT;
181:           	
182:           	for(i=0;i<8;i++){
183:           		LCD_DATA_PIN=0;
184:           		LCD_CLOCK_PIN=1;
185:           		__delay_1us();
186:           		LCD_CLOCK_PIN=0;
187:           	}
188:           #endif
189:           /* ** INICIALIZACION ** */     
190:           #ifndef LCD_USE_3PINES
191:           	LCD_DATA_PIN_5 = 1;
090B  1283     BCF STATUS, 0x5
090C  1688     BSF PORTD, 0x5
192:           	LCD_DATA_PIN_4 = 1;
090D  1608     BSF PORTD, 0x4
193:           #else
194:           	temp=0x03;
195:           	for(i=0;i<8;i++){
196:           		LCD_DATA_PIN=!!(temp & 0x80);
197:           		temp<<=1;
198:           		LCD_CLOCK_PIN=1;
199:           		__delay_1us();
200:           		LCD_CLOCK_PIN=0;
201:           	}
202:           #endif
203:           	for(i=0;i<3;i++){
090E  01A8     CLRF i
0925  1283     BCF STATUS, 0x5
0926  1303     BCF STATUS, 0x6
0927  3003     MOVLW 0x3
0928  0AA8     INCF i, F
0929  0228     SUBWF i, W
092A  1C03     BTFSS STATUS, 0x0
092B  290F     GOTO 0x10F
204:           		LCD_E_PIN = 1;
090F  1508     BSF PORTD, 0x2
205:           		__delay_2ms();
0910  300D     MOVLW 0xD
0911  00A7     MOVWF x
0912  30FB     MOVLW 0xFB
0913  00A6     MOVWF y
0914  0BA6     DECFSZ y, F
0915  2914     GOTO 0x114
0916  0BA7     DECFSZ x, F
0917  2914     GOTO 0x114
0918  2919     GOTO 0x119
206:           		LCD_E_PIN = 0;
0919  1283     BCF STATUS, 0x5
091A  1303     BCF STATUS, 0x6
091B  1108     BCF PORTD, 0x2
207:           	 	__delay_2ms();
091C  300D     MOVLW 0xD
091D  00A7     MOVWF x
091E  30FB     MOVLW 0xFB
091F  00A6     MOVWF y
0920  0BA6     DECFSZ y, F
0921  2920     GOTO 0x120
0922  0BA7     DECFSZ x, F
0923  2920     GOTO 0x120
0924  2925     GOTO 0x125
208:           	}
209:           #ifndef LCD_USE_3PINES
210:           	LCD_DATA_PIN_4 = 0;
092C  1208     BCF PORTD, 0x4
211:           #else
212:           	temp=0x02;
213:           	for(i=0;i<8;i++){
214:           		LCD_DATA_PIN=!!(temp & 0x80);
215:           		temp<<=1;
216:           		LCD_CLOCK_PIN=1;
217:           		__delay_1us();
218:           		LCD_CLOCK_PIN=0;
219:           	}
220:           #endif
221:           	LCD_E_PIN = 1;
092D  1508     BSF PORTD, 0x2
222:           	__delay_1us();
092E  292F     GOTO 0x12F
092F  2930     GOTO 0x130
0930  0000     NOP
223:           	LCD_E_PIN = 0;
0931  1283     BCF STATUS, 0x5
0932  1303     BCF STATUS, 0x6
0933  1108     BCF PORTD, 0x2
224:           
225:           	vWriteLCD(0x20 | (LcdType<<2),LCD_COMMAND);  // Tipo display.-  
0934  3028     MOVLW 0x28
0935  01A4     CLRF x
0936  215C     CALL 0x15C
0937  120A     BCF PCLATH, 0x4
0938  158A     BSF PCLATH, 0x3
226:           	__delay_2ms();     
0939  300D     MOVLW 0xD
093A  00A7     MOVWF x
093B  30FB     MOVLW 0xFB
093C  00A6     MOVWF y
093D  0BA6     DECFSZ y, F
093E  293D     GOTO 0x13D
093F  0BA7     DECFSZ x, F
0940  293D     GOTO 0x13D
0941  2942     GOTO 0x142
227:           	vWriteLCD(0x01,LCD_COMMAND);	// Borramos display.-   
0942  1283     BCF STATUS, 0x5
0943  1303     BCF STATUS, 0x6
0944  3001     MOVLW 0x1
0945  01A4     CLRF x
0946  215C     CALL 0x15C
0947  120A     BCF PCLATH, 0x4
0948  158A     BSF PCLATH, 0x3
228:           	__delay_2ms();           
0949  300D     MOVLW 0xD
094A  00A7     MOVWF x
094B  30FB     MOVLW 0xFB
094C  00A6     MOVWF y
094D  0BA6     DECFSZ y, F
094E  294D     GOTO 0x14D
094F  0BA7     DECFSZ x, F
0950  294D     GOTO 0x14D
0951  2952     GOTO 0x152
229:           	vWriteLCD(0x06,LCD_COMMAND);	// Incrementa cursor.-
0952  1283     BCF STATUS, 0x5
0953  1303     BCF STATUS, 0x6
0954  3006     MOVLW 0x6
0955  01A4     CLRF x
0956  215C     CALL 0x15C
0957  120A     BCF PCLATH, 0x4
0958  158A     BSF PCLATH, 0x3
230:           	vWriteLCD(0x0C,LCD_COMMAND);	// Encendemos display.-
0959  300C     MOVLW 0xC
231:           }
232:           
233:           
234:           void vLCD_Putc(UINT8 Data){
08BF  1283     BCF STATUS, 0x5
08C0  00AB     MOVWF Data
235:           	
236:           	switch(Data){
08C1  3A0A     XORLW 0xA
08C2  1903     BTFSC STATUS, 0x2
08C3  28DC     GOTO 0xDC
08C4  3A06     XORLW 0x6
08C5  1903     BTFSC STATUS, 0x2
08C6  28C9     GOTO 0xC9
08C7  28E3     GOTO 0xE3
237:           		case '\f':
238:           			vWriteLCD(0x01,LCD_COMMAND);
08C9  3001     MOVLW 0x1
08CA  01A4     CLRF x
08CB  215C     CALL 0x15C
08CC  120A     BCF PCLATH, 0x4
08CD  158A     BSF PCLATH, 0x3
239:           			NLinea=1;
08CE  1683     BSF STATUS, 0x5
08D0  01AB     CLRF Data
08D1  0AAB     INCF Data, F
240:           			__delay_2ms();
08CF  300D     MOVLW 0xD
08D2  1283     BCF STATUS, 0x5
08D3  00AA     MOVWF year
08D4  30FB     MOVLW 0xFB
08D5  00A9     MOVWF mth
08D6  0BA9     DECFSZ mth, F
08D7  28D6     GOTO 0xD6
08D8  0BAA     DECFSZ year, F
08D9  28D6     GOTO 0xD6
08DA  28DB     GOTO 0xDB
241:           		break;
08DB  0008     RETURN
242:           		case '\n':
243:           			vGotoxyLCD(1,++NLinea);			
08DC  1683     BSF STATUS, 0x5
08DD  0AAB     INCF Data, F
08DE  082B     MOVF Data, W
08DF  1283     BCF STATUS, 0x5
08E0  00A6     MOVWF y
08E1  3001     MOVLW 0x1
08E2  289C     GOTO 0x9C
244:           		break;
245:           		default:
246:           			vWriteLCD(Data,LCD_DATA);
08E3  01A4     CLRF x
08E4  0AA4     INCF x, F
08E5  082B     MOVF Data, W
08E6  295C     GOTO 0x15C
247:           	}
248:           } 
08C8  0008     RETURN
249:           
250:           void vGotoxyLCD(UINT8 x,UINT8 y){
089C  00A7     MOVWF x
251:           UINT8 Direccion;
252:           
253:           	switch(y){
089D  28A9     GOTO 0xA9
08A9  0826     MOVF y, W
08AA  3A01     XORLW 0x1
08AB  1903     BTFSC STATUS, 0x2
08AC  289E     GOTO 0x9E
08AD  3A03     XORLW 0x3
08AE  1903     BTFSC STATUS, 0x2
08AF  28A3     GOTO 0xA3
08B0  289E     GOTO 0x9E
254:           		case 1:Direccion = LCD_LINE_1_ADDRESS;NLinea=1;break;
089E  01A8     CLRF i
089F  1683     BSF STATUS, 0x5
08A0  01AB     CLRF Data
08A1  0AAB     INCF Data, F
08A2  28B1     GOTO 0xB1
255:           		case 2:Direccion = LCD_LINE_2_ADDRESS;NLinea=2;break;
08A3  3040     MOVLW 0x40
08A4  00A8     MOVWF i
08A5  3002     MOVLW 0x2
08A6  1683     BSF STATUS, 0x5
08A7  00AB     MOVWF Data
08A8  28B1     GOTO 0xB1
256:           		#ifdef LCD_4LINES
257:           		case 3:Direccion = LCD_LINE_3_ADDRESS;NLinea=3;break;
258:           		case 4:Direccion = LCD_LINE_4_ADDRESS;NLinea=4;break;
259:           		#endif
260:           		default:Direccion = LCD_LINE_1_ADDRESS;NLinea=1;break;
261:           	}
262:           
263:           	Direccion+=x-1;
08B1  1283     BCF STATUS, 0x5
08B2  0827     MOVF x, W
08B3  3EFF     ADDLW 0xFF
08B4  07A8     ADDWF i, F
264:           	while(ui8BusyLCD());
08B5  21CD     CALL 0x1CD
08B6  120A     BCF PCLATH, 0x4
08B7  158A     BSF PCLATH, 0x3
08B8  3800     IORLW 0x0
08B9  1D03     BTFSS STATUS, 0x2
08BA  28B5     GOTO 0xB5
265:           	vWriteLCD(0x80|Direccion,LCD_COMMAND);
08BB  01A4     CLRF x
266:           }
267:           
268:           void vPuts_LCD(UINT8 *buffer){
269:           
270:           
271:               while(*buffer != '\0')    {
272:                  // vLCD_Putc(*buffer++);;
273:                   vWriteLCD(*buffer++,LCD_DATA);
274:               }
275:           }
276:           
277:           void vBlinkingLCD(void){
278:           	vWriteLCD(0b1101,LCD_COMMAND);
279:           }
280:           void vnoBlinkingLCD(void){
281:           	vWriteLCD(0b1100,LCD_COMMAND);
282:           }
283:           void vBackLightLCD_On(void){
284:               TRISD3=0;
285:               RD3=1;
286:           }
287:           void vBackLightLCD_Off(void){
288:               TRISD3=0;
289:               RD3=0;
290:           }
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/HardI2C.c  ----------------------------
1:             //Cdigo original bajado de: http://www.todopic.com.ar/foros/index.php?topic=38654.0
2:             //Gracias AngelGris
3:             /**************************************************************************
4:             *      Libreria para protocolo I2C Master por HardWare para HiTech        *
5:             ***************************************************************************
6:             
7:             ***************************************************************************
8:             *                                                                         *
9:             * Antes de incluir este archivo en nuestro programa hay que definir       *
10:            * algunos parametros. Estos son                                           *
11:            *                                                                         *
12:            * PIC_CLK        (se usa para calcular el valor de SSPADD)                *     
13:            * I2C_BAUD       (velocidad de transferencia)                             *
14:            *                                                                         *
15:            ***************************************************************************
16:            
17:            ***************************************************************************
18:            *                                                                         *
19:            * En esta libreria se encuentran las siguientes funciones                 *
20:            *                                                                         *
21:            * setup_i2c(char)               (inicializa el puerto I2C)                *
22:            * start_i2c()                   (envia start, inicia transmision)         *
23:            * rstar_i2c()                   (envia restart, reinicia transmision)     *
24:            * stop_i2c()                    (envia stop, termina transmision)         *
25:            * write_i2c(char)               (envia un byte)                           *
26:            * read_i2c(char)                (recibe un byte y envia ack o noack)      *
27:            *                                                                         *
28:            *  La funcion write_i2c() devuelve 0 si el dispositivo responde o 1 si el *
29:            * dispositivo no responde.                                                *
30:            *                                                                         *
31:            *  A la funcion read_i2c() hay que pasarle 0 si se quiere responder al    *
32:            * disipositivo o 1 si no se quiere responder                              *
33:            *                                                                         *
34:            *  En esta libreria estan definidos los parametros I2C_MASTER, I2C_SLAVE, *
35:            * I2C_10BIT_ADDRESS. Eston son utilizados en la funcion setup_i2c(char)   *
36:            *                                                                         *
37:            *  Tambien estan definidos ACK y NOACK que son los utilizados para        *
38:            * responder o no al dispositivo                                           *
39:            *                                                                         *
40:            ***************************************************************************
41:            
42:            * Ejemplo de configuracion y utilizacion
43:            
44:             #define PIC_CLK   10000000   // cristal 10MHz
45:             #define I2C_BAUD  100000     // velocidad 100 KHz
46:             #include "HardI2c.c"
47:            
48:             void main (void);
49:             {
50:               unsigned char respuesta;
51:               unsigned char dato;  
52:             
53:               ......
54:               ......
55:               ......
56:               setup_i2c (I2C_MASTER);
57:               start_i2c();
58:               respuesta = write_i2c (0b10101110);    // comunicacion para escribir en una 24C02C
59:               if (respuesta == ACK)
60:               {
61:                 write_i2c (0x00);                    // indico la direccion a escribir
62:                 write_i2c (0xF5);                    // escribo el dato F5
63:                 write_i2c (0x06);                    // escribo el dato 06
64:               }
65:               stop_i2c();
66:            
67:               // colocar un delay necesario para que termine de grabar la memoria
68:            
69:               start_i2c();
70:               respuesta = write_i2c (0b10101110);    // comunicacion para escribir en una 24C02C
71:               if (respuesta == ACK)
72:               {
73:                 write_i2c (0x00);                    // indico la direccion de memoria
74:                 rstart_i2c();                       // reinicio la transmisin
75:                 respuesta = write_i2c (0b10101111);  // comunicacion para leer en una 24C02C
76:                 if (respuesta == ACK)
77:                 {
78:                   dato = read_i2c (ACK);             // leo el dato y respondo
79:                   dato = read_i2c (NOACK);           // leo el dato y no respondo
80:                 }
81:               }
82:               stop_i2c();
83:             }
84:            
85:            */
86:            #include <xc.h>
87:            #include <stdbool.h>       /* For true/false definition */
88:            #include "system.h"        /* System funct/params, like osc/peripheral config */
89:            #include "HardI2C.h"
90:            
91:            
92:            #if defined (PIC_CLK) && defined (I2C_BAUD)
93:            
94:            void setup_i2c (char x)
07EE  00A4     MOVWF x
95:             {
96:                TRISC3 = 1;
07EF  1683     BSF STATUS, 0x5
07F0  1587     BSF PORTC, 0x3
97:            
98:                TRISC4 = 1;
07F1  1607     BSF PORTC, 0x4
99:            
100:               SSPSTAT = 0;
07F2  0194     CLRF SSPCON
101:               SSPCON = x;
07F3  1283     BCF STATUS, 0x5
07F4  0824     MOVF x, W
07F5  0094     MOVWF SSPCON
102:               
103:               SSPCON2 = 0;
07F6  1683     BSF STATUS, 0x5
07F7  0191     CLRF TMR2
104:               // SSPCON2bits.RCEN=1;
105:               if (SSPM3 == 1) SSPADD = (unsigned char)((PIC_CLK/(4*I2C_BAUD)) - 1);
07F8  1283     BCF STATUS, 0x5
07F9  1D94     BTFSS SSPCON, 0x3
07FA  0008     RETURN
07FB  300B     MOVLW 0xB
07FC  1683     BSF STATUS, 0x5
07FD  0093     MOVWF SSPBUF
106:           
107:           }
07FE  0008     RETURN
108:           
109:             char start_i2c (void)
110:             { 
111:               while (( SSPCON2 & 0x1F ) || R_nW );
0D0C  1683     BSF STATUS, 0x5
0D0D  0811     MOVF TMR2, W
0D0E  391F     ANDLW 0x1F
0D0F  1903     BTFSC STATUS, 0x2
0D10  1914     BTFSC SSPCON, 0x2
0D11  2D0C     GOTO 0x50C
112:               SEN = 1;
0D12  1411     BSF TMR2, 0x0
113:               return !BCLIF;
114:             }
0D13  0008     RETURN
115:           
116:             void rstart_i2c (void)
117:             {
118:               while (( SSPCON2 & 0x1F ) || R_nW );
0D26  1683     BSF STATUS, 0x5
0D27  0811     MOVF TMR2, W
0D28  391F     ANDLW 0x1F
0D29  1903     BTFSC STATUS, 0x2
0D2A  1914     BTFSC SSPCON, 0x2
0D2B  2D26     GOTO 0x526
119:               RSEN = 1;
0D2C  1491     BSF TMR2, 0x1
120:             }
0D2D  0008     RETURN
121:           
122:             void stop_i2c (void)
123:             {
124:               while (( SSPCON2 & 0x1F ) || R_nW );
0D1E  1683     BSF STATUS, 0x5
0D1F  0811     MOVF TMR2, W
0D20  391F     ANDLW 0x1F
0D21  1903     BTFSC STATUS, 0x2
0D22  1914     BTFSC SSPCON, 0x2
0D23  2D1E     GOTO 0x51E
125:               PEN = 1;
0D24  1511     BSF TMR2, 0x2
126:             }
0D25  0008     RETURN
127:           
128:             char write_i2c (unsigned char data)
0CE2  1283     BCF STATUS, 0x5
0CE3  00A4     MOVWF x
129:             {
130:               if (SSPM3 == 1)
0CE4  1D94     BTFSS SSPCON, 0x3
0CE5  2CF6     GOTO 0x4F6
131:               {
132:                 while (( SSPCON2 & 0x1F ) || R_nW );
0CE6  1683     BSF STATUS, 0x5
0CE7  0811     MOVF TMR2, W
0CE8  391F     ANDLW 0x1F
0CE9  1903     BTFSC STATUS, 0x2
0CEA  1914     BTFSC SSPCON, 0x2
0CEB  2CE6     GOTO 0x4E6
133:                 SSPBUF = data;
0CEC  1283     BCF STATUS, 0x5
0CED  0824     MOVF x, W
0CEE  0093     MOVWF SSPBUF
134:                 while (R_nW == 1);
0CEF  1683     BSF STATUS, 0x5
0CF0  1914     BTFSC SSPCON, 0x2
0CF1  2CEF     GOTO 0x4EF
135:                 //while(ACKSTAT==1);
136:                 return ACKSTAT;
0CF2  3000     MOVLW 0x0
0CF3  1B11     BTFSC TMR2, 0x6
0CF4  3001     MOVLW 0x1
0CF5  0008     RETURN
137:               }
138:               else
139:               {
140:                 SSPBUF = data;
0CF6  0824     MOVF x, W
0CF7  0093     MOVWF SSPBUF
141:                 CKP = 1;
0CF8  1614     BSF SSPCON, 0x4
142:                 return 0;
0CF9  3400     RETLW 0x0
143:               }
144:             }
145:           
146:             unsigned char read_i2c (unsigned char respuesta)
0C08  1283     BCF STATUS, 0x5
0C09  00A4     MOVWF x
147:             {
148:               unsigned char dato;
149:           
150:               if (SSPM3 == 1)
0C0A  1D94     BTFSS SSPCON, 0x3
0C0B  2C2F     GOTO 0x42F
151:               {
152:                 while (( SSPCON2 & 0x1F ) || R_nW );
0C0C  1683     BSF STATUS, 0x5
0C0D  0811     MOVF TMR2, W
0C0E  391F     ANDLW 0x1F
0C0F  1903     BTFSC STATUS, 0x2
0C10  1914     BTFSC SSPCON, 0x2
0C11  2C0C     GOTO 0x40C
153:                 RCEN = 1;
0C12  1591     BSF TMR2, 0x3
154:                 while (( SSPCON2 & 0x1F ) || R_nW );
0C13  0811     MOVF TMR2, W
0C14  391F     ANDLW 0x1F
0C15  1903     BTFSC STATUS, 0x2
0C16  1914     BTFSC SSPCON, 0x2
0C17  2C13     GOTO 0x413
155:                 dato = SSPBUF;
0C18  1283     BCF STATUS, 0x5
0C19  0813     MOVF SSPBUF, W
0C1A  00A5     MOVWF dato
156:                 while (( SSPCON2 & 0x1F ) || R_nW );
0C1B  1683     BSF STATUS, 0x5
0C1C  0811     MOVF TMR2, W
0C1D  391F     ANDLW 0x1F
0C1E  1903     BTFSC STATUS, 0x2
0C1F  1914     BTFSC SSPCON, 0x2
0C20  2C1B     GOTO 0x41B
157:                 ACKDT = respuesta;
0C21  1283     BCF STATUS, 0x5
0C22  1C24     BTFSS x, 0x0
0C23  2C28     GOTO 0x428
0C24  1683     BSF STATUS, 0x5
0C25  1303     BCF STATUS, 0x6
0C26  1691     BSF TMR2, 0x5
0C27  2C2B     GOTO 0x42B
0C28  1683     BSF STATUS, 0x5
0C29  1303     BCF STATUS, 0x6
0C2A  1291     BCF TMR2, 0x5
158:                 ACKEN = 1;
0C2B  1611     BSF TMR2, 0x4
159:                 return dato;
0C2C  1283     BCF STATUS, 0x5
0C2D  0825     MOVF dato, W
0C2E  0008     RETURN
160:               }
161:               else
162:               {
163:                 dato = SSPBUF;
0C2F  0813     MOVF SSPBUF, W
0C30  00A5     MOVWF dato
164:                 return dato;
165:               }
166:             }
0C31  0008     RETURN
167:           #else
168:             #error Faltan definir parametros
169:           #endif
