Disassembly Listing for Control_BOMBA_RTC_ISL1208_V6
Generated From:
/home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/dist/ISL1208_XC8_16f877a/production/Control_BOMBA_RTC_ISL1208_V6.X.production.cof
21/01/2015 22:29:51

---  /opt/microchip/xc8/v1.31/sources/pic/ftdiv.c  ------------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (C) 2006 HI-TECH Software
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_dividend	(*(unsigned short long *)&f1)
11:            #define	f2_as_divisor	(*(unsigned short long *)&f2)
12:            #define	f3_as_quot	(*(unsigned short long *)&f3)
13:            
14:            // floating addition
15:            #ifdef _OLDLIB
16:            #define	cntr		sign2
17:            float
18:            __ftdiv(float f2, float f1)
19:            {
20:            	unsigned char	exp1, exp2, sign1, sign2;
21:            	float	f3;
22:            	
23:            	f3_as_quot = 0;
24:            	sign1 = __ftunpack(&f1_as_dividend, &exp1);
25:            	if(exp1 == 0)
26:            		return f3;
27:            	sign2 = __ftunpack(&f2_as_divisor, &exp2);
28:            	if(exp2 == 0)
29:            		return f3;
30:            	exp1 -= exp2-127+8;	// compute new exponent
31:            	sign1 ^= sign2;
32:            	cntr = 16+8;
33:            	do {
34:            		f3_as_quot <<= 1;
35:            		if(f1_as_dividend >= f2_as_divisor) {
36:            			f1_as_dividend -= f2_as_divisor;
37:            			f3_as_quot |= 1;
38:            		}
39:            		f1_as_dividend <<= 1;
40:            	} while(--cntr != 0);
41:            	__ftpack(&f3_as_quot, exp1);
42:            	if(sign1)
43:            		f3_as_quot |= 0x800000;
44:            	return f3;
45:            }
46:            #else
47:            #define	exp2	sign
48:            float
49:            __ftdiv(float f2, float f1)
50:            {
51:            	unsigned char	exp, sign, cntr;
52:            	float	f3;
53:            	
54:            	// unpack the operands
55:            	if((exp = f1_as_dividend >> 15) == 0)
161F  084F     MOVF f1, W
1620  00D2     MOVWF prec
1621  0850     MOVF 0x50, W
1622  00D3     MOVWF ap
1623  0851     MOVF 0x51, W
1624  00D4     MOVWF flag
1625  1003     BCF STATUS, 0x0
1626  0D53     RLF ap, W
1627  0D54     RLF flag, W
1628  00D9     MOVWF exp
1629  08D9     MOVF exp, F
162A  1D03     BTFSS STATUS, 0x2
162B  2E30     GOTO 0x630
56:            		return 0.0;
162C  01CC     CLRF f2
162D  01CD     CLRF 0x4D
162E  01CE     CLRF 0x4E
162F  0008     RETURN
57:            	if((exp2 = f2_as_divisor >> 15) == 0)
1630  084C     MOVF f2, W
1631  00D2     MOVWF prec
1632  084D     MOVF 0x4D, W
1633  00D3     MOVWF ap
1634  084E     MOVF 0x4E, W
1635  00D4     MOVWF flag
1636  1003     BCF STATUS, 0x0
1637  0D53     RLF ap, W
1638  0D54     RLF flag, W
1639  00DA     MOVWF c
163A  08DA     MOVF c, F
163B  1D03     BTFSS STATUS, 0x2
163C  2E41     GOTO 0x641
58:            		return 0.0;
163D  01CC     CLRF f2
163E  01CD     CLRF 0x4D
163F  01CE     CLRF 0x4E
1640  0008     RETURN
59:            	f3_as_quot = 0;
1642  01D6     CLRF f3
1643  01D7     CLRF _val
1644  01D8     CLRF 0x58
60:            	exp -= exp2-127+8;	// compute new exponent
1641  3089     MOVLW 0x89
1645  075A     ADDWF c, W
1646  00D2     MOVWF prec
1647  02D9     SUBWF exp, F
61:            	sign = f1_as_dividend >> 16;
1648  0851     MOVF 0x51, W
1649  00DA     MOVWF c
62:            	sign ^= (unsigned char)(f2_as_divisor >> 16);
164A  084E     MOVF 0x4E, W
164B  06DA     XORWF c, F
63:            	sign &= 0x80;
164C  3080     MOVLW 0x80
164D  05DA     ANDWF c, F
64:            	f1_as_dividend |= 0x8000UL;
164F  17D0     BSF 0x50, 0x7
65:            	f1_as_dividend &= 0xFFFFUL;
1650  01D1     CLRF 0x51
66:            	f2_as_divisor |= 0x8000UL;
1651  17CD     BSF 0x4D, 0x7
67:            	f2_as_divisor &= 0xFFFFUL;
1652  01CE     CLRF 0x4E
68:            	cntr = 16+8;
164E  3018     MOVLW 0x18
1653  00D5     MOVWF width
69:            	do {
70:            		f3_as_quot <<= 1;
1654  1003     BCF STATUS, 0x0
1655  0DD6     RLF f3, F
1656  0DD7     RLF _val, F
1657  0DD8     RLF 0x58, F
71:            		if(f1_as_dividend >= f2_as_divisor) {
1658  084E     MOVF 0x4E, W
1659  0251     SUBWF 0x51, W
165A  1D03     BTFSS STATUS, 0x2
165B  2E62     GOTO 0x662
165C  084D     MOVF 0x4D, W
165D  0250     SUBWF 0x50, W
165E  1D03     BTFSS STATUS, 0x2
165F  2E62     GOTO 0x662
1660  084C     MOVF f2, W
1661  024F     SUBWF f1, W
1662  1C03     BTFSS STATUS, 0x0
1663  2E70     GOTO 0x670
72:            			f1_as_dividend -= f2_as_divisor;
1664  084C     MOVF f2, W
1665  02CF     SUBWF f1, F
1666  084D     MOVF 0x4D, W
1667  1C03     BTFSS STATUS, 0x0
1668  0F4D     INCFSZ 0x4D, W
1669  02D0     SUBWF 0x50, F
166A  084E     MOVF 0x4E, W
166B  1C03     BTFSS STATUS, 0x0
166C  0A4E     INCF 0x4E, W
166D  02D1     SUBWF 0x51, F
73:            			f3_as_quot |= 1;
166E  1456     BSF f3, 0x0
74:            		}
75:            		f1_as_dividend <<= 1;
166F  1003     BCF STATUS, 0x0
1670  0DCF     RLF f1, F
1671  0DD0     RLF 0x50, F
1672  0DD1     RLF 0x51, F
76:            	} while(--cntr != 0);
1673  0BD5     DECFSZ width, F
1674  2E54     GOTO 0x654
77:            	return __ftpack(f3_as_quot, exp, sign);
1675  0856     MOVF f3, W
1676  00A3     MOVWF x
1677  0857     MOVF _val, W
1678  00A4     MOVWF dato
1679  0858     MOVF 0x58, W
167A  00A5     MOVWF y
167B  0859     MOVF exp, W
167C  00A6     MOVWF x
167D  085A     MOVF c, W
167E  00A7     MOVWF i
167F  27C2     CALL 0x7C2
1680  0823     MOVF x, W
1681  00CC     MOVWF f2
1682  0824     MOVF dato, W
1683  00CD     MOVWF 0x4D
1684  0825     MOVF y, W
1685  00CE     MOVWF 0x4E
78:            }
1686  0008     RETURN
79:            #endif	
---  /opt/microchip/xc8/v1.31/sources/common/wmul.c  ----------------------------------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             unsigned int
3:             __wmul(unsigned int multiplier, unsigned int multiplicand)
4:             {
5:                     unsigned int product;
6:             
7:             #ifdef _PIC18
8:             
9:             #define LOWBYTE(x)  (*(unsigned char *)(&x))
10:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
11:            
12:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
13:            /*
14:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
15:                   a  b
16:            *      c  d
17:            -----------
18:                 |   bd
19:                 |ad  0
20:                 |bc  0
21:            +  ac| 0  0 (we ignore this intermediate product
22:                         because it does not affect the low 16 bits of the result)
23:            ===========
24:             */
25:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
26:                    product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
27:                    product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
28:            
29:            #else
30:            
31:            	product = 0;
078D  01A7     CLRF i
078E  01A8     CLRF mth
32:            	do {
33:            		if(multiplier & 1)
078F  1C23     BTFSS x, 0x0
0790  2F97     GOTO 0x797
34:            			product += multiplicand;
0791  0825     MOVF y, W
0792  07A7     ADDWF i, F
0793  1803     BTFSC STATUS, 0x0
0794  0AA8     INCF mth, F
0795  0826     MOVF x, W
0796  07A8     ADDWF mth, F
35:            		multiplicand <<= 1;
0797  1003     BCF STATUS, 0x0
0798  0DA5     RLF y, F
0799  0DA6     RLF x, F
36:            		multiplier >>= 1;
079A  1003     BCF STATUS, 0x0
079B  0CA4     RRF dato, F
079C  0CA3     RRF x, F
37:            	} while(multiplier != 0);
079D  0824     MOVF dato, W
079E  0423     IORWF x, W
079F  1D03     BTFSS STATUS, 0x2
07A0  2F8F     GOTO 0x78F
38:            
39:            #endif
40:                    return product;
07A1  0828     MOVF mth, W
07A2  00A4     MOVWF dato
07A3  0827     MOVF i, W
07A4  00A3     MOVWF x
41:            }
07A5  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/lwtoft.c  --------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            
11:            // Convert unsigned int to float
12:            
13:            #ifdef _OLDLIB
14:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
15:            float
16:            __lwtoft(unsigned int c)
17:            {
18:            	float	f1;
19:            	
20:            	if(c == 0)
21:            		return 0.0;
22:            	f1_as_mant1 = c;
23:            	__ftpack(&f1_as_mant1, 127+15);
24:            	return f1;
25:            }
26:            #else
27:            float
28:            __lwtoft(unsigned int c)
29:            {
30:            	return __ftpack(c, 127+15, 0);
15F9  0830     MOVF c, W
15FA  00A3     MOVWF x
15FB  0831     MOVF divisor, W
15FC  00A4     MOVWF dato
15FD  308E     MOVLW 0x8E
15FE  01A5     CLRF y
15FF  00A6     MOVWF x
1600  01A7     CLRF i
1601  27C2     CALL 0x7C2
1602  0823     MOVF x, W
1603  00B0     MOVWF c
1604  0824     MOVF dato, W
1605  00B1     MOVWF divisor
1606  0825     MOVF y, W
1607  00B2     MOVWF 0x32
31:            }
1608  0008     RETURN
32:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/lwmod.c  ---------------------------------------------------
1:             // word unsigned modulus
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwmod(unsigned int divisor, unsigned int dividend)
07D0  082B     MOVF sec, W
0F73  0871     MOVF canal, W
7:             #else
8:             __lwmod(unsigned int dividend, unsigned int divisor)
9:             #endif
10:            {
11:            	unsigned char	counter;
12:            
13:            	if(divisor != 0) {
07D0  082B     MOVF sec, W
07D1  042A     IORWF Data, W
07D2  1903     BTFSC STATUS, 0x2
07D3  2FEF     GOTO 0x7EF
0F73  0871     MOVF canal, W
0F74  0470     IORWF divisor, W
0F75  1903     BTFSC STATUS, 0x2
0F76  2F92     GOTO 0x792
14:            		counter = 1;
07D4  01AE     CLRF sign
0F77  01F4     CLRF counter
15:            		while((divisor & 0x8000) == 0) {
07D6  1BAB     BTFSC sec, 0x7
07D7  2FDC     GOTO 0x7DC
07DB  2FD5     GOTO 0x7D5
0F79  1BF1     BTFSC canal, 0x7
0F7A  2F7F     GOTO 0x77F
0F7E  2F78     GOTO 0x778
16:            			divisor <<= 1;
07D5  0AAE     INCF sign, F
07D8  1003     BCF STATUS, 0x0
07D9  0DAA     RLF Data, F
07DA  0DAB     RLF sec, F
0F78  0AF4     INCF counter, F
0F7B  1003     BCF STATUS, 0x0
0F7C  0DF0     RLF divisor, F
0F7D  0DF1     RLF canal, F
17:            			counter++;
07D5  0AAE     INCF sign, F
0F78  0AF4     INCF counter, F
18:            		}
19:            		do {
20:            			if(divisor <= dividend)
07DC  082B     MOVF sec, W
07DD  022D     SUBWF day, W
07DE  1D03     BTFSS STATUS, 0x2
07DF  2FE2     GOTO 0x7E2
07E0  082A     MOVF Data, W
07E1  022C     SUBWF hr, W
07E2  1C03     BTFSS STATUS, 0x0
07E3  2FEB     GOTO 0x7EB
0F7F  0871     MOVF canal, W
0F80  0273     SUBWF counter, W
0F81  1D03     BTFSS STATUS, 0x2
0F82  2F85     GOTO 0x785
0F83  0870     MOVF divisor, W
0F84  0272     SUBWF dividend, W
0F85  1C03     BTFSS STATUS, 0x0
0F86  2F8E     GOTO 0x78E
21:            				dividend -= divisor;
07E4  082A     MOVF Data, W
07E5  02AC     SUBWF hr, F
07E6  082B     MOVF sec, W
07E7  1C03     BTFSS STATUS, 0x0
07E8  03AD     DECF day, F
07E9  02AD     SUBWF day, F
0F87  0870     MOVF divisor, W
0F88  02F2     SUBWF dividend, F
0F89  0871     MOVF canal, W
0F8A  1C03     BTFSS STATUS, 0x0
0F8B  03F3     DECF counter, F
0F8C  02F3     SUBWF counter, F
22:            			divisor >>= 1;
07EA  1003     BCF STATUS, 0x0
07EB  0CAB     RRF sec, F
07EC  0CAA     RRF Data, F
0F8D  1003     BCF STATUS, 0x0
0F8E  0CF1     RRF canal, F
0F8F  0CF0     RRF divisor, F
23:            		} while(--counter != 0);
07ED  0BAE     DECFSZ sign, F
07EE  2FDC     GOTO 0x7DC
0F90  0BF4     DECFSZ counter, F
0F91  2F7F     GOTO 0x77F
24:            	}
25:            	return dividend;
07EF  082D     MOVF day, W
07F0  00AB     MOVWF sec
07F1  082C     MOVF hr, W
07F2  00AA     MOVWF Data
0F92  0873     MOVF counter, W
0F93  00F1     MOVWF canal
0F94  0872     MOVF dividend, W
0F95  00F0     MOVWF divisor
26:            }
07F3  0008     RETURN
0F96  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/lwdiv.c  ---------------------------------------------------
1:             // word unsigned division
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwdiv(unsigned int divisor, unsigned int dividend)
7:             #else
8:             __lwdiv(unsigned int dividend, unsigned int divisor)
9:             #endif
10:            {
11:            	unsigned int	quotient;
12:            	unsigned char	counter;
13:            
14:            	quotient = 0;
07A6  01A7     CLRF i
07A7  01A8     CLRF mth
15:            	if(divisor != 0) {
07A8  0824     MOVF dato, W
07A9  0423     IORWF x, W
07AA  1903     BTFSC STATUS, 0x2
07AB  2FCB     GOTO 0x7CB
16:            		counter = 1;
07AC  01A9     CLRF year
17:            		while((divisor & 0x8000) == 0) {
07AE  1BA4     BTFSC dato, 0x7
07AF  2FB4     GOTO 0x7B4
07B3  2FAD     GOTO 0x7AD
18:            			divisor <<= 1;
07AD  0AA9     INCF year, F
07B0  1003     BCF STATUS, 0x0
07B1  0DA3     RLF x, F
07B2  0DA4     RLF dato, F
19:            			counter++;
07AD  0AA9     INCF year, F
20:            		}
21:            		do {
22:            			quotient <<= 1;
07B4  1003     BCF STATUS, 0x0
07B5  0DA7     RLF i, F
07B6  0DA8     RLF mth, F
23:            			if(divisor <= dividend) {
07B7  0824     MOVF dato, W
07B8  0226     SUBWF x, W
07B9  1D03     BTFSS STATUS, 0x2
07BA  2FBD     GOTO 0x7BD
07BB  0823     MOVF x, W
07BC  0225     SUBWF y, W
07BD  1C03     BTFSS STATUS, 0x0
07BE  2FC7     GOTO 0x7C7
24:            				dividend -= divisor;
07BF  0823     MOVF x, W
07C0  02A5     SUBWF y, F
07C1  0824     MOVF dato, W
07C2  1C03     BTFSS STATUS, 0x0
07C3  03A6     DECF x, F
07C4  02A6     SUBWF x, F
25:            				quotient |= 1;
07C5  1427     BSF i, 0x0
26:            			}
27:            			divisor >>= 1;
07C6  1003     BCF STATUS, 0x0
07C7  0CA4     RRF dato, F
07C8  0CA3     RRF x, F
28:            		} while(--counter != 0);
07C9  0BA9     DECFSZ year, F
07CA  2FB4     GOTO 0x7B4
29:            	}
30:            	return quotient;
07CB  0828     MOVF mth, W
07CC  00A4     MOVWF dato
07CD  0827     MOVF i, W
07CE  00A3     MOVWF x
31:            }
07CF  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/lbmod.c  ---------------------------------------------------
1:             // byte unsigned modulus
2:             
3:             unsigned char
4:             __lbmod(unsigned char dividend, unsigned char divisor)
0C05  00A5     MOVWF y
0FBF  00F2     MOVWF dividend
5:             {
6:             	unsigned char	rem;
7:             	unsigned char	counter;
8:             
9:             	counter = 8;
0C06  3008     MOVLW 0x8
0C07  00A6     MOVWF x
0FC0  3008     MOVLW 0x8
0FC1  00F3     MOVWF counter
10:            	rem = 0;
0C08  01A7     CLRF i
0FC2  01F4     CLRF counter
11:            	do {
12:            		rem = (rem << 1) | (dividend >> 7);
0C09  0825     MOVF y, W
0C0A  00A4     MOVWF dato
0C0B  3007     MOVLW 0x7
0C0C  1003     BCF STATUS, 0x0
0C0D  0CA4     RRF dato, F
0C0E  3EFF     ADDLW 0xFF
0C0F  1003     BCF STATUS, 0x0
0C10  1D03     BTFSS STATUS, 0x2
0C11  2C0D     GOTO 0x40D
0C12  0D27     RLF i, W
0C13  0424     IORWF dato, W
0C14  00A7     MOVWF i
0FC3  0872     MOVF dividend, W
0FC4  00F1     MOVWF canal
0FC5  3007     MOVLW 0x7
0FC6  1003     BCF STATUS, 0x0
0FC7  0CF1     RRF canal, F
0FC8  3EFF     ADDLW 0xFF
0FC9  1003     BCF STATUS, 0x0
0FCA  1D03     BTFSS STATUS, 0x2
0FCB  2FC7     GOTO 0x7C7
0FCC  0D74     RLF counter, W
0FCD  0471     IORWF canal, W
0FCE  00F4     MOVWF counter
13:            		dividend <<= 1;
0C15  1003     BCF STATUS, 0x0
0C16  0DA5     RLF y, F
0FCF  1003     BCF STATUS, 0x0
0FD0  0DF2     RLF dividend, F
14:            		if(divisor <= rem)
0C17  0823     MOVF x, W
0C18  0227     SUBWF i, W
0C19  1C03     BTFSS STATUS, 0x0
0C1A  2C1D     GOTO 0x41D
0FD1  0870     MOVF divisor, W
0FD2  0274     SUBWF counter, W
0FD3  1C03     BTFSS STATUS, 0x0
0FD4  2FD7     GOTO 0x7D7
15:            			rem -= divisor;
0C1B  0823     MOVF x, W
0C1C  02A7     SUBWF i, F
0FD5  0870     MOVF divisor, W
0FD6  02F4     SUBWF counter, F
16:            	} while(--counter != 0);
0C1D  0BA6     DECFSZ x, F
0C1E  2C09     GOTO 0x409
0FD7  0BF3     DECFSZ counter, F
0FD8  2FC3     GOTO 0x7C3
17:            	return rem;
0C1F  0827     MOVF i, W
0FD9  0874     MOVF counter, W
18:            }
0C20  0008     RETURN
0FDA  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/lbdiv.c  ---------------------------------------------------
1:             // byte unsigned division
2:             
3:             unsigned char
4:             __lbdiv(unsigned char dividend, unsigned char divisor)
0B9F  00A4     MOVWF dato
5:             {
6:             	unsigned char	quotient;
7:             	unsigned char	counter;
8:             
9:             	quotient = 0;
0BA0  01A6     CLRF x
10:            	if(divisor != 0) {
0BA1  0823     MOVF x, W
0BA2  1903     BTFSC STATUS, 0x2
0BA3  2BB8     GOTO 0x3B8
11:            		counter = 1;
0BA4  01A5     CLRF y
12:            		while((divisor & 0x80) == 0) {
0BA6  1BA3     BTFSC x, 0x7
0BA7  2BAB     GOTO 0x3AB
0BAA  2BA5     GOTO 0x3A5
13:            			divisor <<= 1;
0BA8  1003     BCF STATUS, 0x0
0BA9  0DA3     RLF x, F
14:            			counter++;
0BA5  0AA5     INCF y, F
15:            		}
16:            		do {
17:            			quotient <<= 1;
0BAB  1003     BCF STATUS, 0x0
0BAC  0DA6     RLF x, F
18:            			if(divisor <= dividend) {
0BAD  0823     MOVF x, W
0BAE  0224     SUBWF dato, W
0BAF  1C03     BTFSS STATUS, 0x0
0BB0  2BB5     GOTO 0x3B5
19:            				dividend -= divisor;
0BB1  0823     MOVF x, W
0BB2  02A4     SUBWF dato, F
20:            				quotient |= 1;
0BB3  1426     BSF x, 0x0
21:            			}
22:            			divisor >>= 1;
0BB4  1003     BCF STATUS, 0x0
0BB5  0CA3     RRF x, F
23:            		} while(--counter != 0);
0BB6  0BA5     DECFSZ y, F
0BB7  2BAB     GOTO 0x3AB
24:            	}
25:            	return quotient;
0BB8  0826     MOVF x, W
26:            }
0BB9  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/isdigit.c  -------------------------------------------------
1:             #include	<ctype.h>
2:             
3:             #ifndef isdigit
4:             
5:             #ifdef _CTYPE_BIT_FUNCS_
6:             
7:             bit
8:             isdigit(char c)
077F  00A4     MOVWF dato
9:             #else
10:            int
11:            isdigit(int c)
12:            #endif
13:            {
14:            	return c <= '9' && c >= '0';
0780  303A     MOVLW 0x3A
0781  01A3     CLRF x
0782  0224     SUBWF dato, W
0783  1803     BTFSC STATUS, 0x0
0784  2F8B     GOTO 0x78B
0785  3030     MOVLW 0x30
0786  0224     SUBWF dato, W
0787  1C03     BTFSS STATUS, 0x0
0788  2F8B     GOTO 0x78B
0789  01A3     CLRF x
078A  0AA3     INCF x, F
078B  0C23     RRF x, W
15:            }
078C  0008     RETURN
16:            
17:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/fttol.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
11:            
12:            // Convert float to long
13:            
14:            #ifdef _OLDLIB
15:            long
16:            __fttol(float f1)
17:            {
18:            	unsigned char	sign1, exp1;
19:            	unsigned long	lval;
20:            
21:            	sign1 = __ftunpack(&f1_as_mant1, &exp1);
22:            	lval = f1_as_mant1;
23:            	exp1 -= 127+15;
24:            	if((signed char)exp1 < 0) {
25:            		if((signed char)exp1 < -15)
26:            			return 0;
27:            		do
28:            			lval >>= 1;
29:            		while(++exp1 != 0);
30:            	} else {
31:            		if(exp1 >= 32)
32:            			return 00;
33:            		while(exp1 != 0) {
34:            			lval <<= 1;
35:            			exp1--;
36:            		}
37:            	}
38:            	if(sign1)
39:            		lval = -lval;
40:            	return lval;
41:            }
42:            #else
43:            long
44:            __fttol(float f1)
45:            {
46:            	unsigned char	sign1, exp1;
47:            	unsigned long	lval;
48:            
49:            	if((exp1 = f1_as_mant1 >> 15) == 0)
0826  0823     MOVF x, W
0827  00A7     MOVWF i
0828  0824     MOVF dato, W
0829  00A8     MOVWF mth
082A  0825     MOVF y, W
082B  00A9     MOVWF year
082C  1003     BCF STATUS, 0x0
082D  0D28     RLF mth, W
082E  0D29     RLF year, W
082F  00AF     MOVWF quotient
0830  08AF     MOVF quotient, F
0831  1D03     BTFSS STATUS, 0x2
0832  2838     GOTO 0x38
50:            		return 0;
0833  01A3     CLRF x
0834  01A4     CLRF dato
0835  01A5     CLRF y
0836  01A6     CLRF x
0837  0008     RETURN
51:            	sign1 = f1_as_mant1 >> 23;
0838  0823     MOVF x, W
0839  00A7     MOVWF i
083A  0824     MOVF dato, W
083B  00A8     MOVWF mth
083C  0825     MOVF y, W
083D  00A9     MOVWF year
083E  3017     MOVLW 0x17
083F  1003     BCF STATUS, 0x0
0840  0CA9     RRF year, F
0841  0CA8     RRF mth, F
0842  0CA7     RRF i, F
0843  3EFF     ADDLW 0xFF
0844  1D03     BTFSS STATUS, 0x2
0845  283F     GOTO 0x3F
0846  0827     MOVF i, W
0847  00AA     MOVWF Data
52:            	f1_as_mant1 |= 0x8000UL;
0848  17A4     BSF dato, 0x7
53:            	f1_as_mant1 &= 0xFFFFUL;
0849  01A5     CLRF y
54:            	lval = f1_as_mant1;
084A  0823     MOVF x, W
084B  00AB     MOVWF sec
084C  0824     MOVF dato, W
084D  00AC     MOVWF hr
084E  0825     MOVF y, W
084F  00AD     MOVWF day
0851  01AE     CLRF sign
55:            	exp1 -= 127+15;
0850  308E     MOVLW 0x8E
0852  02AF     SUBWF quotient, F
56:            	if((signed char)exp1 < 0) {
0853  1FAF     BTFSS quotient, 0x7
0854  2862     GOTO 0x62
57:            		if((signed char)exp1 < -15)
0855  082F     MOVF quotient, W
0856  3A80     XORLW 0x80
0857  3E8F     ADDLW 0x8F
0858  1C03     BTFSS STATUS, 0x0
0859  2833     GOTO 0x33
58:            			return 0;
59:            		do
60:            			lval >>= 1;
085A  1003     BCF STATUS, 0x0
085B  0CAE     RRF sign, F
085C  0CAD     RRF day, F
085D  0CAC     RRF hr, F
085E  0CAB     RRF sec, F
61:            		while(++exp1 != 0);
085F  0FAF     INCFSZ quotient, F
0860  285A     GOTO 0x5A
0861  2870     GOTO 0x70
62:            	} else {
63:            		if(exp1 >= 24)
0862  3018     MOVLW 0x18
0863  022F     SUBWF quotient, W
0864  1803     BTFSC STATUS, 0x0
0865  2833     GOTO 0x33
64:            			return 0;
65:            		while(exp1 != 0) {
0866  08AF     MOVF quotient, F
086F  2866     GOTO 0x66
66:            			lval <<= 1;
0869  1003     BCF STATUS, 0x0
086A  0DAB     RLF sec, F
086B  0DAC     RLF hr, F
086C  0DAD     RLF day, F
086D  0DAE     RLF sign, F
67:            			exp1--;
086E  03AF     DECF quotient, F
68:            		}
0866  08AF     MOVF quotient, F
0867  1903     BTFSC STATUS, 0x2
0868  2870     GOTO 0x70
69:            	}
70:            	if(sign1)
0870  082A     MOVF Data, W
0871  1903     BTFSC STATUS, 0x2
0872  287E     GOTO 0x7E
71:            		lval = -lval;
0873  09AB     COMF sec, F
0874  09AC     COMF hr, F
0875  09AD     COMF day, F
0876  09AE     COMF sign, F
0877  0AAB     INCF sec, F
0878  1903     BTFSC STATUS, 0x2
0879  0AAC     INCF hr, F
087A  1903     BTFSC STATUS, 0x2
087B  0AAD     INCF day, F
087C  1903     BTFSC STATUS, 0x2
087D  0AAE     INCF sign, F
72:            	return lval;
087E  082E     MOVF sign, W
087F  00A6     MOVWF x
0880  082D     MOVF day, W
0881  00A5     MOVWF y
0882  082C     MOVF hr, W
0883  00A4     MOVWF dato
0884  082B     MOVF sec, W
0885  00A3     MOVWF x
73:            }
0886  0008     RETURN
74:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/ftsub.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
11:            #define	f2_as_mant2	(*(unsigned short long *)&f2)
12:            
13:            // floating addition
14:            
15:            float
16:            #ifdef __PICC__
17:            #warning TODO: update cgpic and this file to use the other prototype
18:            __ftsub(float f2, float f1)
19:            #else
20:            __ftsub(float f1, float f2)
21:            #endif
22:            {
23:            	f2_as_mant2 ^= 0x800000;
1609  3080     MOVLW 0x80
160A  06B9     XORWF 0x39, F
24:            	return __ftadd(f1, f2);
160B  083A     MOVF f1, W
160C  00AB     MOVWF sec
160D  083B     MOVF 0x3B, W
160E  00AC     MOVWF hr
160F  083C     MOVF 0x3C, W
1610  00AD     MOVWF day
1611  0837     MOVF mes, W
1612  00AE     MOVWF sign
1613  0838     MOVF anio, W
1614  00AF     MOVWF quotient
1615  0839     MOVF 0x39, W
1616  00B0     MOVWF c
1617  2702     CALL 0x702
1618  082B     MOVF sec, W
1619  00B7     MOVWF mes
161A  082C     MOVF hr, W
161B  00B8     MOVWF anio
161C  082D     MOVF day, W
161D  00B9     MOVWF 0x39
25:            }
161E  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/ftmul.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_plier	(*(unsigned short long *)&f1)
11:            #define	f2_as_plicand	(*(unsigned short long *)&f2)
12:            
13:            // floating addition
14:            
15:            #ifdef _OLDLIB
16:            #define	f3_as_product		(*(unsigned short long *)&f3)
17:            float
18:            __ftmul(float f1, float f2)
19:            {
20:            	unsigned char	exp1, sign1, cntr;
21:            	float	f3;
22:            	
23:            	f3_as_product = 0;
24:            	sign1 = __ftunpack(&f1_as_plier, &exp1);
25:            	sign1 ^= __ftunpack(&f2_as_plicand, &cntr);
26:            	if(cntr == 0 || exp1 == 0)
27:            		return f3;
28:            	exp1 += cntr-127-6;	// compute new exponent
29:            	cntr = 7;
30:            	do {
31:            		if(f1_as_plier & 1)
32:            			f3_as_product += f2_as_plicand;
33:            		f1_as_plier >>= 1;
34:            		f2_as_plicand <<= 1;
35:            	} while(--cntr != 0);
36:            	cntr = 9;
37:            	do {
38:            		if(f1_as_plier & 1)
39:            			f3_as_product += f2_as_plicand;
40:            		f1_as_plier >>= 1;
41:            		f3_as_product >>= 1;
42:            	} while(--cntr != 0);
43:            	__ftpack(&f3_as_product, exp1);
44:            	if(sign1)
45:            		f3_as_product |= 0x800000;
46:            	return f3;
47:            }
48:            #else
49:            #define	exp2	sign
50:            float
51:            __ftmul(float f1, float f2)
52:            {
53:            	unsigned char	exp, sign, cntr;
54:            	unsigned short long	f3_as_product;
55:            
56:            	if((exp = f1_as_plier >> 15) == 0)
1687  083D     MOVF f1, W
1688  00C3     MOVWF dow
1689  083E     MOVF 0x3E, W
168A  00C4     MOVWF a
168B  083F     MOVF 0x3F, W
168C  00C5     MOVWF dia
168D  1003     BCF STATUS, 0x0
168E  0D44     RLF a, W
168F  0D45     RLF dia, W
1690  00C6     MOVWF y
1691  08C6     MOVF y, F
1692  1D03     BTFSS STATUS, 0x2
1693  2E98     GOTO 0x698
57:            		return 0.0;
1694  01BD     CLRF f1
1695  01BE     CLRF 0x3E
1696  01BF     CLRF 0x3F
1697  0008     RETURN
58:            	if((exp2 = f2_as_plicand >> 15) == 0)
1698  0840     MOVF f2, W
1699  00C3     MOVWF dow
169A  0841     MOVF 0x41, W
169B  00C4     MOVWF a
169C  0842     MOVF m, W
169D  00C5     MOVWF dia
169E  1003     BCF STATUS, 0x0
169F  0D44     RLF a, W
16A0  0D45     RLF dia, W
16A1  00CB     MOVWF sign
16A2  08CB     MOVF sign, F
16A3  1D03     BTFSS STATUS, 0x2
16A4  2EA9     GOTO 0x6A9
59:            		return 0.0;
16A5  01BD     CLRF f1
16A6  01BE     CLRF 0x3E
16A7  01BF     CLRF 0x3F
16A8  0008     RETURN
60:            	exp += exp2-127-6;	// compute new exponent
16A9  084B     MOVF sign, W
16AA  3E7B     ADDLW 0x7B
16AB  07C6     ADDWF y, F
61:            	sign = f1_as_plier >> 16;
16AC  083F     MOVF 0x3F, W
16AD  00CB     MOVWF sign
62:            	sign ^= (unsigned char)(f2_as_plicand >> 16);
16AE  0842     MOVF m, W
16AF  06CB     XORWF sign, F
63:            	sign &= 0x80;
16B0  3080     MOVLW 0x80
16B1  05CB     ANDWF sign, F
64:            	f1_as_plier |= 0x8000UL;
16B3  17BE     BSF 0x3E, 0x7
65:            	//f1_as_plier &= 0xFFFFUL;		// not required
66:            	f2_as_plicand |= 0x8000UL;
16B4  17C1     BSF 0x41, 0x7
67:            	f2_as_plicand &= 0xFFFFUL;
16B5  01C2     CLRF m
68:            	f3_as_product = 0;
16B6  01C7     CLRF f
16B7  01C8     CLRF 0x48
16B8  01C9     CLRF 0x49
69:            	cntr = 7;
16B2  3007     MOVLW 0x7
16B9  00CA     MOVWF cntr
70:            	do {
71:            		if(f1_as_plier & 1)
16BA  1C3D     BTFSS f1, 0x0
16BB  2ECA     GOTO 0x6CA
72:            			f3_as_product += f2_as_plicand;
16BC  0840     MOVF f2, W
16BD  07C7     ADDWF f, F
16BE  0841     MOVF 0x41, W
16BF  1103     BCF STATUS, 0x2
16C0  1803     BTFSC STATUS, 0x0
16C1  0A41     INCF 0x41, W
16C2  1D03     BTFSS STATUS, 0x2
16C3  07C8     ADDWF 0x48, F
16C4  0842     MOVF m, W
16C5  1103     BCF STATUS, 0x2
16C6  1803     BTFSC STATUS, 0x0
16C7  0A42     INCF m, W
16C8  1D03     BTFSS STATUS, 0x2
16C9  07C9     ADDWF 0x49, F
73:            		f1_as_plier >>= 1;
16CA  1003     BCF STATUS, 0x0
16CB  0CBF     RRF 0x3F, F
16CC  0CBE     RRF 0x3E, F
16CD  0CBD     RRF f1, F
74:            		f2_as_plicand <<= 1;
16CE  1003     BCF STATUS, 0x0
16CF  0DC0     RLF f2, F
16D0  0DC1     RLF 0x41, F
16D1  0DC2     RLF m, F
75:            	} while(--cntr != 0);
16D2  0BCA     DECFSZ cntr, F
16D3  2EBA     GOTO 0x6BA
76:            	cntr = 9;
16D4  3009     MOVLW 0x9
16D5  00CA     MOVWF cntr
77:            	do {
78:            		if(f1_as_plier & 1)
16D6  1C3D     BTFSS f1, 0x0
16D7  2EE6     GOTO 0x6E6
79:            			f3_as_product += f2_as_plicand;
16D8  0840     MOVF f2, W
16D9  07C7     ADDWF f, F
16DA  0841     MOVF 0x41, W
16DB  1103     BCF STATUS, 0x2
16DC  1803     BTFSC STATUS, 0x0
16DD  0A41     INCF 0x41, W
16DE  1D03     BTFSS STATUS, 0x2
16DF  07C8     ADDWF 0x48, F
16E0  0842     MOVF m, W
16E1  1103     BCF STATUS, 0x2
16E2  1803     BTFSC STATUS, 0x0
16E3  0A42     INCF m, W
16E4  1D03     BTFSS STATUS, 0x2
16E5  07C9     ADDWF 0x49, F
80:            		f1_as_plier >>= 1;
16E6  1003     BCF STATUS, 0x0
16E7  0CBF     RRF 0x3F, F
16E8  0CBE     RRF 0x3E, F
16E9  0CBD     RRF f1, F
81:            		f3_as_product >>= 1;
16EA  1003     BCF STATUS, 0x0
16EB  0CC9     RRF 0x49, F
16EC  0CC8     RRF 0x48, F
16ED  0CC7     RRF f, F
82:            	} while(--cntr != 0);
16EE  0BCA     DECFSZ cntr, F
16EF  2ED6     GOTO 0x6D6
83:            	return __ftpack(f3_as_product, exp, sign);
16F0  0847     MOVF f, W
16F1  00A3     MOVWF x
16F2  0848     MOVF 0x48, W
16F3  00A4     MOVWF dato
16F4  0849     MOVF 0x49, W
16F5  00A5     MOVWF y
16F6  0846     MOVF y, W
16F7  00A6     MOVWF x
16F8  084B     MOVF sign, W
16F9  00A7     MOVWF i
16FA  27C2     CALL 0x7C2
16FB  0823     MOVF x, W
16FC  00BD     MOVWF f1
16FD  0824     MOVF dato, W
16FE  00BE     MOVWF 0x3E
16FF  0825     MOVF y, W
1700  00BF     MOVWF 0x3F
84:            }
1701  0008     RETURN
85:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/ftadd.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
11:            #define	f2_as_mant2	(*(unsigned short long *)&f2)
12:            
13:            // floating addition
14:            #ifdef _OLDLIB
15:            float
16:            __ftadd(float f1, float f2)
17:            {
18:            	unsigned char	exp1, exp2, sign1, sign2, cntr;
19:            	
20:            	if(sizeof(f1_as_mant1) != 3)
21:            		return 0;
22:            	sign1 = __ftunpack(&f1_as_mant1, &exp1);
23:            	if(exp1 == 0)
24:            		return f2;
25:            	sign2 = __ftunpack(&f2_as_mant2, &exp2);
26:            	if(exp2 != 0) {
27:            		cntr = 6;
28:            		// determine the smaller number. 
29:            		if(exp1 < exp2) {
30:            			if((unsigned char)(exp2-exp1) > sizeof(f1)*8) {
31:            				// return f2
32:            				f1_as_mant1 = 0;
33:            				exp1 = exp2;
34:            				sign1 = sign2;
35:            			} else {
36:            				// f1 has the smaller exponent - we can shift f2_as_mant2 up to 6 bits
37:            				// left, decrementing exp2.
38:            				do {
39:            					f2_as_mant2 <<= 1;
40:            					exp2--;
41:            				} while(exp2 != exp1 && --cntr != 0);
42:            				while(exp1 != exp2) {
43:            					f1_as_mant1 >>= 1;
44:            					exp1++;
45:            				}
46:            			}
47:            		} else if(exp1 != exp2) {
48:            			if((unsigned char)(exp1-exp2) > sizeof(f1)*8)
49:            				f2_as_mant2 = 0;
50:            			else {
51:            				// f2 has the smaller exponent - we can shift f1_as_mant1 up to 6 bits
52:            				// left, decrementing exp2.
53:            				do {
54:            					f1_as_mant1 <<= 1;
55:            					exp1--;
56:            				} while(exp2 != exp1 && --cntr != 0);
57:            				while(exp1 != exp2) {
58:            					f2_as_mant2 >>= 1;
59:            					exp2++;
60:            				}
61:            			}
62:            		}
63:            		if(sign1 != 0) { 
64:            			f1_as_mant1 ^= 0xFFFFFF;
65:            			f1_as_mant1++;
66:            		}
67:            		if(sign2 != 0) {
68:            			f2_as_mant2 ^= 0xFFFFFF;
69:            			f2_as_mant2++;
70:            		}
71:            		sign1 = 0;
72:            		f1_as_mant1 += f2_as_mant2;
73:            		if(f1_as_mant1 & 0x800000) {
74:            			f1_as_mant1 ^= 0xFFFFFF;
75:            			f1_as_mant1++;
76:            			sign1 = 1;
77:            		}
78:            	}
79:            	__ftpack(&f1_as_mant1, exp1);
80:            	if(sign1)
81:            		f1_as_mant1 ^= 0x800000;
82:            	return f1;
83:            }
84:            #else
85:            float
86:            __ftadd(float f1, float f2)
87:            {
88:            	unsigned char	exp1, exp2, sign;
89:            
90:            	exp1 = f1_as_mant1 >> 15;
1702  082B     MOVF sec, W
1703  00B1     MOVWF divisor
1704  082C     MOVF hr, W
1705  00B2     MOVWF 0x32
1706  082D     MOVF day, W
1707  00B3     MOVWF dividend
1708  1003     BCF STATUS, 0x0
1709  0D32     RLF 0x32, W
170A  0D33     RLF dividend, W
170B  00B6     MOVWF sign
91:            	exp2 = f2_as_mant2 >> 15;
170C  082E     MOVF sign, W
170D  00B1     MOVWF divisor
170E  082F     MOVF quotient, W
170F  00B2     MOVWF 0x32
1710  0830     MOVF c, W
1711  00B3     MOVWF dividend
1712  1003     BCF STATUS, 0x0
1713  0D32     RLF 0x32, W
1714  0D33     RLF dividend, W
1715  00B5     MOVWF counter
92:            	if(exp1 == 0 || exp1 < exp2  && (unsigned char)(exp2-exp1) > sizeof(f1)*8)
1716  0836     MOVF sign, W
1717  1903     BTFSC STATUS, 0x2
1718  2F25     GOTO 0x725
1719  0835     MOVF counter, W
171A  0236     SUBWF sign, W
171B  0835     MOVF counter, W
171C  1803     BTFSC STATUS, 0x0
171D  2F2D     GOTO 0x72D
171E  00B1     MOVWF divisor
171F  0836     MOVF sign, W
1720  02B1     SUBWF divisor, F
1721  3019     MOVLW 0x19
1722  0231     SUBWF divisor, W
1723  1C03     BTFSS STATUS, 0x0
1724  2F2C     GOTO 0x72C
93:            		return f2;
1725  082E     MOVF sign, W
1726  00AB     MOVWF sec
1727  082F     MOVF quotient, W
1728  00AC     MOVWF hr
1729  0830     MOVF c, W
172A  00AD     MOVWF day
172B  0008     RETURN
94:            	if(exp2 == 0 || exp1 > exp2  && (unsigned char)(exp1-exp2) > sizeof(f1)*8)
172C  0835     MOVF counter, W
172D  1903     BTFSC STATUS, 0x2
172E  0008     RETURN
172F  0836     MOVF sign, W
1730  0235     SUBWF counter, W
1731  1803     BTFSC STATUS, 0x0
1732  2F3B     GOTO 0x73B
1733  0836     MOVF sign, W
1734  00B1     MOVWF divisor
1735  0835     MOVF counter, W
1736  02B1     SUBWF divisor, F
1737  3019     MOVLW 0x19
1738  0231     SUBWF divisor, W
1739  1803     BTFSC STATUS, 0x0
173A  0008     RETURN
95:            		return f1;
96:            	sign = 6;
173B  3006     MOVLW 0x6
173C  00B4     MOVWF sign
97:            	if(f1_as_mant1 & 0x800000L)
173D  1BAD     BTFSC day, 0x7
98:            		sign |= 0x80;
173E  17B4     BSF sign, 0x7
99:            	if(f2_as_mant2 & 0x800000L)
173F  1BB0     BTFSC c, 0x7
100:           		sign |= 0x40;
1740  1734     BSF sign, 0x6
101:           	f1_as_mant1 |= 0x8000UL;
1741  17AC     BSF hr, 0x7
102:           	f1_as_mant1 &= 0xFFFFUL;
1742  01AD     CLRF day
103:           	f2_as_mant2 |= 0x8000UL;
1743  17AF     BSF quotient, 0x7
104:           	f2_as_mant2 &= 0xFFFFUL;
1744  01B0     CLRF c
105:           	// determine the smaller number. 
106:           	if(exp1 < exp2) {
1745  0835     MOVF counter, W
1746  0236     SUBWF sign, W
1747  1803     BTFSC STATUS, 0x0
1748  2F62     GOTO 0x762
107:           		// f1 has the smaller exponent - we can shift f2_as_mant2 up to 6 bits
108:           		// left, decrementing exp2.
109:           		do {
110:           			f2_as_mant2 <<= 1;
1749  1003     BCF STATUS, 0x0
174A  0DAE     RLF sign, F
174B  0DAF     RLF quotient, F
174C  0DB0     RLF c, F
111:           			exp2--;
174D  03B5     DECF counter, F
112:           		} while(exp2 != exp1 && --sign & 7);
174E  0835     MOVF counter, W
174F  0636     XORWF sign, W
1750  1903     BTFSC STATUS, 0x2
1751  2F5D     GOTO 0x75D
1752  03B4     DECF sign, F
1753  0834     MOVF sign, W
1754  3907     ANDLW 0x7
1755  1903     BTFSC STATUS, 0x2
1756  2F5D     GOTO 0x75D
1757  2F49     GOTO 0x749
113:           		while(exp1 != exp2) {
175D  0836     MOVF sign, W
175E  0635     XORWF counter, W
175F  1903     BTFSC STATUS, 0x2
1760  2F7E     GOTO 0x77E
1761  2F58     GOTO 0x758
114:           			f1_as_mant1 >>= 1;
1758  1003     BCF STATUS, 0x0
1759  0CAD     RRF day, F
175A  0CAC     RRF hr, F
175B  0CAB     RRF sec, F
115:           			exp1++;
175C  0AB6     INCF sign, F
116:           		}
117:           	} else if(exp1 > exp2) {
1762  0836     MOVF sign, W
1763  0235     SUBWF counter, W
1764  1803     BTFSC STATUS, 0x0
1765  2F7E     GOTO 0x77E
118:           		// f2 has the smaller exponent - we can shift f1_as_mant1 up to 6 bits
119:           		// left, decrementing exp2.
120:           		do {
121:           			f1_as_mant1 <<= 1;
1766  1003     BCF STATUS, 0x0
1767  0DAB     RLF sec, F
1768  0DAC     RLF hr, F
1769  0DAD     RLF day, F
122:           			exp1--;
176A  03B6     DECF sign, F
123:           		} while(exp2 != exp1 && --sign & 7);
176B  0835     MOVF counter, W
176C  0636     XORWF sign, W
176D  1903     BTFSC STATUS, 0x2
176E  2F7A     GOTO 0x77A
176F  03B4     DECF sign, F
1770  0834     MOVF sign, W
1771  3907     ANDLW 0x7
1772  1903     BTFSC STATUS, 0x2
1773  2F7A     GOTO 0x77A
1774  2F66     GOTO 0x766
124:           		while(exp1 != exp2) {
177A  0836     MOVF sign, W
177B  0635     XORWF counter, W
177C  1D03     BTFSS STATUS, 0x2
177D  2F75     GOTO 0x775
125:           			f2_as_mant2 >>= 1;
1775  1003     BCF STATUS, 0x0
1776  0CB0     RRF c, F
1777  0CAF     RRF quotient, F
1778  0CAE     RRF sign, F
126:           			exp2++;
1779  0AB5     INCF counter, F
127:           		}
128:           	}
129:           	if(sign & 0x80) { 
177E  1FB4     BTFSS sign, 0x7
177F  2F89     GOTO 0x789
130:           		// complement and add 1
131:           		f1_as_mant1 ^= 0xFFFFFFUL;
1780  30FF     MOVLW 0xFF
1781  06AB     XORWF sec, F
1782  06AC     XORWF hr, F
1783  06AD     XORWF day, F
132:           		f1_as_mant1++;
1784  0AAB     INCF sec, F
1785  1903     BTFSC STATUS, 0x2
1786  0AAC     INCF hr, F
1787  1903     BTFSC STATUS, 0x2
1788  0AAD     INCF day, F
133:           	}
134:           	if(sign & 0x40) {
1789  1F34     BTFSS sign, 0x6
178A  2F94     GOTO 0x794
135:           		// complement and add 1
136:           		f2_as_mant2 ^= 0xFFFFFFUL;
178B  30FF     MOVLW 0xFF
178C  06AE     XORWF sign, F
178D  06AF     XORWF quotient, F
178E  06B0     XORWF c, F
137:           		f2_as_mant2++;
178F  0AAE     INCF sign, F
1790  1903     BTFSC STATUS, 0x2
1791  0AAF     INCF quotient, F
1792  1903     BTFSC STATUS, 0x2
1793  0AB0     INCF c, F
138:           	}
139:           	sign = 0;
1794  01B4     CLRF sign
140:           	f2_as_mant2 += f1_as_mant1;
1795  082B     MOVF sec, W
1796  07AE     ADDWF sign, F
1797  082C     MOVF hr, W
1798  1103     BCF STATUS, 0x2
1799  1803     BTFSC STATUS, 0x0
179A  0A2C     INCF hr, W
179B  1D03     BTFSS STATUS, 0x2
179C  07AF     ADDWF quotient, F
179D  082D     MOVF day, W
179E  1103     BCF STATUS, 0x2
179F  1803     BTFSC STATUS, 0x0
17A0  0A2D     INCF day, W
17A1  1D03     BTFSS STATUS, 0x2
17A2  07B0     ADDWF c, F
141:           	if(f2_as_mant2 & 0x800000UL) {
17A3  1FB0     BTFSS c, 0x7
17A4  2FB0     GOTO 0x7B0
142:           		f2_as_mant2 ^= 0xFFFFFFUL;
17A5  30FF     MOVLW 0xFF
17A6  06AE     XORWF sign, F
17A7  06AF     XORWF quotient, F
17A8  06B0     XORWF c, F
143:           		f2_as_mant2++;
17A9  0AAE     INCF sign, F
17AA  1903     BTFSC STATUS, 0x2
17AB  0AAF     INCF quotient, F
17AC  1903     BTFSC STATUS, 0x2
17AD  0AB0     INCF c, F
144:           		sign = 1;
17AE  01B4     CLRF sign
17AF  0AB4     INCF sign, F
145:           	}
146:           	return __ftpack(f2_as_mant2, exp1, sign);
17B0  082E     MOVF sign, W
17B1  00A3     MOVWF x
17B2  082F     MOVF quotient, W
17B3  00A4     MOVWF dato
17B4  0830     MOVF c, W
17B5  00A5     MOVWF y
17B6  0836     MOVF sign, W
17B7  00A6     MOVWF x
17B8  0834     MOVF sign, W
17B9  00A7     MOVWF i
17BA  27C2     CALL 0x7C2
17BB  0823     MOVF x, W
17BC  00AB     MOVWF sec
17BD  0824     MOVF dato, W
17BE  00AC     MOVWF hr
17BF  0825     MOVF y, W
17C0  00AD     MOVWF day
147:           
148:           }
17C1  0008     RETURN
149:           #endif
---  /opt/microchip/xc8/v1.31/sources/common/float.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             #include	"ftarith.h"
7:             
8:             
9:             //	unpack the operand pointed to. Store the exponent into the location pointed to by exp,
10:            //	and return the sign (zero is positive)
11:            
12:            #ifdef _OLDLIB
13:            
14:            unsigned char
15:            __ftunpack(unsigned short long * arg, unsigned char * exp)
16:            {
17:            	unsigned char	sign;
18:            
19:            	*exp = sign = *arg >> 15;
20:            	if(sign == 0) {
21:            		*arg = 0;
22:            		return 0;
23:            	}
24:            	sign = 0;
25:            	*arg |= 0x8000;
26:            	if(*arg & 0x800000)
27:            		sign++;
28:            	*arg &= 0xFFFF;
29:            	return sign;
30:            }
31:            
32:            // normalize and pack the supplied argument into floating point format
33:            
34:            void
35:            __ftpack(unsigned short long * arg, unsigned char exp)
36:            {
37:            	if(exp == 0 || *arg == 0) {
38:            		*arg = 0;
39:            		return;
40:            	}
41:            	while(*arg & 0xFE0000UL) {
42:            		exp++;
43:            		*arg >>= 1;
44:            	}
45:            	while(*arg & 0xFF0000UL) {
46:            		exp++;
47:            		(*arg)++;
48:            		*arg >>= 1;
49:            	}
50:            	while(!(*arg & 0x8000UL)) {
51:            		exp--;
52:            		*arg <<= 1;
53:            	}
54:            	if(!(exp & 1))
55:            		*arg &= ~0x8000L;
56:            	exp >>= 1;
57:            	*arg |= (unsigned short long)exp << 16;
58:            }
59:            
60:            #else
61:            float
62:            __ftpack(unsigned short long arg, unsigned char exp, unsigned char sign)
63:            {
64:            	if(exp == 0 || arg == 0)
17C2  0826     MOVF x, W
17C3  1903     BTFSC STATUS, 0x2
17C4  2FCA     GOTO 0x7CA
17C5  0825     MOVF y, W
17C6  0424     IORWF dato, W
17C7  0423     IORWF x, W
17C8  1D03     BTFSS STATUS, 0x2
17C9  2FD3     GOTO 0x7D3
65:            		return 0.0;
17CA  01A3     CLRF x
17CB  01A4     CLRF dato
17CC  01A5     CLRF y
17CD  0008     RETURN
66:            	while(arg & 0xFE0000UL) {
17D3  30FE     MOVLW 0xFE
17D4  0525     ANDWF y, W
17D5  1903     BTFSC STATUS, 0x2
17D6  2FE2     GOTO 0x7E2
17D7  2FCE     GOTO 0x7CE
67:            		exp++;
17CE  0AA6     INCF x, F
68:            		arg >>= 1;
17CF  1003     BCF STATUS, 0x0
17D0  0CA5     RRF y, F
17D1  0CA4     RRF dato, F
17D2  0CA3     RRF x, F
69:            	}
70:            	while(arg & 0xFF0000UL) {
17E2  30FF     MOVLW 0xFF
17E3  0525     ANDWF y, W
17E4  1903     BTFSC STATUS, 0x2
17E5  2FEC     GOTO 0x7EC
17E6  2FD8     GOTO 0x7D8
71:            		exp++;
17D8  0AA6     INCF x, F
72:            		(arg)++;
17D9  0AA3     INCF x, F
17DA  1903     BTFSC STATUS, 0x2
17DB  0AA4     INCF dato, F
17DC  1903     BTFSC STATUS, 0x2
17DD  0AA5     INCF y, F
73:            		arg >>= 1;
17DE  1003     BCF STATUS, 0x0
17DF  0CA5     RRF y, F
17E0  0CA4     RRF dato, F
17E1  0CA3     RRF x, F
74:            	}
75:            	while(!(arg & 0x8000UL)) {
17EC  1FA4     BTFSS dato, 0x7
17ED  2FE7     GOTO 0x7E7
76:            		exp--;
17E7  03A6     DECF x, F
77:            		arg <<= 1;
17E8  1003     BCF STATUS, 0x0
17E9  0DA3     RLF x, F
17EA  0DA4     RLF dato, F
17EB  0DA5     RLF y, F
78:            	}
79:            	if(!(exp & 1))
17EE  1C26     BTFSS x, 0x0
80:            		arg &= ~0x8000L;
17EF  13A4     BCF dato, 0x7
81:            	exp >>= 1;
17F0  1003     BCF STATUS, 0x0
17F1  0CA6     RRF x, F
82:            	arg |= (unsigned short long)exp << 16;
17F2  0826     MOVF x, W
17F3  00AA     MOVWF Data
17F4  01A9     CLRF year
17F5  01A8     CLRF mth
17F6  0828     MOVF mth, W
17F7  04A3     IORWF x, F
17F8  0829     MOVF year, W
17F9  04A4     IORWF dato, F
17FA  082A     MOVF Data, W
17FB  04A5     IORWF y, F
83:            	if (sign)
17FC  0827     MOVF i, W
17FD  1D03     BTFSS STATUS, 0x2
84:            		arg |= 0x800000UL;
17FE  17A5     BSF y, 0x7
85:               return *(float*)&arg;	
86:            }
17FF  0008     RETURN
87:            
88:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/doprnt.c  --------------------------------------------------
1:             #include	<stdio.h>
2:             #include	<ctype.h>
3:             #include	<stdlib.h>
4:             #include	<string.h>
5:             #include	<stdarg.h>
6:             #include	<conio.h>
7:             #include	<sys.h>
8:             #include	<math.h>
9:             #include	<float.h>
10:            
11:            // disable unused variable warnings
12:            // the compiler will optimize them away, so no harm is done
13:            #pragma warning disable 350
14:            
15:            /*
16:             *	doprnt - versions depends on conditional compilation.
17:             *	Can be customized with defines.
18:             *
19:             *	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
20:             *
21:             *	$Header$
22:             *
23:             */
24:            
25:            #ifndef	CUSTOM_PRINTF
26:            
27:             // define all flags, thus enabling all features
28:            
29:            #define	BASEM	0xC0
30:            #define	OPTSIGN	0x00
31:            #define	SPCSIGN	0x01
32:            #define	MANSIGN	0x02
33:            #define	NEGSIGN	0x03
34:            #define	FILL	0x04
35:            #define	LEFT	0x08
36:            #define	LONG	0x10
37:            #define	UPCASE	0x20
38:            #define	TEN		0x00
39:            #define	EIGHT	0x40
40:            #define	SIXTEEN	0x80
41:            #define	UNSIGN	0xC0
42:            #ifdef	__FLOAT
43:            #define	EFMT	0x100
44:            #define	GFMT	0x200
45:            #define	FFMT	0x400
46:            #endif	// __FLOAT
47:            #define	ALTERN	0x800
48:            #define POINTER	0x2000
49:            #define HEXUPCASE
50:            #define HEXLOWCASE
51:            
52:             // defines for ifdef only, not used as flags
53:            #define	WIDTH	1		// width used
54:            #define	STAR	1		// width or precision as an arg
55:            #define	STRING	1		// %s used
56:            #define	CHAR	1		// %c used
57:            #define	PERCPERC	1	// %% used
58:            #define	SPRINTF	1		// sprintf is used
59:            #define	PRINTF	1		// printf is used
60:            #define	MULTRAD	1		// handle multiple radices
61:            #define	RETVALUE	1	// return value is needed
62:            
63:            #else	// CUSTOM_PRINTF
64:            
65:            #if	defined(HEXUPCASE) || defined(HEXLOWCASE)
66:            #define	SIXTEEN
67:            #endif
68:            
69:            #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
70:            #ifndef UPCASE
71:            #define	UPCASE
72:            #endif
73:            #endif
74:            
75:             // make sure we have the right values for each define
76:            #ifdef	OPTSIGN
77:            #undef	OPTSIGN
78:            #define	OPTSIGN	0x00
79:            #endif
80:            #ifdef	SPCSIGN
81:            #undef	SPCSIGN
82:            #define	SPCSIGN	0x01
83:            #endif
84:            #ifdef	MANSIGN
85:            #undef	MANSIGN
86:            #define	MANSIGN	0x02
87:            #define	SPCSIGN	0x01
88:            #endif
89:            #ifdef	NEGSIGN
90:            #undef	NEGSIGN
91:            #define	NEGSIGN	0x03
92:            #endif
93:            #ifdef	FILL
94:            #define	WIDTH	1
95:            #undef	FILL
96:            #define	FILL	0x04
97:            #endif
98:            #ifdef	LEFT
99:            #undef	LEFT
100:            // LEFT without WIDTH is meaningless
101:           #ifdef	WIDTH
102:           #define	LEFT	0x08
103:           #endif
104:           #endif
105:           #ifdef	LONG
106:           #undef	LONG
107:           #define	LONG	0x10
108:           #define	__LONG	1
109:           #endif
110:           #ifdef	UPCASE
111:           #undef	UPCASE
112:           #define	UPCASE	0x20
113:           #endif
114:           #ifdef	TEN	
115:           #undef	TEN	
116:           #define	TEN		0x00
117:           #endif
118:           #ifdef	EIGHT
119:           #undef	EIGHT
120:           #define	EIGHT	0x40
121:           #endif
122:           #ifdef	SIXTEEN
123:           #undef	SIXTEEN
124:           #define	SIXTEEN	0x80
125:           #endif
126:           #ifdef	UNSIGN
127:           #undef	UNSIGN
128:           #define	UNSIGN	0xC0
129:           #endif
130:           #ifdef	EFMT
131:           #undef	EFMT
132:           #define	EFMT	0x100
133:           #endif
134:           #ifdef	GFMT
135:           #undef	GFMT
136:           #define	GFMT	0x200
137:           #endif
138:           #ifdef	FFMT
139:           #undef	FFMT
140:           #define	FFMT	0x400
141:           #endif
142:           #ifdef	ALTERN
143:           #undef	ALTERN
144:           #define	ALTERN	0x800
145:           #endif
146:           #ifdef	POINTER
147:           #undef	POINTER
148:           #define POINTER	0x2000
149:           #ifndef	SIXTEEN
150:           #define	SIXTEEN	0x80
151:           #endif
152:           #endif
153:           #ifdef	PRECISION
154:           #undef	PRECISION
155:           #define PRECISION	0x4000
156:           #endif
157:           
158:           #if	defined(TEN) && !defined(EIGHT) && !defined(SIXTEEN) && defined(UNSIGN)
159:           #undef	UNSIGN
160:           #define	UNSIGN	0x40
161:           #define	BASEM	UNSIGN
162:           #endif
163:           #if	defined(UNSIGN) && (defined(EIGHT) || defined(SIXTEEN))
164:           #define	MULTRAD	1
165:           #define	BASEM	(UNSIGN)
166:           #endif
167:           #if	defined(TEN) && !defined(SIXTEEN) && defined(EIGHT) && !defined(UNSIGN)
168:           #define	BASEM	EIGHT
169:           #define	MULTRAD	1
170:           #endif
171:           #if	defined(TEN) && defined(SIXTEEN) && !defined(EIGHT) && !defined(UNSIGN)
172:           #define	BASEM	SIXTEEN
173:           #define	MULTRAD	1
174:           #endif
175:           #if	defined(SIXTEEN) && defined(EIGHT) && !defined(BASEM)
176:           #define	BASEM	(SIXTEEN|EIGHT)
177:           #define	MULTRAD	1
178:           #endif
179:           
180:           #endif
181:           
182:            // float code needs these flags
183:           #if	defined(EFMT) || defined(GFMT) || defined(FFMT)
184:           #ifndef	__FLOAT
185:           #define	__FLOAT	1
186:           #endif
187:           #define	FLOATFORMAT	0x700
188:           #ifdef	PRECISION
189:           #define	DEFPREC	0x1000
190:           #endif
191:           #endif
192:           
193:           #ifdef	__FLOAT
194:           //#ifndef	MANSIGN
195:           //#define	MANSIGN	0x02
196:           //#endif
197:           //#ifndef	SPCSIGN
198:           //#define	SPCSIGN	0x01
199:           //#endif
200:           #ifndef	NEGSIGN
201:           #define	NEGSIGN	0x03
202:           #endif
203:           //#ifndef	WIDTH
204:           //#define	WIDTH	1
205:           //#endif
206:           #endif
207:           
208:           #ifdef	SPCSIGN
209:           #define	putsign()	pputc(flag & SPCSIGN ? '-' : '+')
210:           #else
211:           #define	putsign()	pputc('-')
212:           #endif	// SPCSIGN
213:           
214:           // were there ANY % formats defined?
215:           #if	defined(FLOATFORMAT) || defined(TEN) || defined(EIGHT) || defined(SIXTEEN) || \
216:           	defined(CHAR) || defined(POINTER) || defined(STRING) || defined(UNSIGN) || defined(PERCPERC)
217:           #define	ANYFORMAT
218:           #else
219:           #undef	ANYFORMAT
220:           #endif
221:           
222:           #ifdef	CHAR
223:           #ifndef	PERCPERC
224:           #define	PERCPERC
225:           #endif
226:           #endif
227:           
228:           #if	!defined(PRINTF) && !defined(VPRINTF) && !defined(SPRINTF) && !defined(VSPRINTF)
229:           #error	Must define at least one of PRINTF SPRINTF or VSPRINTF
230:           #endif
231:           
232:           #if	i8086 && SMALL_DATA
233:           #define	CONST	far
234:           #else
235:           #define	CONST	const
236:           #endif
237:           
238:            /* we don't need plus signs, use minus signs only if we have floats or signed ints */
239:           
240:           #if	!defined(NEGSIGN) && defined(TEN)
241:           #define	NEGSIGN	0x03
242:           #endif
243:           
244:           #ifndef	RETVALUE
245:           #define	INCR_CNT	/*nix */
246:           #else
247:           #define	INCR_CNT	,(++ccnt)
248:           #endif
249:           
250:           #if	defined(EFMT) || defined(GFMT) || defined(FFMT) || defined(ALTERN) || defined(DEFPREC) || defined(POINTER)
251:           #define	FLAG_SIZE	unsigned short
252:           #else
253:           #define	FLAG_SIZE	unsigned char
254:           #endif
255:           
256:           
257:           #if	(sizeof(long) == sizeof(int) || defined(__FLOAT)) && !defined(__LONG)
258:           #define	__LONG	1
259:           #endif
260:           
261:           #if	sizeof(double) == sizeof(long) && DBL_MAX_EXP == 128
262:           #undef	frexp
263:           #define	frexp(val, ptr) (void)(*(ptr) = (unsigned char)((*(unsigned long *)&val >> 23) & 255) - 126)
264:           #elif	defined(_PSOC_)
265:           #undef	frexp
266:           #define	frexp(val, ptr) (void)(*(ptr) = ((unsigned char)(*(unsigned short long *)&val >> 15)) - 126)
267:           #elif	sizeof(double) == 3 && DBL_MAX_EXP == 128
268:           #undef	frexp
269:           #define	frexp(val, ptr) (void)(*(ptr) = ((*(unsigned long *)&val >> 15) & 255) - 126)
270:           #endif
271:           
272:           #if	defined(__FLOAT) && sizeof(double) == 8
273:           #define	DOUBLE	1
274:           
275:           extern double	_dto64i(double);
276:           extern double	_64itod(double);
277:           extern double	_div64(double, double);
278:           extern double	_divto64i(double, double);
279:           extern unsigned	_div64ir(double, double);
280:           extern unsigned	_mod64i10(double);
281:           
282:           #else
283:           #define	DOUBLE	0
284:           #endif
285:           
286:           #ifdef	__LONG
287:           #define	value	long
288:           #define	NDIG	12		/* max number of digits to be printed */
289:           #else
290:           #define	value	int
291:           #define	NDIG	6		/* max number of digits to be printed */
292:           #endif
293:           
294:           #if	DOUBLE
295:           union {
296:           	unsigned long	ul[40];
297:           	double		db[20];
298:           }	_fdp =
299:           {
300:           #if	!defined(BIG_ENDIAN) && !defined(LITTLE_ENDIAN)
301:           #error Neither BIG_ENDIAN or LITTLE_ENDIAN has been set
302:           #endif
303:           #if	BIG_ENDIAN
304:           	0x00000000,0x00000001,
305:           	0x00000000,0x0000000A,
306:           	0x00000000,0x00000064,
307:           	0x00000000,0x000003E8,
308:           	0x00000000,0x00002710,
309:           	0x00000000,0x000186A0,
310:           	0x00000000,0x000F4240,
311:           	0x00000000,0x00989680,
312:           	0x00000000,0x05F5E100,
313:           	0x00000000,0x3B9ACA00,
314:           	0x00000002,0x540BE400,
315:           	0x00000017,0x4876E800,
316:           	0x000000E8,0xD4A51000,
317:           	0x00000918,0x4E72A000,
318:           	0x00005AF3,0x107A4000,
319:           	0x00038D7E,0xA4C68000,
320:           	0x002386F2,0x6FC10000,
321:           	0x01634578,0x5D8A0000,
322:           	0x0DE0B6B3,0xA7640000,
323:           	0x8AC72304,0x89E80000,
324:           #else
325:           	0x00000001,0x00000000,
326:           	0x0000000A,0x00000000,
327:           	0x00000064,0x00000000,
328:           	0x000003E8,0x00000000,
329:           	0x00002710,0x00000000,
330:           	0x000186A0,0x00000000,
331:           	0x000F4240,0x00000000,
332:           	0x00989680,0x00000000,
333:           	0x05F5E100,0x00000000,
334:           	0x3B9ACA00,0x00000000,
335:           	0x540BE400,0x00000002,
336:           	0x4876E800,0x00000017,
337:           	0xD4A51000,0x000000E8,
338:           	0x4E72A000,0x00000918,
339:           	0x107A4000,0x00005AF3,
340:           	0xA4C68000,0x00038D7E,
341:           	0x6FC10000,0x002386F2,
342:           	0x5D8A0000,0x01634578,
343:           	0xA7640000,0x0DE0B6B3,
344:           	0x89E80000,0x8AC72304,
345:           #endif
346:           };
347:           
348:           #define	fdpowers	_fdp.db
349:           
350:           #else
351:           #define	fdpowers	dpowers
352:           #endif
353:           #if defined(TEN) || defined(__FLOAT) || defined (UNSIGN)
354:           const static unsigned value	dpowers[] =	{1, 10, 100, 1000, 10000,
355:           #ifdef	__LONG
356:           						 100000, 1000000, 10000000, 100000000,
357:           						 1000000000
358:           #endif
359:           							 };
360:           #endif
361:           #ifdef	SIXTEEN
362:           const static unsigned value	hexpowers[] =	{1, 0x10, 0x100, 0x1000,
363:           #if	__LONG
364:           						 0x10000, 0x100000, 0x1000000, 0x10000000
365:           #endif
366:           							};
367:           #endif
368:           #ifdef	EIGHT
369:           const static unsigned value	octpowers[] =	{1, 010, 0100, 01000, 010000, 0100000,
370:           #ifdef	__LONG
371:           						01000000,
372:           						 010000000, 0100000000, 01000000000, 010000000000,
373:           						 0100000000000
374:           #endif
375:           							};
376:           #endif
377:           
378:           #ifdef	__FLOAT
379:           
380:           #define	NDDIG	(sizeof fdpowers/sizeof fdpowers[0])
381:           
382:           #if	DBL_MAX_10_EXP > 120
383:           #define	expon	int
384:           #else
385:           #define	expon	signed char
386:           #endif
387:           
388:           extern const double	_powers_[], _npowers_[];
389:           #ifdef	z80
390:           #define	_div_to_l_(a, b)	((unsigned long)((a)/(b)))
391:           #else
392:           extern unsigned long	_div_to_l_(double, double);
393:           #ifdef	_OMNI_CODE_
394:           extern unsigned long	_tdiv_to_l_(float, float);
395:           #ifdef	_HTKC_
396:           #pragma callname _div_to_l_ double
397:           #pragma callname _tdiv_to_l_ float
398:           #endif
399:           #define	div_to_l_(a,b)	((sizeof(double)== 3) ? _tdiv_to_l_(a,b) : _div_to_l_(a,b))
400:           #else
401:           #define	div_to_l_	_div_to_l_
402:           #endif
403:           #endif
404:           
405:           /* this routine returns a value to round to the number of decimal
406:           	places specified */
407:           #if __FLOAT
408:           static double
409:           fround(unsigned char prec)
410:           {
411:           	/* prec is guaranteed to be less than NDIG */
412:           
413:           	if(prec>=110)
414:           		return 0.5 * _npowers_[prec/100+18] * _npowers_[(prec%100)/10+9] * _npowers_[prec%10];
415:           	else if(prec > 10)
416:           		return 0.5 * _npowers_[prec/10+9] * _npowers_[prec%10];
417:           	return 0.5 * _npowers_[prec];
418:           }
419:           #endif
420:           
421:           /* this routine returns a scaling factor equal to 1 to the decimal
422:              power supplied */
423:           
424:           static double
425:           scale(expon scl)
426:           {
427:           
428:           	if(scl < 0) {
429:           		scl = -scl;
430:           		if(scl>=110)
431:           			return _npowers_[scl/100+18] * _npowers_[(scl%100)/10+9] * _npowers_[scl%10];
432:           		else if(scl > 10)
433:           			return _npowers_[scl/10+9] * _npowers_[scl%10];
434:           		return _npowers_[scl];
435:           	}
436:           	if(scl>=110)
437:           		return _powers_[scl/100+18] * _powers_[(scl%100)/10+9] * _powers_[scl%10];
438:           	else if(scl > 10)
439:           		return _powers_[scl/10+9] * _powers_[scl%10];
440:           	return _powers_[scl];
441:           }
442:           
443:           
444:           #endif	/* __FLOAT */
445:           
446:           
447:           
448:           #ifdef	_HOSTED
449:           #define	pputc(c)	(putc(c, fp) != EOF && ++ccnt)
450:           int
451:           vfprintf(FILE * fp, register const  char * f, register va_list ap)
452:           {
453:           	char		cbuf[2];
454:           #else	/* _HOSTED */
455:           int
456:           #if	defined(VPRINTF) || (defined(PRINTF) && (defined(SPRINTF) || defined(VSPRINTF)))
457:           #define	pputc(c)	if(pb->func) (pb->func(c))INCR_CNT; else ((*pb->ptr++ = c)INCR_CNT)
458:           _doprnt(struct __prbuf * pb, register const  char * f, register va_list ap)
459:           {
460:           #endif
461:           
462:           #if	defined(PRINTF) && !(defined(SPRINTF) || defined(VSPRINTF))
463:           #define	pputc(c)	(putch(c) INCR_CNT)
464:           printf(const char * f, ...)
465:           {
466:           	va_list	ap;
467:           #define	NEED_START
468:           #endif
469:           
470:           #if	!defined(PRINTF) && defined(VSPRINTF)
471:           
472:           #ifdef	SPRINTF
473:           sprintf(char * sp, const char * f, ...)
474:           {
475:           	va_list	ap;
476:           
477:           	va_start(ap, f);
478:           	vsprintf(sp, f, ap);
479:           	va_end(ap);
480:           }
481:           int
482:           #endif	// SPRINTF
483:           
484:           #define	pputc(c)	((*sp++ = (c))INCR_CNT)
485:           vsprintf(char * sp, register const  char * f, register va_list ap)
486:           {
487:           #define NEED_START
488:           #endif	// VSPRINTF
489:           
490:           #if	!defined(PRINTF) && defined(SPRINTF) && !defined(VSPRINTF)
491:           #define	pputc(c)	((*sp++ = (c))INCR_CNT)
492:           sprintf(char * sp, const  char * f, ...)
05C7  00DB     MOVWF sp
493:           {
494:           	va_list	ap;
495:           #define	NEED_START
496:           #endif
497:           #endif	// HOSTED
498:           
499:           	signed char		c;
500:           #if	defined(WIDTH) || defined(__FLOAT)
501:           	int		width;
502:           #endif
503:           #ifdef	__LONG
504:           	int		prec;
505:           #else
506:           	signed char	prec;
507:           #endif
508:           	FLAG_SIZE	flag;
509:           #ifdef	RETVALUE
510:           	int		ccnt = 0;
511:           #else
512:           #define	ccnt	0
513:           #endif
514:           #ifdef	__FLOAT
515:           	char	d;
516:           	double	fval, integ;
517:           	int		exp;
518:           	double		ival;
519:           	union {
520:           		unsigned value	_val;
521:           		struct {
522:           		    CONST char *	_cp;
523:           		    unsigned	_len;
524:           		}		_str;
525:           	}		_val;
526:           #else	// __FLOAT
527:           	union {
528:           		unsigned value	_val;
529:           		struct {
530:           		    CONST char *	_cp;
531:           		    unsigned	_len;
532:           		}		_str;
533:           	}		_val;
534:           #endif	// __FLOAT
535:           
536:           #define	val	_val._val
537:           #define	cp	_val._str._cp
538:           #define	len	_val._str._len
539:           
540:           	
541:           #ifdef	NEED_START
542:           	va_start(ap, f);
05C8  3049     MOVLW 0x49
05C9  00D3     MOVWF ap
543:           #endif
544:           
545:           	while(c = *f++) {
05CA  0848     MOVF 0x48, W
05CB  00D0     MOVWF 0x50
05CC  0847     MOVF f, W
05CD  00CF     MOVWF f1
05CE  0AC7     INCF f, F
05CF  1903     BTFSC STATUS, 0x2
05D0  0AC8     INCF 0x48, F
05D1  0850     MOVF 0x50, W
05D2  00FF     MOVWF 0x7F
05D3  084F     MOVF f1, W
05D4  0084     MOVWF FSR
05D5  160A     BSF PCLATH, 0x4
05D6  158A     BSF PCLATH, 0x3
05D7  2000     CALL 0x0
05D8  120A     BCF PCLATH, 0x4
05D9  118A     BCF PCLATH, 0x3
05DA  00DA     MOVWF c
05DB  08DA     MOVF c, F
05DC  1903     BTFSC STATUS, 0x2
05DD  2F7A     GOTO 0x77A
0779  2DCA     GOTO 0x5CA
546:           #ifdef	ANYFORMAT
547:           		if(c != '%')
05DE  085A     MOVF c, W
05DF  3A25     XORLW 0x25
05E0  1903     BTFSC STATUS, 0x2
05E1  2DE9     GOTO 0x5E9
548:           #endif	//ANYFORMAT
549:           		{
550:           			pputc(c);
05E2  085B     MOVF sp, W
05E3  0084     MOVWF FSR
05E4  085A     MOVF c, W
05E5  1383     BCF STATUS, 0x7
05E6  0080     MOVWF INDF
05E7  0ADB     INCF sp, F
551:           			continue;
05E8  2DCA     GOTO 0x5CA
552:           		}
553:           #ifdef	ANYFORMAT
554:           #ifdef	WIDTH
555:           		width = 0;
05E9  01D5     CLRF width
05EA  01D6     CLRF f3
556:           #endif
557:           		flag = 0;
05EB  01D4     CLRF flag
05EC  2DF1     GOTO 0x5F1
558:           #if	defined(LEFT) || defined(SPCSIGN) || defined(MANSIGN) || defined(ALTERN) || defined(FILL)
559:           		for(;;) {
560:           			switch(*f) {
05F1  0848     MOVF 0x48, W
05F2  00FF     MOVWF 0x7F
05F3  0847     MOVF f, W
05F4  0084     MOVWF FSR
05F5  160A     BSF PCLATH, 0x4
05F6  158A     BSF PCLATH, 0x3
05F7  2000     CALL 0x0
05F8  120A     BCF PCLATH, 0x4
05F9  118A     BCF PCLATH, 0x3
05FA  3A30     XORLW 0x30
05FB  1903     BTFSC STATUS, 0x2
05FC  2DED     GOTO 0x5ED
05FD  2DFE     GOTO 0x5FE
561:           #ifdef	LEFT
562:           			case '-':
563:           				flag |= LEFT;
564:           				f++;
565:           				continue;
566:           #endif
567:           
568:           #ifdef	SPCSIGN
569:           			case ' ':
570:           				flag |= SPCSIGN;
571:           				f++;
572:           				continue;
573:           #endif
574:           
575:           #ifdef	MANSIGN
576:           			case '+':
577:           				flag |= MANSIGN;
578:           				f++;
579:           				continue;
580:           #endif
581:           #ifdef	ALTERN
582:           			case '#':
583:           				flag |= ALTERN;
584:           				f++;
585:           				continue;
586:           #endif
587:           #ifdef	FILL
588:           			case '0':
589:           				flag |= FILL;
05ED  1554     BSF flag, 0x2
590:           				f++;
05EE  0AC7     INCF f, F
05EF  1903     BTFSC STATUS, 0x2
05F0  0AC8     INCF 0x48, F
591:           				continue;
592:           #endif
593:           			}
594:           			break;
595:           		}
596:           #endif
597:           #if	defined(MANSIGN) && defined(SPCSIGN)
598:           		if(flag & MANSIGN)
599:           			flag &= ~SPCSIGN;
600:           #endif
601:           #if	defined(LEFT) && defined(FILL)
602:           		if(flag & LEFT)
603:           			flag &= ~FILL;
604:           #endif
605:           #ifdef	WIDTH
606:           		if(isdigit((unsigned)*f)) {
05FE  0848     MOVF 0x48, W
05FF  00FF     MOVWF 0x7F
0600  0847     MOVF f, W
0601  0084     MOVWF FSR
0602  160A     BSF PCLATH, 0x4
0603  158A     BSF PCLATH, 0x3
0604  2000     CALL 0x0
0605  120A     BCF PCLATH, 0x4
0606  118A     BCF PCLATH, 0x3
0607  277F     CALL 0x77F
0608  120A     BCF PCLATH, 0x4
0609  118A     BCF PCLATH, 0x3
060A  1C03     BTFSS STATUS, 0x0
060B  2E81     GOTO 0x681
607:           			width = 0;
060C  01D5     CLRF width
060D  01D6     CLRF f3
608:           			do {
609:           				width *= 10;
060E  300A     MOVLW 0xA
060F  00A3     MOVWF x
0610  01A4     CLRF dato
0611  0856     MOVF f3, W
0612  00A6     MOVWF x
0613  0855     MOVF width, W
0614  00A5     MOVWF y
0615  278D     CALL 0x78D
0616  0824     MOVF dato, W
0617  00D6     MOVWF f3
0618  0823     MOVF x, W
0619  00D5     MOVWF width
610:           			   	width += *f++ - '0';
061A  0848     MOVF 0x48, W
061B  00FF     MOVWF 0x7F
061C  0847     MOVF f, W
061D  0084     MOVWF FSR
061E  160A     BSF PCLATH, 0x4
061F  158A     BSF PCLATH, 0x3
0620  2000     CALL 0x0
0621  120A     BCF PCLATH, 0x4
0622  118A     BCF PCLATH, 0x3
0623  3ED0     ADDLW 0xD0
0624  00CF     MOVWF f1
0625  30FF     MOVLW 0xFF
0626  1803     BTFSC STATUS, 0x0
0627  3000     MOVLW 0x0
0628  00D0     MOVWF 0x50
0629  084F     MOVF f1, W
062A  07D5     ADDWF width, F
062B  1803     BTFSC STATUS, 0x0
062C  0AD6     INCF f3, F
062D  0850     MOVF 0x50, W
062E  07D6     ADDWF f3, F
062F  0AC7     INCF f, F
0630  1903     BTFSC STATUS, 0x2
0631  0AC8     INCF 0x48, F
611:           			} while(isdigit((unsigned)*f));
0632  0848     MOVF 0x48, W
0633  00FF     MOVWF 0x7F
0634  0847     MOVF f, W
0635  0084     MOVWF FSR
0636  160A     BSF PCLATH, 0x4
0637  158A     BSF PCLATH, 0x3
0638  2000     CALL 0x0
0639  120A     BCF PCLATH, 0x4
063A  118A     BCF PCLATH, 0x3
063B  277F     CALL 0x77F
063C  120A     BCF PCLATH, 0x4
063D  118A     BCF PCLATH, 0x3
063E  1C03     BTFSS STATUS, 0x0
063F  2E81     GOTO 0x681
0640  2E0E     GOTO 0x60E
612:           #ifdef	STAR
613:           		} else if(*f == '*') {
614:           			width = va_arg(ap, int);
615:           			f++;
616:           #endif
617:           		}
618:           #endif
619:           #ifdef	PRECISION
620:           		if(*f == '.') {
621:           			flag |= PRECISION;
622:           			f++;
623:           #ifdef	STAR
624:           			if(*f == '*') {
625:           				prec = va_arg(ap, int);
626:           				f++;
627:           			} else
628:           #endif
629:           			{
630:           				prec = 0;
631:           				while(isdigit((unsigned)*f))
632:           					prec = prec*10 + *f++ - '0';
633:           			}
634:           		} else {
635:           			prec = 0;
636:           #ifdef	DEFPREC
637:           			flag |= DEFPREC;
638:           #endif	// DEFPREC
639:           		}
640:           #endif	// PRECISION
641:           #if	defined(__LONG) && defined(LONG)
642:           loop:
643:           #endif
644:           		switch(c = *f++) {
0681  0848     MOVF 0x48, W
0682  00D0     MOVWF 0x50
0683  0847     MOVF f, W
0684  00CF     MOVWF f1
0685  0AC7     INCF f, F
0686  1903     BTFSC STATUS, 0x2
0687  0AC8     INCF 0x48, F
0688  0850     MOVF 0x50, W
0689  00FF     MOVWF 0x7F
068A  084F     MOVF f1, W
068B  0084     MOVWF FSR
068C  160A     BSF PCLATH, 0x4
068D  158A     BSF PCLATH, 0x3
068E  2000     CALL 0x0
068F  120A     BCF PCLATH, 0x4
0690  118A     BCF PCLATH, 0x3
0691  00DA     MOVWF c
0692  3A00     XORLW 0x0
0693  1903     BTFSC STATUS, 0x2
0694  2F7A     GOTO 0x77A
0695  3A64     XORLW 0x64
0696  1903     BTFSC STATUS, 0x2
0697  2E9F     GOTO 0x69F
0698  3A0D     XORLW 0xD
0699  1903     BTFSC STATUS, 0x2
069A  2E9F     GOTO 0x69F
069B  3A1C     XORLW 0x1C
069C  1903     BTFSC STATUS, 0x2
069D  2E7F     GOTO 0x67F
069E  2E79     GOTO 0x679
645:           
646:           		case 0:
647:           			goto alldone;
648:           
649:           #ifdef	LONG
650:           		case 'l':
651:           #ifdef	__LONG
652:           			flag |= LONG;
653:           			goto loop;
654:           #else
655:           			cp = "(non-long printf)";
656:           			goto strings;
657:           #endif
658:           #endif
659:           
660:           #ifdef	FLOATFORMAT
661:           #ifndef	__FLOAT
662:           		case 'E':
663:           		case 'f':
664:           		case 'e':
665:           		case 'G':
666:           		case 'g':
667:           			cp = "(non-float printf)";
668:           			goto strings;
669:           #else
670:           #ifdef	FFMT
671:           		case 'f':
672:           			flag |= FFMT;
673:           			break;
674:           #endif
675:           
676:           #ifdef	EFMT
677:           #ifdef	UPCASE
678:           		case 'E':
679:           			flag |= UPCASE;
680:           #endif
681:           		case 'e':
682:           			flag |= EFMT;
683:           			break;
684:           #endif
685:           
686:           #ifdef	GFMT
687:           #ifdef	UPCASE
688:           		case 'G':
689:           			flag |= UPCASE;
690:           #endif
691:           		case 'g':
692:           			flag |= GFMT;
693:           			break;
694:           #endif	// GFMT
695:           #endif
696:           #endif	// FLOATFORMAT
697:           #ifdef	EIGHT
698:           		case 'o':
699:           #ifdef	MULTRAD
700:           			flag |= EIGHT;
701:           #endif
702:           			break;
703:           #endif
704:           
705:           #ifdef	TEN
706:           		case 'd':
707:           		case 'i':
708:           			break;
709:           #endif
710:           
711:           #ifdef	POINTER
712:           		case 'p':
713:           #if	i8086 && LARGE_DATA
714:           			flag |= LONG;
715:           #elif	_PIC18 && LARGE_DATA
716:           			flag |= POINTER;
717:           #endif
718:           #endif	// POINTER
719:           #ifdef	SIXTEEN
720:           #ifdef	HEXUPCASE
721:           		case 'X':
722:           #ifdef	UPCASE
723:           			flag |= UPCASE;
724:           #endif
725:           #endif
726:           #if	defined(HEXLOWCASE) || !defined(UPCASE)
727:           		case 'x':
728:           #endif
729:           #ifdef	MULTRAD
730:           			flag |= SIXTEEN;
731:           #endif
732:           			break;
733:           #endif	// SIXTEEN
734:           
735:           #if	defined(STRING) || defined(PERCPERC)
736:           #ifdef	STRING
737:           		case 's':
738:           #if	i8086 && SMALL_DATA
739:           			if(flag & LONG)
740:           				cp = va_arg(ap, far char *);
741:           			else
742:           #endif
743:           				cp = va_arg(ap, const char *);
744:           #endif	// STRING
745:           #if	!defined(__FLOAT) && !defined(CUSTOM_PRINTF)
746:           strings:
747:           #endif
748:           #ifdef	STRING
749:           			if(!cp)
750:           				cp = "(null)";
751:           #endif
752:           #if	defined(WIDTH) || defined(PRECISION)
753:           #if	defined(STRING)
754:           			len = 0;
755:           			while(cp[len])
756:           				len++;
757:           #endif
758:           #ifdef	PERCPERC
759:           dostring:
760:           #endif
761:           #ifdef	PRECISION
762:           			if(prec && prec < len)
763:           				len = prec;
764:           #endif	// PRECISION
765:           #ifdef	WIDTH
766:           			if(width > len)
0641  0856     MOVF f3, W
0642  0259     SUBWF exp, W
0643  1D03     BTFSS STATUS, 0x2
0644  2E47     GOTO 0x647
0645  0855     MOVF width, W
0646  0258     SUBWF 0x58, W
0647  1803     BTFSC STATUS, 0x0
0648  2E50     GOTO 0x650
767:           				width -= len;
0649  0858     MOVF 0x58, W
064A  02D5     SUBWF width, F
064B  0859     MOVF exp, W
064C  1C03     BTFSS STATUS, 0x0
064D  03D6     DECF f3, F
064E  02D6     SUBWF f3, F
064F  2E52     GOTO 0x652
768:           			else
769:           				width = 0;
0650  01D5     CLRF width
0651  01D6     CLRF f3
770:           #ifdef	LEFT
771:           			if(!(flag & LEFT))
772:           #endif	// LEFT
773:           				while(width--)
0652  30FF     MOVLW 0xFF
0653  07D5     ADDWF width, F
0654  1C03     BTFSS STATUS, 0x0
0655  03D6     DECF f3, F
0656  0A55     INCF width, W
0657  1903     BTFSC STATUS, 0x2
0658  0A56     INCF f3, W
0659  1903     BTFSC STATUS, 0x2
065A  2E6D     GOTO 0x66D
0661  2E52     GOTO 0x652
774:           					pputc(' ');
065B  085B     MOVF sp, W
065C  0084     MOVWF FSR
065D  3020     MOVLW 0x20
065E  1383     BCF STATUS, 0x7
065F  0080     MOVWF INDF
0660  0ADB     INCF sp, F
775:           #endif	// WIDTH
776:           			while(len--)
066D  3001     MOVLW 0x1
066E  02D8     SUBWF 0x58, F
066F  3000     MOVLW 0x0
0670  1C03     BTFSS STATUS, 0x0
0671  03D9     DECF exp, F
0672  02D9     SUBWF exp, F
0673  0A58     INCF 0x58, W
0674  1903     BTFSC STATUS, 0x2
0675  0A59     INCF exp, W
0676  1903     BTFSC STATUS, 0x2
0677  2DCA     GOTO 0x5CA
0678  2E62     GOTO 0x662
777:           				pputc(*cp++);
0662  0857     MOVF _val, W
0663  0084     MOVWF FSR
0664  1383     BCF STATUS, 0x7
0665  0800     MOVF INDF, W
0666  00CF     MOVWF f1
0667  085B     MOVF sp, W
0668  0084     MOVWF FSR
0669  084F     MOVF f1, W
066A  0080     MOVWF INDF
066B  0AD7     INCF _val, F
066C  0ADB     INCF sp, F
778:           #ifdef	LEFT
779:           			if(flag & LEFT)
780:           				while(width--)
781:           					pputc(' ');
782:           #endif	// LEFT
783:           			continue;
784:           #else	// WIDTH || PRECISION
785:           #if	defined(STRING)
786:           			while(*cp)
787:           				pputc(*cp++);
788:           			continue;
789:           #endif
790:           #endif	// WIDTH || PRECISION
791:           #endif	// defined(STRING) || defined(PERCPERC)
792:           #ifdef	CHAR
793:           		case 'c':
794:           #if	_HOSTED
795:           			val = va_arg(ap, int);
796:           			c = val >> 8;
797:           			if(flag & LONG && c && (unsigned char)c != 0xFF) {
798:           				cbuf[0] = c;
799:           				cbuf[1] = val;
800:           				len = 2;
801:           			} else {
802:           				cbuf[0] = val;
803:           				len = 1;
804:           			}
805:           			cp = cbuf;
806:           			goto dostring;
807:           #else
808:           			c = va_arg(ap, int);
809:           #endif	// _HOSTED
810:           #endif	// CHAR
811:           		default:
812:           #ifdef	PERCPERC
813:           #if	defined(WIDTH) || defined(PRECISION)
814:           			cp = (char *)&c;
0679  305A     MOVLW 0x5A
067A  00D7     MOVWF _val
815:           			len = 1;
067B  01D8     CLRF 0x58
067C  0AD8     INCF 0x58, F
067D  01D9     CLRF exp
816:           			goto dostring;
067E  2E41     GOTO 0x641
817:           #else
818:           			pputc(c);
819:           			continue;
820:           #endif
821:           #else	// PERCPERC
822:           			continue;
823:           #endif
824:           
825:           #ifdef	UNSIGN
826:           		case 'u':
827:           			flag |= UNSIGN;
067F  1754     BSF flag, 0x6
828:           			break;
0680  2E9F     GOTO 0x69F
829:           #endif
830:           
831:           		}
832:           #endif	// ANYFORMAT
833:           #ifdef	__FLOAT
834:           		if(flag & (FLOATFORMAT)) {
835:           #ifdef	DEFPREC
836:           			if(flag & DEFPREC)
837:           #endif
838:           				prec = 6;
839:           			fval = va_arg(ap, double);	// source the floating point value
840:           			if(fval < 0.0) {
841:           				fval = -fval;		// get the absolute value
842:           				flag |= NEGSIGN;
843:           			}
844:           			exp = 0;		/* If the number is zero, the exponent is zero. */
845:           			if( fval!=0) {		/* If the number is non-zero, find the exponent. */
846:           				frexp(fval, &exp);		/* get binary exponent */
847:           				exp--;				/* adjust 0.5 -> 1.0 */
848:           				exp *= 3;
849:           				exp /= 10;			/* estimate decimal exponent */
850:           				if(exp < 0)
851:           					exp--;
852:           				// the following line can cause "recursive call" errors because scale calls
853:           				// ftmul, and is used when evaluating an argument to ftmul
854:           				//integ = fval * scale(-exp);
855:           				integ = scale(-exp);		// replaced with this
856:           				integ *= fval;
857:           				if(integ < 1.0)
858:           					exp--;
859:           				else if(integ >= 10.0)
860:           					exp++;
861:           			}
862:           #if	defined(EFMT) || defined(GFMT)
863:           			if(exp <= 0)	// value is 0.??? (neg expnt) whole characters = 1 (allow zero)
864:           				c = 1;
865:           			else
866:           				c = exp;
867:           			if(
868:           #ifdef	EFMT
869:           					flag & EFMT
870:           #ifdef	GFMT
871:           					||
872:           #endif
873:           #endif
874:           #ifdef	GFMT
875:           					flag & GFMT && (exp < -4 || exp >= (int)prec)
876:           #endif
877:           				) {	/* use e format */
878:           #ifdef	GFMT
879:           				if(prec && flag & GFMT)
880:           					prec--;		/* g format precision includes integer digit */
881:           #endif
882:           				if((unsigned)prec > NDDIG - 2)
883:           					c = NDDIG - 2;
884:           				else
885:           					c = prec;
886:           				if( fval!=0) {	/* Normalise only if the number is non-zero. */
887:           					fval /= scale(exp-c);
888:           #if	DOUBLE
889:           					ival = _dto64i(fval);
890:           					if(fval - _64itod(ival) >= 0.5) {
891:           						fval += 0.5;
892:           						ival = _dto64i(fval);
893:           					}
894:           					if(ival >= fdpowers[c+1]) {
895:           						fval *= 1e-1;
896:           						exp++;
897:           					} else if(ival < fdpowers[c]) {
898:           						fval *= 10.0;
899:           						exp--;
900:           					}
901:           #else	
902:           					if(fval - (double)(unsigned long)fval >= 0.5)
903:           						fval += 0.5;
904:           					if((unsigned long)fval >= fdpowers[c+1]) {
905:           						fval *= 1e-1;
906:           						exp++;
907:           					} else if((unsigned long)fval < fdpowers[c]) {
908:           						fval *= 10.0;
909:           						exp--;
910:           					}
911:           #endif
912:           				}
913:           #if defined(GFMT) && defined(ALTERN)
914:           				if(flag & GFMT && !(flag & ALTERN)) {		/* g format, precision means something different */
915:           					if(prec > (int)(NDDIG))
916:           						prec = NDDIG;
917:           #if	DOUBLE
918:           					ival = _dto64i(fval);
919:           					while(ival != 0.0 && _mod64i10(ival) == 0) {
920:           						prec--;
921:           						ival = _div64(ival, fdpowers[1]);
922:           					}
923:           #else
924:           					val = (unsigned long)fval;
925:           					while(val && val % 10 == 0) {
926:           						prec--;
927:           						val /= 10;
928:           					}
929:           #endif
930:           					if(prec < c) {
931:           						fval /= scale(c-prec);
932:           						c = prec;
933:           					}
934:           
935:           				}
936:           #endif
937:           #ifdef	WIDTH
938:           				width -=  prec + 5;
939:           #ifdef	ALTERN
940:           				if(prec || flag & ALTERN)
941:           					width--;
942:           #endif
943:           				if(flag & NEGSIGN)
944:           					width--;
945:           #if	DBL_MAX_10_EXP >= 100
946:           #if	DBL_MAX_10_EXP >= 1000
947:           				if(exp >= 1000 || exp <= -1000)	/* 4 digit exponent */
948:           					width--;
949:           #endif
950:           				if(exp >= 100 || exp <= -100)	/* 3 digit exponent */
951:           					width--;
952:           #endif
953:           #endif	// WIDTH
954:           #ifdef	FILL
955:           				if(flag & FILL) {
956:           #if defined(MANSIGN) && defined(SPCSIGN)
957:           					if(flag & MANSIGN)
958:           						pputc(flag & SPCSIGN ? '-' : '+');
959:           					else if(flag & SPCSIGN)
960:           						pputc(' ');
961:           #endif
962:           					while(width > 0) {
963:           						pputc('0');
964:           						width--;
965:           					}
966:           				} else
967:           #endif	// FILL
968:           				{
969:           #ifdef	WIDTH
970:           #ifdef	LEFT
971:           					if(!(flag & LEFT))
972:           #endif
973:           						while(width > 0) {
974:           							pputc(' ');
975:           							width--;
976:           						}
977:           #endif	// WIDTH
978:           #ifdef	MANSIGN
979:           					if(flag & MANSIGN)
980:           						putsign();
981:           #else
982:           					if(flag & NEGSIGN)
983:           						pputc('-');
984:           #endif	// MANSIGN
985:           #ifdef	SPCSIGN
986:           					else if(flag & SPCSIGN)
987:           						pputc(' ');
988:           #endif	// SPCSIGN
989:           				}
990:           #if	DOUBLE
991:           				ival = _dto64i(fval);
992:           				pputc(_div64ir(ival, fdpowers[c]) + '0');
993:           #else
994:           				val = (unsigned long)fval;
995:           				pputc(val/dpowers[c] + '0');
996:           				val %= dpowers[c];
997:           #endif
998:           #ifdef	ALTERN
999:           				if(prec || flag & ALTERN)
1000:          #else
1001:          				if(prec)
1002:          #endif
1003:          				{
1004:          					pputc('.');
1005:          					prec -= c;
1006:          					while(c--) {
1007:          #if	DOUBLE
1008:          						pputc('0' + _mod64i10(_div64(ival, fdpowers[c])));
1009:          #else
1010:          #ifdef	GFMT
1011:          						if(flag & GFMT && val == 0) {
1012:          							prec = c = 0;
1013:          							break;
1014:          						}
1015:          #endif
1016:          						pputc('0' + (val/dpowers[c]));
1017:          						val %= dpowers[c];
1018:          #endif
1019:          					}
1020:          					while(prec) {
1021:          						pputc('0');
1022:          						prec--;
1023:          					}
1024:          				}
1025:          #ifdef	UPCASE
1026:          				if(flag & UPCASE)
1027:          					pputc('E');
1028:          				else
1029:          #endif
1030:          					pputc('e');
1031:          				if(exp < 0) {
1032:          					exp = -exp;
1033:          					pputc('-');
1034:          				} else
1035:          					pputc('+');
1036:          #if	DBL_MAX_10_EXP >= 100
1037:          #if	DBL_MAX_10_EXP >= 1000
1038:          				if(exp >= 1000) {
1039:          					pputc(exp / 1000 + '0');
1040:          					exp %= 1000;
1041:          				}
1042:          #endif
1043:          				if(exp >= 100) {
1044:          					pputc(exp / 100 + '0');
1045:          					exp %= 100;
1046:          				}
1047:          #endif
1048:          				pputc(exp / 10 + '0');
1049:          				pputc(exp % 10 + '0');
1050:          #ifdef	LEFT
1051:          				if((flag & LEFT) && width > 0)
1052:          					do
1053:          						pputc(' ');
1054:          					while(--width);
1055:          #endif	// LEFT
1056:          					continue;
1057:          				}
1058:          #endif	// EFMT || GFMT
1059:          				/* here for f format */
1060:          #if	DOUBLE
1061:          #ifdef	GFMT
1062:          				if(flag & GFMT) {
1063:          					if(exp < 0)	// fractional part only
1064:          						prec -= exp-1;
1065:          					ival = _dto64i(fval);
1066:          					for(c = 1 ; c != NDDIG ; c++)
1067:          						if(ival < fdpowers[c])
1068:          							break;
1069:          					if(prec > NDDIG)
1070:          						prec = NDDIG;
1071:          					prec -= c;
1072:          					ival = _dto64i((fval - _64itod(ival)) * scale(prec)+0.5);
1073:          					// see how many zeros are at the end of the fractional part
1074:          					while(prec && _mod64i10(ival) == 0) {
1075:          						prec--;
1076:          						ival = _div64(ival, fdpowers[1]);
1077:          					}
1078:          				}
1079:          #endif	// GFMT
1080:          				if(prec <= (int)NDDIG)
1081:          					fval += fround(prec);
1082:          				if(exp > (int)(NDDIG)-2) {
1083:          					exp -= NDDIG-2;
1084:          					ival = _divto64i(fval, scale(exp));
1085:          					fval = 0.0;
1086:          				} else {
1087:          					ival = _dto64i(fval);
1088:          					fval -= _64itod(ival);
1089:          					exp = 0;
1090:          				}
1091:          				for(c = 1 ; c != NDDIG ; c++)
1092:          					if(ival < fdpowers[c])
1093:          						break;
1094:          #else	// DOUBLE
1095:          #ifdef	GFMT
1096:          				if(flag & GFMT) {
1097:          					if(exp < 0)	// fractional part only
1098:          						prec -= (exp+1);
1099:          					// count number of digits in the integral part (this is for %g)
1100:          					val = (unsigned long)fval;
1101:          					for(c = 0 ; c != NDDIG ; c++)
1102:          						if(val < fdpowers[c])
1103:          							break;
1104:          					prec -= c;		// reduce precision by this
1105:          					if(prec <= NDIG)
1106:          						fval += fround(prec);
1107:          					// get fractional part and count trailing zeros - reduce
1108:          					// prec as required
1109:          					{
1110:          						double	temp;
1111:          						temp = scale(prec);
1112:          						temp *= fval - (double)val;
1113:          						val = (unsigned long)temp;
1114:          					}
1115:          					while(prec && val % 10 == 0) {
1116:          						val /= 10;
1117:          						prec--;
1118:          					}
1119:          				} else
1120:          #endif	//GFMT
1121:          					if(prec <= NDIG)
1122:          						fval += fround(prec);
1123:          
1124:          				/* ~4.2e9 is the largest float that will fit into a 32-bit long */
1125:          				if((exp > 9)||(fval != 0 && (unsigned long)fval == 0 && exp > 1)) {
1126:          					// fval is > 4.2e9
1127:          					// new exp must be such that div_to_l() is < 4.2e9
1128:          					// OLD CODE:	if(fval / scale(exp) < 4.294967296){
1129:          					if(integ < 4.294967296){
1130:          						exp -= NDDIG-1;
1131:          					}else{
1132:          						exp -= NDDIG-2;
1133:          					}
1134:          					integ = scale(exp);
1135:          					val = div_to_l_(fval, integ);
1136:           					//val = _div_to_l_(integ, fval);
1137:          					//val = (long)(integ * fval);	// fit as much signifigant data into the long as it can hold
1138:          					fval = 0.0;	// There will be no fractional component
1139:          				} else {
1140:          					val = (unsigned long)fval;
1141:          					fval -= (double)val;
1142:          					exp = 0;
1143:          				}
1144:          				// count digits in integral part
1145:          				for(c = 1 ; c != NDDIG ; c++)
1146:          					if(val < fdpowers[c])
1147:          						break;
1148:          #endif	// DOUBLE
1149:          #ifdef	WIDTH
1150:          				// at this point, c contains the number of whole-number digits to print
1151:          				width -= prec + c + exp;
1152:          				if(
1153:          #ifdef	ALTERN
1154:          						flag & ALTERN ||
1155:          #endif
1156:          						prec)
1157:          					width--;		// allow for decimal point
1158:          				if(flag & NEGSIGN)
1159:          					width--;
1160:          #endif	// WIDTH
1161:          #ifdef	FILL
1162:          				if(flag & FILL) {
1163:          #ifdef	MANSIGN
1164:          					if(flag & MANSIGN)
1165:          #else
1166:          					if(flag & NEGSIGN)
1167:          #endif	// MANSIGN
1168:          						putsign();
1169:          #if defined(MANSIGN) && defined(SPCSIGN)
1170:          					else
1171:          #endif
1172:          #ifdef	SPCSIGN
1173:          					if(flag & SPCSIGN)
1174:          						pputc(' ');
1175:          #endif	// SPCSIGN
1176:          #ifdef	WIDTH
1177:          					while(width > 0) {
1178:          						pputc('0');
1179:          						width--;
1180:          					}
1181:          #endif	// WIDTH
1182:          				} else
1183:          #endif	// FILL
1184:          				{
1185:          #ifdef	LEFT
1186:          					if(!(flag & LEFT))
1187:          #endif
1188:          #ifdef	WIDTH
1189:          					while(width > 0) {
1190:          						pputc(' ');
1191:          						width--;
1192:          					}
1193:          #endif	// WIDTH
1194:          #ifdef	MANSIGN
1195:          				if(flag & MANSIGN)
1196:          #else
1197:          				if(flag & NEGSIGN)
1198:          #endif	// MANSIGN
1199:          					putsign();
1200:          #ifdef	SPCSIGN
1201:          				else if(flag & SPCSIGN)
1202:          					pputc(' ');
1203:          #endif	// SPCSIGN
1204:          			}
1205:          			while(c--) {
1206:          #if	DOUBLE
1207:          				pputc('0' + _mod64i10(_div64(ival, fdpowers[c])));
1208:          #else
1209:          				{
1210:          					unsigned long vd = val/dpowers[c];
1211:          					vd %= 10;
1212:          					pputc('0' + vd);
1213:          				}
1214:          #endif	// DOUBLE
1215:          			}
1216:          			while(exp > 0) {
1217:          				pputc('0');
1218:          				exp--;
1219:          			}
1220:          			if(prec > (int)(NDDIG-2))
1221:          				c = NDDIG-2;
1222:          			else
1223:          				c = prec;
1224:          			prec -= c;
1225:          #ifdef	ALTERN
1226:          			if(c || flag & ALTERN)
1227:          #else
1228:          			if(c)
1229:          #endif
1230:          				pputc('.');
1231:          #if	DOUBLE
1232:          			ival = _dto64i(fval * scale(c));
1233:          			while(c)
1234:          				pputc('0' + _mod64i10(_div64(ival, fdpowers[--c])));
1235:          #else	// DOUBLE
1236:          			val = (long)(fval * scale(c));
1237:          			while(c--) {
1238:          				unsigned long vd = val/dpowers[c];
1239:          				vd %= 10;
1240:          				pputc('0' + vd);
1241:          				val %= dpowers[c];
1242:          			}
1243:          #endif	// DOUBLE
1244:          			while(prec) {
1245:          				pputc('0');
1246:          				prec--;
1247:          			}
1248:          #ifdef	LEFT
1249:          			if((flag & LEFT) && width > 0)
1250:          				do
1251:          					pputc(' ');
1252:          				while(--width);
1253:          #endif
1254:          			continue;
1255:          		}
1256:          #endif	/* __FLOAT */
1257:          
1258:          #if	defined(TEN)
1259:          #ifdef	BASEM
1260:          		if((flag & BASEM) == TEN)
069F  1B54     BTFSC flag, 0x6
06A0  2EB5     GOTO 0x6B5
1261:          #endif	//BASEM
1262:          		{
1263:          #ifdef	LONG
1264:          			if(flag & LONG)
1265:          				val = va_arg(ap, long);
1266:          			else
1267:          #endif	// LONG
1268:          				val = (value)va_arg(ap, int);
06A1  0853     MOVF ap, W
06A2  0084     MOVWF FSR
06A3  1383     BCF STATUS, 0x7
06A4  0800     MOVF INDF, W
06A5  00D7     MOVWF _val
06A6  0A84     INCF FSR, F
06A7  0800     MOVF INDF, W
06A8  00D8     MOVWF 0x58
06A9  0AD3     INCF ap, F
06AA  0AD3     INCF ap, F
1269:          #ifdef	NEGSIGN
1270:          			if((value)val < 0) {
06AB  1FD8     BTFSS 0x58, 0x7
06AC  2EBF     GOTO 0x6BF
1271:          				flag |= NEGSIGN;
06AD  3003     MOVLW 0x3
06AE  04D4     IORWF flag, F
1272:          				val = -val;
06AF  09D7     COMF _val, F
06B0  09D8     COMF 0x58, F
06B1  0AD7     INCF _val, F
06B2  1903     BTFSC STATUS, 0x2
06B3  0AD8     INCF 0x58, F
06B4  2EBF     GOTO 0x6BF
1273:          			}
1274:          #endif
1275:          		}
1276:          #ifdef	BASEM
1277:          		else
1278:          #endif
1279:          #endif	// TEN
1280:          
1281:          #if	defined(EIGHT) || defined(SIXTEEN) || defined(UNSIGN)
1282:          		{
1283:          #ifdef	__LONG
1284:          #if	defined(_PIC18) && defined(LARGE_DATA) && defined(POINTER)
1285:          			if(flag & POINTER)
1286:          				val = (unsigned long)va_arg(ap, far char *);
1287:          			else
1288:          #endif
1289:          #ifdef	LONG
1290:          				if(flag & LONG)
1291:          				val = va_arg(ap, unsigned long);
1292:          			else
1293:          #endif	// LONG
1294:          #endif	// __LONG
1295:          				val = va_arg(ap, unsigned);
06B5  0853     MOVF ap, W
06B6  0084     MOVWF FSR
06B7  1383     BCF STATUS, 0x7
06B8  0800     MOVF INDF, W
06B9  00D7     MOVWF _val
06BA  0A84     INCF FSR, F
06BB  0800     MOVF INDF, W
06BC  00D8     MOVWF 0x58
06BD  0AD3     INCF ap, F
06BE  0AD3     INCF ap, F
1296:          		}
1297:          #endif	// EIGHT or SIXTEEN or UNSIGN
1298:          #ifdef	PRECISION
1299:          		if(prec == 0 && val == 0)
1300:          			prec++;
1301:          #endif
1302:          #ifdef	MULTRAD
1303:          		switch((unsigned char)(flag & BASEM)) {
1304:          #endif
1305:          #if	defined(TEN) || defined(UNSIGN)
1306:          #ifdef	MULTRAD
1307:          #ifdef	TEN
1308:          		case TEN:
1309:          #endif
1310:          #ifdef	UNSIGN
1311:          		case UNSIGN:
1312:          #endif
1313:          #endif	// MULTRAD
1314:          			for(c = 1 ; c != sizeof dpowers/sizeof dpowers[0] ; c++)
06BF  01DA     CLRF c
06C0  0ADA     INCF c, F
06C1  085A     MOVF c, W
06C2  3A05     XORLW 0x5
06C3  1903     BTFSC STATUS, 0x2
06C4  2EE0     GOTO 0x6E0
1315:          				if(val < dpowers[c])
06C5  1003     BCF STATUS, 0x0
06C6  0D5A     RLF c, W
06C7  3E12     ADDLW 0x12
06C8  0084     MOVWF FSR
06C9  3098     MOVLW 0x98
06CA  1803     BTFSC STATUS, 0x0
06CB  3E01     ADDLW 0x1
06CC  00FF     MOVWF 0x7F
06CD  160A     BSF PCLATH, 0x4
06CE  158A     BSF PCLATH, 0x3
06CF  2000     CALL 0x0
06D0  120A     BCF PCLATH, 0x4
06D1  118A     BCF PCLATH, 0x3
06D2  00CF     MOVWF f1
06D3  160A     BSF PCLATH, 0x4
06D4  158A     BSF PCLATH, 0x3
06D5  2000     CALL 0x0
06D6  120A     BCF PCLATH, 0x4
06D7  118A     BCF PCLATH, 0x3
06D8  00D0     MOVWF 0x50
06D9  0258     SUBWF 0x58, W
06DA  1D03     BTFSS STATUS, 0x2
06DB  2EDE     GOTO 0x6DE
06DC  084F     MOVF f1, W
06DD  0257     SUBWF _val, W
06DE  1803     BTFSC STATUS, 0x0
06DF  2EC0     GOTO 0x6C0
1316:          					break;
1317:          #ifdef	MULTRAD
1318:          			break;
1319:          #endif
1320:          #endif	// TEN || UNSIGN
1321:          #ifdef	SIXTEEN
1322:          #ifdef	MULTRAD
1323:          		case SIXTEEN:
1324:          #endif	// MULTRAD
1325:          			for(c = 1 ; c != sizeof hexpowers/sizeof hexpowers[0] ; c++)
1326:          				if(val < hexpowers[c])
1327:          					break;
1328:          #ifdef	MULTRAD
1329:          			break;
1330:          #endif
1331:          #endif
1332:          
1333:          #ifdef	EIGHT
1334:          #ifdef	MULTRAD
1335:          		case EIGHT:
1336:          #endif	// MULTRAD
1337:          			for(c = 1 ; c != sizeof octpowers/sizeof octpowers[0] ; c++)
1338:          				if(val < octpowers[c])
1339:          					break;
1340:          #ifdef	MULTRAD
1341:          			break;
1342:          #endif
1343:          #endif
1344:          #ifdef	MULTRAD
1345:          		}
1346:          #endif
1347:          #ifdef	PRECISION
1348:          		if(c < prec)
1349:          			c = prec;
1350:          		else if(prec < c)
1351:          			prec = c;
1352:          #endif
1353:          #if	defined(WIDTH) && defined(NEGSIGN)
1354:          		if(width && flag & NEGSIGN)
06E0  0856     MOVF f3, W
06E1  0455     IORWF width, W
06E2  1903     BTFSC STATUS, 0x2
06E3  2EEC     GOTO 0x6EC
06E4  0854     MOVF flag, W
06E5  3903     ANDLW 0x3
06E6  1903     BTFSC STATUS, 0x2
06E7  2EEC     GOTO 0x6EC
1355:          			width--;
06E8  30FF     MOVLW 0xFF
06E9  07D5     ADDWF width, F
06EA  1C03     BTFSS STATUS, 0x0
06EB  03D6     DECF f3, F
1356:          #ifdef	PRECISION
1357:          		if(flag & PRECISION) {
1358:          			if(width > prec)
1359:          				width -= prec;
1360:          			else
1361:          				width = 0;
1362:          		}
1363:          #endif
1364:          #ifdef	ALTERN
1365:          #ifdef	EIGHT
1366:          		if((flag & (
1367:          #ifdef	FILL
1368:          						FILL|
1369:          #endif
1370:          							BASEM|ALTERN)) == (EIGHT|ALTERN)) {
1371:          			if(width)
1372:          				width--;
1373:          		} else
1374:          #endif	// EIGHT
1375:          #if	defined(SIXTEEN)
1376:          #ifdef	BASEM
1377:          		if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1378:          #else
1379:          		if(flag & ALTERN) {
1380:          #endif
1381:          			if(width > 2)
1382:          				width -= 2;
1383:          			else
1384:          				width = 0;
1385:          		}
1386:          #endif	// SIXTEEN
1387:          #endif	// ALTERN
1388:          #endif	// WIDTH
1389:          #ifdef	WIDTH
1390:          		if(width > c)
06EC  085A     MOVF c, W
06ED  00CF     MOVWF f1
06EE  01D0     CLRF 0x50
06EF  1BCF     BTFSC f1, 0x7
06F0  03D0     DECF 0x50, F
06F1  0850     MOVF 0x50, W
06F2  3A80     XORLW 0x80
06F3  00D1     MOVWF 0x51
06F4  0856     MOVF f3, W
06F5  3A80     XORLW 0x80
06F6  0251     SUBWF 0x51, W
06F7  1D03     BTFSS STATUS, 0x2
06F8  2EFB     GOTO 0x6FB
06F9  0855     MOVF width, W
06FA  024F     SUBWF f1, W
06FB  1803     BTFSC STATUS, 0x0
06FC  2F0A     GOTO 0x70A
1391:          			width -= c;
06FD  1283     BCF STATUS, 0x5
06FE  1303     BCF STATUS, 0x6
06FF  085A     MOVF c, W
0700  00CF     MOVWF f1
0701  01D0     CLRF 0x50
0702  1BCF     BTFSC f1, 0x7
0703  03D0     DECF 0x50, F
0704  02D5     SUBWF width, F
0705  0850     MOVF 0x50, W
0706  1C03     BTFSS STATUS, 0x0
0707  03D6     DECF f3, F
0708  02D6     SUBWF f3, F
0709  2F0E     GOTO 0x70E
1392:          		else
1393:          			width = 0;
070A  1283     BCF STATUS, 0x5
070B  1303     BCF STATUS, 0x6
070C  01D5     CLRF width
070D  01D6     CLRF f3
1394:          #endif
1395:          #ifdef	FILL
1396:          		if(flag & FILL) {
070E  1D54     BTFSS flag, 0x2
070F  2F29     GOTO 0x729
1397:          #ifdef	MANSIGN
1398:          			if(flag & MANSIGN)
1399:          				putsign();
1400:          #elif defined(NEGSIGN)
1401:          			if(flag & NEGSIGN)
0710  0854     MOVF flag, W
0711  3903     ANDLW 0x3
0712  1903     BTFSC STATUS, 0x2
0713  2F1A     GOTO 0x71A
1402:          				pputc('-');
0714  085B     MOVF sp, W
0715  0084     MOVWF FSR
0716  302D     MOVLW 0x2D
0717  1383     BCF STATUS, 0x7
0718  0080     MOVWF INDF
0719  0ADB     INCF sp, F
1403:          #endif
1404:          #if defined(MANSIGN) || defined(NEGSIGN) && defined(SPCSIGN)
1405:          			else
1406:          #endif	// MANSIGN
1407:          #ifdef	SPCSIGN
1408:          			if(flag & SPCSIGN)
1409:          				pputc(' ');
1410:          #endif
1411:          #if defined(ALTERN) && defined(SIXTEEN)
1412:          			else if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1413:          				pputc('0');
1414:          #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
1415:          				pputc(flag & UPCASE ? 'X' : 'x');
1416:          #elif defined(HEXUPCASE)
1417:          				pputc('X');
1418:          #else
1419:          				pputc('x');
1420:          #endif	// HEXUPCASE
1421:          			}
1422:          #endif	// ALTERN
1423:          #ifdef	WIDTH
1424:          			if(width)
071A  0856     MOVF f3, W
071B  0455     IORWF width, W
071C  1903     BTFSC STATUS, 0x2
071D  2F45     GOTO 0x745
1425:          				do
1426:          					pputc('0');
071E  085B     MOVF sp, W
071F  0084     MOVWF FSR
0720  3030     MOVLW 0x30
0721  1383     BCF STATUS, 0x7
0722  0080     MOVWF INDF
0724  0ADB     INCF sp, F
1427:          				while(--width);
0723  30FF     MOVLW 0xFF
0725  07D5     ADDWF width, F
0726  1C03     BTFSS STATUS, 0x0
0727  03D6     DECF f3, F
0728  2F1A     GOTO 0x71A
1428:          #endif	// WIDTH
1429:          		} else
1430:          #endif	//FILL
1431:          		{
1432:          #ifdef	WIDTH
1433:          			if(width
1434:          #ifdef	LEFT
1435:          					&& !(flag & LEFT)
1436:          #endif
1437:          					)
0729  0856     MOVF f3, W
072A  0455     IORWF width, W
072B  1903     BTFSC STATUS, 0x2
072C  2F3B     GOTO 0x73B
1438:          				do
1439:          					pputc(' ');
072D  085B     MOVF sp, W
072E  0084     MOVWF FSR
072F  3020     MOVLW 0x20
0730  1383     BCF STATUS, 0x7
0731  0080     MOVWF INDF
0733  0ADB     INCF sp, F
1440:          				while(--width);
0732  30FF     MOVLW 0xFF
0734  07D5     ADDWF width, F
0735  1C03     BTFSS STATUS, 0x0
0736  03D6     DECF f3, F
0737  0856     MOVF f3, W
0738  0455     IORWF width, W
0739  1D03     BTFSS STATUS, 0x2
073A  2F2D     GOTO 0x72D
1441:          #endif	// WIDTH
1442:          #ifdef	MANSIGN
1443:          			if(flag & MANSIGN)
1444:          				putsign();
1445:          #else
1446:          #ifdef	NEGSIGN
1447:          			if(flag & NEGSIGN)
073B  0854     MOVF flag, W
073C  3903     ANDLW 0x3
073D  1903     BTFSC STATUS, 0x2
073E  2F45     GOTO 0x745
1448:          				pputc('-');
073F  085B     MOVF sp, W
0740  0084     MOVWF FSR
0741  302D     MOVLW 0x2D
0742  1383     BCF STATUS, 0x7
0743  0080     MOVWF INDF
0744  0ADB     INCF sp, F
1449:          #endif
1450:          #endif	// MANSIGN
1451:          #ifdef	SPCSIGN
1452:          			else if(flag & SPCSIGN)
1453:          				pputc(' ');
1454:          #endif
1455:          #ifdef	ALTERN
1456:          #ifdef	EIGHT
1457:          			if((flag & (BASEM|ALTERN)) == (EIGHT|ALTERN))
1458:          				pputc('0');
1459:          			else
1460:          #endif	// EIGHT
1461:          #ifdef	SIXTEEN
1462:          #ifdef	BASEM
1463:          			if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1464:          #else
1465:          			if(flag & ALTERN) {
1466:          #endif
1467:          				pputc('0');
1468:          #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
1469:          				pputc(flag & UPCASE ? 'X' : 'x');
1470:          #elif defined(HEXUPCASE)
1471:          				pputc('X');
1472:          #else
1473:          				pputc('x');
1474:          #endif
1475:          			}
1476:          #endif	// SIXTEEN
1477:          #endif	// ALTERN
1478:          		}
1479:          #if	defined(SIXTEEN) || defined(TEN) || defined(EIGHT) || defined(UNSIGN)
1480:          #ifndef	PRECISION
1481:          		prec = c;
0745  085A     MOVF c, W
0746  00D2     MOVWF prec
1482:          #endif
1483:          		while(prec--) {
0747  2F76     GOTO 0x776
0776  03D2     DECF prec, F
0777  0F52     INCFSZ prec, W
0778  2F48     GOTO 0x748
1484:          #ifdef	MULTRAD
1485:          			switch((unsigned char)(flag & BASEM))
1486:          #endif
1487:          			{
1488:          
1489:          #if	defined(TEN) || defined(UNSIGN)
1490:          #ifdef	MULTRAD
1491:          #ifdef	TEN
1492:          		case TEN:
1493:          #endif
1494:          #ifdef	UNSIGN
1495:          		case UNSIGN:
1496:          #endif
1497:          #endif	// MULTRAD
1498:          				c = (val / dpowers[prec]) % 10 + '0';
0748  300A     MOVLW 0xA
0749  00AA     MOVWF Data
074A  01AB     CLRF sec
074B  1003     BCF STATUS, 0x0
074C  0D52     RLF prec, W
074D  3E12     ADDLW 0x12
074E  0084     MOVWF FSR
074F  3098     MOVLW 0x98
0750  1803     BTFSC STATUS, 0x0
0751  3E01     ADDLW 0x1
0752  00FF     MOVWF 0x7F
0753  160A     BSF PCLATH, 0x4
0754  158A     BSF PCLATH, 0x3
0755  2000     CALL 0x0
0756  120A     BCF PCLATH, 0x4
0757  118A     BCF PCLATH, 0x3
0758  00A3     MOVWF x
0759  160A     BSF PCLATH, 0x4
075A  158A     BSF PCLATH, 0x3
075B  2000     CALL 0x0
075C  120A     BCF PCLATH, 0x4
075D  118A     BCF PCLATH, 0x3
075E  00A4     MOVWF dato
075F  0858     MOVF 0x58, W
0760  00A6     MOVWF x
0761  0857     MOVF _val, W
0762  00A5     MOVWF y
0763  27A6     CALL 0x7A6
0764  120A     BCF PCLATH, 0x4
0765  118A     BCF PCLATH, 0x3
0766  0824     MOVF dato, W
0767  00AD     MOVWF day
0768  0823     MOVF x, W
0769  00AC     MOVWF hr
076A  27D0     CALL 0x7D0
076B  120A     BCF PCLATH, 0x4
076C  118A     BCF PCLATH, 0x3
076D  082A     MOVF Data, W
076E  3E30     ADDLW 0x30
076F  00DA     MOVWF c
1499:          #ifdef	MULTRAD
1500:          				break;
1501:          #endif
1502:          #endif	// TEN || UNSIGN
1503:          
1504:          #ifdef	SIXTEEN
1505:          #ifdef	MULTRAD
1506:          			case SIXTEEN:
1507:          #endif
1508:          			{
1509:          				unsigned char idx = (val / hexpowers[prec]) & 0xF;
1510:          #if	defined(HEXLOWCASE) && defined(HEXUPCASE)
1511:          				c = (flag & UPCASE ? "0123456789ABCDEF" : "0123456789abcdef")[idx];
1512:          #elif	defined(HEXUPCASE)
1513:          				c = "0123456789ABCDEF"[idx];
1514:          #else
1515:          				c = "0123456789abcdef"[idx];
1516:          #endif	//HEXCASE
1517:          			}
1518:          #ifdef	MULTRAD
1519:          				break;
1520:          #endif
1521:          #endif
1522:          
1523:          #ifdef	EIGHT
1524:          #ifdef	MULTRAD
1525:          			case EIGHT:
1526:          #endif	// MULTRAD
1527:          				c = ((val / octpowers[prec]) & 07) + '0';
1528:          #ifdef	MULTRAD
1529:          				break;
1530:          #endif	// MULTRAD
1531:          #endif	// EIGHT
1532:          			}
1533:          			pputc(c);
0770  085B     MOVF sp, W
0771  0084     MOVWF FSR
0772  085A     MOVF c, W
0773  1383     BCF STATUS, 0x7
0774  0080     MOVWF INDF
0775  0ADB     INCF sp, F
1534:          		}
1535:          #endif	// 16 or 10 or 8
1536:          #ifdef	LEFT
1537:          		if((flag & LEFT) && width > 0)
1538:          			do
1539:          				pputc(' ');
1540:          			while(--width);
1541:          #endif	// LEFT
1542:          	}
1543:          #ifdef	ANYFORMAT
1544:          alldone:
1545:          #endif	// ANYFORMAT
1546:          #if	!defined(PRINTF) && (defined(SPRINTF) || defined(VSPRINTF))
1547:          	*sp = 0;
077A  085B     MOVF sp, W
077B  0084     MOVWF FSR
077C  1383     BCF STATUS, 0x7
077D  0180     CLRF INDF
1548:          #endif
1549:          	return ccnt;
1550:          }
077E  0008     RETURN
1551:          
---  /opt/microchip/xc8/v1.31/sources/common/bmul.c  ----------------------------------------------------
1:             // 8 x 8 bit multiplication with 8 bit result
2:             
3:             unsigned char
4:             __bmul(unsigned char multiplier, unsigned char multiplicand)
0BBA  00A5     MOVWF y
5:             {
6:             	unsigned char product;
7:             
8:             	product = 0;
0BBB  01A4     CLRF dato
9:             	do {
10:            		if(multiplier & 1)
0BBC  0823     MOVF x, W
0BBD  1825     BTFSC y, 0x0
11:            			product += multiplicand;
0BBC  0823     MOVF x, W
0BBE  07A4     ADDWF dato, F
12:            		multiplicand <<= 1;
0BBF  1003     BCF STATUS, 0x0
0BC0  0DA3     RLF x, F
13:            		multiplier >>= 1;
0BC1  1003     BCF STATUS, 0x0
0BC2  0CA5     RRF y, F
14:            	} while(multiplier != 0);
0BC3  08A5     MOVF y, F
0BC4  1D03     BTFSS STATUS, 0x2
0BC5  2BBC     GOTO 0x3BC
15:            	return product;
0BC6  0824     MOVF dato, W
16:            }
0BC7  0008     RETURN
17:            
---  /opt/microchip/xc8/v1.31/sources/common/awmod.c  ---------------------------------------------------
1:             // integer signed unsigned modulus
2:             
3:             signed int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __awmod(signed int divisor, signed int dividend)
0BC8  01B6     CLRF sign
1459  01F5     CLRF Pin
7:             #else
8:             __awmod(signed int dividend, signed int divisor)
9:             #endif
10:            {
11:            	unsigned char	counter, sign;
12:            
13:            	sign = 0;
0BC8  01B6     CLRF sign
1459  01F5     CLRF Pin
14:            	if(dividend < 0) {
0BC9  1FB4     BTFSS sign, 0x7
0BCA  2BD2     GOTO 0x3D2
145A  1FF3     BTFSS counter, 0x7
145B  2C63     GOTO 0x463
15:            		dividend = -dividend;
0BCB  09B3     COMF dividend, F
0BCC  09B4     COMF sign, F
0BCD  0AB3     INCF dividend, F
0BCE  1903     BTFSC STATUS, 0x2
0BCF  0AB4     INCF sign, F
145C  09F2     COMF dividend, F
145D  09F3     COMF counter, F
145E  0AF2     INCF dividend, F
145F  1903     BTFSC STATUS, 0x2
1460  0AF3     INCF counter, F
16:            		sign = 1;
0BD0  01B6     CLRF sign
0BD1  0AB6     INCF sign, F
1461  01F5     CLRF Pin
1462  0AF5     INCF Pin, F
17:            	}
18:            	if(divisor < 0)
0BD2  1FB2     BTFSS 0x32, 0x7
0BD3  2BD9     GOTO 0x3D9
1463  1FF1     BTFSS canal, 0x7
1464  2C6A     GOTO 0x46A
19:            		divisor = -divisor;
0BD4  09B1     COMF divisor, F
0BD5  09B2     COMF 0x32, F
0BD6  0AB1     INCF divisor, F
0BD7  1903     BTFSC STATUS, 0x2
0BD8  0AB2     INCF 0x32, F
1465  09F0     COMF divisor, F
1466  09F1     COMF canal, F
1467  0AF0     INCF divisor, F
1468  1903     BTFSC STATUS, 0x2
1469  0AF1     INCF canal, F
20:            	if(divisor != 0) {
0BD9  0832     MOVF 0x32, W
0BDA  0431     IORWF divisor, W
0BDB  1903     BTFSC STATUS, 0x2
0BDC  2BF8     GOTO 0x3F8
146A  0871     MOVF canal, W
146B  0470     IORWF divisor, W
146C  1903     BTFSC STATUS, 0x2
146D  2C89     GOTO 0x489
21:            		counter = 1;
0BDD  01B5     CLRF counter
146E  01F4     CLRF counter
22:            		while(((unsigned int)divisor & 0x8000U) == 0) {
0BDF  1BB2     BTFSC 0x32, 0x7
0BE0  2BE5     GOTO 0x3E5
0BE4  2BDE     GOTO 0x3DE
1470  1BF1     BTFSC canal, 0x7
1471  2C76     GOTO 0x476
1475  2C6F     GOTO 0x46F
23:            			divisor <<= 1;
0BDE  0AB5     INCF counter, F
0BE1  1003     BCF STATUS, 0x0
0BE2  0DB1     RLF divisor, F
0BE3  0DB2     RLF 0x32, F
146F  0AF4     INCF counter, F
1472  1003     BCF STATUS, 0x0
1473  0DF0     RLF divisor, F
1474  0DF1     RLF canal, F
24:            			counter++;
0BDE  0AB5     INCF counter, F
146F  0AF4     INCF counter, F
25:            		}
26:            		do {
27:            			if((unsigned int)divisor <= (unsigned int)dividend)
0BE5  0832     MOVF 0x32, W
0BE6  0234     SUBWF sign, W
0BE7  1D03     BTFSS STATUS, 0x2
0BE8  2BEB     GOTO 0x3EB
0BE9  0831     MOVF divisor, W
0BEA  0233     SUBWF dividend, W
0BEB  1C03     BTFSS STATUS, 0x0
0BEC  2BF4     GOTO 0x3F4
1476  0871     MOVF canal, W
1477  0273     SUBWF counter, W
1478  1D03     BTFSS STATUS, 0x2
1479  2C7C     GOTO 0x47C
147A  0870     MOVF divisor, W
147B  0272     SUBWF dividend, W
147C  1C03     BTFSS STATUS, 0x0
147D  2C85     GOTO 0x485
28:            				dividend -= divisor;
0BED  0831     MOVF divisor, W
0BEE  02B3     SUBWF dividend, F
0BEF  0832     MOVF 0x32, W
0BF0  1C03     BTFSS STATUS, 0x0
0BF1  03B4     DECF sign, F
0BF2  02B4     SUBWF sign, F
147E  0870     MOVF divisor, W
147F  02F2     SUBWF dividend, F
1480  0871     MOVF canal, W
1481  1C03     BTFSS STATUS, 0x0
1482  03F3     DECF counter, F
1483  02F3     SUBWF counter, F
29:            			*(unsigned int *)&divisor >>= 1;
0BF3  1003     BCF STATUS, 0x0
0BF4  0CB2     RRF 0x32, F
0BF5  0CB1     RRF divisor, F
1484  1003     BCF STATUS, 0x0
1485  0CF1     RRF canal, F
1486  0CF0     RRF divisor, F
30:            		} while(--counter != 0);
0BF6  0BB5     DECFSZ counter, F
0BF7  2BE5     GOTO 0x3E5
1487  0BF4     DECFSZ counter, F
1488  2C76     GOTO 0x476
31:            	}
32:            	if(sign)
0BF8  0836     MOVF sign, W
0BF9  1903     BTFSC STATUS, 0x2
0BFA  2C00     GOTO 0x400
1489  0875     MOVF Pin, W
148A  1903     BTFSC STATUS, 0x2
148B  2C91     GOTO 0x491
33:            		dividend = -dividend;
0BFB  09B3     COMF dividend, F
0BFC  09B4     COMF sign, F
0BFD  0AB3     INCF dividend, F
0BFE  1903     BTFSC STATUS, 0x2
0BFF  0AB4     INCF sign, F
148C  09F2     COMF dividend, F
148D  09F3     COMF counter, F
148E  0AF2     INCF dividend, F
148F  1903     BTFSC STATUS, 0x2
1490  0AF3     INCF counter, F
34:            	return dividend;
0C00  0834     MOVF sign, W
0C01  00B2     MOVWF 0x32
0C02  0833     MOVF dividend, W
0C03  00B1     MOVWF divisor
1491  0873     MOVF counter, W
1492  00F1     MOVWF canal
1493  0872     MOVF dividend, W
1494  00F0     MOVWF divisor
35:            }
0C04  0008     RETURN
1495  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/awdiv.c  ---------------------------------------------------
1:             // integer signed division
2:             
3:             signed int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __awdiv(signed int divisor, signed int dividend)
7:             #else
8:             __awdiv(signed int dividend, signed int divisor)
9:             #endif
10:            {
11:            	signed int	quotient;
12:            	unsigned char	counter, sign;
13:            
14:            	sign = 0;
0913  01AE     CLRF sign
15:            	if(divisor < 0) {
0914  1FAA     BTFSS Data, 0x7
0915  291D     GOTO 0x11D
16:            		divisor = -divisor;
0916  09A9     COMF year, F
0917  09AA     COMF Data, F
0918  0AA9     INCF year, F
0919  1903     BTFSC STATUS, 0x2
091A  0AAA     INCF Data, F
17:            		sign = 1;
091B  01AE     CLRF sign
091C  0AAE     INCF sign, F
18:            	}
19:            	if(dividend < 0) {
091D  1FAC     BTFSS hr, 0x7
091E  2926     GOTO 0x126
20:            		dividend = -dividend;
091F  09AB     COMF sec, F
0920  09AC     COMF hr, F
0921  0AAB     INCF sec, F
0922  1903     BTFSC STATUS, 0x2
0923  0AAC     INCF hr, F
21:            		sign ^= 1;
0924  3001     MOVLW 0x1
0925  06AE     XORWF sign, F
22:            	}
23:            	quotient = 0;
0926  01AF     CLRF quotient
0927  01B0     CLRF c
24:            	if(divisor != 0) {
0928  082A     MOVF Data, W
0929  0429     IORWF year, W
092A  1903     BTFSC STATUS, 0x2
092B  294B     GOTO 0x14B
25:            		counter = 1;
092C  01AD     CLRF day
26:            		while((divisor & 0x8000U) == 0) {
092E  1BAA     BTFSC Data, 0x7
092F  2934     GOTO 0x134
0933  292D     GOTO 0x12D
27:            			divisor <<= 1;
092D  0AAD     INCF day, F
0930  1003     BCF STATUS, 0x0
0931  0DA9     RLF year, F
0932  0DAA     RLF Data, F
28:            			counter++;
092D  0AAD     INCF day, F
29:            		}
30:            		do {
31:            			quotient <<= 1;
0934  1003     BCF STATUS, 0x0
0935  0DAF     RLF quotient, F
0936  0DB0     RLF c, F
32:            			if((unsigned int)divisor <= (unsigned int)dividend) {
0937  082A     MOVF Data, W
0938  022C     SUBWF hr, W
0939  1D03     BTFSS STATUS, 0x2
093A  293D     GOTO 0x13D
093B  0829     MOVF year, W
093C  022B     SUBWF sec, W
093D  1C03     BTFSS STATUS, 0x0
093E  2947     GOTO 0x147
33:            				dividend -= divisor;
093F  0829     MOVF year, W
0940  02AB     SUBWF sec, F
0941  082A     MOVF Data, W
0942  1C03     BTFSS STATUS, 0x0
0943  03AC     DECF hr, F
0944  02AC     SUBWF hr, F
34:            				quotient |= 1;
0945  142F     BSF quotient, 0x0
35:            			}
36:            			*(unsigned int *)&divisor >>= 1;
0946  1003     BCF STATUS, 0x0
0947  0CAA     RRF Data, F
0948  0CA9     RRF year, F
37:            		} while(--counter != 0);
0949  0BAD     DECFSZ day, F
094A  2934     GOTO 0x134
38:            	}
39:            	if(sign)
094B  082E     MOVF sign, W
094C  1903     BTFSC STATUS, 0x2
094D  2953     GOTO 0x153
40:            		quotient = -quotient;
094E  09AF     COMF quotient, F
094F  09B0     COMF c, F
0950  0AAF     INCF quotient, F
0951  1903     BTFSC STATUS, 0x2
0952  0AB0     INCF c, F
41:            	return quotient;
0953  0830     MOVF c, W
0954  00AA     MOVWF Data
0955  082F     MOVF quotient, W
0956  00A9     MOVWF year
42:            }
0957  0008     RETURN
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/pwm.c  --------------------------------
1:             #include <xc.h>
2:             #include <stdint.h>         /* For uint8_t definition */
3:             #include <stdbool.h>        /* For true/false definition */
4:             #include "system.h"
5:             #include "pwm.h"
6:             #include "user.h"
7:             /*The following steps should be taken when configuring
8:             the CCP module for PWM operation:
9:             1. Set the PWM period by writing to the PR2 register.
10:            2. Set the PWM duty cycle by writing to the
11:            CCPR1L register and CCP1CON<5:4> bits.
12:            3. Make the CCP1 pin an output by clearing the
13:            TRISC<2> bit.
14:            4. Set the TMR2 prescale value and enable Timer2
15:            by writing to T2CON.
16:            5. Configure the CCP1 module for PWM operation.*/
17:            #define FrecuenciaPWM 4880UL
18:            #define PeriodoPWM 1/FrecuenciaPWM
19:            #define PRESCALERTIMER2 4
20:            #define asignaPR2 _XTAL_FREQ/PRESCALERTIMER2/4*PeriodoPWM-1
21:            
22:            void set_periodo_buzzer(void) {
23:                //PWM Period = [(PR2) + 1] * 4 * TOSC *(TMR2 Prescale Value)
24:                //PR2=PWM PERIOD/(4*TOSC*TMR2 Prescale Value)-1
25:                //para una frecuencia de __XTAL_FREQ/4=5Mhz
26:                PR2 = asignaPR2; //periodo;;//periodo; //asigno el periodo
1431  30FF     MOVLW 0xFF
1432  0092     MOVWF T2CON
27:                T2CONbits.TMR2ON = 1; //Habilito el timer2
1433  1283     BCF STATUS, 0x5
1434  1512     BSF T2CON, 0x2
28:                T2CONbits.T2CKPS = 1; //prescaler en 4
1435  0812     MOVF T2CON, W
1436  39FC     ANDLW 0xFC
1437  3801     IORLW 0x1
1438  0092     MOVWF T2CON
29:                // CCP1CONbits.CCP1M=0b1100; //Configuro el CCp1 como PWM
30:                RB2 = 0;
1439  1106     BCF PORTB, 0x2
31:                TRISC2 = 0; //pongo el pin RC2/PWM1 como salida
143A  1683     BSF STATUS, 0x5
143B  1107     BCF PORTC, 0x2
32:            #warning No olvidar que si el PWM_duty > PWM_period no queda bien definida la frecuencia
33:                set_duty(512);
143C  1283     BCF STATUS, 0x5
34:            }
35:            
36:            /*/PWM Duty Cycle =(CCPR1L:CCP1CON<5:4>)*TOSC*(TMR2 Prescale Value)*/
37:            void set_duty(unsigned int duty) {
38:            
39:            #define PWM10Bits
40:                //pwm modo 10bits
41:            #ifdef PWM10Bits
42:                CCPR1L = duty >> 2;
1441  0824     MOVF dato, W
1442  00A6     MOVWF x
1443  0823     MOVF x, W
1444  00A5     MOVWF y
1445  1003     BCF STATUS, 0x0
1446  0CA6     RRF x, F
1447  0CA5     RRF y, F
1448  1003     BCF STATUS, 0x0
1449  0CA6     RRF x, F
144A  0CA5     RRF y, F
144B  0825     MOVF y, W
144C  0095     MOVWF CCPR1
43:            #endif
44:                CCP1CON = (CCP1CON & 0xCF) | ((duty << 4) & 0x30);
144D  0823     MOVF x, W
144E  00A5     MOVWF y
144F  0E25     SWAPF y, W
1450  39F0     ANDLW 0xF0
1451  00A5     MOVWF y
1452  3930     ANDLW 0x30
1453  00A6     MOVWF x
1454  0817     MOVF CCP1CON, W
1455  39CF     ANDLW 0xCF
1456  0426     IORWF x, W
1457  0097     MOVWF CCP1CON
45:            
46:            
47:            
48:            }
1458  0008     RETURN
49:            
50:            void buzzer_off(void) {
0FE5  30F0     MOVLW 0xF0
13FB  30F0     MOVLW 0xF0
51:                //activapor=0;
52:                CCP1CONbits.CCP1M = 0; //desactiva pwm
0FE5  30F0     MOVLW 0xF0
0FE6  1283     BCF STATUS, 0x5
0FE7  0597     ANDWF CCP1CON, F
13FB  30F0     MOVLW 0xF0
13FC  1283     BCF STATUS, 0x5
13FD  1303     BCF STATUS, 0x6
13FE  0597     ANDWF CCP1CON, F
53:                PORTCbits.RC2 = 0; //pongo el pin de reloj en bajo
0FE8  1107     BCF PORTC, 0x2
13FF  1107     BCF PORTC, 0x2
54:            
55:            }
0FE9  0008     RETURN
1400  0008     RETURN
56:            
57:            void buzzer_on(void) {
0FEA  3003     MOVLW 0x3
1401  3003     MOVLW 0x3
58:                activapwmpor = 3;
0FEA  3003     MOVLW 0x3
0FEB  1683     BSF STATUS, 0x5
0FEC  1303     BCF STATUS, 0x6
0FED  00B2     MOVWF 0x32
1401  3003     MOVLW 0x3
1402  1683     BSF STATUS, 0x5
1403  1303     BCF STATUS, 0x6
1404  00B2     MOVWF 0x32
59:                CCP1CONbits.CCP1M = 0b1100; //activa pwm
0FEE  1283     BCF STATUS, 0x5
0FEF  0817     MOVF CCP1CON, W
0FF0  39F0     ANDLW 0xF0
0FF1  380C     IORLW 0xC
0FF2  0097     MOVWF CCP1CON
1405  1283     BCF STATUS, 0x5
1406  0817     MOVF CCP1CON, W
1407  39F0     ANDLW 0xF0
1408  380C     IORLW 0xC
1409  0097     MOVWF CCP1CON
60:            }
0FF3  0008     RETURN
140A  0008     RETURN
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/main.c  -------------------------------
1:             /******************************************************************************/
2:             /* Files to Include                                                           */
3:             /******************************************************************************/
4:             // Real Time Clock & NVRAM
5:             // Hardware isl1208 of Dallas Maxim
6:             // With interface I2C
7:             #ifndef __PICCPRO__
8:             #define __PICCPRO__
9:             #endif
10:            #if defined(__XC)
11:            #include <xc.h>         /* XC8 General Include File */
12:            #elif defined(HI_TECH_C)
13:            #include <htc.h>        /* HiTech General Include File */
14:            #endif
15:            
16:            #include <stdint.h>        /* For uint8_t definition */
17:            #include <stdbool.h>       /* For true/false definition */
18:            #include <stdio.h>
19:            #include "system.h"        /* System funct/params, like osc/peripheral config */
20:            #include "user.h"          /* User funct/params, such as InitApp */
21:            #include "Pulsadores.h"
22:            #include "pwm.h"
23:            #include "adcPic16.h"
24:            /******************************************************************************/
25:            /* User Global Variable Declaration                                           */
26:            /******************************************************************************/
27:            
28:            /* i.e. uint8_t <variable_name>; */
29:            
30:            /******************************************************************************/
31:            /* Main Program                                                               */
32:            /******************************************************************************/
33:            
34:            //#fuses HS,MCLR,NOWDT,NOPROTECT,NOPUT,NOBROWNOUT,NOPBADEN,NOLVP,NOCPD,NODEBUG,NOWRT,NOVREGEN
35:            //#use delay(clock=20000000)
36:            //#use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7)
37:            
38:            
39:            #define USE_INTERRUPTS 1
40:            
41:            #include "_isl1208.h"
42:            #include "HardI2C.h"
43:            #include "usart1.h"
44:            #include "LCDGeneric.h"
45:            ///////////////////////////////////////////////////////////////////////////////
46:            
47:            void lee_y_transmite_date_and_time(void) {
48:                isl1208_get_date(&fecha.day, &fecha.month, &fecha.yr, &fecha.dow);
0887  306D     MOVLW 0x6D
0888  1283     BCF STATUS, 0x5
0889  00A8     MOVWF mth
088A  306E     MOVLW 0x6E
088B  00A9     MOVWF year
088C  306F     MOVLW 0x6F
088D  00AA     MOVWF Data
088E  306C     MOVLW 0x6C
088F  2217     CALL 0x217
0890  120A     BCF PCLATH, 0x4
0891  158A     BSF PCLATH, 0x3
49:                isl1208_get_time(&horarioactual.hrs, &horarioactual.min, &horarioactual.sec);
0892  30D5     MOVLW 0xD5
50:            }
51:            
52:            void main() {
53:                TMR1IE = 0; //   disable_interrupts(int_timer1);
0029  1683     BSF STATUS, 0x5
002A  100C     BCF PIR1, 0x0
54:                RCIE = 0; //    disable_interrupts(int_rda);
002B  128C     BCF PIR1, 0x5
55:                RBIE = 0;
002C  118B     BCF INTCON, 0x3
56:                INTE = 0; //disable_interrupts(int_ext);
002D  120B     BCF INTCON, 0x4
57:                ADCON1 = 0x06; //todos puertos digitales
002E  3006     MOVLW 0x6
002F  009F     MOVWF ADCON0
58:                //setup_counters(RTCC_INTERNAL,RTCC_DIV_2);
59:                T0CS = 0; // TMR0 Clock Source Select bit: internal
0030  1281     BCF TMR0, 0x5
60:                PSA = 0; //Prescaler is assigned to the Timer0 module
0031  1181     BCF TMR0, 0x3
61:                OPTION_REGbits.PS = 0b101; //: Prescaler Rate Select bits 1/64
0032  0801     MOVF TMR0, W
0033  39F8     ANDLW 0xF8
0034  3805     IORLW 0x5
0035  0081     MOVWF TMR0
62:                //setup_timer_1(T1_INTERNAL | T1_DIV_BY_1);
63:                T1CON = 1;
0036  3001     MOVLW 0x1
0037  1283     BCF STATUS, 0x5
0038  0090     MOVWF T1CON
64:                CCP1CONbits.CCP1M = 0;
0039  30F0     MOVLW 0xF0
003A  0597     ANDWF CCP1CON, F
65:                //configura_USART();
66:                setup_i2c(I2C_MASTER);
003B  3038     MOVLW 0x38
003C  160A     BSF PCLATH, 0x4
003D  118A     BCF PCLATH, 0x3
003E  240B     CALL 0x40B
003F  120A     BCF PCLATH, 0x4
0040  118A     BCF PCLATH, 0x3
67:            
68:            
69:                TRISB = 0b00111111; //Configuro las entradas de las teclas y la entrada del reloj
0041  303F     MOVLW 0x3F
0042  1683     BSF STATUS, 0x5
0043  0086     MOVWF PORTB
70:                PORTB = 0;
0044  1283     BCF STATUS, 0x5
0045  0186     CLRF PORTB
71:                TRISC0 = 0; //Configuro el pin de activacion de la bomba como salida
0046  1683     BSF STATUS, 0x5
0047  1007     BCF PORTC, 0x0
72:                TRISD = 0x00;
0048  0188     CLRF PORTD
73:                PORTD = 0;
0049  1283     BCF STATUS, 0x5
004A  0188     CLRF PORTD
74:                TRISE = 0b00000000;
004B  1683     BSF STATUS, 0x5
004C  0189     CLRF PORTE
75:                PORTE = 0;
004D  1283     BCF STATUS, 0x5
004E  0189     CLRF PORTE
76:            
77:                vInitLCD();
004F  160A     BSF PCLATH, 0x4
0050  118A     BCF PCLATH, 0x3
0051  24E1     CALL 0x4E1
0052  120A     BCF PCLATH, 0x4
0053  118A     BCF PCLATH, 0x3
78:                static char * cadena;
79:                sprintf(cadenaamostrar, cadena_esp);
0054  3031     MOVLW 0x31
0055  00C7     MOVWF f
0056  3098     MOVLW 0x98
0057  00C8     MOVWF 0x48
0058  30C0     MOVLW 0xC0
0059  120A     BCF PCLATH, 0x4
005A  118A     BCF PCLATH, 0x3
005B  25C7     CALL 0x5C7
005C  120A     BCF PCLATH, 0x4
005D  118A     BCF PCLATH, 0x3
80:                sprintf(cadenaamostrar2, cadena_esp);
005E  3031     MOVLW 0x31
005F  00C7     MOVWF f
0060  3098     MOVLW 0x98
0061  00C8     MOVWF 0x48
0062  30C8     MOVLW 0xC8
0063  120A     BCF PCLATH, 0x4
0064  118A     BCF PCLATH, 0x3
0065  25C7     CALL 0x5C7
0066  120A     BCF PCLATH, 0x4
0067  118A     BCF PCLATH, 0x3
81:                vGotoxyLCD(1, 1);
0068  3001     MOVLW 0x1
0069  01A5     CLRF y
006A  0AA5     INCF y, F
006B  160A     BSF PCLATH, 0x4
006C  118A     BCF PCLATH, 0x3
006D  2496     CALL 0x496
006E  120A     BCF PCLATH, 0x4
006F  118A     BCF PCLATH, 0x3
82:                cadena = cadenaamostrar;
0070  30C0     MOVLW 0xC0
0071  1683     BSF STATUS, 0x5
0072  00BF     MOVWF 0x3F
83:                while (*cadena != '\0')
0073  083F     MOVF 0x3F, W
0074  0084     MOVWF FSR
0075  1383     BCF STATUS, 0x7
0076  0880     MOVF INDF, F
0077  1903     BTFSC STATUS, 0x2
0078  2885     GOTO 0x85
0084  2873     GOTO 0x73
84:                    vLCD_Putc(*cadena++);
0079  083F     MOVF 0x3F, W
007A  0084     MOVWF FSR
007B  0800     MOVF INDF, W
007C  160A     BSF PCLATH, 0x4
007D  118A     BCF PCLATH, 0x3
007E  24B9     CALL 0x4B9
007F  120A     BCF PCLATH, 0x4
0080  118A     BCF PCLATH, 0x3
0081  1683     BSF STATUS, 0x5
0082  1303     BCF STATUS, 0x6
0083  0ABF     INCF 0x3F, F
85:                vGotoxyLCD(1, 2);
0085  3002     MOVLW 0x2
0086  1283     BCF STATUS, 0x5
0087  00A5     MOVWF y
0088  3001     MOVLW 0x1
0089  160A     BSF PCLATH, 0x4
008A  118A     BCF PCLATH, 0x3
008B  2496     CALL 0x496
008C  120A     BCF PCLATH, 0x4
008D  118A     BCF PCLATH, 0x3
86:                cadena = cadenaamostrar2;
008E  30C8     MOVLW 0xC8
008F  1683     BSF STATUS, 0x5
0090  00BF     MOVWF 0x3F
87:                while (*cadena != '\0')
0091  083F     MOVF 0x3F, W
0092  0084     MOVWF FSR
0093  1383     BCF STATUS, 0x7
0094  0880     MOVF INDF, F
0095  1903     BTFSC STATUS, 0x2
0096  28A3     GOTO 0xA3
00A2  2891     GOTO 0x91
88:                    vLCD_Putc(*cadena++);
0097  083F     MOVF 0x3F, W
0098  0084     MOVWF FSR
0099  0800     MOVF INDF, W
009A  160A     BSF PCLATH, 0x4
009B  118A     BCF PCLATH, 0x3
009C  24B9     CALL 0x4B9
009D  120A     BCF PCLATH, 0x4
009E  118A     BCF PCLATH, 0x3
009F  1683     BSF STATUS, 0x5
00A0  1303     BCF STATUS, 0x6
00A1  0ABF     INCF 0x3F, F
89:                refrescadisplay = 0;
00A4  12FC     BCF bitvars9, 0x5
90:                __delay_ms(500);
00A3  300D     MOVLW 0xD
00A5  1283     BCF STATUS, 0x5
00A6  00DE     MOVWF 0x5E
00A7  30AF     MOVLW 0xAF
00A8  00DD     MOVWF 0x5D
00A9  30C1     MOVLW 0xC1
00AA  00DC     MOVWF 0x5C
00AB  0BDC     DECFSZ 0x5C, F
00AC  28AB     GOTO 0xAB
00AD  0BDD     DECFSZ 0x5D, F
00AE  28AB     GOTO 0xAB
00AF  0BDE     DECFSZ 0x5E, F
00B0  28AB     GOTO 0xAB
00B1  0000     NOP
91:                sprintf(cadenaamostrar, "Ini...");
00B2  303C     MOVLW 0x3C
00B3  1283     BCF STATUS, 0x5
00B4  1303     BCF STATUS, 0x6
00B5  00C7     MOVWF f
00B6  3099     MOVLW 0x99
00B7  00C8     MOVWF 0x48
00B8  30C0     MOVLW 0xC0
00B9  120A     BCF PCLATH, 0x4
00BA  118A     BCF PCLATH, 0x3
00BB  25C7     CALL 0x5C7
00BC  120A     BCF PCLATH, 0x4
00BD  118A     BCF PCLATH, 0x3
92:                vGotoxyLCD(1, 1);
00BE  3001     MOVLW 0x1
00BF  01A5     CLRF y
00C0  0AA5     INCF y, F
00C1  160A     BSF PCLATH, 0x4
00C2  118A     BCF PCLATH, 0x3
00C3  2496     CALL 0x496
00C4  120A     BCF PCLATH, 0x4
00C5  118A     BCF PCLATH, 0x3
93:                cadena = cadenaamostrar;
00C6  30C0     MOVLW 0xC0
00C7  1683     BSF STATUS, 0x5
00C8  00BF     MOVWF 0x3F
94:                while (*cadena != '\0')
00C9  083F     MOVF 0x3F, W
00CA  0084     MOVWF FSR
00CB  1383     BCF STATUS, 0x7
00CC  0880     MOVF INDF, F
00CD  1903     BTFSC STATUS, 0x2
00CE  28DB     GOTO 0xDB
00DA  28C9     GOTO 0xC9
95:                    vLCD_Putc(*cadena++);
00CF  083F     MOVF 0x3F, W
00D0  0084     MOVWF FSR
00D1  0800     MOVF INDF, W
00D2  160A     BSF PCLATH, 0x4
00D3  118A     BCF PCLATH, 0x3
00D4  24B9     CALL 0x4B9
00D5  120A     BCF PCLATH, 0x4
00D6  118A     BCF PCLATH, 0x3
00D7  1683     BSF STATUS, 0x5
00D8  1303     BCF STATUS, 0x6
00D9  0ABF     INCF 0x3F, F
96:                vGotoxyLCD(1, 2);
00DB  3002     MOVLW 0x2
00DC  1283     BCF STATUS, 0x5
00DD  00A5     MOVWF y
00DE  3001     MOVLW 0x1
00DF  160A     BSF PCLATH, 0x4
00E0  118A     BCF PCLATH, 0x3
00E1  2496     CALL 0x496
00E2  120A     BCF PCLATH, 0x4
00E3  118A     BCF PCLATH, 0x3
97:                cadena = cadenaamostrar2;
00E4  30C8     MOVLW 0xC8
00E5  1683     BSF STATUS, 0x5
00E6  00BF     MOVWF 0x3F
98:                while (*cadena != '\0')
00E7  083F     MOVF 0x3F, W
00E8  0084     MOVWF FSR
00E9  1383     BCF STATUS, 0x7
00EA  0880     MOVF INDF, F
00EB  1903     BTFSC STATUS, 0x2
00EC  28F9     GOTO 0xF9
00F8  28E7     GOTO 0xE7
99:                    vLCD_Putc(*cadena++);
00ED  083F     MOVF 0x3F, W
00EE  0084     MOVWF FSR
00EF  0800     MOVF INDF, W
00F0  160A     BSF PCLATH, 0x4
00F1  118A     BCF PCLATH, 0x3
00F2  24B9     CALL 0x4B9
00F3  120A     BCF PCLATH, 0x4
00F4  118A     BCF PCLATH, 0x3
00F5  1683     BSF STATUS, 0x5
00F6  1303     BCF STATUS, 0x6
00F7  0ABF     INCF 0x3F, F
100:               refrescadisplay = 0;
00F9  12FC     BCF bitvars9, 0x5
101:           
102:           
103:               set_periodo_buzzer(); //configuro el pwm para una frecuencia de 3khz
00FA  160A     BSF PCLATH, 0x4
00FB  118A     BCF PCLATH, 0x3
00FC  2431     CALL 0x431
00FD  120A     BCF PCLATH, 0x4
00FE  118A     BCF PCLATH, 0x3
104:               buzzer_on();
00FF  160A     BSF PCLATH, 0x4
0100  118A     BCF PCLATH, 0x3
0101  2401     CALL 0x401
0102  120A     BCF PCLATH, 0x4
0103  118A     BCF PCLATH, 0x3
105:               __delay_ms(200);
0104  3006     MOVLW 0x6
0105  00DE     MOVWF 0x5E
0106  3013     MOVLW 0x13
0107  00DD     MOVWF 0x5D
0108  30B1     MOVLW 0xB1
0109  00DC     MOVWF 0x5C
010A  0BDC     DECFSZ 0x5C, F
010B  290A     GOTO 0x10A
010C  0BDD     DECFSZ 0x5D, F
010D  290A     GOTO 0x10A
010E  0BDE     DECFSZ 0x5E, F
010F  290A     GOTO 0x10A
0110  2911     GOTO 0x111
106:               buzzer_off();
0111  160A     BSF PCLATH, 0x4
0112  118A     BCF PCLATH, 0x3
0113  23FB     CALL 0x3FB
0114  120A     BCF PCLATH, 0x4
0115  118A     BCF PCLATH, 0x3
107:               __delay_ms(200);
0116  3006     MOVLW 0x6
0117  00DE     MOVWF 0x5E
0118  3013     MOVLW 0x13
0119  00DD     MOVWF 0x5D
011A  30B1     MOVLW 0xB1
011B  00DC     MOVWF 0x5C
011C  0BDC     DECFSZ 0x5C, F
011D  291C     GOTO 0x11C
011E  0BDD     DECFSZ 0x5D, F
011F  291C     GOTO 0x11C
0120  0BDE     DECFSZ 0x5E, F
0121  291C     GOTO 0x11C
0122  2923     GOTO 0x123
108:               buzzer_on();
0123  160A     BSF PCLATH, 0x4
0124  118A     BCF PCLATH, 0x3
0125  2401     CALL 0x401
0126  120A     BCF PCLATH, 0x4
0127  118A     BCF PCLATH, 0x3
109:               __delay_ms(200);
0128  3006     MOVLW 0x6
0129  00DE     MOVWF 0x5E
012A  3013     MOVLW 0x13
012B  00DD     MOVWF 0x5D
012C  30B1     MOVLW 0xB1
012D  00DC     MOVWF 0x5C
012E  0BDC     DECFSZ 0x5C, F
012F  292E     GOTO 0x12E
0130  0BDD     DECFSZ 0x5D, F
0131  292E     GOTO 0x12E
0132  0BDE     DECFSZ 0x5E, F
0133  292E     GOTO 0x12E
0134  2935     GOTO 0x135
110:               buzzer_off();
0135  160A     BSF PCLATH, 0x4
0136  118A     BCF PCLATH, 0x3
0137  23FB     CALL 0x3FB
0138  120A     BCF PCLATH, 0x4
0139  118A     BCF PCLATH, 0x3
111:               //ext_int_edge(2,H_TO_L);
112:               INTEDG = 0;
013A  1683     BSF STATUS, 0x5
013B  1301     BCF TMR0, 0x6
113:               INTE = 1; // enable_interrupts(int_ext2);
013C  160B     BSF INTCON, 0x4
114:               TMR0IE = 1;
013D  168B     BSF INTCON, 0x5
115:               setADCChannel(MIDECORRIENTE);
013E  3000     MOVLW 0x0
013F  120A     BCF PCLATH, 0x4
0140  118A     BCF PCLATH, 0x3
0141  27F4     CALL 0x7F4
0142  120A     BCF PCLATH, 0x4
0143  118A     BCF PCLATH, 0x3
116:               __delay_us(20);
0144  3021     MOVLW 0x21
0145  00DC     MOVWF 0x5C
0146  0BDC     DECFSZ 0x5C, F
0147  2946     GOTO 0x146
117:               openADC();
0148  160A     BSF PCLATH, 0x4
0149  118A     BCF PCLATH, 0x3
014A  241C     CALL 0x41C
014B  120A     BCF PCLATH, 0x4
014C  118A     BCF PCLATH, 0x3
118:               __delay_us(20);
014D  3021     MOVLW 0x21
014E  00DC     MOVWF 0x5C
014F  0BDC     DECFSZ 0x5C, F
0150  294F     GOTO 0x14F
119:               interruptADC_on();
0151  160A     BSF PCLATH, 0x4
0152  118A     BCF PCLATH, 0x3
0153  23F7     CALL 0x3F7
0154  120A     BCF PCLATH, 0x4
0155  118A     BCF PCLATH, 0x3
120:               __delay_ms(500);
0156  300D     MOVLW 0xD
0157  1283     BCF STATUS, 0x5
0158  00DE     MOVWF 0x5E
0159  30AF     MOVLW 0xAF
015A  00DD     MOVWF 0x5D
015B  30C1     MOVLW 0xC1
015C  00DC     MOVWF 0x5C
015D  0BDC     DECFSZ 0x5C, F
015E  295D     GOTO 0x15D
015F  0BDD     DECFSZ 0x5D, F
0160  295D     GOTO 0x15D
0161  0BDE     DECFSZ 0x5E, F
0162  295D     GOTO 0x15D
0163  0000     NOP
121:           
122:           
123:               ADIF = 0;
0164  1283     BCF STATUS, 0x5
0165  1303     BCF STATUS, 0x6
0166  130C     BCF PIR1, 0x6
124:               INTF = 0; // borro las banderas de interrupcion
0167  108B     BCF INTCON, 0x1
125:               TMR0IF = 0;
0168  110B     BCF INTCON, 0x2
126:           
127:               if (ISL1208_ready()) {
0169  120A     BCF PCLATH, 0x4
016A  158A     BSF PCLATH, 0x3
016B  2158     CALL 0x158
016C  120A     BCF PCLATH, 0x4
016D  118A     BCF PCLATH, 0x3
016E  3A00     XORLW 0x0
016F  1903     BTFSC STATUS, 0x2
0170  29C5     GOTO 0x1C5
128:                   sprintf(cadenaamostrar, "RTC OK");
0171  3043     MOVLW 0x43
0172  00C7     MOVWF f
0173  3099     MOVLW 0x99
0174  00C8     MOVWF 0x48
0175  30C0     MOVLW 0xC0
0176  120A     BCF PCLATH, 0x4
0177  118A     BCF PCLATH, 0x3
0178  25C7     CALL 0x5C7
0179  120A     BCF PCLATH, 0x4
017A  118A     BCF PCLATH, 0x3
129:                   vGotoxyLCD(1, 1);
017B  3001     MOVLW 0x1
017C  01A5     CLRF y
017D  0AA5     INCF y, F
017E  160A     BSF PCLATH, 0x4
017F  118A     BCF PCLATH, 0x3
0180  2496     CALL 0x496
0181  120A     BCF PCLATH, 0x4
0182  118A     BCF PCLATH, 0x3
130:                   cadena = cadenaamostrar;
0183  30C0     MOVLW 0xC0
0184  1683     BSF STATUS, 0x5
0185  00BF     MOVWF 0x3F
131:                   while (*cadena != '\0')
0186  083F     MOVF 0x3F, W
0187  0084     MOVWF FSR
0188  1383     BCF STATUS, 0x7
0189  0880     MOVF INDF, F
018A  1903     BTFSC STATUS, 0x2
018B  2998     GOTO 0x198
0197  2986     GOTO 0x186
132:                       vLCD_Putc(*cadena++);
018C  083F     MOVF 0x3F, W
018D  0084     MOVWF FSR
018E  0800     MOVF INDF, W
018F  160A     BSF PCLATH, 0x4
0190  118A     BCF PCLATH, 0x3
0191  24B9     CALL 0x4B9
0192  120A     BCF PCLATH, 0x4
0193  118A     BCF PCLATH, 0x3
0194  1683     BSF STATUS, 0x5
0195  1303     BCF STATUS, 0x6
0196  0ABF     INCF 0x3F, F
133:           
134:                   __delay_ms(500);
0198  300D     MOVLW 0xD
0199  1283     BCF STATUS, 0x5
019A  00DE     MOVWF 0x5E
019B  30AF     MOVLW 0xAF
019C  00DD     MOVWF 0x5D
019D  30C1     MOVLW 0xC1
019E  00DC     MOVWF 0x5C
019F  0BDC     DECFSZ 0x5C, F
01A0  299F     GOTO 0x19F
01A1  0BDD     DECFSZ 0x5D, F
01A2  299F     GOTO 0x19F
01A3  0BDE     DECFSZ 0x5E, F
01A4  299F     GOTO 0x19F
01A5  0000     NOP
135:                   __delay_ms(500);
01A6  300D     MOVLW 0xD
01A7  1283     BCF STATUS, 0x5
01A8  1303     BCF STATUS, 0x6
01A9  00DE     MOVWF 0x5E
01AA  30AF     MOVLW 0xAF
01AB  00DD     MOVWF 0x5D
01AC  30C1     MOVLW 0xC1
01AD  00DC     MOVWF 0x5C
01AE  0BDC     DECFSZ 0x5C, F
01AF  29AE     GOTO 0x1AE
01B0  0BDD     DECFSZ 0x5D, F
01B1  29AE     GOTO 0x1AE
01B2  0BDE     DECFSZ 0x5E, F
01B3  29AE     GOTO 0x1AE
01B4  0000     NOP
136:                   __delay_ms(500);
01B5  300D     MOVLW 0xD
01B6  1283     BCF STATUS, 0x5
01B7  1303     BCF STATUS, 0x6
01B8  00DE     MOVWF 0x5E
01B9  30AF     MOVLW 0xAF
01BA  00DD     MOVWF 0x5D
01BB  30C1     MOVLW 0xC1
01BC  00DC     MOVWF 0x5C
01BD  0BDC     DECFSZ 0x5C, F
01BE  29BD     GOTO 0x1BD
01BF  0BDD     DECFSZ 0x5D, F
01C0  29BD     GOTO 0x1BD
01C1  0BDE     DECFSZ 0x5E, F
01C2  29BD     GOTO 0x1BD
01C3  0000     NOP
137:               } else {
01C4  29EC     GOTO 0x1EC
138:                   sprintf(cadenaamostrar, "RTC ERRO");
01C5  302A     MOVLW 0x2A
01C6  00C7     MOVWF f
01C7  3099     MOVLW 0x99
01C8  00C8     MOVWF 0x48
01C9  30C0     MOVLW 0xC0
01CA  120A     BCF PCLATH, 0x4
01CB  118A     BCF PCLATH, 0x3
01CC  25C7     CALL 0x5C7
01CD  120A     BCF PCLATH, 0x4
01CE  118A     BCF PCLATH, 0x3
139:                   vGotoxyLCD(1, 1);
01CF  3001     MOVLW 0x1
01D0  01A5     CLRF y
01D1  0AA5     INCF y, F
01D2  160A     BSF PCLATH, 0x4
01D3  118A     BCF PCLATH, 0x3
01D4  2496     CALL 0x496
01D5  120A     BCF PCLATH, 0x4
01D6  118A     BCF PCLATH, 0x3
140:                   cadena = cadenaamostrar;
01D7  30C0     MOVLW 0xC0
01D8  1683     BSF STATUS, 0x5
01D9  00BF     MOVWF 0x3F
141:                   while (*cadena != '\0')
01DA  083F     MOVF 0x3F, W
01DB  0084     MOVWF FSR
01DC  1383     BCF STATUS, 0x7
01DD  0880     MOVF INDF, F
01DE  1903     BTFSC STATUS, 0x2
01DF  2998     GOTO 0x198
01EB  29DA     GOTO 0x1DA
142:                       vLCD_Putc(*cadena++);
01E0  083F     MOVF 0x3F, W
01E1  0084     MOVWF FSR
01E2  0800     MOVF INDF, W
01E3  160A     BSF PCLATH, 0x4
01E4  118A     BCF PCLATH, 0x3
01E5  24B9     CALL 0x4B9
01E6  120A     BCF PCLATH, 0x4
01E7  118A     BCF PCLATH, 0x3
01E8  1683     BSF STATUS, 0x5
01E9  1303     BCF STATUS, 0x6
01EA  0ABF     INCF 0x3F, F
143:           
144:                   __delay_ms(500);
145:                   __delay_ms(500);
146:                   __delay_ms(500);
147:           
148:               };
149:               fecha.day = 1;
01EC  1283     BCF STATUS, 0x5
01ED  1303     BCF STATUS, 0x6
01EF  01EC     CLRF fecha
01F0  0AEC     INCF fecha, F
150:               fecha.month = 1;
01F1  01ED     CLRF 0x6D
01F2  0AED     INCF 0x6D, F
151:               fecha.yr = 15;
01EE  300F     MOVLW 0xF
01F3  00EE     MOVWF 0x6E
152:               fecha.dow = 4;
01F4  3004     MOVLW 0x4
01F5  00EF     MOVWF 0x6F
153:               isl1208SR.Valor = 0x00;
01F6  1683     BSF STATUS, 0x5
01F7  01BA     CLRF f1
154:               isl1208SR.Valor = ISL1208_Read_status();
01F8  120A     BCF PCLATH, 0x4
01F9  158A     BSF PCLATH, 0x3
01FA  2168     CALL 0x168
01FB  120A     BCF PCLATH, 0x4
01FC  118A     BCF PCLATH, 0x3
01FD  1683     BSF STATUS, 0x5
01FE  00BA     MOVWF f1
155:               if (isl1208SR.RTCF) {//Si se reseteo el RTC, envio directamente a configurar la hora
01FF  1C3A     BTFSS f1, 0x0
0200  2A04     GOTO 0x204
156:                   menuactual = MENU_CONFIGURAHORARIO;
0201  3003     MOVLW 0x3
0202  00BB     MOVWF 0x3B
157:           
158:               } else {
0203  2A1A     GOTO 0x21A
159:                   lee_y_transmite_date_and_time();
0204  120A     BCF PCLATH, 0x4
0205  158A     BSF PCLATH, 0x3
0206  2087     CALL 0x87
0207  120A     BCF PCLATH, 0x4
0208  118A     BCF PCLATH, 0x3
160:           
161:                   /*TODO leer el valor de la alarma de encendido en algun lado cuando se cambia el
162:                    valor de horarioenc pero no se guarda
163:                    */
164:                   isl1208_get_time_enc(&horarioenc.hrs, &horarioenc.min, &horarioenc.sec);
0209  30D8     MOVLW 0xD8
020A  1283     BCF STATUS, 0x5
020B  00A8     MOVWF mth
020C  30D7     MOVLW 0xD7
020D  00A9     MOVWF year
020E  30D9     MOVLW 0xD9
020F  120A     BCF PCLATH, 0x4
0210  158A     BSF PCLATH, 0x3
0211  21DE     CALL 0x1DE
0212  120A     BCF PCLATH, 0x4
0213  118A     BCF PCLATH, 0x3
165:                   isl1208_get_dow_enc(&fechaenc.dow);
0214  30D3     MOVLW 0xD3
0215  120A     BCF PCLATH, 0x4
0216  158A     BSF PCLATH, 0x3
0217  2183     CALL 0x183
0218  120A     BCF PCLATH, 0x4
0219  118A     BCF PCLATH, 0x3
166:                   //TODO tengo que detectar si la alarma se activo cunado el sistema estaba apagado y procesarla
167:               }
168:               ei(); //enable_interrupts(global);
021A  178B     BSF INTCON, 0x7
021B  2CEE     GOTO 0x4EE
169:               // Inicializa isl1208
170:               //TODO   isl1208_init(isl1208_OUT_ENABLED | isl1208_OUT_1_HZ);
171:           
172:               while (1) {//
173:                   // di(); //
174:                   //Inicia Procesa los men
175:                   ////////////////////////////////////////
176:                   switch (menuactual) {
04EE  1683     BSF STATUS, 0x5
04EF  1303     BCF STATUS, 0x6
04F0  083B     MOVF 0x3B, W
04F1  0084     MOVWF FSR
04F2  3012     MOVLW 0x12
04F3  0204     SUBWF FSR, W
04F4  1803     BTFSC STATUS, 0x0
04F5  2CFD     GOTO 0x4FD
04F6  3010     MOVLW 0x10
04F7  008A     MOVWF PCLATH
04F8  1003     BCF STATUS, 0x0
04F9  0D04     RLF FSR, W
04FA  0704     ADDWF FSR, W
04FB  3E00     ADDLW 0x0
04FC  0082     MOVWF PCL
1000  120A     BCF PCLATH, 0x4
1001  118A     BCF PCLATH, 0x3
1002  2A1C     GOTO 0x21C
1003  120A     BCF PCLATH, 0x4
1004  118A     BCF PCLATH, 0x3
1005  2A66     GOTO 0x266
1006  120A     BCF PCLATH, 0x4
1007  118A     BCF PCLATH, 0x3
1008  2BE5     GOTO 0x3E5
1009  120A     BCF PCLATH, 0x4
100A  118A     BCF PCLATH, 0x3
100B  2A9B     GOTO 0x29B
100C  120A     BCF PCLATH, 0x4
100D  118A     BCF PCLATH, 0x3
100E  2AA3     GOTO 0x2A3
100F  120A     BCF PCLATH, 0x4
1010  118A     BCF PCLATH, 0x3
1011  2AD4     GOTO 0x2D4
1012  120A     BCF PCLATH, 0x4
1013  118A     BCF PCLATH, 0x3
1014  2AE4     GOTO 0x2E4
1015  120A     BCF PCLATH, 0x4
1016  118A     BCF PCLATH, 0x3
1017  2AEC     GOTO 0x2EC
1018  120A     BCF PCLATH, 0x4
1019  118A     BCF PCLATH, 0x3
101A  2AF9     GOTO 0x2F9
101B  120A     BCF PCLATH, 0x4
101C  118A     BCF PCLATH, 0x3
101D  2B09     GOTO 0x309
101E  120A     BCF PCLATH, 0x4
101F  118A     BCF PCLATH, 0x3
1020  2B4A     GOTO 0x34A
1021  120A     BCF PCLATH, 0x4
1022  118A     BCF PCLATH, 0x3
1023  2B52     GOTO 0x352
1024  120A     BCF PCLATH, 0x4
1025  118A     BCF PCLATH, 0x3
1026  2B61     GOTO 0x361
1027  120A     BCF PCLATH, 0x4
1028  118A     BCF PCLATH, 0x3
1029  2B83     GOTO 0x383
102A  120A     BCF PCLATH, 0x4
102B  118A     BCF PCLATH, 0x3
102C  2B97     GOTO 0x397
102D  120A     BCF PCLATH, 0x4
102E  118A     BCF PCLATH, 0x3
102F  2BAB     GOTO 0x3AB
1030  120A     BCF PCLATH, 0x4
1031  118A     BCF PCLATH, 0x3
1032  2BAC     GOTO 0x3AC
1033  120A     BCF PCLATH, 0x4
1034  118A     BCF PCLATH, 0x3
1035  2BC4     GOTO 0x3C4
177:                       case MENU_MUESTRAHORA:
178:                       {
179:                           horario = &horarioactual;
021C  30D4     MOVLW 0xD4
021D  00FD     MOVWF 0x7D
180:                           //Se actualiza lo que se muestra en el display, solamente cuando hay cambios en lo que mostrar
181:           
182:                           if (flanco) {
021E  0839     MOVF 0x39, W
021F  1903     BTFSC STATUS, 0x2
0220  2A46     GOTO 0x246
183:                               lee_y_transmite_date_and_time();
0221  120A     BCF PCLATH, 0x4
0222  158A     BSF PCLATH, 0x3
0223  2087     CALL 0x87
0224  120A     BCF PCLATH, 0x4
0225  118A     BCF PCLATH, 0x3
184:                               sprintf(cadenaamostrar, "%02d:%02d    ", horarioactual.hrs, horarioactual.min);
0226  3058     MOVLW 0x58
0227  1283     BCF STATUS, 0x5
0228  00C7     MOVWF f
0229  3098     MOVLW 0x98
022A  00C8     MOVWF 0x48
022B  1683     BSF STATUS, 0x5
022C  0856     MOVF f3, W
022D  1283     BCF STATUS, 0x5
022E  00C9     MOVWF 0x49
022F  01CA     CLRF cntr
0230  1683     BSF STATUS, 0x5
0231  0855     MOVF width, W
0232  1283     BCF STATUS, 0x5
0233  00CB     MOVWF sign
0234  30C0     MOVLW 0xC0
0235  01CC     CLRF f2
0236  120A     BCF PCLATH, 0x4
0237  118A     BCF PCLATH, 0x3
0238  25C7     CALL 0x5C7
0239  120A     BCF PCLATH, 0x4
023A  118A     BCF PCLATH, 0x3
185:                               sprintf(cadenaamostrar2, cadena_esp);
023B  3031     MOVLW 0x31
023C  00C7     MOVWF f
023D  3098     MOVLW 0x98
023E  00C8     MOVWF 0x48
023F  30C8     MOVLW 0xC8
0240  120A     BCF PCLATH, 0x4
0241  118A     BCF PCLATH, 0x3
0242  25C7     CALL 0x5C7
0243  120A     BCF PCLATH, 0x4
0244  118A     BCF PCLATH, 0x3
186:                           } else {
0245  2CFD     GOTO 0x4FD
187:                               sprintf(cadenaamostrar, "%02d %02d    ", horarioactual.hrs, horarioactual.min);
0246  304A     MOVLW 0x4A
0247  1283     BCF STATUS, 0x5
0248  00C7     MOVWF f
0249  3098     MOVLW 0x98
024A  00C8     MOVWF 0x48
024B  1683     BSF STATUS, 0x5
024C  0856     MOVF f3, W
024D  1283     BCF STATUS, 0x5
024E  00C9     MOVWF 0x49
024F  01CA     CLRF cntr
0250  1683     BSF STATUS, 0x5
0251  0855     MOVF width, W
0252  1283     BCF STATUS, 0x5
0253  00CB     MOVWF sign
0254  30C0     MOVLW 0xC0
0255  01CC     CLRF f2
0256  120A     BCF PCLATH, 0x4
0257  118A     BCF PCLATH, 0x3
0258  25C7     CALL 0x5C7
0259  120A     BCF PCLATH, 0x4
025A  118A     BCF PCLATH, 0x3
188:                               sprintf(cadenaamostrar2, cadena_esp);
025B  3031     MOVLW 0x31
025C  00C7     MOVWF f
025D  3098     MOVLW 0x98
025E  00C8     MOVWF 0x48
025F  30C8     MOVLW 0xC8
0260  120A     BCF PCLATH, 0x4
0261  118A     BCF PCLATH, 0x3
0262  25C7     CALL 0x5C7
0263  120A     BCF PCLATH, 0x4
0264  118A     BCF PCLATH, 0x3
0265  2CFD     GOTO 0x4FD
189:                           }
190:                           break;
191:                       }
192:                       case MENU_MUESTRAFECHA:
193:                       {
194:           
195:                           if (flanco) {
0266  0839     MOVF 0x39, W
0267  1903     BTFSC STATUS, 0x2
0268  2CFD     GOTO 0x4FD
196:                               lee_y_transmite_date_and_time();
0269  120A     BCF PCLATH, 0x4
026A  158A     BSF PCLATH, 0x3
026B  2087     CALL 0x87
026C  120A     BCF PCLATH, 0x4
026D  118A     BCF PCLATH, 0x3
197:                               sprintf(cadenaamostrar, "%02d/%02d/%02d ", fecha.day, fecha.month, fecha.yr);
026E  303A     MOVLW 0x3A
026F  1283     BCF STATUS, 0x5
0270  00C7     MOVWF f
0271  3098     MOVLW 0x98
0272  00C8     MOVWF 0x48
0273  086C     MOVF fecha, W
0274  00C9     MOVWF 0x49
0275  01CA     CLRF cntr
0276  086D     MOVF 0x6D, W
0277  00CB     MOVWF sign
0278  01CC     CLRF f2
0279  086E     MOVF 0x6E, W
027A  00CD     MOVWF 0x4D
027B  30C0     MOVLW 0xC0
027C  01CE     CLRF 0x4E
027D  120A     BCF PCLATH, 0x4
027E  118A     BCF PCLATH, 0x3
027F  25C7     CALL 0x5C7
0280  120A     BCF PCLATH, 0x4
0281  118A     BCF PCLATH, 0x3
198:                               sprintf(cadenaamostrar2, days_of_week[dia_de_la_semana(&fecha.day, &fecha.month, &fecha.yr)]);
0282  306E     MOVLW 0x6E
0283  00B8     MOVWF anio
0284  306D     MOVLW 0x6D
0285  00B7     MOVWF mes
0286  306C     MOVLW 0x6C
0287  120A     BCF PCLATH, 0x4
0288  158A     BSF PCLATH, 0x3
0289  2099     CALL 0x99
028A  120A     BCF PCLATH, 0x4
028B  118A     BCF PCLATH, 0x3
028C  00EB     MOVWF 0x6B
028D  3003     MOVLW 0x3
028E  00A3     MOVWF x
028F  086B     MOVF 0x6B, W
0290  120A     BCF PCLATH, 0x4
0291  158A     BSF PCLATH, 0x3
0292  23BA     CALL 0x3BA
0293  120A     BCF PCLATH, 0x4
0294  118A     BCF PCLATH, 0x3
0295  3E1C     ADDLW 0x1C
0296  00C7     MOVWF f
0297  3098     MOVLW 0x98
0298  1803     BTFSC STATUS, 0x0
0299  3E01     ADDLW 0x1
029A  2BE3     GOTO 0x3E3
199:                           }
200:           
201:           
202:                           break;
203:                       }
204:                       case MENU_CONFIGURAHORARIO:
205:                       {
206:           
207:                           if (flanco) {
029B  0839     MOVF 0x39, W
029C  1903     BTFSC STATUS, 0x2
029D  2CFD     GOTO 0x4FD
208:                               sprintf(cadenaamostrar, "SET HORA ");
029E  30E7     MOVLW 0xE7
029F  1283     BCF STATUS, 0x5
02A0  00C7     MOVWF f
02A1  3098     MOVLW 0x98
02A2  2BD9     GOTO 0x3D9
209:                               sprintf(cadenaamostrar2, cadena_esp);
210:                           }
211:           
212:                           break;
213:                       }
214:                       case SUBMENU_CONFIGURAHORA:
215:                       {
216:                           modificafecha = HORA;
02A3  30D4     MOVLW 0xD4
02A4  01DA     CLRF c
217:                           horario = &horarioactual;
02A3  30D4     MOVLW 0xD4
02A5  00FD     MOVWF 0x7D
218:                           if (flanco || haycambio) {
02A6  08B9     MOVF 0x39, F
02A7  1D03     BTFSS STATUS, 0x2
02A8  2AAB     GOTO 0x2AB
02A9  1E7C     BTFSS bitvars9, 0x4
02AA  2ACC     GOTO 0x2CC
219:                               sprintf(cadenaamostrar, "%02d:%02d    ", horarioactual.hrs, horarioactual.min);
02AB  3058     MOVLW 0x58
02AC  1283     BCF STATUS, 0x5
02AD  00C7     MOVWF f
02AE  3098     MOVLW 0x98
02AF  00C8     MOVWF 0x48
02B0  1683     BSF STATUS, 0x5
02B1  0856     MOVF f3, W
02B2  1283     BCF STATUS, 0x5
02B3  00C9     MOVWF 0x49
02B4  01CA     CLRF cntr
02B5  1683     BSF STATUS, 0x5
02B6  0855     MOVF width, W
02B7  1283     BCF STATUS, 0x5
02B8  00CB     MOVWF sign
02B9  30C0     MOVLW 0xC0
02BA  01CC     CLRF f2
02BB  120A     BCF PCLATH, 0x4
02BC  118A     BCF PCLATH, 0x3
02BD  25C7     CALL 0x5C7
02BE  120A     BCF PCLATH, 0x4
02BF  118A     BCF PCLATH, 0x3
220:                               sprintf(cadenaamostrar2, cadena_esp);
02C0  3031     MOVLW 0x31
02C1  00C7     MOVWF f
02C2  3098     MOVLW 0x98
02C3  00C8     MOVWF 0x48
02C4  30C8     MOVLW 0xC8
02C5  120A     BCF PCLATH, 0x4
02C6  118A     BCF PCLATH, 0x3
02C7  25C7     CALL 0x5C7
02C8  120A     BCF PCLATH, 0x4
02C9  118A     BCF PCLATH, 0x3
221:                               haycambio = 0;
02CA  127C     BCF bitvars9, 0x4
02CB  2CEC     GOTO 0x4EC
222:                           } else {
223:                               sprintf(cadenaamostrar, "  :%02d    ", horarioactual.min);
02CC  309C     MOVLW 0x9C
02CD  1283     BCF STATUS, 0x5
02CE  00C7     MOVWF f
02CF  3098     MOVLW 0x98
02D0  00C8     MOVWF 0x48
02D1  1683     BSF STATUS, 0x5
02D2  0855     MOVF width, W
02D3  2B7E     GOTO 0x37E
224:                               sprintf(cadenaamostrar2, cadena_esp);
225:                           }
226:                           break;
227:                       }
228:                       case SUBMENU_CONFIGURAMINUTOS:
02D4  30D4     MOVLW 0xD4
229:                       {
230:                           modificafecha = MINUTOS;
02D5  01DA     CLRF c
02D6  0ADA     INCF c, F
231:                           horario = &horarioactual;
02D4  30D4     MOVLW 0xD4
02D7  00FD     MOVWF 0x7D
232:                           if (flanco || haycambio) {
02D8  08B9     MOVF 0x39, F
02D9  1903     BTFSC STATUS, 0x2
02DA  1A7C     BTFSC bitvars9, 0x4
233:                               sprintf(cadenaamostrar, "%02d:%02d    ", horarioactual.hrs, horarioactual.min);
02DB  2AAB     GOTO 0x2AB
234:                               sprintf(cadenaamostrar2, cadena_esp);
235:                               haycambio = 0;
236:                           } else {
237:                               sprintf(cadenaamostrar, "%02d:      ", horarioactual.hrs);
02DC  3090     MOVLW 0x90
02DD  1283     BCF STATUS, 0x5
02DE  00C7     MOVWF f
02DF  3098     MOVLW 0x98
02E0  00C8     MOVWF 0x48
02E1  1683     BSF STATUS, 0x5
02E2  0856     MOVF f3, W
02E3  2B7E     GOTO 0x37E
238:                               sprintf(cadenaamostrar2, cadena_esp);
239:                           }
240:                           break;
241:                       }
242:                       case MENU_CONFIGURAFECHA:
243:                       {
244:           
245:                           if (flanco) {
02E4  0839     MOVF 0x39, W
02E5  1903     BTFSC STATUS, 0x2
02E6  2CFD     GOTO 0x4FD
246:                               sprintf(cadenaamostrar, "SET FECHA");
02E7  30FB     MOVLW 0xFB
02E8  1283     BCF STATUS, 0x5
02E9  00C7     MOVWF f
02EA  3098     MOVLW 0x98
02EB  2BD9     GOTO 0x3D9
247:                               sprintf(cadenaamostrar2, cadena_esp);
248:                           }
249:                           break;
250:                       }
251:                       case SUBMENU_CONFIGURADIA:
252:                       {
253:                           modificafecha = DIA;
02EC  3002     MOVLW 0x2
02ED  00DA     MOVWF c
254:           
255:                           if (flanco || haycambio) {
02EE  08B9     MOVF 0x39, F
02EF  1903     BTFSC STATUS, 0x2
02F0  1A7C     BTFSC bitvars9, 0x4
256:                               sprintf(cadenaamostrar, "%02d/%02d/%02d ", fecha.day, fecha.month, fecha.yr);
02F1  2B10     GOTO 0x310
257:                               sprintf(cadenaamostrar2, days_of_week[dia_de_la_semana(&fecha.day, &fecha.month, &fecha.yr)]);
258:                               //sprintf(cadenaamostrar2, "             ");
259:                               haycambio = 0;
260:                           } else {
261:                               sprintf(cadenaamostrar, "  /%02d/%02d ", fecha.month, fecha.yr);
02F2  3082     MOVLW 0x82
02F3  1283     BCF STATUS, 0x5
02F4  00C7     MOVWF f
02F5  3098     MOVLW 0x98
02F6  00C8     MOVWF 0x48
02F7  086D     MOVF 0x6D, W
02F8  2B05     GOTO 0x305
262:                               sprintf(cadenaamostrar2, cadena_esp);
263:                           }
264:                           break;
265:                       }
266:                       case SUBMENU_CONFIGURAMES:
267:                       {
268:                           modificafecha = MES;
02F9  3003     MOVLW 0x3
02FA  00DA     MOVWF c
269:           
270:                           if (flanco || haycambio) {
02FB  08B9     MOVF 0x39, F
02FC  1903     BTFSC STATUS, 0x2
02FD  1A7C     BTFSC bitvars9, 0x4
271:                               sprintf(cadenaamostrar, "%02d/%02d/%02d ", fecha.day, fecha.month, fecha.yr);
02FE  2B10     GOTO 0x310
272:                               sprintf(cadenaamostrar2, days_of_week[dia_de_la_semana(&fecha.day, &fecha.month, &fecha.yr)]);
273:                               haycambio = 0;
274:                           } else {
275:                               sprintf(cadenaamostrar, "%02d/  /%02d ", fecha.day, fecha.yr);
02FF  3074     MOVLW 0x74
0300  1283     BCF STATUS, 0x5
0301  00C7     MOVWF f
0302  3098     MOVLW 0x98
0303  00C8     MOVWF 0x48
0304  086C     MOVF fecha, W
0305  00C9     MOVWF 0x49
0306  01CA     CLRF cntr
0307  086E     MOVF 0x6E, W
0308  2B46     GOTO 0x346
276:                               sprintf(cadenaamostrar2, cadena_esp);
277:                           }
278:                           break;
279:                       }
280:                       case SUBMENU_CONFIGURAANIO:
281:                       {
282:                           modificafecha = ANIO;
0309  3004     MOVLW 0x4
030A  00DA     MOVWF c
283:           
284:                           if (flanco || haycambio) {
030B  08B9     MOVF 0x39, F
030C  1D03     BTFSS STATUS, 0x2
030D  2B10     GOTO 0x310
030E  1E7C     BTFSS bitvars9, 0x4
030F  2B3D     GOTO 0x33D
285:                               sprintf(cadenaamostrar, "%02d/%02d/%02d ", fecha.day, fecha.month, fecha.yr);
0310  303A     MOVLW 0x3A
0311  1283     BCF STATUS, 0x5
0312  00C7     MOVWF f
0313  3098     MOVLW 0x98
0314  00C8     MOVWF 0x48
0315  086C     MOVF fecha, W
0316  00C9     MOVWF 0x49
0317  01CA     CLRF cntr
0318  086D     MOVF 0x6D, W
0319  00CB     MOVWF sign
031A  01CC     CLRF f2
031B  086E     MOVF 0x6E, W
031C  00CD     MOVWF 0x4D
031D  30C0     MOVLW 0xC0
031E  01CE     CLRF 0x4E
031F  120A     BCF PCLATH, 0x4
0320  118A     BCF PCLATH, 0x3
0321  25C7     CALL 0x5C7
0322  120A     BCF PCLATH, 0x4
0323  118A     BCF PCLATH, 0x3
286:                               sprintf(cadenaamostrar2, days_of_week[dia_de_la_semana(&fecha.day, &fecha.month, &fecha.yr)]);
0324  306E     MOVLW 0x6E
0325  00B8     MOVWF anio
0326  306D     MOVLW 0x6D
0327  00B7     MOVWF mes
0328  306C     MOVLW 0x6C
0329  120A     BCF PCLATH, 0x4
032A  158A     BSF PCLATH, 0x3
032B  2099     CALL 0x99
032C  120A     BCF PCLATH, 0x4
032D  118A     BCF PCLATH, 0x3
032E  00EB     MOVWF 0x6B
032F  3003     MOVLW 0x3
0330  00A3     MOVWF x
0331  086B     MOVF 0x6B, W
0332  120A     BCF PCLATH, 0x4
0333  158A     BSF PCLATH, 0x3
0334  23BA     CALL 0x3BA
0335  120A     BCF PCLATH, 0x4
0336  118A     BCF PCLATH, 0x3
0337  3E1C     ADDLW 0x1C
0338  00C7     MOVWF f
0339  3098     MOVLW 0x98
033A  1803     BTFSC STATUS, 0x0
033B  3E01     ADDLW 0x1
033C  2AC3     GOTO 0x2C3
287:                               haycambio = 0;
288:                           } else {
289:                               sprintf(cadenaamostrar, "%02d/%02d/   ", fecha.day, fecha.month);
033D  3066     MOVLW 0x66
033E  1283     BCF STATUS, 0x5
033F  00C7     MOVWF f
0340  3098     MOVLW 0x98
0341  00C8     MOVWF 0x48
0342  086C     MOVF fecha, W
0343  00C9     MOVWF 0x49
0344  01CA     CLRF cntr
0345  086D     MOVF 0x6D, W
0346  00CB     MOVWF sign
0347  30C0     MOVLW 0xC0
0348  01CC     CLRF f2
0349  2BDB     GOTO 0x3DB
290:                               sprintf(cadenaamostrar2, cadena_esp);
291:                           }
292:                           break;
293:                       }
294:                       case MENU_CONFIGURAENCENDIDO:
295:                       {
296:           
297:                           if (flanco) {
034A  0839     MOVF 0x39, W
034B  1903     BTFSC STATUS, 0x2
034C  2CFD     GOTO 0x4FD
298:                               sprintf(cadenaamostrar, "SET ENC  ");
034D  30D3     MOVLW 0xD3
034E  1283     BCF STATUS, 0x5
034F  00C7     MOVWF f
0350  3098     MOVLW 0x98
0351  2BD9     GOTO 0x3D9
299:                               sprintf(cadenaamostrar2, cadena_esp);
300:                           }
301:           
302:                           break;
303:                       }
304:                       case SUBMENU_CONFIGURAHORAENCENDIDO:
305:                       {
306:                           modificafecha = HORA;
0352  30D7     MOVLW 0xD7
0353  01DA     CLRF c
307:                           horario = &horarioenc;
0352  30D7     MOVLW 0xD7
0354  00FD     MOVWF 0x7D
308:                           if (flanco || haycambio) {
0355  08B9     MOVF 0x39, F
0356  1903     BTFSC STATUS, 0x2
0357  1A7C     BTFSC bitvars9, 0x4
309:                               sprintf(cadenaamostrar, "%02d:%02d    ", horarioenc.hrs, horarioenc.min);
0358  2B6A     GOTO 0x36A
310:                               sprintf(cadenaamostrar2, cadena_esp);
311:                               haycambio = 0;
312:                           } else {
313:                               sprintf(cadenaamostrar, "  :%02d    ", horarioenc.min);
0359  309C     MOVLW 0x9C
035A  1283     BCF STATUS, 0x5
035B  00C7     MOVWF f
035C  3098     MOVLW 0x98
035D  00C8     MOVWF 0x48
035E  1683     BSF STATUS, 0x5
035F  0858     MOVF 0x58, W
0360  2B7E     GOTO 0x37E
314:                               sprintf(cadenaamostrar2, cadena_esp);
315:                           }
316:           
317:                           break;
318:                       }
319:                       case SUBMENU_CONFIGURAMINUTOSENCENDIDO:
0361  30D7     MOVLW 0xD7
320:                       {
321:                           modificafecha = MINUTOS;
0362  01DA     CLRF c
0363  0ADA     INCF c, F
322:                           horario = &horarioenc;
0361  30D7     MOVLW 0xD7
0364  00FD     MOVWF 0x7D
323:                           if (flanco || haycambio) {
0365  08B9     MOVF 0x39, F
0366  1D03     BTFSS STATUS, 0x2
0367  2B6A     GOTO 0x36A
0368  1E7C     BTFSS bitvars9, 0x4
0369  2B77     GOTO 0x377
324:                               sprintf(cadenaamostrar, "%02d:%02d    ", horarioenc.hrs, horarioenc.min);
036A  3058     MOVLW 0x58
036B  1283     BCF STATUS, 0x5
036C  00C7     MOVWF f
036D  3098     MOVLW 0x98
036E  00C8     MOVWF 0x48
036F  1683     BSF STATUS, 0x5
0370  0859     MOVF exp, W
0371  1283     BCF STATUS, 0x5
0372  00C9     MOVWF 0x49
0373  01CA     CLRF cntr
0374  1683     BSF STATUS, 0x5
0375  0858     MOVF 0x58, W
0376  2AB7     GOTO 0x2B7
325:                               sprintf(cadenaamostrar2, cadena_esp);
326:                               haycambio = 0;
327:                           } else {
328:                               sprintf(cadenaamostrar, "%02d:      ", horarioenc.hrs);
0377  3090     MOVLW 0x90
0378  1283     BCF STATUS, 0x5
0379  00C7     MOVWF f
037A  3098     MOVLW 0x98
037B  00C8     MOVWF 0x48
037C  1683     BSF STATUS, 0x5
037D  0859     MOVF exp, W
037E  1283     BCF STATUS, 0x5
037F  00C9     MOVWF 0x49
0380  30C0     MOVLW 0xC0
0381  01CA     CLRF cntr
0382  2BDB     GOTO 0x3DB
329:                               sprintf(cadenaamostrar2, cadena_esp);
330:                           }
331:                           break;
332:                       }
333:           
334:           
335:                       case SUBMENU_CONFIGURAPERIODOENCENDIDO:
336:                       {
337:                           modificafecha = PERIODOENCENDIDO;
0383  3009     MOVLW 0x9
0384  00DA     MOVWF c
338:           
339:                           if (flanco || haycambio) {
0385  08B9     MOVF 0x39, F
0386  1D03     BTFSS STATUS, 0x2
0387  2B8A     GOTO 0x38A
0388  1E7C     BTFSS bitvars9, 0x4
0389  2B92     GOTO 0x392
340:                               sprintf(cadenaamostrar, "c/%u dias", periodoencendido);
038A  3005     MOVLW 0x5
038B  1283     BCF STATUS, 0x5
038C  00C7     MOVWF f
038D  3099     MOVLW 0x99
038E  00C8     MOVWF 0x48
038F  1683     BSF STATUS, 0x5
0390  085B     MOVF sp, W
0391  2BBA     GOTO 0x3BA
341:                               sprintf(cadenaamostrar2, cadena_esp);
342:                               haycambio = 0;
343:                           } else {
344:                               sprintf(cadenaamostrar, "c/  dias");
0392  3033     MOVLW 0x33
0393  1283     BCF STATUS, 0x5
0394  00C7     MOVWF f
0395  3099     MOVLW 0x99
0396  2BD9     GOTO 0x3D9
345:                               sprintf(cadenaamostrar2, cadena_esp);
346:                           }
347:                           break;
348:                       }
349:           
350:                       case SUBMENU_CONFIGURATIEMPOENCENDIDO:
351:                       {
352:                           modificafecha = TIEMPOENCENDIDO;
0397  3007     MOVLW 0x7
0398  00DA     MOVWF c
353:           
354:                           if (flanco || haycambio) {
0399  08B9     MOVF 0x39, F
039A  1D03     BTFSS STATUS, 0x2
039B  2B9E     GOTO 0x39E
039C  1E7C     BTFSS bitvars9, 0x4
039D  2BA6     GOTO 0x3A6
355:                               sprintf(cadenaamostrar, "ENCEN:%02d", tiempoencendido);
039E  30BE     MOVLW 0xBE
039F  1283     BCF STATUS, 0x5
03A0  00C7     MOVWF f
03A1  3098     MOVLW 0x98
03A2  00C8     MOVWF 0x48
03A3  1683     BSF STATUS, 0x5
03A4  083C     MOVF 0x3C, W
03A5  2BBA     GOTO 0x3BA
356:                               sprintf(cadenaamostrar2, cadena_esp);
357:                               haycambio = 0;
358:                           } else {
359:                               sprintf(cadenaamostrar, "ENCEN:  ");
03A6  3021     MOVLW 0x21
03A7  1283     BCF STATUS, 0x5
03A8  00C7     MOVWF f
03A9  3099     MOVLW 0x99
03AA  2BD9     GOTO 0x3D9
360:                               sprintf(cadenaamostrar2, cadena_esp);
361:                           }
362:                           break;
363:                       }
364:                       case MENU_CONFIGURAFALLACORRIENTE:
365:                       {
366:                           modificafecha = SINO;
03AB  2BC4     GOTO 0x3C4
367:           
368:                           if (flanco)
369:                               if (banderasino) {
370:                                   sprintf(cadenaamostrar, "NORMAL A ");
371:                                   sprintf(cadenaamostrar2, cadena_esp);
372:                               } else {
373:                                   sprintf(cadenaamostrar, "NORMAL C ");
374:                                   sprintf(cadenaamostrar2, cadena_esp);
375:                               } else {
376:                               sprintf(cadenaamostrar, "NORMAL   ");
377:                               sprintf(cadenaamostrar2, cadena_esp);
378:                           }
379:                           break;
380:                       }
381:                       case MENU_CONFIGURATIEMPOFALLACORRIENTE:
382:                       {
383:                           modificafecha = TIEMPOFALLA;
03AC  3008     MOVLW 0x8
03AD  00DA     MOVWF c
384:           
385:                           if (flanco || haycambio) {
03AE  08B9     MOVF 0x39, F
03AF  1D03     BTFSS STATUS, 0x2
03B0  2BB3     GOTO 0x3B3
03B1  1E7C     BTFSS bitvars9, 0x4
03B2  2BBF     GOTO 0x3BF
386:                               sprintf(cadenaamostrar, "FALLA:%02d", tiempofalla);
03B3  30B3     MOVLW 0xB3
03B4  1283     BCF STATUS, 0x5
03B5  00C7     MOVWF f
03B6  3098     MOVLW 0x98
03B7  00C8     MOVWF 0x48
03B8  1683     BSF STATUS, 0x5
03B9  083D     MOVF f1, W
03BA  1283     BCF STATUS, 0x5
03BB  00C9     MOVWF 0x49
03BC  30C0     MOVLW 0xC0
03BD  01CA     CLRF cntr
03BE  2ABB     GOTO 0x2BB
387:                               sprintf(cadenaamostrar2, cadena_esp);
388:                               haycambio = 0;
389:                           } else {
390:                               sprintf(cadenaamostrar, "FALLA:  ");
03BF  3018     MOVLW 0x18
03C0  1283     BCF STATUS, 0x5
03C1  00C7     MOVWF f
03C2  3099     MOVLW 0x99
03C3  2BD9     GOTO 0x3D9
391:                               sprintf(cadenaamostrar2, cadena_esp);
392:                           }
393:                           break;
394:                       }
395:                       case MENU_CONFIGURAINDICACIONDENIVEL:
396:                       {
397:                           modificafecha = SINO;
03C4  3006     MOVLW 0x6
03C5  00DA     MOVWF c
398:           
399:           
400:                           if (flanco)
03C6  0839     MOVF 0x39, W
03C7  1903     BTFSC STATUS, 0x2
03C8  2BD5     GOTO 0x3D5
401:                               if (banderasino) {
03C9  1D7C     BTFSS bitvars9, 0x2
03CA  2BD0     GOTO 0x3D0
402:                                   sprintf(cadenaamostrar, "NORMAL A ");
03CB  30DD     MOVLW 0xDD
03CC  1283     BCF STATUS, 0x5
03CD  00C7     MOVWF f
03CE  3098     MOVLW 0x98
03CF  2BD9     GOTO 0x3D9
403:                                   sprintf(cadenaamostrar2, cadena_esp);
404:                               } else {
405:                                   sprintf(cadenaamostrar, "NORMAL C ");
03D0  30F1     MOVLW 0xF1
03D1  1283     BCF STATUS, 0x5
03D2  00C7     MOVWF f
03D3  3098     MOVLW 0x98
03D4  2BD9     GOTO 0x3D9
406:                                   sprintf(cadenaamostrar2, cadena_esp);
407:                               } else {
408:                               sprintf(cadenaamostrar, "NORMAL   ");
03D5  30C9     MOVLW 0xC9
03D6  1283     BCF STATUS, 0x5
03D7  00C7     MOVWF f
03D8  3098     MOVLW 0x98
03D9  00C8     MOVWF 0x48
03DA  30C0     MOVLW 0xC0
03DB  120A     BCF PCLATH, 0x4
03DC  118A     BCF PCLATH, 0x3
03DD  25C7     CALL 0x5C7
03DE  120A     BCF PCLATH, 0x4
03DF  118A     BCF PCLATH, 0x3
409:                               sprintf(cadenaamostrar2, cadena_esp);
03E0  3031     MOVLW 0x31
03E1  00C7     MOVWF f
03E2  3098     MOVLW 0x98
03E3  00C8     MOVWF 0x48
03E4  2CE6     GOTO 0x4E6
410:                           }
411:           
412:                           break;
413:                       }
414:                       case MENU_MUESTRAMEDICIONES:
415:                       {
416:                           unsigned int adcenteroI;
417:                           unsigned int adcdecimalI;
418:                           unsigned int adcenteroV;
419:                           mediciondecorriente = (float) medidaI_adc * 50 / 1024;
03E5  1283     BCF STATUS, 0x5
03E6  3080     MOVLW 0x80
03E7  01CC     CLRF f2
03E8  00CD     MOVWF 0x4D
03E9  3044     MOVLW 0x44
03EA  00CE     MOVWF 0x4E
03EB  3048     MOVLW 0x48
03EC  01BD     CLRF f1
03ED  00BE     MOVWF 0x3E
03EE  3042     MOVLW 0x42
03EF  00BF     MOVWF 0x3F
03F0  1683     BSF STATUS, 0x5
03F1  082E     MOVF sign, W
03F2  1283     BCF STATUS, 0x5
03F3  00B1     MOVWF divisor
03F4  1683     BSF STATUS, 0x5
03F5  082D     MOVF day, W
03F6  1283     BCF STATUS, 0x5
03F7  00B0     MOVWF c
03F8  160A     BSF PCLATH, 0x4
03F9  118A     BCF PCLATH, 0x3
03FA  25F9     CALL 0x5F9
03FB  120A     BCF PCLATH, 0x4
03FC  118A     BCF PCLATH, 0x3
03FD  0830     MOVF c, W
03FE  00C0     MOVWF f2
03FF  0831     MOVF divisor, W
0400  00C1     MOVWF 0x41
0401  0832     MOVF 0x32, W
0402  00C2     MOVWF m
0403  160A     BSF PCLATH, 0x4
0404  118A     BCF PCLATH, 0x3
0405  2687     CALL 0x687
0406  120A     BCF PCLATH, 0x4
0407  118A     BCF PCLATH, 0x3
0408  083D     MOVF f1, W
0409  00CF     MOVWF f1
040A  083E     MOVF 0x3E, W
040B  00D0     MOVWF 0x50
040C  083F     MOVF 0x3F, W
040D  00D1     MOVWF 0x51
040E  160A     BSF PCLATH, 0x4
040F  118A     BCF PCLATH, 0x3
0410  261F     CALL 0x61F
0411  120A     BCF PCLATH, 0x4
0412  118A     BCF PCLATH, 0x3
0413  084C     MOVF f2, W
0414  1683     BSF STATUS, 0x5
0415  00AA     MOVWF Data
0416  1283     BCF STATUS, 0x5
0417  084D     MOVF 0x4D, W
0418  1683     BSF STATUS, 0x5
0419  00AB     MOVWF sec
041A  1283     BCF STATUS, 0x5
041B  084E     MOVF 0x4E, W
041C  1683     BSF STATUS, 0x5
041D  00AC     MOVWF hr
420:                           //convierto el valor decimal a float
421:                           //para una entrada de 3.3V la lectura es 1023
422:                           //para 0 V la lectura es 0
423:                           //para una maxima lectura quiero que en el display se observe 50A
424:                           //Deseo que tambien me muestre 1 decimal, separo la parte entera y la decimal
425:                           //como la resolucion es 1024, cada bit corresponde a 50A/1024=0.048828125A
426:                           //cada 20 muestras tengo aproximdamente 1A
427:                           float mediciondevoltaje = (float) medidaV_adc * 440 / 1024;
041E  1283     BCF STATUS, 0x5
041F  3080     MOVLW 0x80
0420  01CC     CLRF f2
0421  00CD     MOVWF 0x4D
0422  3044     MOVLW 0x44
0423  00CE     MOVWF 0x4E
0424  30DC     MOVLW 0xDC
0425  01BD     CLRF f1
0426  00BE     MOVWF 0x3E
0427  3043     MOVLW 0x43
0428  00BF     MOVWF 0x3F
0429  1683     BSF STATUS, 0x5
042A  0830     MOVF c, W
042B  1283     BCF STATUS, 0x5
042C  00B1     MOVWF divisor
042D  1683     BSF STATUS, 0x5
042E  082F     MOVF quotient, W
042F  1283     BCF STATUS, 0x5
0430  00B0     MOVWF c
0431  160A     BSF PCLATH, 0x4
0432  118A     BCF PCLATH, 0x3
0433  25F9     CALL 0x5F9
0434  120A     BCF PCLATH, 0x4
0435  118A     BCF PCLATH, 0x3
0436  0830     MOVF c, W
0437  00C0     MOVWF f2
0438  0831     MOVF divisor, W
0439  00C1     MOVWF 0x41
043A  0832     MOVF 0x32, W
043B  00C2     MOVWF m
043C  160A     BSF PCLATH, 0x4
043D  118A     BCF PCLATH, 0x3
043E  2687     CALL 0x687
043F  120A     BCF PCLATH, 0x4
0440  118A     BCF PCLATH, 0x3
0441  083D     MOVF f1, W
0442  00CF     MOVWF f1
0443  083E     MOVF 0x3E, W
0444  00D0     MOVWF 0x50
0445  083F     MOVF 0x3F, W
0446  00D1     MOVWF 0x51
0447  160A     BSF PCLATH, 0x4
0448  118A     BCF PCLATH, 0x3
0449  261F     CALL 0x61F
044A  120A     BCF PCLATH, 0x4
044B  118A     BCF PCLATH, 0x3
044C  084C     MOVF f2, W
044D  00DF     MOVWF mediciondevoltaje
044E  084D     MOVF 0x4D, W
044F  00E0     MOVWF 0x60
0450  084E     MOVF 0x4E, W
0451  00E1     MOVWF 0x61
428:                           adcenteroI = (unsigned int) mediciondecorriente;
0452  1683     BSF STATUS, 0x5
0453  082A     MOVF Data, W
0454  1283     BCF STATUS, 0x5
0455  00A3     MOVWF x
0456  1683     BSF STATUS, 0x5
0457  082B     MOVF sec, W
0458  1283     BCF STATUS, 0x5
0459  00A4     MOVWF dato
045A  1683     BSF STATUS, 0x5
045B  082C     MOVF hr, W
045C  1283     BCF STATUS, 0x5
045D  00A5     MOVWF y
045E  120A     BCF PCLATH, 0x4
045F  158A     BSF PCLATH, 0x3
0460  2026     CALL 0x26
0461  120A     BCF PCLATH, 0x4
0462  118A     BCF PCLATH, 0x3
0463  0824     MOVF dato, W
0464  00E6     MOVWF 0x66
0465  0823     MOVF x, W
0466  00E5     MOVWF adcenteroI
429:                           adcdecimalI = (unsigned int) ((mediciondecorriente - (unsigned int) mediciondecorriente)*10);
0467  1683     BSF STATUS, 0x5
0468  082A     MOVF Data, W
0469  1283     BCF STATUS, 0x5
046A  00BA     MOVWF f1
046B  1683     BSF STATUS, 0x5
046C  082B     MOVF sec, W
046D  1283     BCF STATUS, 0x5
046E  00BB     MOVWF 0x3B
046F  1683     BSF STATUS, 0x5
0470  082C     MOVF hr, W
0471  1283     BCF STATUS, 0x5
0472  00BC     MOVWF 0x3C
0473  1683     BSF STATUS, 0x5
0474  082A     MOVF Data, W
0475  1283     BCF STATUS, 0x5
0476  00A3     MOVWF x
0477  1683     BSF STATUS, 0x5
0478  082B     MOVF sec, W
0479  1283     BCF STATUS, 0x5
047A  00A4     MOVWF dato
047B  1683     BSF STATUS, 0x5
047C  082C     MOVF hr, W
047D  1283     BCF STATUS, 0x5
047E  00A5     MOVWF y
047F  120A     BCF PCLATH, 0x4
0480  158A     BSF PCLATH, 0x3
0481  2026     CALL 0x26
0482  120A     BCF PCLATH, 0x4
0483  118A     BCF PCLATH, 0x3
0484  0824     MOVF dato, W
0485  00B1     MOVWF divisor
0486  0823     MOVF x, W
0487  00B0     MOVWF c
0488  160A     BSF PCLATH, 0x4
0489  118A     BCF PCLATH, 0x3
048A  25F9     CALL 0x5F9
048B  120A     BCF PCLATH, 0x4
048C  118A     BCF PCLATH, 0x3
048D  0830     MOVF c, W
048E  00B7     MOVWF mes
048F  0831     MOVF divisor, W
0490  00B8     MOVWF anio
0491  0832     MOVF 0x32, W
0492  00B9     MOVWF 0x39
0493  160A     BSF PCLATH, 0x4
0494  118A     BCF PCLATH, 0x3
0495  2609     CALL 0x609
0496  120A     BCF PCLATH, 0x4
0497  118A     BCF PCLATH, 0x3
0498  0837     MOVF mes, W
0499  00C0     MOVWF f2
049A  0838     MOVF anio, W
049B  00C1     MOVWF 0x41
049C  0839     MOVF 0x39, W
049D  00C2     MOVWF m
049E  3020     MOVLW 0x20
049F  01BD     CLRF f1
04A0  00BE     MOVWF 0x3E
04A1  3041     MOVLW 0x41
04A2  00BF     MOVWF 0x3F
04A3  160A     BSF PCLATH, 0x4
04A4  118A     BCF PCLATH, 0x3
04A5  2687     CALL 0x687
04A6  120A     BCF PCLATH, 0x4
04A7  118A     BCF PCLATH, 0x3
04A8  083D     MOVF f1, W
04A9  00E2     MOVWF 0x62
04AA  083E     MOVF 0x3E, W
04AB  00E3     MOVWF 0x63
04AC  083F     MOVF 0x3F, W
04AD  00E4     MOVWF 0x64
04AE  0862     MOVF 0x62, W
04AF  00A3     MOVWF x
04B0  0863     MOVF 0x63, W
04B1  00A4     MOVWF dato
04B2  0864     MOVF 0x64, W
04B3  00A5     MOVWF y
04B4  120A     BCF PCLATH, 0x4
04B5  158A     BSF PCLATH, 0x3
04B6  2026     CALL 0x26
04B7  120A     BCF PCLATH, 0x4
04B8  118A     BCF PCLATH, 0x3
04B9  0824     MOVF dato, W
04BA  00E8     MOVWF 0x68
04BB  0823     MOVF x, W
04BC  00E7     MOVWF adcdecimalI
430:                           adcenteroV = (unsigned int) mediciondevoltaje;
04BD  085F     MOVF mediciondevoltaje, W
04BE  00A3     MOVWF x
04BF  0860     MOVF 0x60, W
04C0  00A4     MOVWF dato
04C1  0861     MOVF 0x61, W
04C2  00A5     MOVWF y
04C3  120A     BCF PCLATH, 0x4
04C4  158A     BSF PCLATH, 0x3
04C5  2026     CALL 0x26
04C6  120A     BCF PCLATH, 0x4
04C7  118A     BCF PCLATH, 0x3
04C8  0824     MOVF dato, W
04C9  00EA     MOVWF 0x6A
04CA  0823     MOVF x, W
04CB  00E9     MOVWF adcenteroV
431:                           sprintf(cadenaamostrar, "%2u.%uA   ", (unsigned int) adcenteroI, (unsigned int) adcdecimalI);
04CC  30A8     MOVLW 0xA8
04CD  00C7     MOVWF f
04CE  3098     MOVLW 0x98
04CF  00C8     MOVWF 0x48
04D0  0866     MOVF 0x66, W
04D1  00CA     MOVWF cntr
04D2  0865     MOVF adcenteroI, W
04D3  00C9     MOVWF 0x49
04D4  0868     MOVF 0x68, W
04D5  00CC     MOVWF f2
04D6  0867     MOVF adcdecimalI, W
04D7  00CB     MOVWF sign
04D8  30C0     MOVLW 0xC0
04D9  120A     BCF PCLATH, 0x4
04DA  118A     BCF PCLATH, 0x3
04DB  25C7     CALL 0x5C7
04DC  120A     BCF PCLATH, 0x4
04DD  118A     BCF PCLATH, 0x3
432:                           sprintf(cadenaamostrar2, "%3uV    ", (unsigned int) adcenteroV);
04DE  300F     MOVLW 0xF
04DF  00C7     MOVWF f
04E0  3099     MOVLW 0x99
04E1  00C8     MOVWF 0x48
04E2  086A     MOVF 0x6A, W
04E3  00CA     MOVWF cntr
04E4  0869     MOVF adcenteroV, W
04E5  00C9     MOVWF 0x49
04E6  30C8     MOVLW 0xC8
04E7  120A     BCF PCLATH, 0x4
04E8  118A     BCF PCLATH, 0x3
04E9  25C7     CALL 0x5C7
04EA  120A     BCF PCLATH, 0x4
04EB  118A     BCF PCLATH, 0x3
433:                           break;
04EC  1683     BSF STATUS, 0x5
04ED  2CFD     GOTO 0x4FD
434:                       }
435:                       default:
436:                           break;
437:                   };
438:                   //////////////////////////////////////////////////////////
439:                   //Finaliza Procesa los men
440:           
441:                   //Verifica estados de falla
442:                   /////////////////////////////////////////////////////////
443:                   switch (estadobomba) {
04FD  3000     MOVLW 0x0
04FE  3A00     XORLW 0x0
04FF  1903     BTFSC STATUS, 0x2
0500  2D02     GOTO 0x502
0501  2D0A     GOTO 0x50A
0502  3000     MOVLW 0x0
0503  3A00     XORLW 0x0
0504  1903     BTFSC STATUS, 0x2
0505  2D0A     GOTO 0x50A
0506  3A01     XORLW 0x1
0507  1903     BTFSC STATUS, 0x2
0508  2D0A     GOTO 0x50A
0509  2D0A     GOTO 0x50A
444:                       case BOMBAAPAGADA:
445:                       {
446:           
447:                           break;
448:                       }
449:                       case BOMBAENCENDIDA:
450:                       {
451:           
452:                           break;
453:                       }
454:                       default:
455:                           break;
456:                   }
457:                   switch (estadonivel) {
050A  3000     MOVLW 0x0
050B  3A00     XORLW 0x0
050C  1903     BTFSC STATUS, 0x2
050D  2D0F     GOTO 0x50F
050E  2D17     GOTO 0x517
050F  3000     MOVLW 0x0
0510  3A00     XORLW 0x0
0511  1903     BTFSC STATUS, 0x2
0512  2D17     GOTO 0x517
0513  3A01     XORLW 0x1
0514  1903     BTFSC STATUS, 0x2
0515  2D17     GOTO 0x517
0516  2D17     GOTO 0x517
458:                       case NIVELNORMAL:
459:                       {
460:           
461:                           break;
462:                       }
463:                       case NIVELBAJO:
464:                       {
465:           
466:                           break;
467:                       }
468:                       default:
469:                           break;
470:                   }
471:           
472:                   switch (estadofallacorriente) {
0517  3000     MOVLW 0x0
0518  3A00     XORLW 0x0
0519  1903     BTFSC STATUS, 0x2
051A  2D1C     GOTO 0x51C
051B  2D24     GOTO 0x524
051C  3000     MOVLW 0x0
051D  3A00     XORLW 0x0
051E  1903     BTFSC STATUS, 0x2
051F  2D24     GOTO 0x524
0520  3A01     XORLW 0x1
0521  1903     BTFSC STATUS, 0x2
0522  2D24     GOTO 0x524
0523  2D24     GOTO 0x524
473:                       case CORRIENTENORMAL:
474:                       {
475:                           break;
476:                       }
477:                       case FALLACORRIENTE:
478:                       {
479:                           break;
480:                       }
481:                       default:
482:                           break;
483:                   }
484:                   switch (estadofallavoltaje) {
0524  3000     MOVLW 0x0
0525  3A00     XORLW 0x0
0526  1903     BTFSC STATUS, 0x2
0527  2D29     GOTO 0x529
0528  2D37     GOTO 0x537
0529  3000     MOVLW 0x0
052A  3A00     XORLW 0x0
052B  1903     BTFSC STATUS, 0x2
052C  2D37     GOTO 0x537
052D  3A01     XORLW 0x1
052E  1903     BTFSC STATUS, 0x2
052F  2D37     GOTO 0x537
0530  2D37     GOTO 0x537
485:                       case VOLTAJENORMAL:
486:                       {
487:                           break;
488:                       }
489:                       case FALLAVOLTAJE:
490:                       {
491:                           break;
492:                       }
493:                       default:
494:                           break;
495:                   }
496:                   //////////////////////////////////////////////////////
497:                   //Fin Verifica estados de falla
498:           
499:                   //Activa o desactiva la Bomba
500:                   ///////////////////////////////////////////////////////
501:                   switch (activabomba) {
0537  3000     MOVLW 0x0
0538  3A00     XORLW 0x0
0539  1903     BTFSC STATUS, 0x2
053A  2D3C     GOTO 0x53C
053B  2D44     GOTO 0x544
053C  3000     MOVLW 0x0
053D  3A00     XORLW 0x0
053E  1903     BTFSC STATUS, 0x2
053F  2D34     GOTO 0x534
0540  3A01     XORLW 0x1
0541  1903     BTFSC STATUS, 0x2
0542  2D31     GOTO 0x531
0543  2D44     GOTO 0x544
502:                       case ENCIENDEBOMBA:
503:                       {
504:                           salidabomba = 1;
0531  1283     BCF STATUS, 0x5
0532  1407     BSF PORTC, 0x0
505:                           break;
0533  2D44     GOTO 0x544
506:                       }
507:                       case APAGABOMBA:
508:                       {
509:                           salidabomba = 0;
0534  1283     BCF STATUS, 0x5
0535  1007     BCF PORTC, 0x0
510:                           break;
0536  2D44     GOTO 0x544
511:                       }
512:                       default:
513:                           break;
514:                   }
515:                   //////////////////////////////////////////////////////
516:                   //Fin Activa o desactiva la Bomba
517:           
518:                   //Actualiza Display
519:                   /////////////////////////////////////////////
520:                   if (refrescadisplay) {
0544  1EFC     BTFSS bitvars9, 0x5
0545  2D83     GOTO 0x583
521:                       vGotoxyLCD(1, 1);
0546  1283     BCF STATUS, 0x5
0547  3001     MOVLW 0x1
0548  01A5     CLRF y
0549  0AA5     INCF y, F
054A  160A     BSF PCLATH, 0x4
054B  118A     BCF PCLATH, 0x3
054C  2496     CALL 0x496
054D  120A     BCF PCLATH, 0x4
054E  118A     BCF PCLATH, 0x3
522:                       cadena = cadenaamostrar;
054F  30C0     MOVLW 0xC0
0550  1683     BSF STATUS, 0x5
0551  00BF     MOVWF 0x3F
523:                       while (*cadena != '\0')
0552  083F     MOVF 0x3F, W
0553  0084     MOVWF FSR
0554  1383     BCF STATUS, 0x7
0555  0880     MOVF INDF, F
0556  1903     BTFSC STATUS, 0x2
0557  2D64     GOTO 0x564
0563  2D52     GOTO 0x552
524:                           vLCD_Putc(*cadena++);
0558  083F     MOVF 0x3F, W
0559  0084     MOVWF FSR
055A  0800     MOVF INDF, W
055B  160A     BSF PCLATH, 0x4
055C  118A     BCF PCLATH, 0x3
055D  24B9     CALL 0x4B9
055E  120A     BCF PCLATH, 0x4
055F  118A     BCF PCLATH, 0x3
0560  1683     BSF STATUS, 0x5
0561  1303     BCF STATUS, 0x6
0562  0ABF     INCF 0x3F, F
525:                       vGotoxyLCD(1, 2);
0564  3002     MOVLW 0x2
0565  1283     BCF STATUS, 0x5
0566  00A5     MOVWF y
0567  3001     MOVLW 0x1
0568  160A     BSF PCLATH, 0x4
0569  118A     BCF PCLATH, 0x3
056A  2496     CALL 0x496
056B  120A     BCF PCLATH, 0x4
056C  118A     BCF PCLATH, 0x3
526:                       cadena = cadenaamostrar2;
056D  30C8     MOVLW 0xC8
056E  1683     BSF STATUS, 0x5
056F  00BF     MOVWF 0x3F
527:                       while (*cadena != '\0')
0570  083F     MOVF 0x3F, W
0571  0084     MOVWF FSR
0572  1383     BCF STATUS, 0x7
0573  0880     MOVF INDF, F
0574  1903     BTFSC STATUS, 0x2
0575  2D82     GOTO 0x582
0581  2D70     GOTO 0x570
528:                           vLCD_Putc(*cadena++);
0576  083F     MOVF 0x3F, W
0577  0084     MOVWF FSR
0578  0800     MOVF INDF, W
0579  160A     BSF PCLATH, 0x4
057A  118A     BCF PCLATH, 0x3
057B  24B9     CALL 0x4B9
057C  120A     BCF PCLATH, 0x4
057D  118A     BCF PCLATH, 0x3
057E  1683     BSF STATUS, 0x5
057F  1303     BCF STATUS, 0x6
0580  0ABF     INCF 0x3F, F
529:           
530:                       refrescadisplay = 0;
0582  12FC     BCF bitvars9, 0x5
531:                   }
532:                   ////////////////////////////////////////////////
533:                   //Fin Actualiza Display
534:           
535:                   //Graba Nuevos datos en el RC
536:                   /////////////////////////////////////////////////
537:                   if (bandera_startglobal) {
0583  18FC     BTFSC bitvars9, 0x1
538:                       bandera_grabafechay_hora = 1;
0584  147C     BSF bitvars9, 0x0
539:           
540:                   }
541:                   if (!bandera_startglobal && bandera_grabafechay_hora) {
0585  1CFC     BTFSS bitvars9, 0x1
0586  1C7C     BTFSS bitvars9, 0x0
0587  2DC4     GOTO 0x5C4
542:                       if (horario == &horarioactual) {
0588  087D     MOVF 0x7D, W
0589  3AD4     XORLW 0xD4
058A  1D03     BTFSS STATUS, 0x2
058B  2DA9     GOTO 0x5A9
543:                           isl1208_set_time((*horario).hrs, (*horario).min, 00);
058C  0A7D     INCF 0x7D, W
058D  0084     MOVWF FSR
058E  1383     BCF STATUS, 0x7
058F  0800     MOVF INDF, W
0590  1283     BCF STATUS, 0x5
0591  00AA     MOVWF Data
0592  01AB     CLRF sec
0593  087D     MOVF 0x7D, W
0594  3E02     ADDLW 0x2
0595  0084     MOVWF FSR
0596  0800     MOVF INDF, W
0597  120A     BCF PCLATH, 0x4
0598  158A     BSF PCLATH, 0x3
0599  22A2     CALL 0x2A2
059A  120A     BCF PCLATH, 0x4
059B  118A     BCF PCLATH, 0x3
544:                           isl1208_set_date(&fecha.day, &fecha.month, &fecha.yr, &fecha.dow);
059C  306D     MOVLW 0x6D
059D  1283     BCF STATUS, 0x5
059E  00AA     MOVWF Data
059F  306E     MOVLW 0x6E
05A0  00AB     MOVWF sec
05A1  306F     MOVLW 0x6F
05A2  00AC     MOVWF hr
05A3  306C     MOVLW 0x6C
05A4  120A     BCF PCLATH, 0x4
05A5  158A     BSF PCLATH, 0x3
05A6  22DE     CALL 0x2DE
05A7  120A     BCF PCLATH, 0x4
05A8  118A     BCF PCLATH, 0x3
545:                       }
546:                       if (horario == &horarioenc) {
05A9  087D     MOVF 0x7D, W
05AA  3AD7     XORLW 0xD7
05AB  1D03     BTFSS STATUS, 0x2
05AC  2DC3     GOTO 0x5C3
547:                           isl1208_set_time_enc((*horario).hrs, (*horario).min, 00);
05AD  0A7D     INCF 0x7D, W
05AE  0084     MOVWF FSR
05AF  1383     BCF STATUS, 0x7
05B0  0800     MOVF INDF, W
05B1  1283     BCF STATUS, 0x5
05B2  00AA     MOVWF Data
05B3  01AB     CLRF sec
05B4  087D     MOVF 0x7D, W
05B5  3E02     ADDLW 0x2
05B6  0084     MOVWF FSR
05B7  0800     MOVF INDF, W
05B8  120A     BCF PCLATH, 0x4
05B9  158A     BSF PCLATH, 0x3
05BA  2279     CALL 0x279
05BB  120A     BCF PCLATH, 0x4
05BC  118A     BCF PCLATH, 0x3
548:                           //isl1208_set_date(&fecha.day, &fecha.month, &fecha.yr, &fecha.dow);
549:                           isl1208_set_dow_enc(&fechaenc.dow);
05BD  30D3     MOVLW 0xD3
05BE  120A     BCF PCLATH, 0x4
05BF  158A     BSF PCLATH, 0x3
05C0  225B     CALL 0x25B
05C1  120A     BCF PCLATH, 0x4
05C2  118A     BCF PCLATH, 0x3
550:                       }
551:                       bandera_grabafechay_hora = 0;
05C3  107C     BCF bitvars9, 0x0
552:                   }
553:                   //////////////////////////////////////////////////////////////////
554:                   //Finaliza Graba Nuevos datos en el RC
555:                   NOP();
05C4  0000     NOP
556:                   NOP();
05C5  0000     NOP
557:           
558:               }
559:           }
560:           
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/interrupts.c  -------------------------
1:             
2:             /******************************************************************************/
3:             /*Files to Include                                                            */
4:             /******************************************************************************/
5:             
6:             #if defined(__XC)
7:             #include <xc.h>         /* XC8 General Include File */
8:             #elif defined(HI_TECH_C)
9:             #include <htc.h>        /* HiTech General Include File */
10:            #endif
11:            #include <stdbool.h>        /* For true/false definition */
12:            #include <stdint.h>
13:            #include "user.h"
14:            #include "system.h"
15:            
16:            #include "Pulsadores.h"
17:            #include "pwm.h"
18:            #include "adcPic16.h"
19:            #include "_isl1208.h"
20:            /* Interrupt Routines                                                         */
21:            /******************************************************************************/
22:            
23:            /* Baseline devices don't have interrupts. Note that some PIC16's 
24:             * are baseline devices.  Unfortunately the baseline detection macro is 
25:             * _PIC12 */
26:            #ifndef _PIC18
27:            #ifndef _PIC12
28:            
29:            void interrupt isr(void) {
0004  00FE     MOVWF 0x7E
0005  0E03     SWAPF STATUS, W
0006  1283     BCF STATUS, 0x5
0007  1303     BCF STATUS, 0x6
0008  00A0     MOVWF 0x20
0009  0804     MOVF FSR, W
000A  00A1     MOVWF 0x21
000B  080A     MOVF PCLATH, W
000C  00A2     MOVWF 0x22
000D  120A     BCF PCLATH, 0x4
000E  158A     BSF PCLATH, 0x3
000F  2C21     GOTO 0x421
0010  120A     BCF PCLATH, 0x4
0011  118A     BCF PCLATH, 0x3
0012  2813     GOTO 0x13
30:                if (ADIF && ADIE) {
0C21  1F0C     BTFSS PIR1, 0x6
0C22  2C43     GOTO 0x443
0C23  1683     BSF STATUS, 0x5
0C24  1F0C     BTFSS PIR1, 0x6
0C25  2C43     GOTO 0x443
31:                    if (getADCChannel() == MIDECORRIENTE) {
0C26  27DB     CALL 0x7DB
0C27  120A     BCF PCLATH, 0x4
0C28  158A     BSF PCLATH, 0x3
0C29  3800     IORLW 0x0
0C2A  1D03     BTFSS STATUS, 0x2
0C2B  2C35     GOTO 0x435
32:                        medidaI_adc = adcRead();
0C2C  2797     CALL 0x797
0C2D  120A     BCF PCLATH, 0x4
0C2E  158A     BSF PCLATH, 0x3
0C2F  0871     MOVF canal, W
0C30  00AE     MOVWF sign
0C31  0870     MOVF divisor, W
0C32  00AD     MOVWF day
33:                        setADCChannel(MIDETENSION);
0C33  3001     MOVLW 0x1
0C34  2C3D     GOTO 0x43D
34:                    } else {
35:                        medidaV_adc = adcRead();
0C35  2797     CALL 0x797
0C36  120A     BCF PCLATH, 0x4
0C37  158A     BSF PCLATH, 0x3
0C38  0871     MOVF canal, W
0C39  00B0     MOVWF c
0C3A  0870     MOVF divisor, W
0C3B  00AF     MOVWF quotient
36:                        /*TODO debo realizar un promedio en las mediciones para filtrar las
37:                        variaciones rpidas de tensin*/
38:                        setADCChannel(MIDECORRIENTE);
0C3C  3000     MOVLW 0x0
0C3D  27F4     CALL 0x7F4
0C3E  120A     BCF PCLATH, 0x4
0C3F  158A     BSF PCLATH, 0x3
39:                    }
40:                    ADIF = 0;
0C40  130C     BCF PIR1, 0x6
41:                    cambio_de_canal = 1;
0C41  15FC     BSF bitvars9, 0x3
42:                } else if (INTF && INTE) { // INTERRUPCION por EXT2 Clock Out --------------------------------------------
0C42  2EC6     GOTO 0x6C6
0C43  188B     BTFSC INTCON, 0x1
0C44  1E0B     BTFSS INTCON, 0x4
0C45  2C52     GOTO 0x452
43:                    if (INTEDG == 1) {
0C46  1683     BSF STATUS, 0x5
0C47  1F01     BTFSS TMR0, 0x6
0C48  2C4C     GOTO 0x44C
44:                        //      ext_int_edge(2,H_TO_L);
45:                        INTEDG = 0;
0C49  1301     BCF TMR0, 0x6
46:                        flanco = 0;
0C4A  01B9     CLRF 0x39
47:                        //PORTEbits.RE0 = 1; //output_high(PIN_E0);
48:                    } else {
0C4B  2C4F     GOTO 0x44F
49:                        //   ext_int_edge(2,L_TO_H);
50:                        INTEDG = 1;
0C4C  1701     BSF TMR0, 0x6
51:                        flanco = 1;
0C4D  01B9     CLRF 0x39
0C4E  0AB9     INCF 0x39, F
52:                        // PORTEbits.RE0 = 0; //output_low(PIN_E0);
53:                        //      flanco=1;
54:            
55:                    }
56:                    refrescadisplay = 1;
0C4F  16FC     BSF bitvars9, 0x5
57:                    INTF = 0;
0C50  108B     BCF INTCON, 0x1
58:                } else if (T0IF && T0IE) {
0C51  2EC6     GOTO 0x6C6
0C52  190B     BTFSC INTCON, 0x2
0C53  1E8B     BTFSS INTCON, 0x5
0C54  2EC6     GOTO 0x6C6
59:            
60:                    //Interrupcion por desborde del timer0. Tal como esta configurado, se el timer desborda cada
61:                    //0.003264seg o sea 3.264 ms, por lo tanto para que pase alrededor de 0.5segundo, se debe entrar 150 veces
62:                    //como con un unsigned int no funciona uso unsigned char y solo hasta 150
63:                    //cada 3ms realizamos una conversion analogica para obtener la medida de corriente
64:                    if (cambio_de_canal)
0C55  1DFC     BTFSS bitvars9, 0x3
0C56  2C59     GOTO 0x459
65:                        cambio_de_canal = 0;
0C57  11FC     BCF bitvars9, 0x3
0C58  2C5C     GOTO 0x45C
66:                    else
67:                        startADC();
0C59  27E2     CALL 0x7E2
0C5A  120A     BCF PCLATH, 0x4
0C5B  158A     BSF PCLATH, 0x3
68:                    if (cuenta40ms < 12) {
0C5C  300C     MOVLW 0xC
0C5D  1683     BSF STATUS, 0x5
0C5E  0233     SUBWF dividend, W
0C5F  1803     BTFSC STATUS, 0x0
0C60  2C63     GOTO 0x463
69:                        cuenta40ms++;
0C61  0AB3     INCF dividend, F
70:                    } else {
0C62  2CB2     GOTO 0x4B2
71:                        cuenta40ms = 0;
0C63  01B3     CLRF dividend
72:                        if (activapwmpor > 0) {
0C64  0832     MOVF 0x32, W
0C65  1903     BTFSC STATUS, 0x2
0C66  2C69     GOTO 0x469
73:                            activapwmpor--;
0C67  03B2     DECF 0x32, F
74:                        } else {
0C68  2C6E     GOTO 0x46E
75:                            buzzer_off();
0C69  27E5     CALL 0x7E5
0C6A  120A     BCF PCLATH, 0x4
0C6B  158A     BSF PCLATH, 0x3
76:                            activapwmpor = 0;
0C6C  1683     BSF STATUS, 0x5
0C6D  01B2     CLRF 0x32
77:                        }
78:                        if (cuenta500ms < 11) {
0C6E  300B     MOVLW 0xB
0C6F  0234     SUBWF sign, W
0C70  1803     BTFSC STATUS, 0x0
0C71  2C74     GOTO 0x474
79:                            cuenta500ms++;
0C72  0AB4     INCF sign, F
80:            
81:            
82:                        } else {
0C73  2CB2     GOTO 0x4B2
83:            
84:                            cuenta500ms = 0;
0C74  3000     MOVLW 0x0
0C75  01B4     CLRF sign
85:                            flanco = !flanco;
0C74  3000     MOVLW 0x0
0C76  08B9     MOVF 0x39, F
0C77  1903     BTFSC STATUS, 0x2
0C78  3001     MOVLW 0x1
0C79  00B9     MOVWF 0x39
86:                            refrescadisplay = 1;
0C7B  16FC     BSF bitvars9, 0x5
87:                            if (cuentasegundos < 60) {
0C7A  303C     MOVLW 0x3C
0C7C  0238     SUBWF anio, W
0C7D  1803     BTFSC STATUS, 0x0
0C7E  2C81     GOTO 0x481
88:            
89:                                cuentasegundos++;
0C7F  0AB8     INCF anio, F
90:                            } else {
0C80  2CB2     GOTO 0x4B2
91:                                //TODO quitar esto en la version final
92:                                TRISDbits.TRISD3 = 0;
0C81  1188     BCF PORTD, 0x3
93:                                PORTDbits.RD3 = !PORTDbits.RD3;
0C82  1003     BCF STATUS, 0x0
0C83  1283     BCF STATUS, 0x5
0C84  1D88     BTFSS PORTD, 0x3
0C85  1403     BSF STATUS, 0x0
0C86  1C03     BTFSS STATUS, 0x0
0C87  2C8C     GOTO 0x48C
0C88  1283     BCF STATUS, 0x5
0C89  1303     BCF STATUS, 0x6
0C8A  1588     BSF PORTD, 0x3
0C8B  2C8F     GOTO 0x48F
0C8C  1283     BCF STATUS, 0x5
0C8D  1303     BCF STATUS, 0x6
0C8E  1188     BCF PORTD, 0x3
94:                                //TODO quitar esto en la version final
95:                                salidabomba = !salidabomba;
0C8F  1003     BCF STATUS, 0x0
0C90  1C07     BTFSS PORTC, 0x0
0C91  1403     BSF STATUS, 0x0
0C92  1C03     BTFSS STATUS, 0x0
0C93  2C98     GOTO 0x498
0C94  1283     BCF STATUS, 0x5
0C95  1303     BCF STATUS, 0x6
0C96  1407     BSF PORTC, 0x0
0C97  2C9B     GOTO 0x49B
0C98  1283     BCF STATUS, 0x5
0C99  1303     BCF STATUS, 0x6
0C9A  1007     BCF PORTC, 0x0
96:                                cuentasegundos = 0;
0C9B  1683     BSF STATUS, 0x5
0C9D  01B8     CLRF anio
97:                                if (cuentaminutos < 60) {
0C9C  303C     MOVLW 0x3C
0C9E  0237     SUBWF mes, W
0C9F  1803     BTFSC STATUS, 0x0
0CA0  2CA3     GOTO 0x4A3
98:                                    cuentaminutos++;
0CA1  0AB7     INCF mes, F
99:                                } else {
0CA2  2CB2     GOTO 0x4B2
100:                                   cuentaminutos = 0;
0CA3  3018     MOVLW 0x18
0CA4  01B7     CLRF mes
101:                                   if (cuentahoras < 24) {
0CA3  3018     MOVLW 0x18
0CA5  0236     SUBWF sign, W
0CA6  1803     BTFSC STATUS, 0x0
0CA7  2CAA     GOTO 0x4AA
102:                                       cuentahoras++;
0CA8  0AB6     INCF sign, F
103:                                   } else
0CA9  2CAB     GOTO 0x4AB
104:                                       cuentahoras = 0;
0CAA  01B6     CLRF sign
105:                                   if (cuentadias < 30) {
0CAB  301E     MOVLW 0x1E
0CAC  0235     SUBWF counter, W
0CAD  1803     BTFSC STATUS, 0x0
0CAE  2CB1     GOTO 0x4B1
106:                                       cuentadias++;
0CAF  0AB5     INCF counter, F
107:                                   } else {
0CB0  2CB2     GOTO 0x4B2
108:                                       cuentadias = 0;
0CB1  01B5     CLRF counter
109:                                   }
110:                               }
111:           
112:                           }
113:                       }
114:                   }
115:                   static char maximodia;
116:                   if (Pulsacion(0, BOTON_Subir, CON_REPETICION, LOGICA_INVERSA)) {
0CB2  3000     MOVLW 0x0
0CB3  1283     BCF STATUS, 0x5
0CB4  1886     BTFSC PORTB, 0x1
0CB5  3001     MOVLW 0x1
0CB6  00F5     MOVWF Pin
0CB7  3000     MOVLW 0x0
0CB8  01F6     CLRF TipoPin
0CB9  0AF6     INCF TipoPin, F
0CBA  01F7     CLRF Logica
0CBB  0AF7     INCF Logica, F
0CBC  26D1     CALL 0x6D1
0CBD  120A     BCF PCLATH, 0x4
0CBE  158A     BSF PCLATH, 0x3
0CBF  3A00     XORLW 0x0
0CC0  1903     BTFSC STATUS, 0x2
0CC1  2DA5     GOTO 0x5A5
117:           
118:                       refrescadisplay = 1;
0CC2  16FC     BSF bitvars9, 0x5
119:                       switch (modificafecha) {
0800  120A     BCF PCLATH, 0x4
0801  158A     BSF PCLATH, 0x3
0802  2CD4     GOTO 0x4D4
0803  120A     BCF PCLATH, 0x4
0804  158A     BSF PCLATH, 0x3
0805  2CC4     GOTO 0x4C4
0806  120A     BCF PCLATH, 0x4
0807  158A     BSF PCLATH, 0x3
0808  2CED     GOTO 0x4ED
0809  120A     BCF PCLATH, 0x4
080A  158A     BSF PCLATH, 0x3
080B  2CFC     GOTO 0x4FC
080C  120A     BCF PCLATH, 0x4
080D  158A     BSF PCLATH, 0x3
080E  2D09     GOTO 0x509
080F  120A     BCF PCLATH, 0x4
0810  158A     BSF PCLATH, 0x3
0811  2D4F     GOTO 0x54F
0812  120A     BCF PCLATH, 0x4
0813  158A     BSF PCLATH, 0x3
0814  2D17     GOTO 0x517
0815  120A     BCF PCLATH, 0x4
0816  158A     BSF PCLATH, 0x3
0817  2D1A     GOTO 0x51A
0818  120A     BCF PCLATH, 0x4
0819  158A     BSF PCLATH, 0x3
081A  2D27     GOTO 0x527
081B  120A     BCF PCLATH, 0x4
081C  158A     BSF PCLATH, 0x3
081D  2D34     GOTO 0x534
0CC3  2D40     GOTO 0x540
0D40  1683     BSF STATUS, 0x5
0D41  1303     BCF STATUS, 0x6
0D42  085A     MOVF c, W
0D43  0084     MOVWF FSR
0D44  300A     MOVLW 0xA
0D45  0204     SUBWF FSR, W
0D46  1803     BTFSC STATUS, 0x0
0D47  2D4F     GOTO 0x54F
0D48  3008     MOVLW 0x8
0D49  008A     MOVWF PCLATH
0D4A  1003     BCF STATUS, 0x0
0D4B  0D04     RLF FSR, W
0D4C  0704     ADDWF FSR, W
0D4D  3E00     ADDLW 0x0
0D4E  0082     MOVWF PCL
120:                           case MINUTOS:
121:                               haycambio = 1;
0CC4  167C     BSF bitvars9, 0x4
122:                               if ((*horario).min < 59) (*horario).min++;
0CC5  0A7D     INCF 0x7D, W
0CC6  0084     MOVWF FSR
0CC7  303B     MOVLW 0x3B
0CC8  1383     BCF STATUS, 0x7
0CC9  0200     SUBWF INDF, W
0CCA  0A7D     INCF 0x7D, W
0CCC  1C03     BTFSS STATUS, 0x0
0CCD  2CE0     GOTO 0x4E0
123:                               else
124:                                   if ((*horario).min == 59) (*horario).min = 0;
0CCB  0084     MOVWF FSR
0CCE  0800     MOVF INDF, W
0CCF  3A3B     XORLW 0x3B
0CD0  1D03     BTFSS STATUS, 0x2
0CD1  2D4F     GOTO 0x54F
0CD2  0A7D     INCF 0x7D, W
0CD3  2CEA     GOTO 0x4EA
125:                               break;
126:                           case HORA:
127:                               haycambio = 1;
0CD4  167C     BSF bitvars9, 0x4
128:                               if ((*horario).hrs < 23) (*horario).hrs++;
0CD5  087D     MOVF 0x7D, W
0CD6  3E02     ADDLW 0x2
0CD7  0084     MOVWF FSR
0CD8  3017     MOVLW 0x17
0CD9  1383     BCF STATUS, 0x7
0CDA  0200     SUBWF INDF, W
0CDB  087D     MOVF 0x7D, W
0CDC  1803     BTFSC STATUS, 0x0
0CDD  2CE2     GOTO 0x4E2
0CDE  3E02     ADDLW 0x2
0CDF  0084     MOVWF FSR
0CE0  0A80     INCF INDF, F
0CE1  2D4F     GOTO 0x54F
129:                               else
130:                                   if ((*horario).hrs == 23) (*horario).hrs = 0;
0CE2  3E02     ADDLW 0x2
0CE3  0084     MOVWF FSR
0CE4  0800     MOVF INDF, W
0CE5  3A17     XORLW 0x17
0CE6  1D03     BTFSS STATUS, 0x2
0CE7  2D4F     GOTO 0x54F
0CE8  087D     MOVF 0x7D, W
0CE9  3E02     ADDLW 0x2
0CEA  0084     MOVWF FSR
0CEB  0180     CLRF INDF
0CEC  2D4F     GOTO 0x54F
131:                               break;
132:                           case DIA:
133:                               haycambio = 1;
0CED  167C     BSF bitvars9, 0x4
134:                               if (fecha.day < maximodia) fecha.day++;
0CEE  083E     MOVF 0x3E, W
0CEF  1283     BCF STATUS, 0x5
0CF0  026C     SUBWF fecha, W
0CF1  1C03     BTFSS STATUS, 0x0
0CF2  2CFA     GOTO 0x4FA
135:                               else
136:                                   if (fecha.day == maximodia) fecha.day = 1;
0CF3  086C     MOVF fecha, W
0CF4  1683     BSF STATUS, 0x5
0CF5  063E     XORWF 0x3E, W
0CF6  1D03     BTFSS STATUS, 0x2
0CF7  2D4F     GOTO 0x54F
0CF8  1283     BCF STATUS, 0x5
0CF9  01EC     CLRF fecha
0CFA  0AEC     INCF fecha, F
0CFB  2D4F     GOTO 0x54F
137:                               break;
138:                           case MES:
0CFC  300C     MOVLW 0xC
139:                               haycambio = 1;
0CFD  167C     BSF bitvars9, 0x4
140:                               if (fecha.month < 12) fecha.month++;
0CFC  300C     MOVLW 0xC
0CFE  1283     BCF STATUS, 0x5
0CFF  026D     SUBWF 0x6D, W
0D00  1C03     BTFSS STATUS, 0x0
0D01  2D07     GOTO 0x507
141:                               else
142:                                   if (fecha.month == 12) fecha.month = 1;
0D02  086D     MOVF 0x6D, W
0D03  3A0C     XORLW 0xC
0D04  1D03     BTFSS STATUS, 0x2
0D05  2D4F     GOTO 0x54F
0D06  01ED     CLRF 0x6D
0D07  0AED     INCF 0x6D, F
0D08  2D4F     GOTO 0x54F
143:                               break;
144:                           case ANIO:
0D09  3063     MOVLW 0x63
145:                               haycambio = 1;
0D0A  167C     BSF bitvars9, 0x4
146:                               if (fecha.yr < 99) fecha.yr++; //solamente vamos hasta el ao 00
0D09  3063     MOVLW 0x63
0D0B  1283     BCF STATUS, 0x5
0D0C  026E     SUBWF 0x6E, W
0D0D  1803     BTFSC STATUS, 0x0
0D0E  2D11     GOTO 0x511
0D0F  0AEE     INCF 0x6E, F
0D10  2D4F     GOTO 0x54F
147:                               else
148:                                   if (fecha.yr == 99) fecha.yr = 0; //solamente contamos desde el ao 99
0D11  086E     MOVF 0x6E, W
0D12  3A63     XORLW 0x63
0D13  1D03     BTFSS STATUS, 0x2
0D14  2D4F     GOTO 0x54F
0D15  01EE     CLRF 0x6E
0D16  2D4F     GOTO 0x54F
149:                               break;
150:                           case SINO:
151:                               banderasino = !banderasino;
0D17  3004     MOVLW 0x4
0D18  06FC     XORWF bitvars9, F
152:                               break;
0D19  2D4F     GOTO 0x54F
153:                           case TIEMPOENCENDIDO:
0D1A  303C     MOVLW 0x3C
154:                               haycambio = 1;
0D1B  167C     BSF bitvars9, 0x4
155:                               if (tiempoencendido < TIEMPOMAXIMOENCENDIDO) tiempoencendido++; //
0D1A  303C     MOVLW 0x3C
0D1C  023C     SUBWF 0x3C, W
0D1D  1803     BTFSC STATUS, 0x0
0D1E  2D21     GOTO 0x521
0D1F  0ABC     INCF 0x3C, F
0D20  2D4F     GOTO 0x54F
156:                               else
157:                                   if (tiempoencendido == TIEMPOMAXIMOENCENDIDO) tiempoencendido = 0;
0D21  083C     MOVF 0x3C, W
0D22  3A3C     XORLW 0x3C
0D23  1D03     BTFSS STATUS, 0x2
0D24  2D4F     GOTO 0x54F
0D25  01BC     CLRF 0x3C
0D26  2D4F     GOTO 0x54F
158:                               break;
159:                           case TIEMPOFALLA:
0D27  301E     MOVLW 0x1E
160:                               haycambio = 1;
0D28  167C     BSF bitvars9, 0x4
161:                               if (tiempofalla < TIEMPOMAXIMOFALLA) tiempofalla++; //
0D27  301E     MOVLW 0x1E
0D29  023D     SUBWF f1, W
0D2A  1803     BTFSC STATUS, 0x0
0D2B  2D2E     GOTO 0x52E
0D2C  0ABD     INCF f1, F
0D2D  2D4F     GOTO 0x54F
162:                               else
163:                                   if (tiempofalla == TIEMPOMAXIMOFALLA) tiempofalla = 0;
0D2E  083D     MOVF f1, W
0D2F  3A1E     XORLW 0x1E
0D30  1D03     BTFSS STATUS, 0x2
0D31  2D4F     GOTO 0x54F
0D32  01BD     CLRF f1
0D33  2D4F     GOTO 0x54F
164:                               break;
165:                           case PERIODOENCENDIDO:
0D34  3007     MOVLW 0x7
166:                               haycambio = 1;
0D35  167C     BSF bitvars9, 0x4
167:                               if (periodoencendido < TIEMPOMAXIMOPERIODO) periodoencendido++; //
0D34  3007     MOVLW 0x7
0D36  025B     SUBWF sp, W
0D37  1C03     BTFSS STATUS, 0x0
0D38  2D3E     GOTO 0x53E
168:                               else
169:                                   if (periodoencendido == TIEMPOMAXIMOPERIODO) periodoencendido = 1;
0D39  085B     MOVF sp, W
0D3A  3A07     XORLW 0x7
0D3B  1D03     BTFSS STATUS, 0x2
0D3C  2D4F     GOTO 0x54F
0D3D  01DB     CLRF sp
0D3E  0ADB     INCF sp, F
0D3F  2D4F     GOTO 0x54F
170:                               break;
171:                           default:
172:                               break;
173:                       }
174:                       if (aniobisiesto(fecha.yr) && fecha.month == 2) {
0D4F  1283     BCF STATUS, 0x5
0D50  086E     MOVF 0x6E, W
0D51  279E     CALL 0x79E
0D52  120A     BCF PCLATH, 0x4
0D53  158A     BSF PCLATH, 0x3
0D54  0877     MOVF Logica, W
0D55  0476     IORWF TipoPin, W
0D56  1903     BTFSC STATUS, 0x2
0D57  2D60     GOTO 0x560
0D58  1283     BCF STATUS, 0x5
0D59  1303     BCF STATUS, 0x6
0D5A  086D     MOVF 0x6D, W
0D5B  3A02     XORLW 0x2
0D5C  1D03     BTFSS STATUS, 0x2
0D5D  2D60     GOTO 0x560
175:                           maximodia = 29;
0D5E  301D     MOVLW 0x1D
0D5F  2D67     GOTO 0x567
176:                       } else if (fecha.month == 2)
0D60  1283     BCF STATUS, 0x5
0D61  1303     BCF STATUS, 0x6
0D62  086D     MOVF 0x6D, W
0D63  3A02     XORLW 0x2
0D64  1D03     BTFSS STATUS, 0x2
0D65  2D69     GOTO 0x569
177:                           maximodia = 28;
0D66  301C     MOVLW 0x1C
0D67  1683     BSF STATUS, 0x5
0D68  00BE     MOVWF 0x3E
178:                       if (fecha.month == 4 || fecha.month == 6 || fecha.month == 9 || fecha.month == 11) {
0D69  1283     BCF STATUS, 0x5
0D6A  086D     MOVF 0x6D, W
0D6B  3A04     XORLW 0x4
0D6C  1903     BTFSC STATUS, 0x2
0D6D  2D7A     GOTO 0x57A
0D6E  086D     MOVF 0x6D, W
0D6F  3A06     XORLW 0x6
0D70  1903     BTFSC STATUS, 0x2
0D71  2D7A     GOTO 0x57A
0D72  086D     MOVF 0x6D, W
0D73  3A09     XORLW 0x9
0D74  1903     BTFSC STATUS, 0x2
0D75  2D7A     GOTO 0x57A
0D76  086D     MOVF 0x6D, W
0D77  3A0B     XORLW 0xB
0D78  1D03     BTFSS STATUS, 0x2
0D79  2D7D     GOTO 0x57D
179:                           maximodia = 30;
0D7A  301E     MOVLW 0x1E
0D7B  1683     BSF STATUS, 0x5
0D7C  00BE     MOVWF 0x3E
180:                       }
181:                       if (fecha.month == 1 || fecha.month == 3 || fecha.month == 5 || fecha.month == 7 || fecha.month == 8 || fecha.month == 10 || fecha.month == 12) {
0D7D  1283     BCF STATUS, 0x5
0D7E  036D     DECF 0x6D, W
0D7F  1903     BTFSC STATUS, 0x2
0D80  2D99     GOTO 0x599
0D81  086D     MOVF 0x6D, W
0D82  3A03     XORLW 0x3
0D83  1903     BTFSC STATUS, 0x2
0D84  2D99     GOTO 0x599
0D85  086D     MOVF 0x6D, W
0D86  3A05     XORLW 0x5
0D87  1903     BTFSC STATUS, 0x2
0D88  2D99     GOTO 0x599
0D89  086D     MOVF 0x6D, W
0D8A  3A07     XORLW 0x7
0D8B  1903     BTFSC STATUS, 0x2
0D8C  2D99     GOTO 0x599
0D8D  086D     MOVF 0x6D, W
0D8E  3A08     XORLW 0x8
0D8F  1903     BTFSC STATUS, 0x2
0D90  2D99     GOTO 0x599
0D91  086D     MOVF 0x6D, W
0D92  3A0A     XORLW 0xA
0D93  1903     BTFSC STATUS, 0x2
0D94  2D99     GOTO 0x599
0D95  086D     MOVF 0x6D, W
0D96  3A0C     XORLW 0xC
0D97  1D03     BTFSS STATUS, 0x2
0D98  2D9C     GOTO 0x59C
182:                           maximodia = 31;
0D99  301F     MOVLW 0x1F
0D9A  1683     BSF STATUS, 0x5
0D9B  00BE     MOVWF 0x3E
183:                       }
184:                       if (fecha.day > maximodia)
0D9C  1283     BCF STATUS, 0x5
0D9D  086C     MOVF fecha, W
0D9E  1683     BSF STATUS, 0x5
0D9F  023E     SUBWF 0x3E, W
0DA0  1803     BTFSC STATUS, 0x0
0DA1  2DA5     GOTO 0x5A5
185:                           fecha.day = maximodia;
0DA2  083E     MOVF 0x3E, W
0DA3  1283     BCF STATUS, 0x5
0DA4  00EC     MOVWF fecha
186:                   }
187:                   if (Pulsacion(1, BOTON_Bajar, CON_REPETICION, LOGICA_INVERSA)) {
0DA5  3000     MOVLW 0x0
0DA6  1283     BCF STATUS, 0x5
0DA7  1303     BCF STATUS, 0x6
0DA8  1906     BTFSC PORTB, 0x2
0DA9  3001     MOVLW 0x1
0DAA  00F5     MOVWF Pin
0DAB  3001     MOVLW 0x1
0DAC  01F6     CLRF TipoPin
0DAD  0AF6     INCF TipoPin, F
0DAE  01F7     CLRF Logica
0DAF  0AF7     INCF Logica, F
0DB0  26D1     CALL 0x6D1
0DB1  120A     BCF PCLATH, 0x4
0DB2  158A     BSF PCLATH, 0x3
0DB3  3A00     XORLW 0x0
0DB4  1903     BTFSC STATUS, 0x2
0DB5  2E98     GOTO 0x698
188:           
189:                       refrescadisplay = 1;
0DB6  16FC     BSF bitvars9, 0x5
190:                       switch (modificafecha) {
0DB7  2E33     GOTO 0x633
0E33  1683     BSF STATUS, 0x5
0E34  1303     BCF STATUS, 0x6
0E35  085A     MOVF c, W
0E36  0084     MOVWF FSR
0E37  300A     MOVLW 0xA
0E38  0204     SUBWF FSR, W
0E39  1803     BTFSC STATUS, 0x0
0E3A  2E42     GOTO 0x642
0E3B  3010     MOVLW 0x10
0E3C  008A     MOVWF PCLATH
0E3D  1003     BCF STATUS, 0x0
0E3E  0D04     RLF FSR, W
0E3F  0704     ADDWF FSR, W
0E40  3E36     ADDLW 0x36
0E41  0082     MOVWF PCL
1036  120A     BCF PCLATH, 0x4
191:                           case MINUTOS:
192:                               haycambio = 1;
0DB8  167C     BSF bitvars9, 0x4
193:                               if ((*horario).min > 0) (*horario).min--;
0DB9  0A7D     INCF 0x7D, W
0DBA  0084     MOVWF FSR
0DBB  1383     BCF STATUS, 0x7
0DBC  0880     MOVF INDF, F
0DBD  1903     BTFSC STATUS, 0x2
0DBE  2DC1     GOTO 0x5C1
0DBF  0A7D     INCF 0x7D, W
0DC0  2DD4     GOTO 0x5D4
194:                               else
195:                                   if ((*horario).min == 0) (*horario).min = 59;
0DC1  0A7D     INCF 0x7D, W
0DC2  0084     MOVWF FSR
0DC3  0880     MOVF INDF, F
0DC4  1D03     BTFSS STATUS, 0x2
0DC5  2E42     GOTO 0x642
0DC6  0A7D     INCF 0x7D, W
0DC7  0084     MOVWF FSR
0DC8  303B     MOVLW 0x3B
0DC9  2DE1     GOTO 0x5E1
196:                               break;
197:                           case HORA:
198:                               haycambio = 1;
0DCA  167C     BSF bitvars9, 0x4
199:                               if ((*horario).hrs > 0) (*horario).hrs--;
0DCB  087D     MOVF 0x7D, W
0DCC  3E02     ADDLW 0x2
0DCD  0084     MOVWF FSR
0DCE  1383     BCF STATUS, 0x7
0DCF  0880     MOVF INDF, F
0DD0  1903     BTFSC STATUS, 0x2
0DD1  2DD7     GOTO 0x5D7
0DD2  087D     MOVF 0x7D, W
0DD3  3E02     ADDLW 0x2
0DD4  0084     MOVWF FSR
0DD5  0380     DECF INDF, F
0DD6  2E42     GOTO 0x642
200:                               else
201:                                   if ((*horario).hrs == 0) (*horario).hrs = 23;
0DD7  087D     MOVF 0x7D, W
0DD8  3E02     ADDLW 0x2
0DD9  0084     MOVWF FSR
0DDA  0880     MOVF INDF, F
0DDB  1D03     BTFSS STATUS, 0x2
0DDC  2E42     GOTO 0x642
0DDD  087D     MOVF 0x7D, W
0DDE  3E02     ADDLW 0x2
0DDF  0084     MOVWF FSR
0DE0  3017     MOVLW 0x17
0DE1  0080     MOVWF INDF
0DE2  2E42     GOTO 0x642
202:                               break;
203:                           case DIA:
0DE3  3002     MOVLW 0x2
204:                               haycambio = 1;
0DE4  167C     BSF bitvars9, 0x4
205:                               if (fecha.day > 1) fecha.day--;
0DE3  3002     MOVLW 0x2
0DE5  1283     BCF STATUS, 0x5
0DE6  026C     SUBWF fecha, W
0DE7  1C03     BTFSS STATUS, 0x0
0DE8  2DEB     GOTO 0x5EB
0DE9  03EC     DECF fecha, F
0DEA  2E42     GOTO 0x642
206:                               else
207:                                   if (fecha.day == 1) fecha.day = maximodia;
0DEB  0B6C     DECFSZ fecha, W
0DEC  2E42     GOTO 0x642
0DED  1683     BSF STATUS, 0x5
0DEE  083E     MOVF 0x3E, W
0DEF  1283     BCF STATUS, 0x5
0DF0  00EC     MOVWF fecha
0DF1  2E42     GOTO 0x642
208:                               break;
209:                           case MES:
0DF2  3002     MOVLW 0x2
210:                               haycambio = 1;
0DF3  167C     BSF bitvars9, 0x4
211:                               if (fecha.month > 1) fecha.month--;
0DF2  3002     MOVLW 0x2
0DF4  1283     BCF STATUS, 0x5
0DF5  026D     SUBWF 0x6D, W
0DF6  1C03     BTFSS STATUS, 0x0
0DF7  2DFA     GOTO 0x5FA
0DF8  03ED     DECF 0x6D, F
0DF9  2E42     GOTO 0x642
212:                               else
213:                                   if (fecha.month == 1) fecha.month = 12;
0DFA  0B6D     DECFSZ 0x6D, W
0DFB  2E42     GOTO 0x642
0DFC  300C     MOVLW 0xC
0DFD  00ED     MOVWF 0x6D
0DFE  2E42     GOTO 0x642
214:                               break;
215:                           case ANIO:
216:                               haycambio = 1;
0DFF  167C     BSF bitvars9, 0x4
217:                               if (fecha.yr > 0) fecha.yr--; //solamente vamos hasta el ao 00
0E00  1283     BCF STATUS, 0x5
0E01  086E     MOVF 0x6E, W
0E02  1903     BTFSC STATUS, 0x2
0E03  2E06     GOTO 0x606
0E04  03EE     DECF 0x6E, F
0E05  2E42     GOTO 0x642
218:                               else
219:                                   if (fecha.yr == 0) fecha.yr = 99; //solamente contamos desde el ao 99
0E06  08EE     MOVF 0x6E, F
0E07  1D03     BTFSS STATUS, 0x2
0E08  2E42     GOTO 0x642
0E09  3063     MOVLW 0x63
0E0A  00EE     MOVWF 0x6E
0E0B  2E42     GOTO 0x642
220:                               break;
221:                           case SINO:
222:                               banderasino = !banderasino;
0E0C  3004     MOVLW 0x4
0E0D  06FC     XORWF bitvars9, F
223:                               break;
0E0E  2E42     GOTO 0x642
224:                           case TIEMPOENCENDIDO:
225:                               haycambio = 1;
0E0F  167C     BSF bitvars9, 0x4
226:                               if (tiempoencendido > 0) tiempoencendido--; //
0E10  083C     MOVF 0x3C, W
0E11  1903     BTFSC STATUS, 0x2
0E12  2E15     GOTO 0x615
0E13  03BC     DECF 0x3C, F
0E14  2E42     GOTO 0x642
227:                               else
228:                                   if (tiempoencendido == 0) tiempoencendido = TIEMPOMAXIMOENCENDIDO;
0E15  08BC     MOVF 0x3C, F
0E16  1D03     BTFSS STATUS, 0x2
0E17  2E42     GOTO 0x642
0E18  303C     MOVLW 0x3C
0E19  00BC     MOVWF 0x3C
0E1A  2E42     GOTO 0x642
229:                               break;
230:                           case TIEMPOFALLA:
231:                               haycambio = 1;
0E1B  167C     BSF bitvars9, 0x4
232:                               if (tiempofalla > 0) tiempofalla--; //
0E1C  083D     MOVF f1, W
0E1D  1903     BTFSC STATUS, 0x2
0E1E  2E21     GOTO 0x621
0E1F  03BD     DECF f1, F
0E20  2E42     GOTO 0x642
233:                               else
234:                                   if (tiempofalla == 0) tiempofalla = TIEMPOMAXIMOFALLA;
0E21  08BD     MOVF f1, F
0E22  1D03     BTFSS STATUS, 0x2
0E23  2E42     GOTO 0x642
0E24  301E     MOVLW 0x1E
0E25  00BD     MOVWF f1
0E26  2E42     GOTO 0x642
235:                               break;
236:                           case PERIODOENCENDIDO:
0E27  3002     MOVLW 0x2
237:                               haycambio = 1;
0E28  167C     BSF bitvars9, 0x4
238:                               if (periodoencendido > 1) periodoencendido--; //
0E27  3002     MOVLW 0x2
0E29  025B     SUBWF sp, W
0E2A  1C03     BTFSS STATUS, 0x0
0E2B  2E2E     GOTO 0x62E
0E2C  03DB     DECF sp, F
0E2D  2E42     GOTO 0x642
239:                               else
240:                                   if (periodoencendido == 1) periodoencendido = TIEMPOMAXIMOPERIODO;
0E2E  0B5B     DECFSZ sp, W
0E2F  2E42     GOTO 0x642
0E30  3007     MOVLW 0x7
0E31  00DB     MOVWF sp
0E32  2E42     GOTO 0x642
241:                               break;
242:                           default:
243:                               break;
244:                       }
245:                       if (aniobisiesto(fecha.yr) && fecha.month == 2) {
0E42  1283     BCF STATUS, 0x5
0E43  086E     MOVF 0x6E, W
0E44  279E     CALL 0x79E
0E45  120A     BCF PCLATH, 0x4
0E46  158A     BSF PCLATH, 0x3
0E47  0877     MOVF Logica, W
0E48  0476     IORWF TipoPin, W
0E49  1903     BTFSC STATUS, 0x2
0E4A  2E53     GOTO 0x653
0E4B  1283     BCF STATUS, 0x5
0E4C  1303     BCF STATUS, 0x6
0E4D  086D     MOVF 0x6D, W
0E4E  3A02     XORLW 0x2
0E4F  1D03     BTFSS STATUS, 0x2
0E50  2E53     GOTO 0x653
246:                           maximodia = 29;
0E51  301D     MOVLW 0x1D
0E52  2E5A     GOTO 0x65A
247:                       } else if (fecha.month == 2)
0E53  1283     BCF STATUS, 0x5
0E54  1303     BCF STATUS, 0x6
0E55  086D     MOVF 0x6D, W
0E56  3A02     XORLW 0x2
0E57  1D03     BTFSS STATUS, 0x2
0E58  2E5C     GOTO 0x65C
248:                           maximodia = 28;
0E59  301C     MOVLW 0x1C
0E5A  1683     BSF STATUS, 0x5
0E5B  00BE     MOVWF 0x3E
249:                       if (fecha.month == 4 || fecha.month == 6 || fecha.month == 9 || fecha.month == 11) {
0E5C  1283     BCF STATUS, 0x5
0E5D  086D     MOVF 0x6D, W
0E5E  3A04     XORLW 0x4
0E5F  1903     BTFSC STATUS, 0x2
0E60  2E6D     GOTO 0x66D
0E61  086D     MOVF 0x6D, W
0E62  3A06     XORLW 0x6
0E63  1903     BTFSC STATUS, 0x2
0E64  2E6D     GOTO 0x66D
0E65  086D     MOVF 0x6D, W
0E66  3A09     XORLW 0x9
0E67  1903     BTFSC STATUS, 0x2
0E68  2E6D     GOTO 0x66D
0E69  086D     MOVF 0x6D, W
0E6A  3A0B     XORLW 0xB
0E6B  1D03     BTFSS STATUS, 0x2
0E6C  2E70     GOTO 0x670
250:                           maximodia = 30;
0E6D  301E     MOVLW 0x1E
0E6E  1683     BSF STATUS, 0x5
0E6F  00BE     MOVWF 0x3E
251:                       }
252:                       if (fecha.month == 1 || fecha.month == 3 || fecha.month == 5 || fecha.month == 7 || fecha.month == 8 || fecha.month == 10 || fecha.month == 12) {
0E70  1283     BCF STATUS, 0x5
0E71  036D     DECF 0x6D, W
0E72  1903     BTFSC STATUS, 0x2
0E73  2E8C     GOTO 0x68C
0E74  086D     MOVF 0x6D, W
0E75  3A03     XORLW 0x3
0E76  1903     BTFSC STATUS, 0x2
0E77  2E8C     GOTO 0x68C
0E78  086D     MOVF 0x6D, W
0E79  3A05     XORLW 0x5
0E7A  1903     BTFSC STATUS, 0x2
0E7B  2E8C     GOTO 0x68C
0E7C  086D     MOVF 0x6D, W
0E7D  3A07     XORLW 0x7
0E7E  1903     BTFSC STATUS, 0x2
0E7F  2E8C     GOTO 0x68C
0E80  086D     MOVF 0x6D, W
0E81  3A08     XORLW 0x8
0E82  1903     BTFSC STATUS, 0x2
0E83  2E8C     GOTO 0x68C
0E84  086D     MOVF 0x6D, W
0E85  3A0A     XORLW 0xA
0E86  1903     BTFSC STATUS, 0x2
0E87  2E8C     GOTO 0x68C
0E88  086D     MOVF 0x6D, W
0E89  3A0C     XORLW 0xC
0E8A  1D03     BTFSS STATUS, 0x2
0E8B  2E8F     GOTO 0x68F
253:                           maximodia = 31;
0E8C  301F     MOVLW 0x1F
0E8D  1683     BSF STATUS, 0x5
0E8E  00BE     MOVWF 0x3E
254:                       }
255:                       if (fecha.day > maximodia)
0E8F  1283     BCF STATUS, 0x5
0E90  086C     MOVF fecha, W
0E91  1683     BSF STATUS, 0x5
0E92  023E     SUBWF 0x3E, W
0E93  1803     BTFSC STATUS, 0x0
0E94  2E98     GOTO 0x698
256:                           fecha.day = maximodia;
0E95  083E     MOVF 0x3E, W
0E96  1283     BCF STATUS, 0x5
0E97  00EC     MOVWF fecha
257:                   }
258:           
259:           
260:                   bandera_startglobal = 0;
0E98  3000     MOVLW 0x0
0E99  10FC     BCF bitvars9, 0x1
261:                   if (Pulsacion(3, BOTON_ONOFF, INMEDIATO, LOGICA_INVERSA)) {
0E98  3000     MOVLW 0x0
0E9A  1283     BCF STATUS, 0x5
0E9B  1303     BCF STATUS, 0x6
0E9C  1A86     BTFSC PORTB, 0x5
0E9D  3001     MOVLW 0x1
0E9E  00F5     MOVWF Pin
0E9F  3002     MOVLW 0x2
0EA0  00F6     MOVWF TipoPin
0EA1  3003     MOVLW 0x3
0EA2  01F7     CLRF Logica
0EA3  0AF7     INCF Logica, F
0EA4  26D1     CALL 0x6D1
0EA5  120A     BCF PCLATH, 0x4
0EA6  158A     BSF PCLATH, 0x3
0EA7  3A00     XORLW 0x0
0EA8  1D03     BTFSS STATUS, 0x2
262:           
263:                       bandera_startglobal = 1;
0EA9  14FC     BSF bitvars9, 0x1
264:                   }
265:           
266:                   if (Pulsacion(4, BOTON_MENU, SIN_REPETICION/*INMEDIATO*/, LOGICA_INVERSA)) {
0EAA  3000     MOVLW 0x0
0EAB  1283     BCF STATUS, 0x5
0EAC  1303     BCF STATUS, 0x6
0EAD  1986     BTFSC PORTB, 0x3
0EAE  3001     MOVLW 0x1
0EAF  00F5     MOVWF Pin
0EB0  3004     MOVLW 0x4
0EB1  01F6     CLRF TipoPin
0EB2  01F7     CLRF Logica
0EB3  0AF7     INCF Logica, F
0EB4  26D1     CALL 0x6D1
0EB5  120A     BCF PCLATH, 0x4
0EB6  158A     BSF PCLATH, 0x3
0EB7  3A00     XORLW 0x0
0EB8  1903     BTFSC STATUS, 0x2
0EB9  2EC5     GOTO 0x6C5
267:           
268:                       buzzer_on();
0EBA  27EA     CALL 0x7EA
0EBB  120A     BCF PCLATH, 0x4
0EBC  158A     BSF PCLATH, 0x3
269:                       if (menuactual < ULTIMOMENU)
0EBD  3011     MOVLW 0x11
0EBE  1683     BSF STATUS, 0x5
0EBF  023B     SUBWF 0x3B, W
0EC0  1803     BTFSC STATUS, 0x0
0EC1  2EC4     GOTO 0x6C4
270:                           menuactual++;
0EC2  0ABB     INCF 0x3B, F
0EC3  2EC5     GOTO 0x6C5
271:                       else
272:                           menuactual = 0;
0EC4  01BB     CLRF 0x3B
273:                   }
274:                   T0IF = 0;
0EC5  110B     BCF INTCON, 0x2
275:               } else {
276:                   ///interrupciones no contempladas
277:               }
278:           
279:               /* This code stub shows general interrupt handling.  Note that these
280:               conditional statements are not handled within 3 seperate if blocks.
281:               Do not use a seperate if block for each interrupt flag to avoid run
282:               time errors. */
283:           
284:           #if 0
285:           
286:               /* Add interrupt routine code here. */
287:           
288:               /* Determine which flag generated the interrupt */
289:               if (<Interrupt Flag 1 >) {
290:                   <Interrupt Flag 1 = 0 >; /* Clear Interrupt Flag 1 */
291:               } else if (<Interrupt Flag 2 >) {
292:                   <Interrupt Flag 2 = 0 >; /* Clear Interrupt Flag 2 */
293:               } else {
294:                   /* Unhandled interrupts */
295:               }
296:           
297:           #endif
298:           
299:           }
0EC6  1283     BCF STATUS, 0x5
300:           #endif
301:           
302:           
303:           #endif
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/adcPic16.c  ---------------------------
1:             #include <xc.h>
2:             #include <stdint.h>
3:             #include <stdbool.h>
4:             #include "system.h"
5:             #include "user.h"
6:             #include "adcPic16.h"
7:             
8:             void setADCChannel(char canal) {
07F4  1283     BCF STATUS, 0x5
07F5  00A4     MOVWF dato
0FF4  00F1     MOVWF canal
9:                 ADCON0bits.CHS = canal; //Selecciono el canal AD0
07F6  00A3     MOVWF x
07F7  0DA3     RLF x, F
07F8  0DA3     RLF x, F
07F9  0DA3     RLF x, F
07FA  081F     MOVF ADCON0, W
07FB  0623     XORWF x, W
07FC  39C7     ANDLW 0xC7
07FD  0623     XORWF x, W
07FE  009F     MOVWF ADCON0
0FF5  00F0     MOVWF divisor
0FF6  0DF0     RLF divisor, F
0FF7  0DF0     RLF divisor, F
0FF8  0DF0     RLF divisor, F
0FF9  1283     BCF STATUS, 0x5
0FFA  081F     MOVF ADCON0, W
0FFB  0670     XORWF divisor, W
0FFC  39C7     ANDLW 0xC7
0FFD  0670     XORWF divisor, W
0FFE  009F     MOVWF ADCON0
10:            };
07FF  0008     RETURN
0FFF  0008     RETURN
11:            
12:            char getADCChannel(void) {
13:                return ADCON0bits.CHS; //Selecciono el canal AD0
0FDB  1283     BCF STATUS, 0x5
0FDC  0C1F     RRF ADCON0, W
0FDD  00F0     MOVWF divisor
0FDE  0CF0     RRF divisor, F
0FDF  0C70     RRF divisor, W
0FE0  3907     ANDLW 0x7
14:            };
0FE1  0008     RETURN
15:            
16:            void openADC(void) {
17:            
18:                TRISA0 = 1; //configuro como entrada para el ADC0
141C  1683     BSF STATUS, 0x5
141D  1303     BCF STATUS, 0x6
141E  1405     BSF PORTA, 0x0
19:                TRISA1 = 1; //configuro como entrada para el ADC1
141F  1485     BSF PORTA, 0x1
20:                TRISA3 = 1; //Configuro como entrada para Vref+
1420  1585     BSF PORTA, 0x3
21:                TRISA2 = 0; //No usado
1421  1105     BCF PORTA, 0x2
22:                TRISA4 = 0;//No usado
1422  1205     BCF PORTA, 0x4
23:                TRISA5 = 0;//No usado
1423  1285     BCF PORTA, 0x5
24:                ADCON1bits.PCFG = 0b101; //An3 como VREF+ , AN0 y AN1 como entrada analogica, AN0 Corriente, AN1 Tension de red
1424  081F     MOVF ADCON0, W
1425  39F0     ANDLW 0xF0
1426  3805     IORLW 0x5
1427  009F     MOVWF ADCON0
25:                ADCON1bits.ADFM = 1; //justificado a la derecha
1428  179F     BSF ADCON0, 0x7
26:                ADCON1bits.ADCS2 = 1;
1429  171F     BSF ADCON0, 0x6
27:                ADCON0bits.ADCS = 0b10; //Tosc/64
142A  1283     BCF STATUS, 0x5
142B  081F     MOVF ADCON0, W
142C  393F     ANDLW 0x3F
142D  3880     IORLW 0x80
142E  009F     MOVWF ADCON0
28:                ADCON0bits.ADON = 1; //Activo el ADC
142F  141F     BSF ADCON0, 0x0
29:            
30:            }
1430  0008     RETURN
31:            
32:            unsigned int adcRead(void) {
33:            
34:                return ((unsigned int) ADRESH << 8) | ADRESL;
0F97  081E     MOVF ADRESH, W
0F98  00F1     MOVWF canal
0F99  01F0     CLRF divisor
0F9A  1683     BSF STATUS, 0x5
0F9B  081E     MOVF ADRESH, W
0F9C  04F0     IORWF divisor, F
35:            }
0F9D  0008     RETURN
36:            
37:            void startADC(void) {
38:                ADCON0bits.GO_DONE = 1;
0FE2  1283     BCF STATUS, 0x5
0FE3  151F     BSF ADCON0, 0x2
39:            }
0FE4  0008     RETURN
40:            
41:            void interruptADC_on(void) {
42:                ADIE = 1;
13F7  1683     BSF STATUS, 0x5
13F8  1303     BCF STATUS, 0x6
13F9  170C     BSF PIR1, 0x6
43:            }
13FA  0008     RETURN
44:            
45:            void interruptADC_off(void) {
46:                ADIE = 0;
47:            }
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/_isl1208.c  ---------------------------
1:             ////////////////////////////////////////////////////////////////////////////////////////
2:             ///                               isl1208.C                                          ///
3:             ///                     Driver for Real Time Clock                                   ///
4:             ///                     modified by Pablo Fernando Manieri - Enero 2015              ///
5:             ///                                                                                  ///
6:             /// bool ISL1208_ready(void) - Testea si el RTC est presente                        ///
7:             /// void isl1208_init(val)                                                           ///
8:             ///                  - Enable oscillator without clearing the seconds register       ///
9:             ///                    used when PIC loses power and isl1208 run from 3V BAT         ///
10:            ///                  - Config Control Register with next parameters:                 ///
11:            ///                     isl1208_ALL_DISABLED          All disabled                   ///
12:            ///                     isl1208_OUT_ON_DISABLED_HIHG  Out to Hight on Disable Out    ///
13:            ///                     isl1208_OUT_ENABLED           Out Enabled                    ///
14:            ///                     isl1208_OUT_1_HZ              Freq. Out to 1 Hz              ///
15:            ///                     isl1208_OUT_4_KHZ             Freq. Out to 4.096 Khz         ///
16:            ///                     isl1208_OUT_8_KHZ             Freq. Out to 8.192 Khz         ///
17:            ///                     isl1208_OUT_32_KHZ            Freq. Out to 32.768 Khz        ///
18:            ///                                                                                  ///
19:            ///                     Example init:                                                ///
20:            ///                     isl1208_init(isl1208_ALL_DISABLED);                          ///
21:            ///                     isl1208_init(isl1208_OUT_ENABLED | isl1208_OUT_1_HZ);        ///
22:            ///                                                                                  ///
23:            /// void isl1208_set_date_time(day,mth,year,dow,hour,min,sec) - Set the date/time    ///
24:            ///                                                                                  ///
25:            /// void isl1208_get_date(day,mth,year,dow) - Get the date                           ///
26:            ///                                                                                  ///
27:            /// void isl1208_get_time(hr,min,sec) - Get the time                                 ///
28:            ///                                                                                  ///
29:            /// char isl1208_read_nvram_unsigned char(char addr) - Read unsigned char in address ///
30:            ///                                                                                  ///
31:            /// void isl1208_write_nvram_unsigned char(char addr, char value) - Write unsigned   ///
32:            ///                                                                  char in address ///
33:            ///                                                                                  ///
34:            /// void isl1208_get_day_of_week(char* ptr) - Get string Day Of Week                 ///
35:            ///                                                                                  ///
36:            ///                                                                                  ///
37:            ////////////////////////////////////////////////////////////////////////////////////////
38:            
39:            #include <xc.h>
40:            #include <stdio.h>
41:            #include <stdbool.h>       /* For true/false definition */
42:            #include "system.h"        /* System funct/params, like osc/peripheral config */
43:            #include "HardI2C.h"
44:            #include "_isl1208.h"
45:            #include "user.h"
46:            
47:            bool ISL1208_ready(void) {
48:                bool ack;
49:            
50:                start_i2c(); // If the write command is acknowledged,
0958  2353     CALL 0x353
0959  120A     BCF PCLATH, 0x4
095A  158A     BSF PCLATH, 0x3
51:                ack = write_i2c(isl1208_Write); // then the device is ready.
095B  30DE     MOVLW 0xDE
095C  2329     CALL 0x329
095D  120A     BCF PCLATH, 0x4
095E  158A     BSF PCLATH, 0x3
095F  1283     BCF STATUS, 0x5
0960  00A4     MOVWF dato
52:                stop_i2c();
0961  235B     CALL 0x35B
53:                return !ack; // Invert ACK returned so TRUE = ACK OK
0962  1283     BCF STATUS, 0x5
0963  3000     MOVLW 0x0
0964  08A4     MOVF dato, F
0965  1903     BTFSC STATUS, 0x2
0966  3001     MOVLW 0x1
54:            }
0967  0008     RETURN
55:            
56:            unsigned char ISL1208_Read_status(void) {
57:                char SR;
58:                start_i2c(); // If the write command is acknowledged,
0968  2353     CALL 0x353
0969  120A     BCF PCLATH, 0x4
096A  158A     BSF PCLATH, 0x3
59:                write_i2c(isl1208_Write); // then the device is ready.
096B  30DE     MOVLW 0xDE
096C  2329     CALL 0x329
096D  120A     BCF PCLATH, 0x4
096E  158A     BSF PCLATH, 0x3
60:                write_i2c(0x07);
096F  3007     MOVLW 0x7
0970  2329     CALL 0x329
0971  120A     BCF PCLATH, 0x4
0972  158A     BSF PCLATH, 0x3
61:                rstart_i2c(); 
0973  2397     CALL 0x397
0974  120A     BCF PCLATH, 0x4
0975  158A     BSF PCLATH, 0x3
62:                write_i2c(isl1208_Read);
0976  30DF     MOVLW 0xDF
0977  2329     CALL 0x329
0978  120A     BCF PCLATH, 0x4
0979  158A     BSF PCLATH, 0x3
63:                SR = read_i2c(NOACK);
097A  3001     MOVLW 0x1
097B  2363     CALL 0x363
097C  120A     BCF PCLATH, 0x4
097D  158A     BSF PCLATH, 0x3
097E  00A5     MOVWF y
64:                stop_i2c();
097F  235B     CALL 0x35B
65:                return SR;
0980  1283     BCF STATUS, 0x5
0981  0825     MOVF y, W
66:            }
0982  0008     RETURN
67:            
68:            void isl1208_init(unsigned char val) {
69:            
70:                unsigned char seconds = 0;
71:            
72:            #ifndef USE_INTERRUPTS
73:                //di();
74:            #endif
75:                //TODO Verificar secuencia correcta para pode escribir en el ISL1208
76:                
77:            #ifndef USE_INTERRUPTS
78:                //ei();
79:            #endif
80:            
81:            }
82:            
83:            void isl1208_set_time(unsigned char hr, unsigned char min, unsigned char sec) {
0AA2  00AC     MOVWF hr
84:            
85:            #ifndef USE_INTERRUPTS
86:                //di();
87:            #endif
88:            
89:                sec &= 0x7F;
0AA4  13AB     BCF sec, 0x7
90:                min &= 0x7F;
0AA5  13AA     BCF Data, 0x7
91:                hr &= 0x3F;
0AA3  303F     MOVLW 0x3F
0AA6  05AC     ANDWF hr, F
92:                start_i2c();
0AA7  2353     CALL 0x353
0AA8  120A     BCF PCLATH, 0x4
0AA9  158A     BSF PCLATH, 0x3
93:                write_i2c(isl1208_Write);
0AAA  30DE     MOVLW 0xDE
0AAB  2329     CALL 0x329
0AAC  120A     BCF PCLATH, 0x4
0AAD  158A     BSF PCLATH, 0x3
94:                write_i2c(0x07);
0AAE  3007     MOVLW 0x7
0AAF  2329     CALL 0x329
0AB0  120A     BCF PCLATH, 0x4
0AB1  158A     BSF PCLATH, 0x3
95:                write_i2c(0b00010000);
0AB2  3010     MOVLW 0x10
0AB3  2329     CALL 0x329
0AB4  120A     BCF PCLATH, 0x4
0AB5  158A     BSF PCLATH, 0x3
96:                stop_i2c();
0AB6  235B     CALL 0x35B
0AB7  120A     BCF PCLATH, 0x4
0AB8  158A     BSF PCLATH, 0x3
97:                start_i2c();
0AB9  2353     CALL 0x353
0ABA  120A     BCF PCLATH, 0x4
0ABB  158A     BSF PCLATH, 0x3
98:                write_i2c(isl1208_Write);
0ABC  30DE     MOVLW 0xDE
0ABD  2329     CALL 0x329
0ABE  120A     BCF PCLATH, 0x4
0ABF  158A     BSF PCLATH, 0x3
99:                write_i2c(0x00);
0AC0  3000     MOVLW 0x0
0AC1  2329     CALL 0x329
0AC2  120A     BCF PCLATH, 0x4
0AC3  158A     BSF PCLATH, 0x3
100:               write_i2c(isl1208_bin2bcd(sec));
0AC4  1283     BCF STATUS, 0x5
0AC5  082B     MOVF sec, W
0AC6  2341     CALL 0x341
0AC7  120A     BCF PCLATH, 0x4
0AC8  158A     BSF PCLATH, 0x3
0AC9  2329     CALL 0x329
0ACA  120A     BCF PCLATH, 0x4
0ACB  158A     BSF PCLATH, 0x3
101:               write_i2c(isl1208_bin2bcd(min));
0ACC  1283     BCF STATUS, 0x5
0ACD  082A     MOVF Data, W
0ACE  2341     CALL 0x341
0ACF  120A     BCF PCLATH, 0x4
0AD0  158A     BSF PCLATH, 0x3
0AD1  2329     CALL 0x329
0AD2  120A     BCF PCLATH, 0x4
0AD3  158A     BSF PCLATH, 0x3
102:               write_i2c(isl1208_bin2bcd(hr) | 0b10000000);
0AD4  1283     BCF STATUS, 0x5
0AD5  082C     MOVF hr, W
0AD6  2341     CALL 0x341
0AD7  120A     BCF PCLATH, 0x4
0AD8  158A     BSF PCLATH, 0x3
0AD9  3880     IORLW 0x80
0ADA  2329     CALL 0x329
0ADB  120A     BCF PCLATH, 0x4
0ADC  158A     BSF PCLATH, 0x3
103:               stop_i2c();
0ADD  2B5B     GOTO 0x35B
104:           
105:           #ifndef USE_INTERRUPTS
106:               //  ei();
107:           #endif
108:           
109:           }
110:           
111:           void isl1208_set_date(unsigned char* day, unsigned char* mth, unsigned char* year, unsigned char* dow) {
0ADE  00AD     MOVWF day
112:           
113:           #ifndef USE_INTERRUPTS
114:               //di();
115:           #endif
116:           
117:               start_i2c();
0ADF  2353     CALL 0x353
0AE0  120A     BCF PCLATH, 0x4
0AE1  158A     BSF PCLATH, 0x3
118:               write_i2c(isl1208_Write);
0AE2  30DE     MOVLW 0xDE
0AE3  2329     CALL 0x329
0AE4  120A     BCF PCLATH, 0x4
0AE5  158A     BSF PCLATH, 0x3
119:               write_i2c(0x07);
0AE6  3007     MOVLW 0x7
0AE7  2329     CALL 0x329
0AE8  120A     BCF PCLATH, 0x4
0AE9  158A     BSF PCLATH, 0x3
120:               write_i2c(0b00010000);
0AEA  3010     MOVLW 0x10
0AEB  2329     CALL 0x329
0AEC  120A     BCF PCLATH, 0x4
0AED  158A     BSF PCLATH, 0x3
121:               stop_i2c();
0AEE  235B     CALL 0x35B
0AEF  120A     BCF PCLATH, 0x4
0AF0  158A     BSF PCLATH, 0x3
122:               start_i2c();
0AF1  2353     CALL 0x353
0AF2  120A     BCF PCLATH, 0x4
0AF3  158A     BSF PCLATH, 0x3
123:               write_i2c(isl1208_Write);
0AF4  30DE     MOVLW 0xDE
0AF5  2329     CALL 0x329
0AF6  120A     BCF PCLATH, 0x4
0AF7  158A     BSF PCLATH, 0x3
124:               write_i2c(0x03);
0AF8  3003     MOVLW 0x3
0AF9  2329     CALL 0x329
0AFA  120A     BCF PCLATH, 0x4
0AFB  158A     BSF PCLATH, 0x3
125:               write_i2c(isl1208_bin2bcd(*day));
0AFC  1283     BCF STATUS, 0x5
0AFD  082D     MOVF day, W
0AFE  0084     MOVWF FSR
0AFF  1383     BCF STATUS, 0x7
0B00  0800     MOVF INDF, W
0B01  2341     CALL 0x341
0B02  120A     BCF PCLATH, 0x4
0B03  158A     BSF PCLATH, 0x3
0B04  2329     CALL 0x329
0B05  120A     BCF PCLATH, 0x4
0B06  158A     BSF PCLATH, 0x3
126:               write_i2c(isl1208_bin2bcd(*mth));
0B07  1283     BCF STATUS, 0x5
0B08  082A     MOVF Data, W
0B09  0084     MOVWF FSR
0B0A  1383     BCF STATUS, 0x7
0B0B  0800     MOVF INDF, W
0B0C  2341     CALL 0x341
0B0D  120A     BCF PCLATH, 0x4
0B0E  158A     BSF PCLATH, 0x3
0B0F  2329     CALL 0x329
0B10  120A     BCF PCLATH, 0x4
0B11  158A     BSF PCLATH, 0x3
127:               write_i2c(isl1208_bin2bcd(*year));
0B12  1283     BCF STATUS, 0x5
0B13  082B     MOVF sec, W
0B14  0084     MOVWF FSR
0B15  1383     BCF STATUS, 0x7
0B16  0800     MOVF INDF, W
0B17  2341     CALL 0x341
0B18  120A     BCF PCLATH, 0x4
0B19  158A     BSF PCLATH, 0x3
0B1A  2329     CALL 0x329
0B1B  120A     BCF PCLATH, 0x4
0B1C  158A     BSF PCLATH, 0x3
128:               write_i2c(isl1208_bin2bcd(*dow));
0B1D  1283     BCF STATUS, 0x5
0B1E  082C     MOVF hr, W
0B1F  0084     MOVWF FSR
0B20  1383     BCF STATUS, 0x7
0B21  0800     MOVF INDF, W
0B22  2341     CALL 0x341
0B23  120A     BCF PCLATH, 0x4
0B24  158A     BSF PCLATH, 0x3
0B25  2329     CALL 0x329
0B26  120A     BCF PCLATH, 0x4
0B27  158A     BSF PCLATH, 0x3
129:               stop_i2c();
0B28  2B5B     GOTO 0x35B
130:           
131:           #ifndef USE_INTERRUPTS
132:               //  ei();
133:           #endif
134:           
135:           }
136:           
137:           void isl1208_get_date(unsigned char* day, unsigned char* mth, unsigned char* year, unsigned char *dow) {
0A17  00AB     MOVWF sec
138:           
139:           #ifndef USE_INTERRUPTS
140:               // di();
141:           #endif
142:           
143:               start_i2c();
0A18  2353     CALL 0x353
0A19  120A     BCF PCLATH, 0x4
0A1A  158A     BSF PCLATH, 0x3
144:               write_i2c(isl1208_Write);
0A1B  30DE     MOVLW 0xDE
0A1C  2329     CALL 0x329
0A1D  120A     BCF PCLATH, 0x4
0A1E  158A     BSF PCLATH, 0x3
145:               write_i2c(0x03);
0A1F  3003     MOVLW 0x3
0A20  2329     CALL 0x329
0A21  120A     BCF PCLATH, 0x4
0A22  158A     BSF PCLATH, 0x3
146:               rstart_i2c();
0A23  2397     CALL 0x397
0A24  120A     BCF PCLATH, 0x4
0A25  158A     BSF PCLATH, 0x3
147:               write_i2c(isl1208_Read);
0A26  30DF     MOVLW 0xDF
0A27  2329     CALL 0x329
0A28  120A     BCF PCLATH, 0x4
0A29  158A     BSF PCLATH, 0x3
148:               *day = isl1208_bcd2bin(read_i2c(ACK) & 0x3f);
0A2A  1283     BCF STATUS, 0x5
0A2B  082B     MOVF sec, W
0A2C  0084     MOVWF FSR
0A2D  3000     MOVLW 0x0
0A2E  2363     CALL 0x363
0A2F  120A     BCF PCLATH, 0x4
0A30  158A     BSF PCLATH, 0x3
0A31  393F     ANDLW 0x3F
0A32  238D     CALL 0x38D
0A33  120A     BCF PCLATH, 0x4
0A34  158A     BSF PCLATH, 0x3
0A35  1383     BCF STATUS, 0x7
0A36  0080     MOVWF INDF
149:               *mth = isl1208_bcd2bin(read_i2c(ACK) & 0x1f);
0A37  0828     MOVF mth, W
0A38  0084     MOVWF FSR
0A39  3000     MOVLW 0x0
0A3A  2363     CALL 0x363
0A3B  120A     BCF PCLATH, 0x4
0A3C  158A     BSF PCLATH, 0x3
0A3D  391F     ANDLW 0x1F
0A3E  238D     CALL 0x38D
0A3F  120A     BCF PCLATH, 0x4
0A40  158A     BSF PCLATH, 0x3
0A41  1383     BCF STATUS, 0x7
0A42  0080     MOVWF INDF
150:               *year = isl1208_bcd2bin(read_i2c(ACK));
0A43  0829     MOVF year, W
0A44  0084     MOVWF FSR
0A45  3000     MOVLW 0x0
0A46  2363     CALL 0x363
0A47  120A     BCF PCLATH, 0x4
0A48  158A     BSF PCLATH, 0x3
0A49  238D     CALL 0x38D
0A4A  120A     BCF PCLATH, 0x4
0A4B  158A     BSF PCLATH, 0x3
0A4C  1383     BCF STATUS, 0x7
0A4D  0080     MOVWF INDF
151:               *dow = isl1208_bcd2bin(read_i2c(NOACK) & 0x07);
0A4E  082A     MOVF Data, W
0A4F  0084     MOVWF FSR
0A50  3001     MOVLW 0x1
0A51  2363     CALL 0x363
0A52  120A     BCF PCLATH, 0x4
0A53  158A     BSF PCLATH, 0x3
0A54  3907     ANDLW 0x7
0A55  238D     CALL 0x38D
0A56  120A     BCF PCLATH, 0x4
0A57  158A     BSF PCLATH, 0x3
0A58  1383     BCF STATUS, 0x7
0A59  0080     MOVWF INDF
152:               stop_i2c();
0A5A  2B5B     GOTO 0x35B
153:           #ifndef USE_INTERRUPTS
154:               // ei();
155:           #endif
156:           
157:           }
158:           
159:           void isl1208_get_time(unsigned char *hr, unsigned char* min, unsigned char *sec) {
09A5  00AA     MOVWF Data
160:           
161:           #ifndef USE_INTERRUPTS
162:               // di();
163:           #endif
164:           
165:               start_i2c();
09A6  2353     CALL 0x353
09A7  120A     BCF PCLATH, 0x4
09A8  158A     BSF PCLATH, 0x3
166:               write_i2c(isl1208_Write);
09A9  30DE     MOVLW 0xDE
09AA  2329     CALL 0x329
09AB  120A     BCF PCLATH, 0x4
09AC  158A     BSF PCLATH, 0x3
167:               write_i2c(0x00);
09AD  3000     MOVLW 0x0
09AE  2329     CALL 0x329
09AF  120A     BCF PCLATH, 0x4
09B0  158A     BSF PCLATH, 0x3
168:           
169:               rstart_i2c();
09B1  2397     CALL 0x397
09B2  120A     BCF PCLATH, 0x4
09B3  158A     BSF PCLATH, 0x3
170:               write_i2c(isl1208_Read);
09B4  30DF     MOVLW 0xDF
09B5  2329     CALL 0x329
09B6  120A     BCF PCLATH, 0x4
09B7  158A     BSF PCLATH, 0x3
171:               *sec = isl1208_bcd2bin(read_i2c(ACK) & 0x7f);
09B8  1283     BCF STATUS, 0x5
09B9  0829     MOVF year, W
09BA  0084     MOVWF FSR
09BB  3000     MOVLW 0x0
09BC  2363     CALL 0x363
09BD  120A     BCF PCLATH, 0x4
09BE  158A     BSF PCLATH, 0x3
09BF  397F     ANDLW 0x7F
09C0  238D     CALL 0x38D
09C1  120A     BCF PCLATH, 0x4
09C2  158A     BSF PCLATH, 0x3
09C3  1383     BCF STATUS, 0x7
09C4  0080     MOVWF INDF
172:               * min = isl1208_bcd2bin(read_i2c(ACK) & 0x7f);
09C5  0828     MOVF mth, W
09C6  0084     MOVWF FSR
09C7  3000     MOVLW 0x0
09C8  2363     CALL 0x363
09C9  120A     BCF PCLATH, 0x4
09CA  158A     BSF PCLATH, 0x3
09CB  397F     ANDLW 0x7F
09CC  238D     CALL 0x38D
09CD  120A     BCF PCLATH, 0x4
09CE  158A     BSF PCLATH, 0x3
09CF  1383     BCF STATUS, 0x7
09D0  0080     MOVWF INDF
173:               * hr = isl1208_bcd2bin(read_i2c(NOACK) & 0x3f);
09D1  082A     MOVF Data, W
09D2  0084     MOVWF FSR
09D3  3001     MOVLW 0x1
09D4  2363     CALL 0x363
09D5  120A     BCF PCLATH, 0x4
09D6  158A     BSF PCLATH, 0x3
09D7  393F     ANDLW 0x3F
09D8  238D     CALL 0x38D
09D9  120A     BCF PCLATH, 0x4
09DA  158A     BSF PCLATH, 0x3
09DB  1383     BCF STATUS, 0x7
09DC  0080     MOVWF INDF
174:               stop_i2c();
09DD  2B5B     GOTO 0x35B
175:           
176:           #ifndef USE_INTERRUPTS
177:               // ei();
178:           #endif
179:           
180:           }
181:           
182:           void isl1208_set_time_enc(unsigned char hr, unsigned char min, unsigned char sec) {
0A79  00AC     MOVWF hr
183:           #ifndef USE_INTERRUPTS
184:               //di();
185:           #endif
186:               min &=0x7F;
0A7B  13AA     BCF Data, 0x7
187:               hr &= 0x3F;
0A7A  303F     MOVLW 0x3F
0A7C  05AC     ANDWF hr, F
188:               
189:               start_i2c();
0A7D  2353     CALL 0x353
0A7E  120A     BCF PCLATH, 0x4
0A7F  158A     BSF PCLATH, 0x3
190:               write_i2c(isl1208_Write);
0A80  30DE     MOVLW 0xDE
0A81  2329     CALL 0x329
0A82  120A     BCF PCLATH, 0x4
0A83  158A     BSF PCLATH, 0x3
191:               write_i2c(0x0C);
0A84  300C     MOVLW 0xC
0A85  2329     CALL 0x329
0A86  120A     BCF PCLATH, 0x4
0A87  158A     BSF PCLATH, 0x3
192:               write_i2c(isl1208_bin2bcd(0));
0A88  3000     MOVLW 0x0
0A89  2341     CALL 0x341
0A8A  120A     BCF PCLATH, 0x4
0A8B  158A     BSF PCLATH, 0x3
0A8C  2329     CALL 0x329
0A8D  120A     BCF PCLATH, 0x4
0A8E  158A     BSF PCLATH, 0x3
193:               write_i2c(isl1208_bin2bcd(min)| 0b10000000); //habilita la alarma de minutos
0A8F  1283     BCF STATUS, 0x5
0A90  082A     MOVF Data, W
0A91  2341     CALL 0x341
0A92  120A     BCF PCLATH, 0x4
0A93  158A     BSF PCLATH, 0x3
0A94  3880     IORLW 0x80
0A95  2329     CALL 0x329
0A96  120A     BCF PCLATH, 0x4
0A97  158A     BSF PCLATH, 0x3
194:               write_i2c(isl1208_bin2bcd(hr) | 0b10000000); //habilita la alarma de horas
0A98  1283     BCF STATUS, 0x5
0A99  082C     MOVF hr, W
0A9A  2341     CALL 0x341
0A9B  120A     BCF PCLATH, 0x4
0A9C  158A     BSF PCLATH, 0x3
0A9D  3880     IORLW 0x80
0A9E  2329     CALL 0x329
0A9F  120A     BCF PCLATH, 0x4
0AA0  158A     BSF PCLATH, 0x3
195:               stop_i2c();
0AA1  2B5B     GOTO 0x35B
196:           
197:           #ifndef USE_INTERRUPTS
198:               //  ei();
199:           #endif
200:           
201:           }
202:           void isl1208_set_dow_enc(unsigned char *dow) {
0A5B  1283     BCF STATUS, 0x5
0A5C  00AA     MOVWF Data
203:           //TODO terminar de implementar la funcion de escritura de dow.
204:           #ifndef USE_INTERRUPTS
205:               //di();
206:           #endif
207:               *dow &=0x07;
0A5D  0084     MOVWF FSR
0A5E  3007     MOVLW 0x7
0A5F  1383     BCF STATUS, 0x7
0A60  0580     ANDWF INDF, F
208:               start_i2c();
0A61  2353     CALL 0x353
0A62  120A     BCF PCLATH, 0x4
0A63  158A     BSF PCLATH, 0x3
209:               write_i2c(isl1208_Write);
0A64  30DE     MOVLW 0xDE
0A65  2329     CALL 0x329
0A66  120A     BCF PCLATH, 0x4
0A67  158A     BSF PCLATH, 0x3
210:               write_i2c(0x11);
0A68  3011     MOVLW 0x11
0A69  2329     CALL 0x329
0A6A  120A     BCF PCLATH, 0x4
0A6B  158A     BSF PCLATH, 0x3
211:               write_i2c(isl1208_bin2bcd(*dow)| 0b10000000); //habilita la alarma de dow
0A6C  1283     BCF STATUS, 0x5
0A6D  082A     MOVF Data, W
0A6E  0084     MOVWF FSR
0A6F  1383     BCF STATUS, 0x7
0A70  0800     MOVF INDF, W
0A71  2341     CALL 0x341
0A72  120A     BCF PCLATH, 0x4
0A73  158A     BSF PCLATH, 0x3
0A74  3880     IORLW 0x80
0A75  2329     CALL 0x329
0A76  120A     BCF PCLATH, 0x4
0A77  158A     BSF PCLATH, 0x3
212:               stop_i2c();
0A78  2B5B     GOTO 0x35B
213:           
214:           #ifndef USE_INTERRUPTS
215:               //  ei();
216:           #endif
217:           
218:           }
219:           
220:           void isl1208_get_dow_enc(unsigned char *dow) {
0983  1283     BCF STATUS, 0x5
0984  00A8     MOVWF mth
221:           //TODO terminar de implementar la funcion de escritura de dow.
222:           #ifndef USE_INTERRUPTS
223:               //di();
224:           #endif
225:           
226:               start_i2c();
0985  2353     CALL 0x353
0986  120A     BCF PCLATH, 0x4
0987  158A     BSF PCLATH, 0x3
227:               write_i2c(isl1208_Write);
0988  30DE     MOVLW 0xDE
0989  2329     CALL 0x329
098A  120A     BCF PCLATH, 0x4
098B  158A     BSF PCLATH, 0x3
228:               write_i2c(0x11);
098C  3011     MOVLW 0x11
098D  2329     CALL 0x329
098E  120A     BCF PCLATH, 0x4
098F  158A     BSF PCLATH, 0x3
229:               rstart_i2c();
0990  2397     CALL 0x397
0991  120A     BCF PCLATH, 0x4
0992  158A     BSF PCLATH, 0x3
230:               write_i2c(isl1208_Read);
0993  30DF     MOVLW 0xDF
0994  2329     CALL 0x329
0995  120A     BCF PCLATH, 0x4
0996  158A     BSF PCLATH, 0x3
231:               *dow = isl1208_bcd2bin(read_i2c(NOACK) & 0x07);
0997  1283     BCF STATUS, 0x5
0998  0828     MOVF mth, W
0999  0084     MOVWF FSR
099A  3001     MOVLW 0x1
099B  2363     CALL 0x363
099C  120A     BCF PCLATH, 0x4
099D  158A     BSF PCLATH, 0x3
099E  3907     ANDLW 0x7
099F  238D     CALL 0x38D
09A0  120A     BCF PCLATH, 0x4
09A1  158A     BSF PCLATH, 0x3
09A2  1383     BCF STATUS, 0x7
09A3  0080     MOVWF INDF
232:               stop_i2c();
09A4  2B5B     GOTO 0x35B
233:           
234:           #ifndef USE_INTERRUPTS
235:               //  ei();
236:           #endif
237:           
238:           }
239:           void isl1208_get_time_enc(unsigned char *hr, unsigned char* min, unsigned char *sec) {
09DE  00AA     MOVWF Data
240:           
241:           #ifndef USE_INTERRUPTS
242:               // di();
243:           #endif
244:           
245:               start_i2c();
09DF  2353     CALL 0x353
09E0  120A     BCF PCLATH, 0x4
09E1  158A     BSF PCLATH, 0x3
246:               write_i2c(isl1208_Write);
09E2  30DE     MOVLW 0xDE
09E3  2329     CALL 0x329
09E4  120A     BCF PCLATH, 0x4
09E5  158A     BSF PCLATH, 0x3
247:               write_i2c(0x0C);
09E6  300C     MOVLW 0xC
09E7  2329     CALL 0x329
09E8  120A     BCF PCLATH, 0x4
09E9  158A     BSF PCLATH, 0x3
248:           
249:               rstart_i2c();
09EA  2397     CALL 0x397
09EB  120A     BCF PCLATH, 0x4
09EC  158A     BSF PCLATH, 0x3
250:               write_i2c(isl1208_Read);
09ED  30DF     MOVLW 0xDF
09EE  2329     CALL 0x329
09EF  120A     BCF PCLATH, 0x4
09F0  158A     BSF PCLATH, 0x3
251:               *sec = isl1208_bcd2bin(read_i2c(ACK) & 0x7f);
09F1  1283     BCF STATUS, 0x5
09F2  0829     MOVF year, W
09F3  0084     MOVWF FSR
09F4  3000     MOVLW 0x0
09F5  2363     CALL 0x363
09F6  120A     BCF PCLATH, 0x4
09F7  158A     BSF PCLATH, 0x3
09F8  397F     ANDLW 0x7F
09F9  238D     CALL 0x38D
09FA  120A     BCF PCLATH, 0x4
09FB  158A     BSF PCLATH, 0x3
09FC  1383     BCF STATUS, 0x7
09FD  0080     MOVWF INDF
252:               * min = isl1208_bcd2bin(read_i2c(ACK) & 0x7f);
09FE  0828     MOVF mth, W
09FF  0084     MOVWF FSR
0A00  3000     MOVLW 0x0
0A01  2363     CALL 0x363
0A02  120A     BCF PCLATH, 0x4
0A03  158A     BSF PCLATH, 0x3
0A04  397F     ANDLW 0x7F
0A05  238D     CALL 0x38D
0A06  120A     BCF PCLATH, 0x4
0A07  158A     BSF PCLATH, 0x3
0A08  1383     BCF STATUS, 0x7
0A09  0080     MOVWF INDF
253:               * hr = isl1208_bcd2bin(read_i2c(NOACK) & 0x3f);
0A0A  082A     MOVF Data, W
0A0B  0084     MOVWF FSR
0A0C  3001     MOVLW 0x1
0A0D  2363     CALL 0x363
0A0E  120A     BCF PCLATH, 0x4
0A0F  158A     BSF PCLATH, 0x3
0A10  393F     ANDLW 0x3F
0A11  238D     CALL 0x38D
0A12  120A     BCF PCLATH, 0x4
0A13  158A     BSF PCLATH, 0x3
0A14  1383     BCF STATUS, 0x7
0A15  0080     MOVWF INDF
254:               stop_i2c();
0A16  2B5B     GOTO 0x35B
255:           
256:           #ifndef USE_INTERRUPTS
257:               // ei();
258:           #endif
259:           
260:           }
261:           
262:           char isl1208_read_nvram_byte(char addr) {
263:           
264:               char retval;
265:           
266:           #ifndef USE_INTERRUPTS
267:               // di();
268:           #endif
269:           
270:               start_i2c();
271:               write_i2c(isl1208_Write);
272:               write_i2c(addr);
273:           
274:               start_i2c();
275:               write_i2c(isl1208_Read);
276:               retval = read_i2c(NOACK);
277:               stop_i2c();
278:           
279:           
280:           
281:           #ifndef USE_INTERRUPTS
282:               // ei();
283:           #endif
284:               return (retval);
285:           }
286:           
287:           void isl1208_write_nvram_byte(char addr, char value) {
288:           
289:           #ifndef USE_INTERRUPTS
290:               //di();
291:           #endif
292:           
293:               start_i2c();
294:               write_i2c(isl1208_Write);
295:               write_i2c(addr);
296:               write_i2c(value);
297:               stop_i2c();
298:           
299:           #ifndef USE_INTERRUPTS
300:               // ei();
301:           #endif
302:           
303:           }
304:           int aniobisiesto(unsigned char year)
0F9E  00FA     MOVWF j
305:           {
306:               return ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0);
0F9F  01F9     CLRF Indice
0FA0  0AF9     INCF Indice, F
0FA1  3903     ANDLW 0x3
0FA2  1D03     BTFSS STATUS, 0x2
0FA3  2FAD     GOTO 0x7AD
0FA4  3064     MOVLW 0x64
0FA5  00F0     MOVWF divisor
0FA6  087A     MOVF j, W
0FA7  27BF     CALL 0x7BF
0FA8  120A     BCF PCLATH, 0x4
0FA9  158A     BSF PCLATH, 0x3
0FAA  3800     IORLW 0x0
0FAB  1D03     BTFSS STATUS, 0x2
0FAC  2FBB     GOTO 0x7BB
0FAD  3090     MOVLW 0x90
0FAE  00F0     MOVWF divisor
0FAF  3001     MOVLW 0x1
0FB0  00F1     MOVWF canal
0FB1  087A     MOVF j, W
0FB2  00F2     MOVWF dividend
0FB3  01F3     CLRF counter
0FB4  160A     BSF PCLATH, 0x4
0FB5  118A     BCF PCLATH, 0x3
0FB6  2459     CALL 0x459
0FB7  0871     MOVF canal, W
0FB8  0470     IORWF divisor, W
0FB9  1D03     BTFSS STATUS, 0x2
0FBA  01F9     CLRF Indice
0FBB  0879     MOVF Indice, W
0FBC  00F6     MOVWF TipoPin
0FBD  01F7     CLRF Logica
307:           }
0FBE  0008     RETURN
308:           unsigned char dia_de_la_semana(unsigned char *dia, unsigned char *mes, unsigned char *anio){
0899  00C5     MOVWF dia
309:           //se usa el algoritmo de Zeller
310:              unsigned char a,y,m,dow;
311:           
312:              a = (14 -*mes) / 12;
089A  300E     MOVLW 0xE
089B  00AB     MOVWF sec
089C  01AC     CLRF hr
089D  0837     MOVF mes, W
089E  0084     MOVWF FSR
089F  0800     MOVF INDF, W
08A0  02AB     SUBWF sec, F
08A1  1C03     BTFSS STATUS, 0x0
08A2  03AC     DECF hr, F
08A3  300C     MOVLW 0xC
08A4  00A9     MOVWF year
08A5  01AA     CLRF Data
08A6  2113     CALL 0x113
08A7  120A     BCF PCLATH, 0x4
08A8  158A     BSF PCLATH, 0x3
08A9  0829     MOVF year, W
08AA  00C4     MOVWF a
313:           y = *anio - a;
08AB  0838     MOVF anio, W
08AC  0084     MOVWF FSR
08AD  0844     MOVF a, W
08AE  1383     BCF STATUS, 0x7
08AF  0200     SUBWF INDF, W
08B0  00C6     MOVWF y
314:           m = *mes + 12 * a - 2;
08B1  0837     MOVF mes, W
08B2  0084     MOVWF FSR
08B3  300C     MOVLW 0xC
08B4  00A3     MOVWF x
08B5  0844     MOVF a, W
08B6  23BA     CALL 0x3BA
08B7  120A     BCF PCLATH, 0x4
08B8  158A     BSF PCLATH, 0x3
08B9  1383     BCF STATUS, 0x7
08BA  0700     ADDWF INDF, W
08BB  3EFE     ADDLW 0xFE
08BC  00C2     MOVWF m
315:           
316:           //Para el calendario Juliano:
317:           //d = (5 + dia + y + y/4 + (31*m)/12) mod 7
318:           
319:           //Para el calendario Gregoriano:
320:            dow = (*dia + y + y/4 - y/100 + y/400 + (31*m)/12) % 7;
08BD  3007     MOVLW 0x7
08BE  00B1     MOVWF divisor
08BF  3090     MOVLW 0x90
08C0  01B2     CLRF 0x32
08C1  00A9     MOVWF year
08C2  3001     MOVLW 0x1
08C3  00AA     MOVWF Data
08C4  0846     MOVF y, W
08C5  00AB     MOVWF sec
08C6  01AC     CLRF hr
08C7  2113     CALL 0x113
08C8  0846     MOVF y, W
08C9  00B9     MOVWF 0x39
08CA  1003     BCF STATUS, 0x0
08CB  0CB9     RRF 0x39, F
08CC  1003     BCF STATUS, 0x0
08CD  0CB9     RRF 0x39, F
08CE  0845     MOVF dia, W
08CF  0084     MOVWF FSR
08D0  1383     BCF STATUS, 0x7
08D1  0800     MOVF INDF, W
08D2  0746     ADDWF y, W
08D3  00BA     MOVWF f1
08D4  01BB     CLRF 0x3B
08D5  0DBB     RLF 0x3B, F
08D6  0839     MOVF 0x39, W
08D7  073A     ADDWF f1, W
08D8  00BC     MOVWF 0x3C
08D9  3000     MOVLW 0x0
08DA  1803     BTFSC STATUS, 0x0
08DB  3001     MOVLW 0x1
08DC  073B     ADDWF 0x3B, W
08DD  00BD     MOVWF f1
08DE  0829     MOVF year, W
08DF  073C     ADDWF 0x3C, W
08E0  00BE     MOVWF 0x3E
08E1  082A     MOVF Data, W
08E2  1803     BTFSC STATUS, 0x0
08E3  0A2A     INCF Data, W
08E4  073D     ADDWF f1, W
08E5  00BF     MOVWF 0x3F
08E6  300C     MOVLW 0xC
08E7  00A9     MOVWF year
08E8  01AA     CLRF Data
08E9  0842     MOVF m, W
08EA  00A3     MOVWF x
08EB  301F     MOVLW 0x1F
08EC  01A4     CLRF dato
08ED  00A5     MOVWF y
08EE  01A6     CLRF x
08EF  120A     BCF PCLATH, 0x4
08F0  118A     BCF PCLATH, 0x3
08F1  278D     CALL 0x78D
08F2  120A     BCF PCLATH, 0x4
08F3  158A     BSF PCLATH, 0x3
08F4  0824     MOVF dato, W
08F5  00AC     MOVWF hr
08F6  0823     MOVF x, W
08F7  00AB     MOVWF sec
08F8  2113     CALL 0x113
08F9  120A     BCF PCLATH, 0x4
08FA  158A     BSF PCLATH, 0x3
08FB  0829     MOVF year, W
08FC  073E     ADDWF 0x3E, W
08FD  00C0     MOVWF f2
08FE  082A     MOVF Data, W
08FF  1803     BTFSC STATUS, 0x0
0900  0A2A     INCF Data, W
0901  073F     ADDWF 0x3F, W
0902  00C1     MOVWF 0x41
0903  3064     MOVLW 0x64
0904  00A3     MOVWF x
0905  0846     MOVF y, W
0906  239F     CALL 0x39F
0907  120A     BCF PCLATH, 0x4
0908  158A     BSF PCLATH, 0x3
0909  0240     SUBWF f2, W
090A  00B3     MOVWF dividend
090B  0841     MOVF 0x41, W
090C  1C03     BTFSS STATUS, 0x0
090D  0341     DECF 0x41, W
090E  00B4     MOVWF sign
090F  23C8     CALL 0x3C8
0910  0831     MOVF divisor, W
0911  00C3     MOVWF dow
321:           
322:           //El resultado es un cero (0) para el domingo, 1 para el lunes? 6 para el sbado
323:           
324:            return (dow);
325:           }
0912  0008     RETURN
326:           ///////////////////////////////////////////////////////////////////////////////
327:           
328:           unsigned char isl1208_bin2bcd(unsigned char binary_value) {
0B41  1283     BCF STATUS, 0x5
0B42  00A9     MOVWF year
329:               return ((binary_value / 10) << 4) +binary_value % 10;
0B43  300A     MOVLW 0xA
0B44  00A3     MOVWF x
0B45  0829     MOVF year, W
0B46  239F     CALL 0x39F
0B47  120A     BCF PCLATH, 0x4
0B48  158A     BSF PCLATH, 0x3
0B49  00A8     MOVWF mth
0B4A  0E28     SWAPF mth, W
0B4B  39F0     ANDLW 0xF0
0B4C  00A8     MOVWF mth
0B4D  300A     MOVLW 0xA
0B4E  00A3     MOVWF x
0B4F  0829     MOVF year, W
0B50  2405     CALL 0x405
0B51  0728     ADDWF mth, W
330:           
331:           }
0B52  0008     RETURN
332:           
333:           unsigned char isl1208_bcd2bin(unsigned char bcd_value) {
0B8D  00A7     MOVWF i
334:               return (bcd_value & 0x0F) + (bcd_value >> 4) * 10;
0B8E  390F     ANDLW 0xF
0B8F  00A6     MOVWF x
0B90  300A     MOVLW 0xA
0B91  00A3     MOVWF x
0B92  0E27     SWAPF i, W
0B93  390F     ANDLW 0xF
0B94  23BA     CALL 0x3BA
0B95  0726     ADDWF x, W
335:           }
0B96  0008     RETURN
336:           
337:           
338:           /*unsigned int ISL1208::bcd2bin(unsigned char val)
339:           {
340:               return (val & 0x0F) + (val >> 4) * 10;
341:           }
342:           
343:           char ISL1208::bin2bcd(unsigned int val)
344:           {
345:               return ((val / 10) << 4) + val % 10;
346:           }*/
347:           ///////////////////////////////////////////////////////////////////////////////
348:           
349:           
350:           
351:           
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/Pulsadores.c  -------------------------
1:             //Programa de gestin de pulsadores por Nocturno adaptado a xc8 por Pablo F. Manieri
2:             
3:             #include <xc.h>
4:             #include <stdint.h>
5:             #include <stdbool.h>
6:             #include "system.h"
7:             #include "user.h"
8:             #include "Pulsadores.h"
9:             
10:            /****** HARDWARE ********
11:            BOTON_Subir       	RB1
12:            BOTON_Bajar       	RB2
13:            BOTON_MENU       	RB3
14:            BOTON_MANAUT     	RB4
15:            BOTON_ONOFF		RB5
16:            **************************/
17:            
18:            bool Pulsacion(unsigned char Indice, unsigned char Pin, unsigned char TipoPin, bool Logica) {
0ED1  00F9     MOVWF Indice
19:               /*
20:                  Esta funcin gestiona las entradas de pulsador, mediante el control de un retardo
21:                  antirrebotes y con la opcin de autorrepeticin de hasta 4 velocidades
22:                  
23:                  Para que funcione, hay que dimensionar la variable Entradas con el n de pulsadores
24:                  que queramos controlar.
25:                  
26:                  ENTRADAS
27:                     Indice: hace referencia al n de pulsador a chequear
28:                     Pin: indica el estado del pin del pulsador (lgica inversa)
29:                     TipoPIN:
30:                        TipoPin=0   -> No tiene autorrepeticin
31:                        TipoPin=1   -> Pin con autorrepeticin
32:                     
33:                  SALIDA
34:                     La funcin devuelve un 1 si el pulsador est en condiciones de ser procesado
35:                     y un 0 en caso contrario.
36:                  
37:               */
38:               static unsigned int Entradas[5]={0,0,0,0,0};  // Dimensionar en funcin del n de pulsadores
39:               unsigned int j;
40:              bool resultado=0;
0ED2  01F8     CLRF resultado
41:               
42:               j=Entradas[Indice];  // Como leemos muchas veces el array, lo pasamos a variable local para 
0ED3  1003     BCF STATUS, 0x0
0ED4  0D79     RLF Indice, W
0ED5  3EA0     ADDLW 0xA0
0ED6  0084     MOVWF FSR
0ED7  1383     BCF STATUS, 0x7
0ED8  0800     MOVF INDF, W
0ED9  00FA     MOVWF j
0EDA  0A84     INCF FSR, F
0EDB  0800     MOVF INDF, W
0EDC  00FB     MOVWF 0x7B
43:                                    // incrementar la velocidad de ejecucin
44:                                    
45:               // Si se detecta pulsacin y antes no haba, devolvemos un 1 en resultado
46:               if ((((!Pin && Logica==LOGICA_INVERSA) || (Pin && Logica==LOGICA_DIRECTA)) && (j==0))) {
0EDD  08F5     MOVF Pin, F
0EDE  1903     BTFSC STATUS, 0x2
0EDF  0377     DECF Logica, W
0EE0  1903     BTFSC STATUS, 0x2
0EE1  2EE8     GOTO 0x6E8
0EE2  0875     MOVF Pin, W
0EE3  1903     BTFSC STATUS, 0x2
0EE4  2EF1     GOTO 0x6F1
0EE5  08F7     MOVF Logica, F
0EE6  1D03     BTFSS STATUS, 0x2
0EE7  2EF1     GOTO 0x6F1
0EE8  087B     MOVF 0x7B, W
0EE9  047A     IORWF j, W
0EEA  1D03     BTFSS STATUS, 0x2
0EEB  2EF1     GOTO 0x6F1
47:                     resultado=1;
0EEC  01F8     CLRF resultado
0EED  0AF8     INCF resultado, F
48:                     j=1;
0EEE  01FA     CLRF j
0EEF  0AFA     INCF j, F
0EF0  01FB     CLRF 0x7B
49:               };
50:               
51:               // Cada vez que se entra a la funcin se incrementa una unidad el array
52:               if (j>0) 
0EF1  087B     MOVF 0x7B, W
0EF2  047A     IORWF j, W
0EF3  1903     BTFSC STATUS, 0x2
0EF4  2EFE     GOTO 0x6FE
53:                     Entradas[Indice]++;
0EF5  1003     BCF STATUS, 0x0
0EF6  0D79     RLF Indice, W
0EF7  3EA0     ADDLW 0xA0
0EF8  0084     MOVWF FSR
0EF9  3001     MOVLW 0x1
0EFA  0780     ADDWF INDF, F
0EFB  0A84     INCF FSR, F
0EFC  1803     BTFSC STATUS, 0x0
0EFD  0A80     INCF INDF, F
54:               
55:               // Si se detecta que ya no se est pulsando, inicializamos a 0 el array
56:               if (((Pin && Logica==LOGICA_INVERSA) || (!Pin && Logica==LOGICA_DIRECTA)) && j>ANTIRREBOTES)
0EFE  0875     MOVF Pin, W
0EFF  1903     BTFSC STATUS, 0x2
0F00  2F04     GOTO 0x704
0F01  0377     DECF Logica, W
0F02  1903     BTFSC STATUS, 0x2
0F03  2F0A     GOTO 0x70A
0F04  08F5     MOVF Pin, F
0F05  1D03     BTFSS STATUS, 0x2
0F06  2F18     GOTO 0x718
0F07  08F7     MOVF Logica, F
0F08  1D03     BTFSS STATUS, 0x2
0F09  2F18     GOTO 0x718
0F0A  3000     MOVLW 0x0
0F0B  027B     SUBWF 0x7B, W
0F0C  3033     MOVLW 0x33
0F0D  1903     BTFSC STATUS, 0x2
0F0E  027A     SUBWF j, W
0F0F  1C03     BTFSS STATUS, 0x0
0F10  2F18     GOTO 0x718
57:                  Entradas[Indice]=0;
0F11  1003     BCF STATUS, 0x0
0F12  0D79     RLF Indice, W
0F13  3EA0     ADDLW 0xA0
0F14  0084     MOVWF FSR
0F15  0180     CLRF INDF
0F16  0A84     INCF FSR, F
0F17  0180     CLRF INDF
58:                  
59:               if (TipoPin) { // Si el pulsador tiene autorrepeticin
0F18  0876     MOVF TipoPin, W
0F19  1903     BTFSC STATUS, 0x2
0F1A  2F67     GOTO 0x767
60:                 // Cuando se supera el n de ciclos 4, devolveremos un 1 con la frecuencia VELOCIDAD4
61:                   if ((j>=CAMBIO4) && !(j%VELOCIDAD4)){
0F1B  300F     MOVLW 0xF
0F1C  027B     SUBWF 0x7B, W
0F1D  30A0     MOVLW 0xA0
0F1E  1903     BTFSC STATUS, 0x2
0F1F  027A     SUBWF j, W
0F20  1803     BTFSC STATUS, 0x0
0F21  187A     BTFSC j, 0x0
0F22  2F28     GOTO 0x728
62:                       resultado=1;
0F23  01F8     CLRF resultado
0F24  0AF8     INCF resultado, F
63:                  }else
0F25  1283     BCF STATUS, 0x5
0F26  1303     BCF STATUS, 0x6
0F27  2F67     GOTO 0x767
64:                   // Cuando se supera el n de ciclos 3, devolveremos un 1 con la frecuencia VELOCIDAD3
65:                  if ((j>=CAMBIO3) && !(j%VELOCIDAD3)){           
0F28  3007     MOVLW 0x7
0F29  027B     SUBWF 0x7B, W
0F2A  30D0     MOVLW 0xD0
0F2B  1903     BTFSC STATUS, 0x2
0F2C  027A     SUBWF j, W
0F2D  1C03     BTFSS STATUS, 0x0
0F2E  2F3D     GOTO 0x73D
0F2F  300A     MOVLW 0xA
0F30  00F0     MOVWF divisor
0F31  01F1     CLRF canal
0F32  087B     MOVF 0x7B, W
0F33  00F3     MOVWF counter
0F34  087A     MOVF j, W
0F35  00F2     MOVWF dividend
0F36  2773     CALL 0x773
0F37  120A     BCF PCLATH, 0x4
0F38  158A     BSF PCLATH, 0x3
0F39  0871     MOVF canal, W
0F3A  0470     IORWF divisor, W
0F3B  1903     BTFSC STATUS, 0x2
0F3C  2F23     GOTO 0x723
66:                     resultado=1;
67:                  } else 
68:                     // Cuando se supera el n de ciclos 2, devolveremos un 1 con la frecuencia VELOCIDAD2
69:                     if ((j>=CAMBIO2) && !(j%VELOCIDAD2)){
0F3D  3001     MOVLW 0x1
0F3E  027B     SUBWF 0x7B, W
0F3F  30F4     MOVLW 0xF4
0F40  1903     BTFSC STATUS, 0x2
0F41  027A     SUBWF j, W
0F42  1C03     BTFSS STATUS, 0x0
0F43  2F52     GOTO 0x752
0F44  3032     MOVLW 0x32
0F45  00F0     MOVWF divisor
0F46  01F1     CLRF canal
0F47  087B     MOVF 0x7B, W
0F48  00F3     MOVWF counter
0F49  087A     MOVF j, W
0F4A  00F2     MOVWF dividend
0F4B  2773     CALL 0x773
0F4C  120A     BCF PCLATH, 0x4
0F4D  158A     BSF PCLATH, 0x3
0F4E  0871     MOVF canal, W
0F4F  0470     IORWF divisor, W
0F50  1903     BTFSC STATUS, 0x2
0F51  2F23     GOTO 0x723
70:                        resultado=1;
71:                  } else
72:                     // Cuando se supera el n de ciclos 1, devolveremos un 1 con la frecuencia VELOCIDAD1
73:                     if ((j>CAMBIO1) && !(j%VELOCIDAD1)){
0F52  3000     MOVLW 0x0
0F53  027B     SUBWF 0x7B, W
0F54  3065     MOVLW 0x65
0F55  1903     BTFSC STATUS, 0x2
0F56  027A     SUBWF j, W
0F57  1C03     BTFSS STATUS, 0x0
0F58  2F67     GOTO 0x767
0F59  3064     MOVLW 0x64
0F5A  00F0     MOVWF divisor
0F5B  01F1     CLRF canal
0F5C  087B     MOVF 0x7B, W
0F5D  00F3     MOVWF counter
0F5E  087A     MOVF j, W
0F5F  00F2     MOVWF dividend
0F60  2773     CALL 0x773
0F61  120A     BCF PCLATH, 0x4
0F62  158A     BSF PCLATH, 0x3
0F63  0871     MOVF canal, W
0F64  0470     IORWF divisor, W
0F65  1903     BTFSC STATUS, 0x2
0F66  2F23     GOTO 0x723
74:                        resultado=1;
75:                  };
76:               }
77:               if ((TipoPin==INMEDIATO)&&(j>=1))
0F67  0876     MOVF TipoPin, W
0F68  3A02     XORLW 0x2
0F69  1D03     BTFSS STATUS, 0x2
0F6A  2F71     GOTO 0x771
0F6B  087B     MOVF 0x7B, W
0F6C  047A     IORWF j, W
0F6D  1903     BTFSC STATUS, 0x2
0F6E  2F71     GOTO 0x771
78:                   resultado=1;
0F6F  01F8     CLRF resultado
0F70  0AF8     INCF resultado, F
79:               return (resultado);
0F71  0878     MOVF resultado, W
80:            }
0F72  0008     RETURN
81:            
82:            
83:               
84:            
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/LCDGeneric.c  -------------------------
1:             /**
2:                \version: 1.0
3:             
4:                
5:                \author Suky (Casanova Alejandro) 
6:                \web www.infopic.comlu.com
7:                \date 16/08/10
8:             
9:             
10:            ///////////////////////////////////////////////////////////////////////////
11:            ////                                                                   ////
12:            ////                                                                   ////
13:            ////        (C) Copyright 2010 www.infopic.comlu.com                   ////
14:            //// Este cdigo puede ser usado, modificado y distribuido libremente  ////
15:            //// sin eliminar esta cabecera y  sin garanta de ningn tipo.        ////
16:            ////                                                                   ////
17:            ////                                                                   ////
18:            /////////////////////////////////////////////////////////////////////////// 
19:               
20:             *- Version Log --------------------------------------------------------------*
21:             *   Fecha       Autor                Comentarios                             *
22:             *----------------------------------------------------------------------------*
23:             * 16/08/10      Suky               Original (Rev 1.0)                        *
24:             * 20/08/10      Suky               Se incluye CodeVisionAVR                  *
25:             *----------------------------------------------------------------------------* */
26:            #include "xc.h"
27:            #include "system.h"
28:            #include "LCDGeneric.h"
29:            
30:            UINT8 NLinea;
31:            
32:            UINT8 ui8BusyLCD(void){
33:            
34:            #ifdef LCD_USE_RW
35:            	 LCD_DATA_PIN_7 = 0;
15C7  1388     BCF PORTD, 0x7
36:            	 LCD_DATA_PIN_6 = 0;
15C8  1308     BCF PORTD, 0x6
37:            	 LCD_DATA_PIN_5 = 0;
15C9  1288     BCF PORTD, 0x5
38:            	 LCD_DATA_PIN_4 = 0;
15CA  1208     BCF PORTD, 0x4
39:            
40:                 LCD_TRIS_DATA_PIN_7 = CONFIG_INPUT;
15CB  1683     BSF STATUS, 0x5
15CC  1788     BSF PORTD, 0x7
41:                 LCD_TRIS_DATA_PIN_6 = CONFIG_INPUT;
15CD  1708     BSF PORTD, 0x6
42:                 LCD_TRIS_DATA_PIN_5 = CONFIG_INPUT;
15CE  1688     BSF PORTD, 0x5
43:                 LCD_TRIS_DATA_PIN_4 = CONFIG_INPUT;
15CF  1608     BSF PORTD, 0x4
44:            
45:                 LCD_RW_PIN = 1;    
15D0  1283     BCF STATUS, 0x5
15D1  1488     BSF PORTD, 0x1
46:                 LCD_RS_PIN = 0; 
15D2  1008     BCF PORTD, 0x0
47:            	 LCD_E_PIN=1;         
15D3  1508     BSF PORTD, 0x2
48:                 __delay_1us();
15D4  2DD5     GOTO 0x5D5
15D5  2DD6     GOTO 0x5D6
15D6  0000     NOP
49:            
50:                 if(LCD_READ_PIN_7==1){
15D7  1283     BCF STATUS, 0x5
15D8  1303     BCF STATUS, 0x6
15D9  1F88     BTFSS PORTD, 0x7
15DA  2DEA     GOTO 0x5EA
51:                      LCD_E_PIN = 0; 
15DB  1108     BCF PORTD, 0x2
52:            		  __delay_1us();
15DC  2DDD     GOTO 0x5DD
15DD  2DDE     GOTO 0x5DE
15DE  0000     NOP
53:            		  LCD_E_PIN = 1;
15DF  1283     BCF STATUS, 0x5
15E0  1303     BCF STATUS, 0x6
15E1  1508     BSF PORTD, 0x2
54:            		  __delay_1us();
15E2  2DE3     GOTO 0x5E3
15E3  2DE4     GOTO 0x5E4
15E4  0000     NOP
55:            		  LCD_E_PIN = 0;
15E5  1283     BCF STATUS, 0x5
15E6  1303     BCF STATUS, 0x6
15E7  1108     BCF PORTD, 0x2
56:                  	  LCD_RW_PIN = 0; 
15E8  1088     BCF PORTD, 0x1
57:                      return 1;
15E9  3401     RETLW 0x1
58:                 }else{
59:                      LCD_E_PIN = 0;
15EA  1108     BCF PORTD, 0x2
60:            		  __delay_1us();
15EB  2DEC     GOTO 0x5EC
15EC  2DED     GOTO 0x5ED
15ED  0000     NOP
61:            		  LCD_E_PIN = 1;
15EE  1283     BCF STATUS, 0x5
15EF  1303     BCF STATUS, 0x6
15F0  1508     BSF PORTD, 0x2
62:            		  __delay_1us();
15F1  2DF2     GOTO 0x5F2
15F2  2DF3     GOTO 0x5F3
15F3  0000     NOP
63:            		  LCD_E_PIN = 0;
15F4  1283     BCF STATUS, 0x5
15F5  1303     BCF STATUS, 0x6
15F6  1108     BCF PORTD, 0x2
64:            		  LCD_RW_PIN = 0;       
15F7  1088     BCF PORTD, 0x1
65:                      return 0;
15F8  3400     RETLW 0x0
66:                 }
67:            #else
68:            	 __delay_100us();
69:            	 return 0;
70:            #endif
71:            }
72:            
73:            void vWriteLCD(UINT8 Data,UINT8 Type){
1556  00A4     MOVWF dato
74:            
75:            #ifdef LCD_USE_3PINES
76:            	UINT8 i, data_temp;
77:            #endif
78:            
79:            	while(ui8BusyLCD());
1557  25C7     CALL 0x5C7
1558  160A     BSF PCLATH, 0x4
1559  118A     BCF PCLATH, 0x3
155A  3800     IORLW 0x0
155B  1D03     BTFSS STATUS, 0x2
155C  2D57     GOTO 0x557
80:            
81:            	#ifndef LCD_USE_3PINES
82:            		#ifdef LCD_USE_RW
83:            			LCD_RW_PIN = 0;
155D  1088     BCF PORTD, 0x1
84:            		#endif   
85:            		if(Type){
155E  0823     MOVF x, W
155F  1903     BTFSC STATUS, 0x2
1560  2D63     GOTO 0x563
86:            			LCD_RS_PIN=1;
1561  1408     BSF PORTD, 0x0
87:            		}else{
1562  2D64     GOTO 0x564
88:            			LCD_RS_PIN = 0;
1563  1008     BCF PORTD, 0x0
89:            		}	  
90:            		LCD_TRIS_DATA_PIN_7 = CONFIG_OUTPUT;
1564  1683     BSF STATUS, 0x5
1565  1388     BCF PORTD, 0x7
91:            		LCD_TRIS_DATA_PIN_6 = CONFIG_OUTPUT;
1566  1308     BCF PORTD, 0x6
92:            		LCD_TRIS_DATA_PIN_5 = CONFIG_OUTPUT;
1567  1288     BCF PORTD, 0x5
93:            		LCD_TRIS_DATA_PIN_4 = CONFIG_OUTPUT;
1568  1208     BCF PORTD, 0x4
94:            		
95:            		LCD_DATA_PIN_7 = !!(Data & 0x80);
1569  1283     BCF STATUS, 0x5
156A  1FA4     BTFSS dato, 0x7
156B  2D70     GOTO 0x570
156C  1283     BCF STATUS, 0x5
156D  1303     BCF STATUS, 0x6
156E  1788     BSF PORTD, 0x7
156F  2D73     GOTO 0x573
1570  1283     BCF STATUS, 0x5
1571  1303     BCF STATUS, 0x6
1572  1388     BCF PORTD, 0x7
96:            		LCD_DATA_PIN_6 = !!(Data & 0x40);
1573  1F24     BTFSS dato, 0x6
1574  2D79     GOTO 0x579
1575  1283     BCF STATUS, 0x5
1576  1303     BCF STATUS, 0x6
1577  1708     BSF PORTD, 0x6
1578  2D7C     GOTO 0x57C
1579  1283     BCF STATUS, 0x5
157A  1303     BCF STATUS, 0x6
157B  1308     BCF PORTD, 0x6
97:            		LCD_DATA_PIN_5 = !!(Data & 0x20);
157C  1EA4     BTFSS dato, 0x5
157D  2D82     GOTO 0x582
157E  1283     BCF STATUS, 0x5
157F  1303     BCF STATUS, 0x6
1580  1688     BSF PORTD, 0x5
1581  2D85     GOTO 0x585
1582  1283     BCF STATUS, 0x5
1583  1303     BCF STATUS, 0x6
1584  1288     BCF PORTD, 0x5
98:            		LCD_DATA_PIN_4 = !!(Data & 0x10);
1585  1E24     BTFSS dato, 0x4
1586  2D8B     GOTO 0x58B
1587  1283     BCF STATUS, 0x5
1588  1303     BCF STATUS, 0x6
1589  1608     BSF PORTD, 0x4
158A  2D8E     GOTO 0x58E
158B  1283     BCF STATUS, 0x5
158C  1303     BCF STATUS, 0x6
158D  1208     BCF PORTD, 0x4
99:            	#else
100:           		data_temp=(Data>>4);  // Rs es bit 4
101:           		if(Type){
102:           			data_temp|=0x10;
103:           		}
104:           		for(i=0;i<8;i++){
105:           			LCD_DATA_PIN=!!(data_temp & 0x80);
106:           			data_temp<<=1;
107:           			LCD_CLOCK_PIN=1;
108:           			__delay_1us();
109:           			LCD_CLOCK_PIN=0;
110:           		}
111:           	#endif
112:           	__delay_1Cycle();
158E  0000     NOP
113:           	LCD_E_PIN = 1;
158F  1283     BCF STATUS, 0x5
1590  1303     BCF STATUS, 0x6
1591  1508     BSF PORTD, 0x2
114:           	__delay_1us();
1592  2D93     GOTO 0x593
1593  2D94     GOTO 0x594
1594  0000     NOP
115:           	LCD_E_PIN = 0;
1595  1283     BCF STATUS, 0x5
1596  1303     BCF STATUS, 0x6
1597  1108     BCF PORTD, 0x2
116:           	#ifndef LCD_USE_3PINES	
117:           		LCD_DATA_PIN_7 = !!(Data & 0x08);
1598  1DA4     BTFSS dato, 0x3
1599  2D9E     GOTO 0x59E
159A  1283     BCF STATUS, 0x5
159B  1303     BCF STATUS, 0x6
159C  1788     BSF PORTD, 0x7
159D  2DA1     GOTO 0x5A1
159E  1283     BCF STATUS, 0x5
159F  1303     BCF STATUS, 0x6
15A0  1388     BCF PORTD, 0x7
118:           		LCD_DATA_PIN_6 = !!(Data & 0x04);
15A1  1D24     BTFSS dato, 0x2
15A2  2DA7     GOTO 0x5A7
15A3  1283     BCF STATUS, 0x5
15A4  1303     BCF STATUS, 0x6
15A5  1708     BSF PORTD, 0x6
15A6  2DAA     GOTO 0x5AA
15A7  1283     BCF STATUS, 0x5
15A8  1303     BCF STATUS, 0x6
15A9  1308     BCF PORTD, 0x6
119:           		LCD_DATA_PIN_5 = !!(Data & 0x02);
15AA  1CA4     BTFSS dato, 0x1
15AB  2DB0     GOTO 0x5B0
15AC  1283     BCF STATUS, 0x5
15AD  1303     BCF STATUS, 0x6
15AE  1688     BSF PORTD, 0x5
15AF  2DB3     GOTO 0x5B3
15B0  1283     BCF STATUS, 0x5
15B1  1303     BCF STATUS, 0x6
15B2  1288     BCF PORTD, 0x5
120:           		LCD_DATA_PIN_4 = !!(Data & 0x01);
15B3  1C24     BTFSS dato, 0x0
15B4  2DB9     GOTO 0x5B9
15B5  1283     BCF STATUS, 0x5
15B6  1303     BCF STATUS, 0x6
15B7  1608     BSF PORTD, 0x4
15B8  2DBC     GOTO 0x5BC
15B9  1283     BCF STATUS, 0x5
15BA  1303     BCF STATUS, 0x6
15BB  1208     BCF PORTD, 0x4
121:           	#else
122:           		data_temp=(Data&0x0F);  // Rs es bit 4
123:           		if(Type){
124:           			data_temp|=0x10;
125:           		}
126:           		for(i=0;i<8;i++){
127:           			LCD_DATA_PIN=!!(data_temp & 0x80);
128:           			data_temp<<=1;
129:           			LCD_CLOCK_PIN=1;
130:           			__delay_1us();
131:           			LCD_CLOCK_PIN=0;
132:           		}
133:           	#endif
134:           	__delay_1Cycle();	
15BC  0000     NOP
135:           	LCD_E_PIN = 1;
15BD  1283     BCF STATUS, 0x5
15BE  1303     BCF STATUS, 0x6
15BF  1508     BSF PORTD, 0x2
136:           	__delay_1us();
15C0  2DC1     GOTO 0x5C1
15C1  2DC2     GOTO 0x5C2
15C2  0000     NOP
137:           	LCD_E_PIN = 0;
15C3  1283     BCF STATUS, 0x5
15C4  1303     BCF STATUS, 0x6
15C5  1108     BCF PORTD, 0x2
138:           	
139:           } 
15C6  0008     RETURN
140:           
141:           void vInitLCD(){
142:           UINT8 i;
143:           #ifdef LCD_USE_3PINES
144:           	UINT8 temp;
145:           #endif
146:           
147:           	for(i=0;i<8;i++){__delay_2ms();}
14E1  01A7     CLRF i
14E2  300D     MOVLW 0xD
14E3  00A6     MOVWF x
14E4  30FB     MOVLW 0xFB
14E5  00A5     MOVWF y
14E6  0BA5     DECFSZ y, F
14E7  2CE6     GOTO 0x4E6
14E8  0BA6     DECFSZ x, F
14E9  2CE6     GOTO 0x4E6
14EA  2CEB     GOTO 0x4EB
14EB  1283     BCF STATUS, 0x5
14EC  1303     BCF STATUS, 0x6
14ED  3008     MOVLW 0x8
14EE  0AA7     INCF i, F
14EF  0227     SUBWF i, W
14F0  1C03     BTFSS STATUS, 0x0
14F1  2CE2     GOTO 0x4E2
148:           	NLinea=1;
14F2  1683     BSF STATUS, 0x5
14F3  01B1     CLRF divisor
14F4  0AB1     INCF divisor, F
149:           	
150:           #ifndef LCD_USE_3PINES
151:           /* ** Configuracin de pines ** */	
152:           	LCD_DATA_PIN_7 = 0;
14F5  1283     BCF STATUS, 0x5
14F6  1388     BCF PORTD, 0x7
153:           	LCD_DATA_PIN_6 = 0;
14F7  1308     BCF PORTD, 0x6
154:           	LCD_DATA_PIN_5 = 0;
14F8  1288     BCF PORTD, 0x5
155:           	LCD_DATA_PIN_4 = 0;
14F9  1208     BCF PORTD, 0x4
156:           	#ifdef LCD_USE_RW
157:           		LCD_RW_PIN = 0;
14FA  1088     BCF PORTD, 0x1
158:           	#endif
159:           	LCD_RS_PIN = 0;
14FB  1008     BCF PORTD, 0x0
160:           	LCD_E_PIN = 0;
14FC  1108     BCF PORTD, 0x2
161:           	
162:           	LCD_TRIS_DATA_PIN_7 = CONFIG_OUTPUT;
14FD  1683     BSF STATUS, 0x5
14FE  1388     BCF PORTD, 0x7
163:           	LCD_TRIS_DATA_PIN_6 = CONFIG_OUTPUT;
14FF  1308     BCF PORTD, 0x6
164:           	LCD_TRIS_DATA_PIN_5 = CONFIG_OUTPUT;
1500  1288     BCF PORTD, 0x5
165:           	LCD_TRIS_DATA_PIN_4 = CONFIG_OUTPUT;
1501  1208     BCF PORTD, 0x4
166:           	#ifdef LCD_USE_RW	
167:           		LCD_TRIS_RW = CONFIG_OUTPUT;
1502  1088     BCF PORTD, 0x1
168:           	#endif
169:           	LCD_TRIS_RS = CONFIG_OUTPUT;
1503  1008     BCF PORTD, 0x0
170:           	LCD_TRIS_E = CONFIG_OUTPUT;
1504  1108     BCF PORTD, 0x2
171:           #else
172:           	LCD_DATA_PIN = 0;
173:           	LCD_CLOCK_PIN = 0;
174:           	LCD_E_PIN = 0;
175:           
176:           	LCD_TRIS_DATA = CONFIG_OUTPUT;
177:           	LCD_TRIS_CLOCK = CONFIG_OUTPUT;
178:           	LCD_TRIS_E = CONFIG_OUTPUT;
179:           	
180:           	for(i=0;i<8;i++){
181:           		LCD_DATA_PIN=0;
182:           		LCD_CLOCK_PIN=1;
183:           		__delay_1us();
184:           		LCD_CLOCK_PIN=0;
185:           	}
186:           #endif
187:           /* ** INICIALIZACION ** */     
188:           #ifndef LCD_USE_3PINES
189:           	LCD_DATA_PIN_5 = 1;
1505  1283     BCF STATUS, 0x5
1506  1688     BSF PORTD, 0x5
190:           	LCD_DATA_PIN_4 = 1;
1507  1608     BSF PORTD, 0x4
191:           #else
192:           	temp=0x03;
193:           	for(i=0;i<8;i++){
194:           		LCD_DATA_PIN=!!(temp & 0x80);
195:           		temp<<=1;
196:           		LCD_CLOCK_PIN=1;
197:           		__delay_1us();
198:           		LCD_CLOCK_PIN=0;
199:           	}
200:           #endif
201:           	for(i=0;i<3;i++){
1508  01A7     CLRF i
151F  1283     BCF STATUS, 0x5
1520  1303     BCF STATUS, 0x6
1521  3003     MOVLW 0x3
1522  0AA7     INCF i, F
1523  0227     SUBWF i, W
1524  1C03     BTFSS STATUS, 0x0
1525  2D09     GOTO 0x509
202:           		LCD_E_PIN = 1;
1509  1508     BSF PORTD, 0x2
203:           		__delay_2ms();
150A  300D     MOVLW 0xD
150B  00A6     MOVWF x
150C  30FB     MOVLW 0xFB
150D  00A5     MOVWF y
150E  0BA5     DECFSZ y, F
150F  2D0E     GOTO 0x50E
1510  0BA6     DECFSZ x, F
1511  2D0E     GOTO 0x50E
1512  2D13     GOTO 0x513
204:           		LCD_E_PIN = 0;
1513  1283     BCF STATUS, 0x5
1514  1303     BCF STATUS, 0x6
1515  1108     BCF PORTD, 0x2
205:           	 	__delay_2ms();
1516  300D     MOVLW 0xD
1517  00A6     MOVWF x
1518  30FB     MOVLW 0xFB
1519  00A5     MOVWF y
151A  0BA5     DECFSZ y, F
151B  2D1A     GOTO 0x51A
151C  0BA6     DECFSZ x, F
151D  2D1A     GOTO 0x51A
151E  2D1F     GOTO 0x51F
206:           	}
207:           #ifndef LCD_USE_3PINES
208:           	LCD_DATA_PIN_4 = 0;
1526  1208     BCF PORTD, 0x4
209:           #else
210:           	temp=0x02;
211:           	for(i=0;i<8;i++){
212:           		LCD_DATA_PIN=!!(temp & 0x80);
213:           		temp<<=1;
214:           		LCD_CLOCK_PIN=1;
215:           		__delay_1us();
216:           		LCD_CLOCK_PIN=0;
217:           	}
218:           #endif
219:           	LCD_E_PIN = 1;
1527  1508     BSF PORTD, 0x2
220:           	__delay_1us();
1528  2D29     GOTO 0x529
1529  2D2A     GOTO 0x52A
152A  0000     NOP
221:           	LCD_E_PIN = 0;
152B  1283     BCF STATUS, 0x5
152C  1303     BCF STATUS, 0x6
152D  1108     BCF PORTD, 0x2
222:           
223:           	vWriteLCD(0x20 | (LcdType<<2),LCD_COMMAND);  // Tipo display.-  
152E  3028     MOVLW 0x28
152F  01A3     CLRF x
1530  2556     CALL 0x556
1531  160A     BSF PCLATH, 0x4
1532  118A     BCF PCLATH, 0x3
224:           	__delay_2ms();     
1533  300D     MOVLW 0xD
1534  00A6     MOVWF x
1535  30FB     MOVLW 0xFB
1536  00A5     MOVWF y
1537  0BA5     DECFSZ y, F
1538  2D37     GOTO 0x537
1539  0BA6     DECFSZ x, F
153A  2D37     GOTO 0x537
153B  2D3C     GOTO 0x53C
225:           	vWriteLCD(0x01,LCD_COMMAND);	// Borramos display.-   
153C  1283     BCF STATUS, 0x5
153D  1303     BCF STATUS, 0x6
153E  3001     MOVLW 0x1
153F  01A3     CLRF x
1540  2556     CALL 0x556
1541  160A     BSF PCLATH, 0x4
1542  118A     BCF PCLATH, 0x3
226:           	__delay_2ms();           
1543  300D     MOVLW 0xD
1544  00A6     MOVWF x
1545  30FB     MOVLW 0xFB
1546  00A5     MOVWF y
1547  0BA5     DECFSZ y, F
1548  2D47     GOTO 0x547
1549  0BA6     DECFSZ x, F
154A  2D47     GOTO 0x547
154B  2D4C     GOTO 0x54C
227:           	vWriteLCD(0x06,LCD_COMMAND);	// Incrementa cursor.-
154C  1283     BCF STATUS, 0x5
154D  1303     BCF STATUS, 0x6
154E  3006     MOVLW 0x6
154F  01A3     CLRF x
1550  2556     CALL 0x556
1551  160A     BSF PCLATH, 0x4
1552  118A     BCF PCLATH, 0x3
228:           	vWriteLCD(0x0C,LCD_COMMAND);	// Encendemos display.-
1553  300C     MOVLW 0xC
229:           }
230:           
231:           
232:           void vLCD_Putc(UINT8 Data){
14B9  1283     BCF STATUS, 0x5
14BA  00AA     MOVWF Data
233:           	
234:           	switch(Data){
14BB  3A0A     XORLW 0xA
14BC  1903     BTFSC STATUS, 0x2
14BD  2CD6     GOTO 0x4D6
14BE  3A06     XORLW 0x6
14BF  1903     BTFSC STATUS, 0x2
14C0  2CC3     GOTO 0x4C3
14C1  2CDD     GOTO 0x4DD
235:           		case '\f':
236:           			vWriteLCD(0x01,LCD_COMMAND);
14C3  3001     MOVLW 0x1
14C4  01A3     CLRF x
14C5  2556     CALL 0x556
14C6  160A     BSF PCLATH, 0x4
14C7  118A     BCF PCLATH, 0x3
237:           			NLinea=1;
14C8  1683     BSF STATUS, 0x5
14CA  01B1     CLRF divisor
14CB  0AB1     INCF divisor, F
238:           			__delay_2ms();
14C9  300D     MOVLW 0xD
14CC  1283     BCF STATUS, 0x5
14CD  00A9     MOVWF year
14CE  30FB     MOVLW 0xFB
14CF  00A8     MOVWF mth
14D0  0BA8     DECFSZ mth, F
14D1  2CD0     GOTO 0x4D0
14D2  0BA9     DECFSZ year, F
14D3  2CD0     GOTO 0x4D0
14D4  2CD5     GOTO 0x4D5
239:           		break;
14D5  0008     RETURN
240:           		case '\n':
241:           			vGotoxyLCD(1,++NLinea);			
14D6  1683     BSF STATUS, 0x5
14D7  0AB1     INCF divisor, F
14D8  0831     MOVF divisor, W
14D9  1283     BCF STATUS, 0x5
14DA  00A5     MOVWF y
14DB  3001     MOVLW 0x1
14DC  2C96     GOTO 0x496
242:           		break;
243:           		default:
244:           			vWriteLCD(Data,LCD_DATA);
14DD  01A3     CLRF x
14DE  0AA3     INCF x, F
14DF  082A     MOVF Data, W
14E0  2D56     GOTO 0x556
245:           	}
246:           } 
14C2  0008     RETURN
247:           
248:           void vGotoxyLCD(UINT8 x,UINT8 y){
1496  00A6     MOVWF x
249:           UINT8 Direccion;
250:           
251:           	switch(y){
1497  2CA3     GOTO 0x4A3
14A3  0825     MOVF y, W
14A4  3A01     XORLW 0x1
14A5  1903     BTFSC STATUS, 0x2
14A6  2C98     GOTO 0x498
14A7  3A03     XORLW 0x3
14A8  1903     BTFSC STATUS, 0x2
14A9  2C9D     GOTO 0x49D
14AA  2C98     GOTO 0x498
252:           		case 1:Direccion = LCD_LINE_1_ADDRESS;NLinea=1;break;
1498  01A7     CLRF i
1499  1683     BSF STATUS, 0x5
149A  01B1     CLRF divisor
149B  0AB1     INCF divisor, F
149C  2CAB     GOTO 0x4AB
253:           		case 2:Direccion = LCD_LINE_2_ADDRESS;NLinea=2;break;
149D  3040     MOVLW 0x40
149E  00A7     MOVWF i
149F  3002     MOVLW 0x2
14A0  1683     BSF STATUS, 0x5
14A1  00B1     MOVWF divisor
14A2  2CAB     GOTO 0x4AB
254:           		#ifdef LCD_4LINES
255:           		case 3:Direccion = LCD_LINE_3_ADDRESS;NLinea=3;break;
256:           		case 4:Direccion = LCD_LINE_4_ADDRESS;NLinea=4;break;
257:           		#endif
258:           		default:Direccion = LCD_LINE_1_ADDRESS;NLinea=1;break;
259:           	}
260:           
261:           	Direccion+=x-1;
14AB  1283     BCF STATUS, 0x5
14AC  0826     MOVF x, W
14AD  3EFF     ADDLW 0xFF
14AE  07A7     ADDWF i, F
262:           	while(ui8BusyLCD());
14AF  25C7     CALL 0x5C7
14B0  160A     BSF PCLATH, 0x4
14B1  118A     BCF PCLATH, 0x3
14B2  3800     IORLW 0x0
14B3  1D03     BTFSS STATUS, 0x2
14B4  2CAF     GOTO 0x4AF
263:           	vWriteLCD(0x80|Direccion,LCD_COMMAND);
14B5  01A3     CLRF x
264:           }
265:           
266:           void vPuts_LCD(UINT8 *buffer){
267:           
268:           
269:               while(*buffer != '\0')    {
270:                  // vLCD_Putc(*buffer++);;
271:                   vWriteLCD(*buffer++,LCD_DATA);
272:               }
273:           }
274:           
275:           void vBlinkingLCD(void){
276:           	vWriteLCD(0b1101,LCD_COMMAND);
277:           }
278:           void vnoBlinkingLCD(void){
279:           	vWriteLCD(0b1100,LCD_COMMAND);
280:           }
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/HardI2C.c  ----------------------------
1:             /**************************************************************************
2:             *      Libreria para protocolo I2C Master por HardWare para HiTech        *
3:             ***************************************************************************
4:             
5:             ***************************************************************************
6:             *                                                                         *
7:             * Antes de incluir este archivo en nuestro programa hay que definir       *
8:             * algunos parametros. Estos son                                           *
9:             *                                                                         *
10:            * PIC_CLK        (se usa para calcular el valor de SSPADD)                *     
11:            * I2C_BAUD       (velocidad de transferencia)                             *
12:            *                                                                         *
13:            ***************************************************************************
14:            
15:            ***************************************************************************
16:            *                                                                         *
17:            * En esta libreria se encuentran las siguientes funciones                 *
18:            *                                                                         *
19:            * setup_i2c(char)               (inicializa el puerto I2C)                *
20:            * start_i2c()                   (envia start, inicia transmision)         *
21:            * rstar_i2c()                   (envia restart, reinicia transmision)     *
22:            * stop_i2c()                    (envia stop, termina transmision)         *
23:            * write_i2c(char)               (envia un byte)                           *
24:            * read_i2c(char)                (recibe un byte y envia ack o noack)      *
25:            *                                                                         *
26:            *  La funcion write_i2c() devuelve 0 si el dispositivo responde o 1 si el *
27:            * dispositivo no responde.                                                *
28:            *                                                                         *
29:            *  A la funcion read_i2c() hay que pasarle 0 si se quiere responder al    *
30:            * disipositivo o 1 si no se quiere responder                              *
31:            *                                                                         *
32:            *  En esta libreria estan definidos los parametros I2C_MASTER, I2C_SLAVE, *
33:            * I2C_10BIT_ADDRESS. Eston son utilizados en la funcion setup_i2c(char)   *
34:            *                                                                         *
35:            *  Tambien estan definidos ACK y NOACK que son los utilizados para        *
36:            * responder o no al dispositivo                                           *
37:            *                                                                         *
38:            ***************************************************************************
39:            
40:            * Ejemplo de configuracion y utilizacion
41:            
42:             #define PIC_CLK   10000000   // cristal 10MHz
43:             #define I2C_BAUD  100000     // velocidad 100 KHz
44:             #include "HardI2c.c"
45:            
46:             void main (void);
47:             {
48:               unsigned char respuesta;
49:               unsigned char dato;  
50:             
51:               ......
52:               ......
53:               ......
54:               setup_i2c (I2C_MASTER);
55:               start_i2c();
56:               respuesta = write_i2c (0b10101110);    // comunicacion para escribir en una 24C02C
57:               if (respuesta == ACK)
58:               {
59:                 write_i2c (0x00);                    // indico la direccion a escribir
60:                 write_i2c (0xF5);                    // escribo el dato F5
61:                 write_i2c (0x06);                    // escribo el dato 06
62:               }
63:               stop_i2c();
64:            
65:               // colocar un delay necesario para que termine de grabar la memoria
66:            
67:               start_i2c();
68:               respuesta = write_i2c (0b10101110);    // comunicacion para escribir en una 24C02C
69:               if (respuesta == ACK)
70:               {
71:                 write_i2c (0x00);                    // indico la direccion de memoria
72:                 rstart_i2c();                       // reinicio la transmisin
73:                 respuesta = write_i2c (0b10101111);  // comunicacion para leer en una 24C02C
74:                 if (respuesta == ACK)
75:                 {
76:                   dato = read_i2c (ACK);             // leo el dato y respondo
77:                   dato = read_i2c (NOACK);           // leo el dato y no respondo
78:                 }
79:               }
80:               stop_i2c();
81:             }
82:            
83:            */
84:            #include <xc.h>
85:            #include <stdbool.h>       /* For true/false definition */
86:            #include "system.h"        /* System funct/params, like osc/peripheral config */
87:            #include "HardI2C.h"
88:            
89:            
90:            #if defined (PIC_CLK) && defined (I2C_BAUD)
91:            
92:            void setup_i2c (char x)
140B  00A3     MOVWF x
93:             {
94:                TRISC3 = 1;
140C  1683     BSF STATUS, 0x5
140D  1587     BSF PORTC, 0x3
95:            
96:                TRISC4 = 1;
140E  1607     BSF PORTC, 0x4
97:            
98:                SSPSTAT = 0;
140F  0194     CLRF SSPCON
99:                SSPCON = x;
1410  1283     BCF STATUS, 0x5
1411  0823     MOVF x, W
1412  0094     MOVWF SSPCON
100:               
101:               SSPCON2 = 0;
1413  1683     BSF STATUS, 0x5
1414  0191     CLRF TMR2
102:               // SSPCON2bits.RCEN=1;
103:               if (SSPM3 == 1) SSPADD = (unsigned char)((PIC_CLK/(4*I2C_BAUD)) - 1);
1415  1283     BCF STATUS, 0x5
1416  1D94     BTFSS SSPCON, 0x3
1417  0008     RETURN
1418  300B     MOVLW 0xB
1419  1683     BSF STATUS, 0x5
141A  0093     MOVWF SSPBUF
104:           
105:           }
141B  0008     RETURN
106:           
107:             char start_i2c (void)
108:             { 
109:               while (( SSPCON2 & 0x1F ) || R_nW );
0B53  1683     BSF STATUS, 0x5
0B54  0811     MOVF TMR2, W
0B55  391F     ANDLW 0x1F
0B56  1903     BTFSC STATUS, 0x2
0B57  1914     BTFSC SSPCON, 0x2
0B58  2B53     GOTO 0x353
110:               SEN = 1;
0B59  1411     BSF TMR2, 0x0
111:               return !BCLIF;
112:             }
0B5A  0008     RETURN
113:           
114:             void rstart_i2c (void)
115:             {
116:               while (( SSPCON2 & 0x1F ) || R_nW );
0B97  1683     BSF STATUS, 0x5
0B98  0811     MOVF TMR2, W
0B99  391F     ANDLW 0x1F
0B9A  1903     BTFSC STATUS, 0x2
0B9B  1914     BTFSC SSPCON, 0x2
0B9C  2B97     GOTO 0x397
117:               RSEN = 1;
0B9D  1491     BSF TMR2, 0x1
118:             }
0B9E  0008     RETURN
119:           
120:             void stop_i2c (void)
121:             {
122:               while (( SSPCON2 & 0x1F ) || R_nW );
0B5B  1683     BSF STATUS, 0x5
0B5C  0811     MOVF TMR2, W
0B5D  391F     ANDLW 0x1F
0B5E  1903     BTFSC STATUS, 0x2
0B5F  1914     BTFSC SSPCON, 0x2
0B60  2B5B     GOTO 0x35B
123:               PEN = 1;
0B61  1511     BSF TMR2, 0x2
124:             }
0B62  0008     RETURN
125:           
126:             char write_i2c (unsigned char data)
0B29  1283     BCF STATUS, 0x5
0B2A  00A3     MOVWF x
127:             {
128:               if (SSPM3 == 1)
0B2B  1D94     BTFSS SSPCON, 0x3
0B2C  2B3D     GOTO 0x33D
129:               {
130:                 while (( SSPCON2 & 0x1F ) || R_nW );
0B2D  1683     BSF STATUS, 0x5
0B2E  0811     MOVF TMR2, W
0B2F  391F     ANDLW 0x1F
0B30  1903     BTFSC STATUS, 0x2
0B31  1914     BTFSC SSPCON, 0x2
0B32  2B2D     GOTO 0x32D
131:                 SSPBUF = data;
0B33  1283     BCF STATUS, 0x5
0B34  0823     MOVF x, W
0B35  0093     MOVWF SSPBUF
132:                 while (R_nW == 1);
0B36  1683     BSF STATUS, 0x5
0B37  1914     BTFSC SSPCON, 0x2
0B38  2B36     GOTO 0x336
133:                 //while(ACKSTAT==1);
134:                 return ACKSTAT;
0B39  3000     MOVLW 0x0
0B3A  1B11     BTFSC TMR2, 0x6
0B3B  3001     MOVLW 0x1
0B3C  0008     RETURN
135:               }
136:               else
137:               {
138:                 SSPBUF = data;
0B3D  0823     MOVF x, W
0B3E  0093     MOVWF SSPBUF
139:                 CKP = 1;
0B3F  1614     BSF SSPCON, 0x4
140:                 return 0;
0B40  3400     RETLW 0x0
141:               }
142:             }
143:           
144:             unsigned char read_i2c (unsigned char respuesta)
0B63  1283     BCF STATUS, 0x5
0B64  00A3     MOVWF x
145:             {
146:               unsigned char dato;
147:           
148:               if (SSPM3 == 1)
0B65  1D94     BTFSS SSPCON, 0x3
0B66  2B8A     GOTO 0x38A
149:               {
150:                 while (( SSPCON2 & 0x1F ) || R_nW );
0B67  1683     BSF STATUS, 0x5
0B68  0811     MOVF TMR2, W
0B69  391F     ANDLW 0x1F
0B6A  1903     BTFSC STATUS, 0x2
0B6B  1914     BTFSC SSPCON, 0x2
0B6C  2B67     GOTO 0x367
151:                 RCEN = 1;
0B6D  1591     BSF TMR2, 0x3
152:                 while (( SSPCON2 & 0x1F ) || R_nW );
0B6E  0811     MOVF TMR2, W
0B6F  391F     ANDLW 0x1F
0B70  1903     BTFSC STATUS, 0x2
0B71  1914     BTFSC SSPCON, 0x2
0B72  2B6E     GOTO 0x36E
153:                 dato = SSPBUF;
0B73  1283     BCF STATUS, 0x5
0B74  0813     MOVF SSPBUF, W
0B75  00A4     MOVWF dato
154:                 while (( SSPCON2 & 0x1F ) || R_nW );
0B76  1683     BSF STATUS, 0x5
0B77  0811     MOVF TMR2, W
0B78  391F     ANDLW 0x1F
0B79  1903     BTFSC STATUS, 0x2
0B7A  1914     BTFSC SSPCON, 0x2
0B7B  2B76     GOTO 0x376
155:                 ACKDT = respuesta;
0B7C  1283     BCF STATUS, 0x5
0B7D  1C23     BTFSS x, 0x0
0B7E  2B83     GOTO 0x383
0B7F  1683     BSF STATUS, 0x5
0B80  1303     BCF STATUS, 0x6
0B81  1691     BSF TMR2, 0x5
0B82  2B86     GOTO 0x386
0B83  1683     BSF STATUS, 0x5
0B84  1303     BCF STATUS, 0x6
0B85  1291     BCF TMR2, 0x5
156:                 ACKEN = 1;
0B86  1611     BSF TMR2, 0x4
157:                 return dato;
0B87  1283     BCF STATUS, 0x5
0B88  0824     MOVF dato, W
0B89  0008     RETURN
158:               }
159:               else
160:               {
161:                 dato = SSPBUF;
0B8A  0813     MOVF SSPBUF, W
0B8B  00A4     MOVWF dato
162:                 return dato;
163:               }
164:             }
0B8C  0008     RETURN
165:           #else
166:             #error Faltan definir parametros
167:           #endif
