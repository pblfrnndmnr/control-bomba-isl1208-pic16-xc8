Disassembly Listing for Control_BOMBA_RTC_ISL1208_V4
Generated From:
/media/Utilidades/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V4.X/dist/ISL1208_XC8_16f877a/debug/Control_BOMBA_RTC_ISL1208_V4.X.debug.cof
16/12/2014 21:18:04

---  /opt/microchip/xc8/v1.31/sources/pic/ftdiv.c  ------------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (C) 2006 HI-TECH Software
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_dividend	(*(unsigned short long *)&f1)
11:            #define	f2_as_divisor	(*(unsigned short long *)&f2)
12:            #define	f3_as_quot	(*(unsigned short long *)&f3)
13:            
14:            // floating addition
15:            #ifdef _OLDLIB
16:            #define	cntr		sign2
17:            float
18:            __ftdiv(float f2, float f1)
19:            {
20:            	unsigned char	exp1, exp2, sign1, sign2;
21:            	float	f3;
22:            	
23:            	f3_as_quot = 0;
24:            	sign1 = __ftunpack(&f1_as_dividend, &exp1);
25:            	if(exp1 == 0)
26:            		return f3;
27:            	sign2 = __ftunpack(&f2_as_divisor, &exp2);
28:            	if(exp2 == 0)
29:            		return f3;
30:            	exp1 -= exp2-127+8;	// compute new exponent
31:            	sign1 ^= sign2;
32:            	cntr = 16+8;
33:            	do {
34:            		f3_as_quot <<= 1;
35:            		if(f1_as_dividend >= f2_as_divisor) {
36:            			f1_as_dividend -= f2_as_divisor;
37:            			f3_as_quot |= 1;
38:            		}
39:            		f1_as_dividend <<= 1;
40:            	} while(--cntr != 0);
41:            	__ftpack(&f3_as_quot, exp1);
42:            	if(sign1)
43:            		f3_as_quot |= 0x800000;
44:            	return f3;
45:            }
46:            #else
47:            #define	exp2	sign
48:            float
49:            __ftdiv(float f2, float f1)
50:            {
51:            	unsigned char	exp, sign, cntr;
52:            	float	f3;
53:            	
54:            	// unpack the operands
55:            	if((exp = f1_as_dividend >> 15) == 0)
084A  084F     MOVF f1, W
084B  00D2     MOVWF 0x52
084C  0850     MOVF 0x50, W
084D  00D3     MOVWF 0x53
084E  0851     MOVF 0x51, W
084F  00D4     MOVWF 0x54
0850  1003     BCF STATUS, 0x0
0851  0D53     RLF 0x53, W
0852  0D54     RLF 0x54, W
0853  00D9     MOVWF exp
0854  08D9     MOVF exp, F
0855  1D03     BTFSS STATUS, 0x2
0856  285B     GOTO 0x5B
56:            		return 0.0;
0857  01CC     CLRF f2
0858  01CD     CLRF 0x4D
0859  01CE     CLRF 0x4E
085A  0008     RETURN
57:            	if((exp2 = f2_as_divisor >> 15) == 0)
085B  084C     MOVF f2, W
085C  00D2     MOVWF 0x52
085D  084D     MOVF 0x4D, W
085E  00D3     MOVWF 0x53
085F  084E     MOVF 0x4E, W
0860  00D4     MOVWF 0x54
0861  1003     BCF STATUS, 0x0
0862  0D53     RLF 0x53, W
0863  0D54     RLF 0x54, W
0864  00DA     MOVWF sign
0865  08DA     MOVF sign, F
0866  1D03     BTFSS STATUS, 0x2
0867  286C     GOTO 0x6C
58:            		return 0.0;
0868  01CC     CLRF f2
0869  01CD     CLRF 0x4D
086A  01CE     CLRF 0x4E
086B  0008     RETURN
59:            	f3_as_quot = 0;
086D  01D6     CLRF f3
086E  01D7     CLRF 0x57
086F  01D8     CLRF 0x58
60:            	exp -= exp2-127+8;	// compute new exponent
086C  3089     MOVLW 0x89
0870  075A     ADDWF sign, W
0871  00D2     MOVWF 0x52
0872  02D9     SUBWF exp, F
61:            	sign = f1_as_dividend >> 16;
0873  0851     MOVF 0x51, W
0874  00DA     MOVWF sign
62:            	sign ^= (unsigned char)(f2_as_divisor >> 16);
0875  084E     MOVF 0x4E, W
0876  06DA     XORWF sign, F
63:            	sign &= 0x80;
0877  3080     MOVLW 0x80
0878  05DA     ANDWF sign, F
64:            	f1_as_dividend |= 0x8000UL;
087A  17D0     BSF 0x50, 0x7
65:            	f1_as_dividend &= 0xFFFFUL;
087B  01D1     CLRF 0x51
66:            	f2_as_divisor |= 0x8000UL;
087C  17CD     BSF 0x4D, 0x7
67:            	f2_as_divisor &= 0xFFFFUL;
087D  01CE     CLRF 0x4E
68:            	cntr = 16+8;
0879  3018     MOVLW 0x18
087E  00D5     MOVWF cntr
69:            	do {
70:            		f3_as_quot <<= 1;
087F  1003     BCF STATUS, 0x0
0880  0DD6     RLF f3, F
0881  0DD7     RLF 0x57, F
0882  0DD8     RLF 0x58, F
71:            		if(f1_as_dividend >= f2_as_divisor) {
0883  084E     MOVF 0x4E, W
0884  0251     SUBWF 0x51, W
0885  1D03     BTFSS STATUS, 0x2
0886  288D     GOTO 0x8D
0887  084D     MOVF 0x4D, W
0888  0250     SUBWF 0x50, W
0889  1D03     BTFSS STATUS, 0x2
088A  288D     GOTO 0x8D
088B  084C     MOVF f2, W
088C  024F     SUBWF f1, W
088D  1C03     BTFSS STATUS, 0x0
088E  289B     GOTO 0x9B
72:            			f1_as_dividend -= f2_as_divisor;
088F  084C     MOVF f2, W
0890  02CF     SUBWF f1, F
0891  084D     MOVF 0x4D, W
0892  1C03     BTFSS STATUS, 0x0
0893  0F4D     INCFSZ 0x4D, W
0894  02D0     SUBWF 0x50, F
0895  084E     MOVF 0x4E, W
0896  1C03     BTFSS STATUS, 0x0
0897  0A4E     INCF 0x4E, W
0898  02D1     SUBWF 0x51, F
73:            			f3_as_quot |= 1;
0899  1456     BSF f3, 0x0
74:            		}
75:            		f1_as_dividend <<= 1;
089A  1003     BCF STATUS, 0x0
089B  0DCF     RLF f1, F
089C  0DD0     RLF 0x50, F
089D  0DD1     RLF 0x51, F
76:            	} while(--cntr != 0);
089E  0BD5     DECFSZ cntr, F
089F  287F     GOTO 0x7F
77:            	return __ftpack(f3_as_quot, exp, sign);
08A0  0856     MOVF f3, W
08A1  00A3     MOVWF x
08A2  0857     MOVF 0x57, W
08A3  00A4     MOVWF Data
08A4  0858     MOVF 0x58, W
08A5  00A5     MOVWF y
08A6  0859     MOVF exp, W
08A7  00A6     MOVWF x
08A8  085A     MOVF sign, W
08A9  00A7     MOVWF i
08AA  21ED     CALL 0x1ED
08AB  0823     MOVF x, W
08AC  00CC     MOVWF f2
08AD  0824     MOVF Data, W
08AE  00CD     MOVWF 0x4D
08AF  0825     MOVF y, W
08B0  00CE     MOVWF 0x4E
78:            }
08B1  0008     RETURN
79:            #endif	
---  /opt/microchip/xc8/v1.31/sources/common/wmul.c  ----------------------------------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             unsigned int
3:             __wmul(unsigned int multiplier, unsigned int multiplicand)
4:             {
5:                     unsigned int product;
6:             
7:             #ifdef _PIC18
8:             
9:             #define LOWBYTE(x)  (*(unsigned char *)(&x))
10:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
11:            
12:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
13:            /*
14:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
15:                   a  b
16:            *      c  d
17:            -----------
18:                 |   bd
19:                 |ad  0
20:                 |bc  0
21:            +  ac| 0  0 (we ignore this intermediate product
22:                         because it does not affect the low 16 bits of the result)
23:            ===========
24:             */
25:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
26:                    product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
27:                    product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
28:            
29:            #else
30:            
31:            	product = 0;
0C69  01A7     CLRF i
0C6A  01A8     CLRF data
32:            	do {
33:            		if(multiplier & 1)
0C6B  1C23     BTFSS x, 0x0
0C6C  2C73     GOTO 0x473
34:            			product += multiplicand;
0C6D  0825     MOVF y, W
0C6E  07A7     ADDWF i, F
0C6F  1803     BTFSC STATUS, 0x0
0C70  0AA8     INCF data, F
0C71  0826     MOVF x, W
0C72  07A8     ADDWF data, F
35:            		multiplicand <<= 1;
0C73  1003     BCF STATUS, 0x0
0C74  0DA5     RLF y, F
0C75  0DA6     RLF x, F
36:            		multiplier >>= 1;
0C76  1003     BCF STATUS, 0x0
0C77  0CA4     RRF Data, F
0C78  0CA3     RRF x, F
37:            	} while(multiplier != 0);
0C79  0824     MOVF Data, W
0C7A  0423     IORWF x, W
0C7B  1D03     BTFSS STATUS, 0x2
0C7C  2C6B     GOTO 0x46B
38:            
39:            #endif
40:                    return product;
0C7D  0828     MOVF data, W
0C7E  00A4     MOVWF Data
0C7F  0827     MOVF i, W
0C80  00A3     MOVWF x
41:            }
0C81  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/lwtoft.c  --------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            
11:            // Convert unsigned int to float
12:            
13:            #ifdef _OLDLIB
14:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
15:            float
16:            __lwtoft(unsigned int c)
17:            {
18:            	float	f1;
19:            	
20:            	if(c == 0)
21:            		return 0.0;
22:            	f1_as_mant1 = c;
23:            	__ftpack(&f1_as_mant1, 127+15);
24:            	return f1;
25:            }
26:            #else
27:            float
28:            __lwtoft(unsigned int c)
29:            {
30:            	return __ftpack(c, 127+15, 0);
0824  0830     MOVF day, W
0825  00A3     MOVWF x
0826  0831     MOVF 0x31, W
0827  00A4     MOVWF Data
0828  308E     MOVLW 0x8E
0829  01A5     CLRF y
082A  00A6     MOVWF x
082B  01A7     CLRF i
082C  21ED     CALL 0x1ED
082D  0823     MOVF x, W
082E  00B0     MOVWF day
082F  0824     MOVF Data, W
0830  00B1     MOVWF 0x31
0831  0825     MOVF y, W
0832  00B2     MOVWF 0x32
31:            }
0833  0008     RETURN
32:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/lwmod.c  ---------------------------------------------------
1:             // word unsigned modulus
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwmod(unsigned int divisor, unsigned int dividend)
0C45  082B     MOVF val, W
0F9D  0872     MOVF canal, W
7:             #else
8:             __lwmod(unsigned int dividend, unsigned int divisor)
9:             #endif
10:            {
11:            	unsigned char	counter;
12:            
13:            	if(divisor != 0) {
0C45  082B     MOVF val, W
0C46  042A     IORWF Data, W
0C47  1903     BTFSC STATUS, 0x2
0C48  2C64     GOTO 0x464
0F9D  0872     MOVF canal, W
0F9E  0471     IORWF divisor, W
0F9F  1903     BTFSC STATUS, 0x2
0FA0  2FBC     GOTO 0x7BC
14:            		counter = 1;
0C49  01AE     CLRF min
0FA1  01F5     CLRF counter
15:            		while((divisor & 0x8000) == 0) {
0C4B  1BAB     BTFSC val, 0x7
0C4C  2C51     GOTO 0x451
0C50  2C4A     GOTO 0x44A
0FA3  1BF2     BTFSC canal, 0x7
0FA4  2FA9     GOTO 0x7A9
0FA8  2FA2     GOTO 0x7A2
16:            			divisor <<= 1;
0C4A  0AAE     INCF min, F
0C4D  1003     BCF STATUS, 0x0
0C4E  0DAA     RLF Data, F
0C4F  0DAB     RLF val, F
0FA2  0AF5     INCF counter, F
0FA5  1003     BCF STATUS, 0x0
0FA6  0DF1     RLF divisor, F
0FA7  0DF2     RLF canal, F
17:            			counter++;
0C4A  0AAE     INCF min, F
0FA2  0AF5     INCF counter, F
18:            		}
19:            		do {
20:            			if(divisor <= dividend)
0C51  082B     MOVF val, W
0C52  022D     SUBWF hr, W
0C53  1D03     BTFSS STATUS, 0x2
0C54  2C57     GOTO 0x457
0C55  082A     MOVF Data, W
0C56  022C     SUBWF seconds, W
0C57  1C03     BTFSS STATUS, 0x0
0C58  2C60     GOTO 0x460
0FA9  0872     MOVF canal, W
0FAA  0274     SUBWF counter, W
0FAB  1D03     BTFSS STATUS, 0x2
0FAC  2FAF     GOTO 0x7AF
0FAD  0871     MOVF divisor, W
0FAE  0273     SUBWF dividend, W
0FAF  1C03     BTFSS STATUS, 0x0
0FB0  2FB8     GOTO 0x7B8
21:            				dividend -= divisor;
0C59  082A     MOVF Data, W
0C5A  02AC     SUBWF seconds, F
0C5B  082B     MOVF val, W
0C5C  1C03     BTFSS STATUS, 0x0
0C5D  03AD     DECF hr, F
0C5E  02AD     SUBWF hr, F
0FB1  0871     MOVF divisor, W
0FB2  02F3     SUBWF dividend, F
0FB3  0872     MOVF canal, W
0FB4  1C03     BTFSS STATUS, 0x0
0FB5  03F4     DECF counter, F
0FB6  02F4     SUBWF counter, F
22:            			divisor >>= 1;
0C5F  1003     BCF STATUS, 0x0
0C60  0CAB     RRF val, F
0C61  0CAA     RRF Data, F
0FB7  1003     BCF STATUS, 0x0
0FB8  0CF2     RRF canal, F
0FB9  0CF1     RRF divisor, F
23:            		} while(--counter != 0);
0C62  0BAE     DECFSZ min, F
0C63  2C51     GOTO 0x451
0FBA  0BF5     DECFSZ counter, F
0FBB  2FA9     GOTO 0x7A9
24:            	}
25:            	return dividend;
0C64  082D     MOVF hr, W
0C65  00AB     MOVWF val
0C66  082C     MOVF seconds, W
0C67  00AA     MOVWF Data
0FBC  0874     MOVF counter, W
0FBD  00F2     MOVWF canal
0FBE  0873     MOVF dividend, W
0FBF  00F1     MOVWF divisor
26:            }
0C68  0008     RETURN
0FC0  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/lwdiv.c  ---------------------------------------------------
1:             // word unsigned division
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwdiv(unsigned int divisor, unsigned int dividend)
7:             #else
8:             __lwdiv(unsigned int dividend, unsigned int divisor)
9:             #endif
10:            {
11:            	unsigned int	quotient;
12:            	unsigned char	counter;
13:            
14:            	quotient = 0;
0C1B  01A8     CLRF data
0C1C  01A9     CLRF dato
15:            	if(divisor != 0) {
0C1D  0824     MOVF Data, W
0C1E  0423     IORWF x, W
0C1F  1903     BTFSC STATUS, 0x2
0C20  2C40     GOTO 0x440
16:            		counter = 1;
0C21  01A7     CLRF i
17:            		while((divisor & 0x8000) == 0) {
0C23  1BA4     BTFSC Data, 0x7
0C24  2C29     GOTO 0x429
0C28  2C22     GOTO 0x422
18:            			divisor <<= 1;
0C22  0AA7     INCF i, F
0C25  1003     BCF STATUS, 0x0
0C26  0DA3     RLF x, F
0C27  0DA4     RLF Data, F
19:            			counter++;
0C22  0AA7     INCF i, F
20:            		}
21:            		do {
22:            			quotient <<= 1;
0C29  1003     BCF STATUS, 0x0
0C2A  0DA8     RLF data, F
0C2B  0DA9     RLF dato, F
23:            			if(divisor <= dividend) {
0C2C  0824     MOVF Data, W
0C2D  0226     SUBWF x, W
0C2E  1D03     BTFSS STATUS, 0x2
0C2F  2C32     GOTO 0x432
0C30  0823     MOVF x, W
0C31  0225     SUBWF y, W
0C32  1C03     BTFSS STATUS, 0x0
0C33  2C3C     GOTO 0x43C
24:            				dividend -= divisor;
0C34  0823     MOVF x, W
0C35  02A5     SUBWF y, F
0C36  0824     MOVF Data, W
0C37  1C03     BTFSS STATUS, 0x0
0C38  03A6     DECF x, F
0C39  02A6     SUBWF x, F
25:            				quotient |= 1;
0C3A  1428     BSF data, 0x0
26:            			}
27:            			divisor >>= 1;
0C3B  1003     BCF STATUS, 0x0
0C3C  0CA4     RRF Data, F
0C3D  0CA3     RRF x, F
28:            		} while(--counter != 0);
0C3E  0BA7     DECFSZ i, F
0C3F  2C29     GOTO 0x429
29:            	}
30:            	return quotient;
0C40  0829     MOVF dato, W
0C41  00A4     MOVWF Data
0C42  0828     MOVF data, W
0C43  00A3     MOVWF x
31:            }
0C44  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/lbmod.c  ---------------------------------------------------
1:             // byte unsigned modulus
2:             
3:             unsigned char
4:             __lbmod(unsigned char dividend, unsigned char divisor)
0331  00A5     MOVWF y
0808  00F3     MOVWF dividend
5:             {
6:             	unsigned char	rem;
7:             	unsigned char	counter;
8:             
9:             	counter = 8;
0332  3008     MOVLW 0x8
0333  00A6     MOVWF x
0809  3008     MOVLW 0x8
080A  00F4     MOVWF counter
10:            	rem = 0;
0334  01A7     CLRF i
080B  01F5     CLRF counter
11:            	do {
12:            		rem = (rem << 1) | (dividend >> 7);
0335  0825     MOVF y, W
0336  00A4     MOVWF Data
0337  3007     MOVLW 0x7
0338  1003     BCF STATUS, 0x0
0339  0CA4     RRF Data, F
033A  3EFF     ADDLW 0xFF
033B  1003     BCF STATUS, 0x0
033C  1D03     BTFSS STATUS, 0x2
033D  2B39     GOTO 0x339
033E  0D27     RLF i, W
033F  0424     IORWF Data, W
0340  00A7     MOVWF i
080C  0873     MOVF dividend, W
080D  00F2     MOVWF canal
080E  3007     MOVLW 0x7
080F  1003     BCF STATUS, 0x0
0810  0CF2     RRF canal, F
0811  3EFF     ADDLW 0xFF
0812  1003     BCF STATUS, 0x0
0813  1D03     BTFSS STATUS, 0x2
0814  2810     GOTO 0x10
0815  0D75     RLF counter, W
0816  0472     IORWF canal, W
0817  00F5     MOVWF counter
13:            		dividend <<= 1;
0341  1003     BCF STATUS, 0x0
0342  0DA5     RLF y, F
0818  1003     BCF STATUS, 0x0
0819  0DF3     RLF dividend, F
14:            		if(divisor <= rem)
0343  0823     MOVF x, W
0344  0227     SUBWF i, W
0345  1C03     BTFSS STATUS, 0x0
0346  2B49     GOTO 0x349
081A  0871     MOVF divisor, W
081B  0275     SUBWF counter, W
081C  1C03     BTFSS STATUS, 0x0
081D  2820     GOTO 0x20
15:            			rem -= divisor;
0347  0823     MOVF x, W
0348  02A7     SUBWF i, F
081E  0871     MOVF divisor, W
081F  02F5     SUBWF counter, F
16:            	} while(--counter != 0);
0349  0BA6     DECFSZ x, F
034A  2B35     GOTO 0x335
0820  0BF4     DECFSZ counter, F
0821  280C     GOTO 0xC
17:            	return rem;
034B  0827     MOVF i, W
0822  0875     MOVF counter, W
18:            }
034C  0008     RETURN
0823  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/lbdiv.c  ---------------------------------------------------
1:             // byte unsigned division
2:             
3:             unsigned char
4:             __lbdiv(unsigned char dividend, unsigned char divisor)
0308  00A4     MOVWF Data
5:             {
6:             	unsigned char	quotient;
7:             	unsigned char	counter;
8:             
9:             	quotient = 0;
0309  01A6     CLRF x
10:            	if(divisor != 0) {
030A  0823     MOVF x, W
030B  1903     BTFSC STATUS, 0x2
030C  2B21     GOTO 0x321
11:            		counter = 1;
030D  01A5     CLRF y
12:            		while((divisor & 0x80) == 0) {
030F  1BA3     BTFSC x, 0x7
0310  2B14     GOTO 0x314
0313  2B0E     GOTO 0x30E
13:            			divisor <<= 1;
0311  1003     BCF STATUS, 0x0
0312  0DA3     RLF x, F
14:            			counter++;
030E  0AA5     INCF y, F
15:            		}
16:            		do {
17:            			quotient <<= 1;
0314  1003     BCF STATUS, 0x0
0315  0DA6     RLF x, F
18:            			if(divisor <= dividend) {
0316  0823     MOVF x, W
0317  0224     SUBWF Data, W
0318  1C03     BTFSS STATUS, 0x0
0319  2B1E     GOTO 0x31E
19:            				dividend -= divisor;
031A  0823     MOVF x, W
031B  02A4     SUBWF Data, F
20:            				quotient |= 1;
031C  1426     BSF x, 0x0
21:            			}
22:            			divisor >>= 1;
031D  1003     BCF STATUS, 0x0
031E  0CA3     RRF x, F
23:            		} while(--counter != 0);
031F  0BA5     DECFSZ y, F
0320  2B14     GOTO 0x314
24:            	}
25:            	return quotient;
0321  0826     MOVF x, W
26:            }
0322  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/isdigit.c  -------------------------------------------------
1:             #include	<ctype.h>
2:             
3:             #ifndef isdigit
4:             
5:             #ifdef _CTYPE_BIT_FUNCS_
6:             
7:             bit
8:             isdigit(char c)
0C0D  00A4     MOVWF Data
9:             #else
10:            int
11:            isdigit(int c)
12:            #endif
13:            {
14:            	return c <= '9' && c >= '0';
0C0E  303A     MOVLW 0x3A
0C0F  01A3     CLRF x
0C10  0224     SUBWF Data, W
0C11  1803     BTFSC STATUS, 0x0
0C12  2C19     GOTO 0x419
0C13  3030     MOVLW 0x30
0C14  0224     SUBWF Data, W
0C15  1C03     BTFSS STATUS, 0x0
0C16  2C19     GOTO 0x419
0C17  01A3     CLRF x
0C18  0AA3     INCF x, F
0C19  0C23     RRF x, W
15:            }
0C1A  0008     RETURN
16:            
17:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/fttol.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
11:            
12:            // Convert float to long
13:            
14:            #ifdef _OLDLIB
15:            long
16:            __fttol(float f1)
17:            {
18:            	unsigned char	sign1, exp1;
19:            	unsigned long	lval;
20:            
21:            	sign1 = __ftunpack(&f1_as_mant1, &exp1);
22:            	lval = f1_as_mant1;
23:            	exp1 -= 127+15;
24:            	if((signed char)exp1 < 0) {
25:            		if((signed char)exp1 < -15)
26:            			return 0;
27:            		do
28:            			lval >>= 1;
29:            		while(++exp1 != 0);
30:            	} else {
31:            		if(exp1 >= 32)
32:            			return 00;
33:            		while(exp1 != 0) {
34:            			lval <<= 1;
35:            			exp1--;
36:            		}
37:            	}
38:            	if(sign1)
39:            		lval = -lval;
40:            	return lval;
41:            }
42:            #else
43:            long
44:            __fttol(float f1)
45:            {
46:            	unsigned char	sign1, exp1;
47:            	unsigned long	lval;
48:            
49:            	if((exp1 = f1_as_mant1 >> 15) == 0)
0093  0823     MOVF x, W
0094  00A7     MOVWF i
0095  0824     MOVF Data, W
0096  00A8     MOVWF data
0097  0825     MOVF y, W
0098  00A9     MOVWF dato
0099  1003     BCF STATUS, 0x0
009A  0D28     RLF data, W
009B  0D29     RLF dato, W
009C  00AF     MOVWF sec
009D  08AF     MOVF sec, F
009E  1D03     BTFSS STATUS, 0x2
009F  28A5     GOTO 0xA5
50:            		return 0;
00A0  01A3     CLRF x
00A1  01A4     CLRF Data
00A2  01A5     CLRF y
00A3  01A6     CLRF x
00A4  0008     RETURN
51:            	sign1 = f1_as_mant1 >> 23;
00A5  0823     MOVF x, W
00A6  00A7     MOVWF i
00A7  0824     MOVF Data, W
00A8  00A8     MOVWF data
00A9  0825     MOVF y, W
00AA  00A9     MOVWF dato
00AB  3017     MOVLW 0x17
00AC  1003     BCF STATUS, 0x0
00AD  0CA9     RRF dato, F
00AE  0CA8     RRF data, F
00AF  0CA7     RRF i, F
00B0  3EFF     ADDLW 0xFF
00B1  1D03     BTFSS STATUS, 0x2
00B2  28AC     GOTO 0xAC
00B3  0827     MOVF i, W
00B4  00AA     MOVWF Data
52:            	f1_as_mant1 |= 0x8000UL;
00B5  17A4     BSF Data, 0x7
53:            	f1_as_mant1 &= 0xFFFFUL;
00B6  01A5     CLRF y
54:            	lval = f1_as_mant1;
00B7  0823     MOVF x, W
00B8  00AB     MOVWF val
00B9  0824     MOVF Data, W
00BA  00AC     MOVWF seconds
00BB  0825     MOVF y, W
00BC  00AD     MOVWF hr
00BE  01AE     CLRF min
55:            	exp1 -= 127+15;
00BD  308E     MOVLW 0x8E
00BF  02AF     SUBWF sec, F
56:            	if((signed char)exp1 < 0) {
00C0  1FAF     BTFSS sec, 0x7
00C1  28CF     GOTO 0xCF
57:            		if((signed char)exp1 < -15)
00C2  082F     MOVF sec, W
00C3  3A80     XORLW 0x80
00C4  3E8F     ADDLW 0x8F
00C5  1C03     BTFSS STATUS, 0x0
00C6  28A0     GOTO 0xA0
58:            			return 0;
59:            		do
60:            			lval >>= 1;
00C7  1003     BCF STATUS, 0x0
00C8  0CAE     RRF min, F
00C9  0CAD     RRF hr, F
00CA  0CAC     RRF seconds, F
00CB  0CAB     RRF val, F
61:            		while(++exp1 != 0);
00CC  0FAF     INCFSZ sec, F
00CD  28C7     GOTO 0xC7
00CE  28DD     GOTO 0xDD
62:            	} else {
63:            		if(exp1 >= 24)
00CF  3018     MOVLW 0x18
00D0  022F     SUBWF sec, W
00D1  1803     BTFSC STATUS, 0x0
00D2  28A0     GOTO 0xA0
64:            			return 0;
65:            		while(exp1 != 0) {
00D3  08AF     MOVF sec, F
00DC  28D3     GOTO 0xD3
66:            			lval <<= 1;
00D6  1003     BCF STATUS, 0x0
00D7  0DAB     RLF val, F
00D8  0DAC     RLF seconds, F
00D9  0DAD     RLF hr, F
00DA  0DAE     RLF min, F
67:            			exp1--;
00DB  03AF     DECF sec, F
68:            		}
00D3  08AF     MOVF sec, F
00D4  1903     BTFSC STATUS, 0x2
00D5  28DD     GOTO 0xDD
69:            	}
70:            	if(sign1)
00DD  082A     MOVF Data, W
00DE  1903     BTFSC STATUS, 0x2
00DF  28EB     GOTO 0xEB
71:            		lval = -lval;
00E0  09AB     COMF val, F
00E1  09AC     COMF seconds, F
00E2  09AD     COMF hr, F
00E3  09AE     COMF min, F
00E4  0AAB     INCF val, F
00E5  1903     BTFSC STATUS, 0x2
00E6  0AAC     INCF seconds, F
00E7  1903     BTFSC STATUS, 0x2
00E8  0AAD     INCF hr, F
00E9  1903     BTFSC STATUS, 0x2
00EA  0AAE     INCF min, F
72:            	return lval;
00EB  082E     MOVF min, W
00EC  00A6     MOVWF x
00ED  082D     MOVF hr, W
00EE  00A5     MOVWF y
00EF  082C     MOVF seconds, W
00F0  00A4     MOVWF Data
00F1  082B     MOVF val, W
00F2  00A3     MOVWF x
73:            }
00F3  0008     RETURN
74:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/ftsub.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
11:            #define	f2_as_mant2	(*(unsigned short long *)&f2)
12:            
13:            // floating addition
14:            
15:            float
16:            #ifdef __PICC__
17:            #warning TODO: update cgpic and this file to use the other prototype
18:            __ftsub(float f2, float f1)
19:            #else
20:            __ftsub(float f1, float f2)
21:            #endif
22:            {
23:            	f2_as_mant2 ^= 0x800000;
0834  3080     MOVLW 0x80
0835  06B9     XORWF 0x39, F
24:            	return __ftadd(f1, f2);
0836  083A     MOVF prec, W
0837  00AB     MOVWF val
0838  083B     MOVF ap, W
0839  00AC     MOVWF seconds
083A  083C     MOVF flag, W
083B  00AD     MOVWF hr
083C  0837     MOVF f2, W
083D  00AE     MOVWF min
083E  0838     MOVF 0x38, W
083F  00AF     MOVWF sec
0840  0839     MOVF 0x39, W
0841  00B0     MOVWF day
0842  212D     CALL 0x12D
0843  082B     MOVF val, W
0844  00B7     MOVWF f2
0845  082C     MOVF seconds, W
0846  00B8     MOVWF 0x38
0847  082D     MOVF hr, W
0848  00B9     MOVWF 0x39
25:            }
0849  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/ftmul.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_plier	(*(unsigned short long *)&f1)
11:            #define	f2_as_plicand	(*(unsigned short long *)&f2)
12:            
13:            // floating addition
14:            
15:            #ifdef _OLDLIB
16:            #define	f3_as_product		(*(unsigned short long *)&f3)
17:            float
18:            __ftmul(float f1, float f2)
19:            {
20:            	unsigned char	exp1, sign1, cntr;
21:            	float	f3;
22:            	
23:            	f3_as_product = 0;
24:            	sign1 = __ftunpack(&f1_as_plier, &exp1);
25:            	sign1 ^= __ftunpack(&f2_as_plicand, &cntr);
26:            	if(cntr == 0 || exp1 == 0)
27:            		return f3;
28:            	exp1 += cntr-127-6;	// compute new exponent
29:            	cntr = 7;
30:            	do {
31:            		if(f1_as_plier & 1)
32:            			f3_as_product += f2_as_plicand;
33:            		f1_as_plier >>= 1;
34:            		f2_as_plicand <<= 1;
35:            	} while(--cntr != 0);
36:            	cntr = 9;
37:            	do {
38:            		if(f1_as_plier & 1)
39:            			f3_as_product += f2_as_plicand;
40:            		f1_as_plier >>= 1;
41:            		f3_as_product >>= 1;
42:            	} while(--cntr != 0);
43:            	__ftpack(&f3_as_product, exp1);
44:            	if(sign1)
45:            		f3_as_product |= 0x800000;
46:            	return f3;
47:            }
48:            #else
49:            #define	exp2	sign
50:            float
51:            __ftmul(float f1, float f2)
52:            {
53:            	unsigned char	exp, sign, cntr;
54:            	unsigned short long	f3_as_product;
55:            
56:            	if((exp = f1_as_plier >> 15) == 0)
08B2  083D     MOVF c, W
08B3  00C3     MOVWF 0x43
08B4  083E     MOVF width, W
08B5  00C4     MOVWF sp
08B6  083F     MOVF 0x3F, W
08B7  00C5     MOVWF 0x45
08B8  1003     BCF STATUS, 0x0
08B9  0D44     RLF sp, W
08BA  0D45     RLF 0x45, W
08BB  00C6     MOVWF exp
08BC  08C6     MOVF exp, F
08BD  1D03     BTFSS STATUS, 0x2
08BE  28C3     GOTO 0xC3
57:            		return 0.0;
08BF  01BD     CLRF c
08C0  01BE     CLRF width
08C1  01BF     CLRF 0x3F
08C2  0008     RETURN
58:            	if((exp2 = f2_as_plicand >> 15) == 0)
08C3  0840     MOVF _val, W
08C4  00C3     MOVWF 0x43
08C5  0841     MOVF 0x41, W
08C6  00C4     MOVWF sp
08C7  0842     MOVF 0x42, W
08C8  00C5     MOVWF 0x45
08C9  1003     BCF STATUS, 0x0
08CA  0D44     RLF sp, W
08CB  0D45     RLF 0x45, W
08CC  00CB     MOVWF sign
08CD  08CB     MOVF sign, F
08CE  1D03     BTFSS STATUS, 0x2
08CF  28D4     GOTO 0xD4
59:            		return 0.0;
08D0  01BD     CLRF c
08D1  01BE     CLRF width
08D2  01BF     CLRF 0x3F
08D3  0008     RETURN
60:            	exp += exp2-127-6;	// compute new exponent
08D4  084B     MOVF sign, W
08D5  3E7B     ADDLW 0x7B
08D6  07C6     ADDWF exp, F
61:            	sign = f1_as_plier >> 16;
08D7  083F     MOVF 0x3F, W
08D8  00CB     MOVWF sign
62:            	sign ^= (unsigned char)(f2_as_plicand >> 16);
08D9  0842     MOVF 0x42, W
08DA  06CB     XORWF sign, F
63:            	sign &= 0x80;
08DB  3080     MOVLW 0x80
08DC  05CB     ANDWF sign, F
64:            	f1_as_plier |= 0x8000UL;
08DE  17BE     BSF width, 0x7
65:            	//f1_as_plier &= 0xFFFFUL;		// not required
66:            	f2_as_plicand |= 0x8000UL;
08DF  17C1     BSF 0x41, 0x7
67:            	f2_as_plicand &= 0xFFFFUL;
08E0  01C2     CLRF 0x42
68:            	f3_as_product = 0;
08E1  01C7     CLRF f3_as_product
08E2  01C8     CLRF 0x48
08E3  01C9     CLRF 0x49
69:            	cntr = 7;
08DD  3007     MOVLW 0x7
08E4  00CA     MOVWF cntr
70:            	do {
71:            		if(f1_as_plier & 1)
08E5  1C3D     BTFSS c, 0x0
08E6  28F5     GOTO 0xF5
72:            			f3_as_product += f2_as_plicand;
08E7  0840     MOVF _val, W
08E8  07C7     ADDWF f3_as_product, F
08E9  0841     MOVF 0x41, W
08EA  1103     BCF STATUS, 0x2
08EB  1803     BTFSC STATUS, 0x0
08EC  0A41     INCF 0x41, W
08ED  1D03     BTFSS STATUS, 0x2
08EE  07C8     ADDWF 0x48, F
08EF  0842     MOVF 0x42, W
08F0  1103     BCF STATUS, 0x2
08F1  1803     BTFSC STATUS, 0x0
08F2  0A42     INCF 0x42, W
08F3  1D03     BTFSS STATUS, 0x2
08F4  07C9     ADDWF 0x49, F
73:            		f1_as_plier >>= 1;
08F5  1003     BCF STATUS, 0x0
08F6  0CBF     RRF 0x3F, F
08F7  0CBE     RRF width, F
08F8  0CBD     RRF c, F
74:            		f2_as_plicand <<= 1;
08F9  1003     BCF STATUS, 0x0
08FA  0DC0     RLF _val, F
08FB  0DC1     RLF 0x41, F
08FC  0DC2     RLF 0x42, F
75:            	} while(--cntr != 0);
08FD  0BCA     DECFSZ cntr, F
08FE  28E5     GOTO 0xE5
76:            	cntr = 9;
08FF  3009     MOVLW 0x9
0900  00CA     MOVWF cntr
77:            	do {
78:            		if(f1_as_plier & 1)
0901  1C3D     BTFSS c, 0x0
0902  2911     GOTO 0x111
79:            			f3_as_product += f2_as_plicand;
0903  0840     MOVF _val, W
0904  07C7     ADDWF f3_as_product, F
0905  0841     MOVF 0x41, W
0906  1103     BCF STATUS, 0x2
0907  1803     BTFSC STATUS, 0x0
0908  0A41     INCF 0x41, W
0909  1D03     BTFSS STATUS, 0x2
090A  07C8     ADDWF 0x48, F
090B  0842     MOVF 0x42, W
090C  1103     BCF STATUS, 0x2
090D  1803     BTFSC STATUS, 0x0
090E  0A42     INCF 0x42, W
090F  1D03     BTFSS STATUS, 0x2
0910  07C9     ADDWF 0x49, F
80:            		f1_as_plier >>= 1;
0911  1003     BCF STATUS, 0x0
0912  0CBF     RRF 0x3F, F
0913  0CBE     RRF width, F
0914  0CBD     RRF c, F
81:            		f3_as_product >>= 1;
0915  1003     BCF STATUS, 0x0
0916  0CC9     RRF 0x49, F
0917  0CC8     RRF 0x48, F
0918  0CC7     RRF f3_as_product, F
82:            	} while(--cntr != 0);
0919  0BCA     DECFSZ cntr, F
091A  2901     GOTO 0x101
83:            	return __ftpack(f3_as_product, exp, sign);
091B  0847     MOVF f3_as_product, W
091C  00A3     MOVWF x
091D  0848     MOVF 0x48, W
091E  00A4     MOVWF Data
091F  0849     MOVF 0x49, W
0920  00A5     MOVWF y
0921  0846     MOVF exp, W
0922  00A6     MOVWF x
0923  084B     MOVF sign, W
0924  00A7     MOVWF i
0925  21ED     CALL 0x1ED
0926  0823     MOVF x, W
0927  00BD     MOVWF c
0928  0824     MOVF Data, W
0929  00BE     MOVWF width
092A  0825     MOVF y, W
092B  00BF     MOVWF 0x3F
84:            }
092C  0008     RETURN
85:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/ftadd.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
11:            #define	f2_as_mant2	(*(unsigned short long *)&f2)
12:            
13:            // floating addition
14:            #ifdef _OLDLIB
15:            float
16:            __ftadd(float f1, float f2)
17:            {
18:            	unsigned char	exp1, exp2, sign1, sign2, cntr;
19:            	
20:            	if(sizeof(f1_as_mant1) != 3)
21:            		return 0;
22:            	sign1 = __ftunpack(&f1_as_mant1, &exp1);
23:            	if(exp1 == 0)
24:            		return f2;
25:            	sign2 = __ftunpack(&f2_as_mant2, &exp2);
26:            	if(exp2 != 0) {
27:            		cntr = 6;
28:            		// determine the smaller number. 
29:            		if(exp1 < exp2) {
30:            			if((unsigned char)(exp2-exp1) > sizeof(f1)*8) {
31:            				// return f2
32:            				f1_as_mant1 = 0;
33:            				exp1 = exp2;
34:            				sign1 = sign2;
35:            			} else {
36:            				// f1 has the smaller exponent - we can shift f2_as_mant2 up to 6 bits
37:            				// left, decrementing exp2.
38:            				do {
39:            					f2_as_mant2 <<= 1;
40:            					exp2--;
41:            				} while(exp2 != exp1 && --cntr != 0);
42:            				while(exp1 != exp2) {
43:            					f1_as_mant1 >>= 1;
44:            					exp1++;
45:            				}
46:            			}
47:            		} else if(exp1 != exp2) {
48:            			if((unsigned char)(exp1-exp2) > sizeof(f1)*8)
49:            				f2_as_mant2 = 0;
50:            			else {
51:            				// f2 has the smaller exponent - we can shift f1_as_mant1 up to 6 bits
52:            				// left, decrementing exp2.
53:            				do {
54:            					f1_as_mant1 <<= 1;
55:            					exp1--;
56:            				} while(exp2 != exp1 && --cntr != 0);
57:            				while(exp1 != exp2) {
58:            					f2_as_mant2 >>= 1;
59:            					exp2++;
60:            				}
61:            			}
62:            		}
63:            		if(sign1 != 0) { 
64:            			f1_as_mant1 ^= 0xFFFFFF;
65:            			f1_as_mant1++;
66:            		}
67:            		if(sign2 != 0) {
68:            			f2_as_mant2 ^= 0xFFFFFF;
69:            			f2_as_mant2++;
70:            		}
71:            		sign1 = 0;
72:            		f1_as_mant1 += f2_as_mant2;
73:            		if(f1_as_mant1 & 0x800000) {
74:            			f1_as_mant1 ^= 0xFFFFFF;
75:            			f1_as_mant1++;
76:            			sign1 = 1;
77:            		}
78:            	}
79:            	__ftpack(&f1_as_mant1, exp1);
80:            	if(sign1)
81:            		f1_as_mant1 ^= 0x800000;
82:            	return f1;
83:            }
84:            #else
85:            float
86:            __ftadd(float f1, float f2)
87:            {
88:            	unsigned char	exp1, exp2, sign;
89:            
90:            	exp1 = f1_as_mant1 >> 15;
092D  082B     MOVF val, W
092E  00B1     MOVWF 0x31
092F  082C     MOVF seconds, W
0930  00B2     MOVWF 0x32
0931  082D     MOVF hr, W
0932  00B3     MOVWF 0x33
0933  1003     BCF STATUS, 0x0
0934  0D32     RLF 0x32, W
0935  0D33     RLF 0x33, W
0936  00B6     MOVWF exp1
91:            	exp2 = f2_as_mant2 >> 15;
0937  082E     MOVF min, W
0938  00B1     MOVWF 0x31
0939  082F     MOVF sec, W
093A  00B2     MOVWF 0x32
093B  0830     MOVF day, W
093C  00B3     MOVWF 0x33
093D  1003     BCF STATUS, 0x0
093E  0D32     RLF 0x32, W
093F  0D33     RLF 0x33, W
0940  00B5     MOVWF exp2
92:            	if(exp1 == 0 || exp1 < exp2  && (unsigned char)(exp2-exp1) > sizeof(f1)*8)
0941  0836     MOVF exp1, W
0942  1903     BTFSC STATUS, 0x2
0943  2950     GOTO 0x150
0944  0835     MOVF exp2, W
0945  0236     SUBWF exp1, W
0946  0835     MOVF exp2, W
0947  1803     BTFSC STATUS, 0x0
0948  2958     GOTO 0x158
0949  00B1     MOVWF 0x31
094A  0836     MOVF exp1, W
094B  02B1     SUBWF 0x31, F
094C  3019     MOVLW 0x19
094D  0231     SUBWF 0x31, W
094E  1C03     BTFSS STATUS, 0x0
094F  2957     GOTO 0x157
93:            		return f2;
0950  082E     MOVF min, W
0951  00AB     MOVWF val
0952  082F     MOVF sec, W
0953  00AC     MOVWF seconds
0954  0830     MOVF day, W
0955  00AD     MOVWF hr
0956  0008     RETURN
94:            	if(exp2 == 0 || exp1 > exp2  && (unsigned char)(exp1-exp2) > sizeof(f1)*8)
0957  0835     MOVF exp2, W
0958  1903     BTFSC STATUS, 0x2
0959  0008     RETURN
095A  0836     MOVF exp1, W
095B  0235     SUBWF exp2, W
095C  1803     BTFSC STATUS, 0x0
095D  2966     GOTO 0x166
095E  0836     MOVF exp1, W
095F  00B1     MOVWF 0x31
0960  0835     MOVF exp2, W
0961  02B1     SUBWF 0x31, F
0962  3019     MOVLW 0x19
0963  0231     SUBWF 0x31, W
0964  1803     BTFSC STATUS, 0x0
0965  0008     RETURN
95:            		return f1;
96:            	sign = 6;
0966  3006     MOVLW 0x6
0967  00B4     MOVWF sign
97:            	if(f1_as_mant1 & 0x800000L)
0968  1BAD     BTFSC hr, 0x7
98:            		sign |= 0x80;
0969  17B4     BSF sign, 0x7
99:            	if(f2_as_mant2 & 0x800000L)
096A  1BB0     BTFSC day, 0x7
100:           		sign |= 0x40;
096B  1734     BSF sign, 0x6
101:           	f1_as_mant1 |= 0x8000UL;
096C  17AC     BSF seconds, 0x7
102:           	f1_as_mant1 &= 0xFFFFUL;
096D  01AD     CLRF hr
103:           	f2_as_mant2 |= 0x8000UL;
096E  17AF     BSF sec, 0x7
104:           	f2_as_mant2 &= 0xFFFFUL;
096F  01B0     CLRF day
105:           	// determine the smaller number. 
106:           	if(exp1 < exp2) {
0970  0835     MOVF exp2, W
0971  0236     SUBWF exp1, W
0972  1803     BTFSC STATUS, 0x0
0973  298D     GOTO 0x18D
107:           		// f1 has the smaller exponent - we can shift f2_as_mant2 up to 6 bits
108:           		// left, decrementing exp2.
109:           		do {
110:           			f2_as_mant2 <<= 1;
0974  1003     BCF STATUS, 0x0
0975  0DAE     RLF min, F
0976  0DAF     RLF sec, F
0977  0DB0     RLF day, F
111:           			exp2--;
0978  03B5     DECF exp2, F
112:           		} while(exp2 != exp1 && --sign & 7);
0979  0835     MOVF exp2, W
097A  0636     XORWF exp1, W
097B  1903     BTFSC STATUS, 0x2
097C  2988     GOTO 0x188
097D  03B4     DECF sign, F
097E  0834     MOVF sign, W
097F  3907     ANDLW 0x7
0980  1903     BTFSC STATUS, 0x2
0981  2988     GOTO 0x188
0982  2974     GOTO 0x174
113:           		while(exp1 != exp2) {
0988  0836     MOVF exp1, W
0989  0635     XORWF exp2, W
098A  1903     BTFSC STATUS, 0x2
098B  29A9     GOTO 0x1A9
098C  2983     GOTO 0x183
114:           			f1_as_mant1 >>= 1;
0983  1003     BCF STATUS, 0x0
0984  0CAD     RRF hr, F
0985  0CAC     RRF seconds, F
0986  0CAB     RRF val, F
115:           			exp1++;
0987  0AB6     INCF exp1, F
116:           		}
117:           	} else if(exp1 > exp2) {
098D  0836     MOVF exp1, W
098E  0235     SUBWF exp2, W
098F  1803     BTFSC STATUS, 0x0
0990  29A9     GOTO 0x1A9
118:           		// f2 has the smaller exponent - we can shift f1_as_mant1 up to 6 bits
119:           		// left, decrementing exp2.
120:           		do {
121:           			f1_as_mant1 <<= 1;
0991  1003     BCF STATUS, 0x0
0992  0DAB     RLF val, F
0993  0DAC     RLF seconds, F
0994  0DAD     RLF hr, F
122:           			exp1--;
0995  03B6     DECF exp1, F
123:           		} while(exp2 != exp1 && --sign & 7);
0996  0835     MOVF exp2, W
0997  0636     XORWF exp1, W
0998  1903     BTFSC STATUS, 0x2
0999  29A5     GOTO 0x1A5
099A  03B4     DECF sign, F
099B  0834     MOVF sign, W
099C  3907     ANDLW 0x7
099D  1903     BTFSC STATUS, 0x2
099E  29A5     GOTO 0x1A5
099F  2991     GOTO 0x191
124:           		while(exp1 != exp2) {
09A5  0836     MOVF exp1, W
09A6  0635     XORWF exp2, W
09A7  1D03     BTFSS STATUS, 0x2
09A8  29A0     GOTO 0x1A0
125:           			f2_as_mant2 >>= 1;
09A0  1003     BCF STATUS, 0x0
09A1  0CB0     RRF day, F
09A2  0CAF     RRF sec, F
09A3  0CAE     RRF min, F
126:           			exp2++;
09A4  0AB5     INCF exp2, F
127:           		}
128:           	}
129:           	if(sign & 0x80) { 
09A9  1FB4     BTFSS sign, 0x7
09AA  29B4     GOTO 0x1B4
130:           		// complement and add 1
131:           		f1_as_mant1 ^= 0xFFFFFFUL;
09AB  30FF     MOVLW 0xFF
09AC  06AB     XORWF val, F
09AD  06AC     XORWF seconds, F
09AE  06AD     XORWF hr, F
132:           		f1_as_mant1++;
09AF  0AAB     INCF val, F
09B0  1903     BTFSC STATUS, 0x2
09B1  0AAC     INCF seconds, F
09B2  1903     BTFSC STATUS, 0x2
09B3  0AAD     INCF hr, F
133:           	}
134:           	if(sign & 0x40) {
09B4  1F34     BTFSS sign, 0x6
09B5  29BF     GOTO 0x1BF
135:           		// complement and add 1
136:           		f2_as_mant2 ^= 0xFFFFFFUL;
09B6  30FF     MOVLW 0xFF
09B7  06AE     XORWF min, F
09B8  06AF     XORWF sec, F
09B9  06B0     XORWF day, F
137:           		f2_as_mant2++;
09BA  0AAE     INCF min, F
09BB  1903     BTFSC STATUS, 0x2
09BC  0AAF     INCF sec, F
09BD  1903     BTFSC STATUS, 0x2
09BE  0AB0     INCF day, F
138:           	}
139:           	sign = 0;
09BF  01B4     CLRF sign
140:           	f2_as_mant2 += f1_as_mant1;
09C0  082B     MOVF val, W
09C1  07AE     ADDWF min, F
09C2  082C     MOVF seconds, W
09C3  1103     BCF STATUS, 0x2
09C4  1803     BTFSC STATUS, 0x0
09C5  0A2C     INCF seconds, W
09C6  1D03     BTFSS STATUS, 0x2
09C7  07AF     ADDWF sec, F
09C8  082D     MOVF hr, W
09C9  1103     BCF STATUS, 0x2
09CA  1803     BTFSC STATUS, 0x0
09CB  0A2D     INCF hr, W
09CC  1D03     BTFSS STATUS, 0x2
09CD  07B0     ADDWF day, F
141:           	if(f2_as_mant2 & 0x800000UL) {
09CE  1FB0     BTFSS day, 0x7
09CF  29DB     GOTO 0x1DB
142:           		f2_as_mant2 ^= 0xFFFFFFUL;
09D0  30FF     MOVLW 0xFF
09D1  06AE     XORWF min, F
09D2  06AF     XORWF sec, F
09D3  06B0     XORWF day, F
143:           		f2_as_mant2++;
09D4  0AAE     INCF min, F
09D5  1903     BTFSC STATUS, 0x2
09D6  0AAF     INCF sec, F
09D7  1903     BTFSC STATUS, 0x2
09D8  0AB0     INCF day, F
144:           		sign = 1;
09D9  01B4     CLRF sign
09DA  0AB4     INCF sign, F
145:           	}
146:           	return __ftpack(f2_as_mant2, exp1, sign);
09DB  082E     MOVF min, W
09DC  00A3     MOVWF x
09DD  082F     MOVF sec, W
09DE  00A4     MOVWF Data
09DF  0830     MOVF day, W
09E0  00A5     MOVWF y
09E1  0836     MOVF exp1, W
09E2  00A6     MOVWF x
09E3  0834     MOVF sign, W
09E4  00A7     MOVWF i
09E5  21ED     CALL 0x1ED
09E6  0823     MOVF x, W
09E7  00AB     MOVWF val
09E8  0824     MOVF Data, W
09E9  00AC     MOVWF seconds
09EA  0825     MOVF y, W
09EB  00AD     MOVWF hr
147:           
148:           }
09EC  0008     RETURN
149:           #endif
---  /opt/microchip/xc8/v1.31/sources/common/float.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             #include	"ftarith.h"
7:             
8:             
9:             //	unpack the operand pointed to. Store the exponent into the location pointed to by exp,
10:            //	and return the sign (zero is positive)
11:            
12:            #ifdef _OLDLIB
13:            
14:            unsigned char
15:            __ftunpack(unsigned short long * arg, unsigned char * exp)
16:            {
17:            	unsigned char	sign;
18:            
19:            	*exp = sign = *arg >> 15;
20:            	if(sign == 0) {
21:            		*arg = 0;
22:            		return 0;
23:            	}
24:            	sign = 0;
25:            	*arg |= 0x8000;
26:            	if(*arg & 0x800000)
27:            		sign++;
28:            	*arg &= 0xFFFF;
29:            	return sign;
30:            }
31:            
32:            // normalize and pack the supplied argument into floating point format
33:            
34:            void
35:            __ftpack(unsigned short long * arg, unsigned char exp)
36:            {
37:            	if(exp == 0 || *arg == 0) {
38:            		*arg = 0;
39:            		return;
40:            	}
41:            	while(*arg & 0xFE0000UL) {
42:            		exp++;
43:            		*arg >>= 1;
44:            	}
45:            	while(*arg & 0xFF0000UL) {
46:            		exp++;
47:            		(*arg)++;
48:            		*arg >>= 1;
49:            	}
50:            	while(!(*arg & 0x8000UL)) {
51:            		exp--;
52:            		*arg <<= 1;
53:            	}
54:            	if(!(exp & 1))
55:            		*arg &= ~0x8000L;
56:            	exp >>= 1;
57:            	*arg |= (unsigned short long)exp << 16;
58:            }
59:            
60:            #else
61:            float
62:            __ftpack(unsigned short long arg, unsigned char exp, unsigned char sign)
63:            {
64:            	if(exp == 0 || arg == 0)
09ED  0826     MOVF x, W
09EE  1903     BTFSC STATUS, 0x2
09EF  29F5     GOTO 0x1F5
09F0  0825     MOVF y, W
09F1  0424     IORWF Data, W
09F2  0423     IORWF x, W
09F3  1D03     BTFSS STATUS, 0x2
09F4  29FE     GOTO 0x1FE
65:            		return 0.0;
09F5  01A3     CLRF x
09F6  01A4     CLRF Data
09F7  01A5     CLRF y
09F8  0008     RETURN
66:            	while(arg & 0xFE0000UL) {
09FE  30FE     MOVLW 0xFE
09FF  0525     ANDWF y, W
0A00  1903     BTFSC STATUS, 0x2
0A01  2A0D     GOTO 0x20D
0A02  29F9     GOTO 0x1F9
67:            		exp++;
09F9  0AA6     INCF x, F
68:            		arg >>= 1;
09FA  1003     BCF STATUS, 0x0
09FB  0CA5     RRF y, F
09FC  0CA4     RRF Data, F
09FD  0CA3     RRF x, F
69:            	}
70:            	while(arg & 0xFF0000UL) {
0A0D  30FF     MOVLW 0xFF
0A0E  0525     ANDWF y, W
0A0F  1903     BTFSC STATUS, 0x2
0A10  2A17     GOTO 0x217
0A11  2A03     GOTO 0x203
71:            		exp++;
0A03  0AA6     INCF x, F
72:            		(arg)++;
0A04  0AA3     INCF x, F
0A05  1903     BTFSC STATUS, 0x2
0A06  0AA4     INCF Data, F
0A07  1903     BTFSC STATUS, 0x2
0A08  0AA5     INCF y, F
73:            		arg >>= 1;
0A09  1003     BCF STATUS, 0x0
0A0A  0CA5     RRF y, F
0A0B  0CA4     RRF Data, F
0A0C  0CA3     RRF x, F
74:            	}
75:            	while(!(arg & 0x8000UL)) {
0A17  1FA4     BTFSS Data, 0x7
0A18  2A12     GOTO 0x212
76:            		exp--;
0A12  03A6     DECF x, F
77:            		arg <<= 1;
0A13  1003     BCF STATUS, 0x0
0A14  0DA3     RLF x, F
0A15  0DA4     RLF Data, F
0A16  0DA5     RLF y, F
78:            	}
79:            	if(!(exp & 1))
0A19  1C26     BTFSS x, 0x0
80:            		arg &= ~0x8000L;
0A1A  13A4     BCF Data, 0x7
81:            	exp >>= 1;
0A1B  1003     BCF STATUS, 0x0
0A1C  0CA6     RRF x, F
82:            	arg |= (unsigned short long)exp << 16;
0A1D  0826     MOVF x, W
0A1E  00AA     MOVWF Data
0A1F  01A9     CLRF dato
0A20  01A8     CLRF data
0A21  0828     MOVF data, W
0A22  04A3     IORWF x, F
0A23  0829     MOVF dato, W
0A24  04A4     IORWF Data, F
0A25  082A     MOVF Data, W
0A26  04A5     IORWF y, F
83:            	if (sign)
0A27  0827     MOVF i, W
0A28  1D03     BTFSS STATUS, 0x2
84:            		arg |= 0x800000UL;
0A29  17A5     BSF y, 0x7
85:               return *(float*)&arg;	
86:            }
0A2A  0008     RETURN
87:            
88:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/doprnt.c  --------------------------------------------------
1:             #include	<stdio.h>
2:             #include	<ctype.h>
3:             #include	<stdlib.h>
4:             #include	<string.h>
5:             #include	<stdarg.h>
6:             #include	<conio.h>
7:             #include	<sys.h>
8:             #include	<math.h>
9:             #include	<float.h>
10:            
11:            // disable unused variable warnings
12:            // the compiler will optimize them away, so no harm is done
13:            #pragma warning disable 350
14:            
15:            /*
16:             *	doprnt - versions depends on conditional compilation.
17:             *	Can be customized with defines.
18:             *
19:             *	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
20:             *
21:             *	$Header$
22:             *
23:             */
24:            
25:            #ifndef	CUSTOM_PRINTF
26:            
27:             // define all flags, thus enabling all features
28:            
29:            #define	BASEM	0xC0
30:            #define	OPTSIGN	0x00
31:            #define	SPCSIGN	0x01
32:            #define	MANSIGN	0x02
33:            #define	NEGSIGN	0x03
34:            #define	FILL	0x04
35:            #define	LEFT	0x08
36:            #define	LONG	0x10
37:            #define	UPCASE	0x20
38:            #define	TEN		0x00
39:            #define	EIGHT	0x40
40:            #define	SIXTEEN	0x80
41:            #define	UNSIGN	0xC0
42:            #ifdef	__FLOAT
43:            #define	EFMT	0x100
44:            #define	GFMT	0x200
45:            #define	FFMT	0x400
46:            #endif	// __FLOAT
47:            #define	ALTERN	0x800
48:            #define POINTER	0x2000
49:            #define HEXUPCASE
50:            #define HEXLOWCASE
51:            
52:             // defines for ifdef only, not used as flags
53:            #define	WIDTH	1		// width used
54:            #define	STAR	1		// width or precision as an arg
55:            #define	STRING	1		// %s used
56:            #define	CHAR	1		// %c used
57:            #define	PERCPERC	1	// %% used
58:            #define	SPRINTF	1		// sprintf is used
59:            #define	PRINTF	1		// printf is used
60:            #define	MULTRAD	1		// handle multiple radices
61:            #define	RETVALUE	1	// return value is needed
62:            
63:            #else	// CUSTOM_PRINTF
64:            
65:            #if	defined(HEXUPCASE) || defined(HEXLOWCASE)
66:            #define	SIXTEEN
67:            #endif
68:            
69:            #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
70:            #ifndef UPCASE
71:            #define	UPCASE
72:            #endif
73:            #endif
74:            
75:             // make sure we have the right values for each define
76:            #ifdef	OPTSIGN
77:            #undef	OPTSIGN
78:            #define	OPTSIGN	0x00
79:            #endif
80:            #ifdef	SPCSIGN
81:            #undef	SPCSIGN
82:            #define	SPCSIGN	0x01
83:            #endif
84:            #ifdef	MANSIGN
85:            #undef	MANSIGN
86:            #define	MANSIGN	0x02
87:            #define	SPCSIGN	0x01
88:            #endif
89:            #ifdef	NEGSIGN
90:            #undef	NEGSIGN
91:            #define	NEGSIGN	0x03
92:            #endif
93:            #ifdef	FILL
94:            #define	WIDTH	1
95:            #undef	FILL
96:            #define	FILL	0x04
97:            #endif
98:            #ifdef	LEFT
99:            #undef	LEFT
100:            // LEFT without WIDTH is meaningless
101:           #ifdef	WIDTH
102:           #define	LEFT	0x08
103:           #endif
104:           #endif
105:           #ifdef	LONG
106:           #undef	LONG
107:           #define	LONG	0x10
108:           #define	__LONG	1
109:           #endif
110:           #ifdef	UPCASE
111:           #undef	UPCASE
112:           #define	UPCASE	0x20
113:           #endif
114:           #ifdef	TEN	
115:           #undef	TEN	
116:           #define	TEN		0x00
117:           #endif
118:           #ifdef	EIGHT
119:           #undef	EIGHT
120:           #define	EIGHT	0x40
121:           #endif
122:           #ifdef	SIXTEEN
123:           #undef	SIXTEEN
124:           #define	SIXTEEN	0x80
125:           #endif
126:           #ifdef	UNSIGN
127:           #undef	UNSIGN
128:           #define	UNSIGN	0xC0
129:           #endif
130:           #ifdef	EFMT
131:           #undef	EFMT
132:           #define	EFMT	0x100
133:           #endif
134:           #ifdef	GFMT
135:           #undef	GFMT
136:           #define	GFMT	0x200
137:           #endif
138:           #ifdef	FFMT
139:           #undef	FFMT
140:           #define	FFMT	0x400
141:           #endif
142:           #ifdef	ALTERN
143:           #undef	ALTERN
144:           #define	ALTERN	0x800
145:           #endif
146:           #ifdef	POINTER
147:           #undef	POINTER
148:           #define POINTER	0x2000
149:           #ifndef	SIXTEEN
150:           #define	SIXTEEN	0x80
151:           #endif
152:           #endif
153:           #ifdef	PRECISION
154:           #undef	PRECISION
155:           #define PRECISION	0x4000
156:           #endif
157:           
158:           #if	defined(TEN) && !defined(EIGHT) && !defined(SIXTEEN) && defined(UNSIGN)
159:           #undef	UNSIGN
160:           #define	UNSIGN	0x40
161:           #define	BASEM	UNSIGN
162:           #endif
163:           #if	defined(UNSIGN) && (defined(EIGHT) || defined(SIXTEEN))
164:           #define	MULTRAD	1
165:           #define	BASEM	(UNSIGN)
166:           #endif
167:           #if	defined(TEN) && !defined(SIXTEEN) && defined(EIGHT) && !defined(UNSIGN)
168:           #define	BASEM	EIGHT
169:           #define	MULTRAD	1
170:           #endif
171:           #if	defined(TEN) && defined(SIXTEEN) && !defined(EIGHT) && !defined(UNSIGN)
172:           #define	BASEM	SIXTEEN
173:           #define	MULTRAD	1
174:           #endif
175:           #if	defined(SIXTEEN) && defined(EIGHT) && !defined(BASEM)
176:           #define	BASEM	(SIXTEEN|EIGHT)
177:           #define	MULTRAD	1
178:           #endif
179:           
180:           #endif
181:           
182:            // float code needs these flags
183:           #if	defined(EFMT) || defined(GFMT) || defined(FFMT)
184:           #ifndef	__FLOAT
185:           #define	__FLOAT	1
186:           #endif
187:           #define	FLOATFORMAT	0x700
188:           #ifdef	PRECISION
189:           #define	DEFPREC	0x1000
190:           #endif
191:           #endif
192:           
193:           #ifdef	__FLOAT
194:           //#ifndef	MANSIGN
195:           //#define	MANSIGN	0x02
196:           //#endif
197:           //#ifndef	SPCSIGN
198:           //#define	SPCSIGN	0x01
199:           //#endif
200:           #ifndef	NEGSIGN
201:           #define	NEGSIGN	0x03
202:           #endif
203:           //#ifndef	WIDTH
204:           //#define	WIDTH	1
205:           //#endif
206:           #endif
207:           
208:           #ifdef	SPCSIGN
209:           #define	putsign()	pputc(flag & SPCSIGN ? '-' : '+')
210:           #else
211:           #define	putsign()	pputc('-')
212:           #endif	// SPCSIGN
213:           
214:           // were there ANY % formats defined?
215:           #if	defined(FLOATFORMAT) || defined(TEN) || defined(EIGHT) || defined(SIXTEEN) || \
216:           	defined(CHAR) || defined(POINTER) || defined(STRING) || defined(UNSIGN) || defined(PERCPERC)
217:           #define	ANYFORMAT
218:           #else
219:           #undef	ANYFORMAT
220:           #endif
221:           
222:           #ifdef	CHAR
223:           #ifndef	PERCPERC
224:           #define	PERCPERC
225:           #endif
226:           #endif
227:           
228:           #if	!defined(PRINTF) && !defined(VPRINTF) && !defined(SPRINTF) && !defined(VSPRINTF)
229:           #error	Must define at least one of PRINTF SPRINTF or VSPRINTF
230:           #endif
231:           
232:           #if	i8086 && SMALL_DATA
233:           #define	CONST	far
234:           #else
235:           #define	CONST	const
236:           #endif
237:           
238:            /* we don't need plus signs, use minus signs only if we have floats or signed ints */
239:           
240:           #if	!defined(NEGSIGN) && defined(TEN)
241:           #define	NEGSIGN	0x03
242:           #endif
243:           
244:           #ifndef	RETVALUE
245:           #define	INCR_CNT	/*nix */
246:           #else
247:           #define	INCR_CNT	,(++ccnt)
248:           #endif
249:           
250:           #if	defined(EFMT) || defined(GFMT) || defined(FFMT) || defined(ALTERN) || defined(DEFPREC) || defined(POINTER)
251:           #define	FLAG_SIZE	unsigned short
252:           #else
253:           #define	FLAG_SIZE	unsigned char
254:           #endif
255:           
256:           
257:           #if	(sizeof(long) == sizeof(int) || defined(__FLOAT)) && !defined(__LONG)
258:           #define	__LONG	1
259:           #endif
260:           
261:           #if	sizeof(double) == sizeof(long) && DBL_MAX_EXP == 128
262:           #undef	frexp
263:           #define	frexp(val, ptr) (void)(*(ptr) = (unsigned char)((*(unsigned long *)&val >> 23) & 255) - 126)
264:           #elif	defined(_PSOC_)
265:           #undef	frexp
266:           #define	frexp(val, ptr) (void)(*(ptr) = ((unsigned char)(*(unsigned short long *)&val >> 15)) - 126)
267:           #elif	sizeof(double) == 3 && DBL_MAX_EXP == 128
268:           #undef	frexp
269:           #define	frexp(val, ptr) (void)(*(ptr) = ((*(unsigned long *)&val >> 15) & 255) - 126)
270:           #endif
271:           
272:           #if	defined(__FLOAT) && sizeof(double) == 8
273:           #define	DOUBLE	1
274:           
275:           extern double	_dto64i(double);
276:           extern double	_64itod(double);
277:           extern double	_div64(double, double);
278:           extern double	_divto64i(double, double);
279:           extern unsigned	_div64ir(double, double);
280:           extern unsigned	_mod64i10(double);
281:           
282:           #else
283:           #define	DOUBLE	0
284:           #endif
285:           
286:           #ifdef	__LONG
287:           #define	value	long
288:           #define	NDIG	12		/* max number of digits to be printed */
289:           #else
290:           #define	value	int
291:           #define	NDIG	6		/* max number of digits to be printed */
292:           #endif
293:           
294:           #if	DOUBLE
295:           union {
296:           	unsigned long	ul[40];
297:           	double		db[20];
298:           }	_fdp =
299:           {
300:           #if	!defined(BIG_ENDIAN) && !defined(LITTLE_ENDIAN)
301:           #error Neither BIG_ENDIAN or LITTLE_ENDIAN has been set
302:           #endif
303:           #if	BIG_ENDIAN
304:           	0x00000000,0x00000001,
305:           	0x00000000,0x0000000A,
306:           	0x00000000,0x00000064,
307:           	0x00000000,0x000003E8,
308:           	0x00000000,0x00002710,
309:           	0x00000000,0x000186A0,
310:           	0x00000000,0x000F4240,
311:           	0x00000000,0x00989680,
312:           	0x00000000,0x05F5E100,
313:           	0x00000000,0x3B9ACA00,
314:           	0x00000002,0x540BE400,
315:           	0x00000017,0x4876E800,
316:           	0x000000E8,0xD4A51000,
317:           	0x00000918,0x4E72A000,
318:           	0x00005AF3,0x107A4000,
319:           	0x00038D7E,0xA4C68000,
320:           	0x002386F2,0x6FC10000,
321:           	0x01634578,0x5D8A0000,
322:           	0x0DE0B6B3,0xA7640000,
323:           	0x8AC72304,0x89E80000,
324:           #else
325:           	0x00000001,0x00000000,
326:           	0x0000000A,0x00000000,
327:           	0x00000064,0x00000000,
328:           	0x000003E8,0x00000000,
329:           	0x00002710,0x00000000,
330:           	0x000186A0,0x00000000,
331:           	0x000F4240,0x00000000,
332:           	0x00989680,0x00000000,
333:           	0x05F5E100,0x00000000,
334:           	0x3B9ACA00,0x00000000,
335:           	0x540BE400,0x00000002,
336:           	0x4876E800,0x00000017,
337:           	0xD4A51000,0x000000E8,
338:           	0x4E72A000,0x00000918,
339:           	0x107A4000,0x00005AF3,
340:           	0xA4C68000,0x00038D7E,
341:           	0x6FC10000,0x002386F2,
342:           	0x5D8A0000,0x01634578,
343:           	0xA7640000,0x0DE0B6B3,
344:           	0x89E80000,0x8AC72304,
345:           #endif
346:           };
347:           
348:           #define	fdpowers	_fdp.db
349:           
350:           #else
351:           #define	fdpowers	dpowers
352:           #endif
353:           #if defined(TEN) || defined(__FLOAT) || defined (UNSIGN)
354:           const static unsigned value	dpowers[] =	{1, 10, 100, 1000, 10000,
355:           #ifdef	__LONG
356:           						 100000, 1000000, 10000000, 100000000,
357:           						 1000000000
358:           #endif
359:           							 };
360:           #endif
361:           #ifdef	SIXTEEN
362:           const static unsigned value	hexpowers[] =	{1, 0x10, 0x100, 0x1000,
363:           #if	__LONG
364:           						 0x10000, 0x100000, 0x1000000, 0x10000000
365:           #endif
366:           							};
367:           #endif
368:           #ifdef	EIGHT
369:           const static unsigned value	octpowers[] =	{1, 010, 0100, 01000, 010000, 0100000,
370:           #ifdef	__LONG
371:           						01000000,
372:           						 010000000, 0100000000, 01000000000, 010000000000,
373:           						 0100000000000
374:           #endif
375:           							};
376:           #endif
377:           
378:           #ifdef	__FLOAT
379:           
380:           #define	NDDIG	(sizeof fdpowers/sizeof fdpowers[0])
381:           
382:           #if	DBL_MAX_10_EXP > 120
383:           #define	expon	int
384:           #else
385:           #define	expon	signed char
386:           #endif
387:           
388:           extern const double	_powers_[], _npowers_[];
389:           #ifdef	z80
390:           #define	_div_to_l_(a, b)	((unsigned long)((a)/(b)))
391:           #else
392:           extern unsigned long	_div_to_l_(double, double);
393:           #ifdef	_OMNI_CODE_
394:           extern unsigned long	_tdiv_to_l_(float, float);
395:           #ifdef	_HTKC_
396:           #pragma callname _div_to_l_ double
397:           #pragma callname _tdiv_to_l_ float
398:           #endif
399:           #define	div_to_l_(a,b)	((sizeof(double)== 3) ? _tdiv_to_l_(a,b) : _div_to_l_(a,b))
400:           #else
401:           #define	div_to_l_	_div_to_l_
402:           #endif
403:           #endif
404:           
405:           /* this routine returns a value to round to the number of decimal
406:           	places specified */
407:           #if __FLOAT
408:           static double
409:           fround(unsigned char prec)
410:           {
411:           	/* prec is guaranteed to be less than NDIG */
412:           
413:           	if(prec>=110)
414:           		return 0.5 * _npowers_[prec/100+18] * _npowers_[(prec%100)/10+9] * _npowers_[prec%10];
415:           	else if(prec > 10)
416:           		return 0.5 * _npowers_[prec/10+9] * _npowers_[prec%10];
417:           	return 0.5 * _npowers_[prec];
418:           }
419:           #endif
420:           
421:           /* this routine returns a scaling factor equal to 1 to the decimal
422:              power supplied */
423:           
424:           static double
425:           scale(expon scl)
426:           {
427:           
428:           	if(scl < 0) {
429:           		scl = -scl;
430:           		if(scl>=110)
431:           			return _npowers_[scl/100+18] * _npowers_[(scl%100)/10+9] * _npowers_[scl%10];
432:           		else if(scl > 10)
433:           			return _npowers_[scl/10+9] * _npowers_[scl%10];
434:           		return _npowers_[scl];
435:           	}
436:           	if(scl>=110)
437:           		return _powers_[scl/100+18] * _powers_[(scl%100)/10+9] * _powers_[scl%10];
438:           	else if(scl > 10)
439:           		return _powers_[scl/10+9] * _powers_[scl%10];
440:           	return _powers_[scl];
441:           }
442:           
443:           
444:           #endif	/* __FLOAT */
445:           
446:           
447:           
448:           #ifdef	_HOSTED
449:           #define	pputc(c)	(putc(c, fp) != EOF && ++ccnt)
450:           int
451:           vfprintf(FILE * fp, register const  char * f, register va_list ap)
452:           {
453:           	char		cbuf[2];
454:           #else	/* _HOSTED */
455:           int
456:           #if	defined(VPRINTF) || (defined(PRINTF) && (defined(SPRINTF) || defined(VSPRINTF)))
457:           #define	pputc(c)	if(pb->func) (pb->func(c))INCR_CNT; else ((*pb->ptr++ = c)INCR_CNT)
458:           _doprnt(struct __prbuf * pb, register const  char * f, register va_list ap)
459:           {
460:           #endif
461:           
462:           #if	defined(PRINTF) && !(defined(SPRINTF) || defined(VSPRINTF))
463:           #define	pputc(c)	(putch(c) INCR_CNT)
464:           printf(const char * f, ...)
465:           {
466:           	va_list	ap;
467:           #define	NEED_START
468:           #endif
469:           
470:           #if	!defined(PRINTF) && defined(VSPRINTF)
471:           
472:           #ifdef	SPRINTF
473:           sprintf(char * sp, const char * f, ...)
474:           {
475:           	va_list	ap;
476:           
477:           	va_start(ap, f);
478:           	vsprintf(sp, f, ap);
479:           	va_end(ap);
480:           }
481:           int
482:           #endif	// SPRINTF
483:           
484:           #define	pputc(c)	((*sp++ = (c))INCR_CNT)
485:           vsprintf(char * sp, register const  char * f, register va_list ap)
486:           {
487:           #define NEED_START
488:           #endif	// VSPRINTF
489:           
490:           #if	!defined(PRINTF) && defined(SPRINTF) && !defined(VSPRINTF)
491:           #define	pputc(c)	((*sp++ = (c))INCR_CNT)
492:           sprintf(char * sp, const  char * f, ...)
0A2B  00C4     MOVWF sp
493:           {
494:           	va_list	ap;
495:           #define	NEED_START
496:           #endif
497:           #endif	// HOSTED
498:           
499:           	signed char		c;
500:           #if	defined(WIDTH) || defined(__FLOAT)
501:           	int		width;
502:           #endif
503:           #ifdef	__LONG
504:           	int		prec;
505:           #else
506:           	signed char	prec;
507:           #endif
508:           	FLAG_SIZE	flag;
509:           #ifdef	RETVALUE
510:           	int		ccnt = 0;
511:           #else
512:           #define	ccnt	0
513:           #endif
514:           #ifdef	__FLOAT
515:           	char	d;
516:           	double	fval, integ;
517:           	int		exp;
518:           	double		ival;
519:           	union {
520:           		unsigned value	_val;
521:           		struct {
522:           		    CONST char *	_cp;
523:           		    unsigned	_len;
524:           		}		_str;
525:           	}		_val;
526:           #else	// __FLOAT
527:           	union {
528:           		unsigned value	_val;
529:           		struct {
530:           		    CONST char *	_cp;
531:           		    unsigned	_len;
532:           		}		_str;
533:           	}		_val;
534:           #endif	// __FLOAT
535:           
536:           #define	val	_val._val
537:           #define	cp	_val._str._cp
538:           #define	len	_val._str._len
539:           
540:           	
541:           #ifdef	NEED_START
542:           	va_start(ap, f);
0A2C  3031     MOVLW 0x31
0A2D  00BB     MOVWF ap
543:           #endif
544:           
545:           	while(c = *f++) {
0A2E  0830     MOVF day, W
0A2F  00B8     MOVWF 0x38
0A30  082F     MOVF sec, W
0A31  00B7     MOVWF f2
0A32  0AAF     INCF sec, F
0A33  1903     BTFSC STATUS, 0x2
0A34  0AB0     INCF day, F
0A35  0838     MOVF 0x38, W
0A36  00FF     MOVWF 0x7F
0A37  0837     MOVF f2, W
0A38  0084     MOVWF FSR
0A39  160A     BSF PCLATH, 0x4
0A3A  158A     BSF PCLATH, 0x3
0A3B  2000     CALL 0x0
0A3C  120A     BCF PCLATH, 0x4
0A3D  158A     BSF PCLATH, 0x3
0A3E  00BD     MOVWF c
0A3F  08BD     MOVF c, F
0A40  1903     BTFSC STATUS, 0x2
0A41  2C08     GOTO 0x408
0C07  2A2E     GOTO 0x22E
546:           #ifdef	ANYFORMAT
547:           		if(c != '%')
0A42  083D     MOVF c, W
0A43  3A25     XORLW 0x25
0A44  1903     BTFSC STATUS, 0x2
0A45  2A4D     GOTO 0x24D
548:           #endif	//ANYFORMAT
549:           		{
550:           			pputc(c);
0A46  0844     MOVF sp, W
0A47  0084     MOVWF FSR
0A48  083D     MOVF c, W
0A49  1383     BCF STATUS, 0x7
0A4A  0080     MOVWF INDF
0A4B  0AC4     INCF sp, F
551:           			continue;
0A4C  2A2E     GOTO 0x22E
552:           		}
553:           #ifdef	ANYFORMAT
554:           #ifdef	WIDTH
555:           		width = 0;
0A4D  01BE     CLRF width
0A4E  01BF     CLRF 0x3F
556:           #endif
557:           		flag = 0;
0A4F  01BC     CLRF flag
0A50  2A55     GOTO 0x255
558:           #if	defined(LEFT) || defined(SPCSIGN) || defined(MANSIGN) || defined(ALTERN) || defined(FILL)
559:           		for(;;) {
560:           			switch(*f) {
0A55  0830     MOVF day, W
0A56  00FF     MOVWF 0x7F
0A57  082F     MOVF sec, W
0A58  0084     MOVWF FSR
0A59  160A     BSF PCLATH, 0x4
0A5A  158A     BSF PCLATH, 0x3
0A5B  2000     CALL 0x0
0A5C  120A     BCF PCLATH, 0x4
0A5D  158A     BSF PCLATH, 0x3
0A5E  3A30     XORLW 0x30
0A5F  1903     BTFSC STATUS, 0x2
0A60  2A51     GOTO 0x251
0A61  2A62     GOTO 0x262
561:           #ifdef	LEFT
562:           			case '-':
563:           				flag |= LEFT;
564:           				f++;
565:           				continue;
566:           #endif
567:           
568:           #ifdef	SPCSIGN
569:           			case ' ':
570:           				flag |= SPCSIGN;
571:           				f++;
572:           				continue;
573:           #endif
574:           
575:           #ifdef	MANSIGN
576:           			case '+':
577:           				flag |= MANSIGN;
578:           				f++;
579:           				continue;
580:           #endif
581:           #ifdef	ALTERN
582:           			case '#':
583:           				flag |= ALTERN;
584:           				f++;
585:           				continue;
586:           #endif
587:           #ifdef	FILL
588:           			case '0':
589:           				flag |= FILL;
0A51  153C     BSF flag, 0x2
590:           				f++;
0A52  0AAF     INCF sec, F
0A53  1903     BTFSC STATUS, 0x2
0A54  0AB0     INCF day, F
591:           				continue;
592:           #endif
593:           			}
594:           			break;
595:           		}
596:           #endif
597:           #if	defined(MANSIGN) && defined(SPCSIGN)
598:           		if(flag & MANSIGN)
599:           			flag &= ~SPCSIGN;
600:           #endif
601:           #if	defined(LEFT) && defined(FILL)
602:           		if(flag & LEFT)
603:           			flag &= ~FILL;
604:           #endif
605:           #ifdef	WIDTH
606:           		if(isdigit((unsigned)*f)) {
0A62  0830     MOVF day, W
0A63  00FF     MOVWF 0x7F
0A64  082F     MOVF sec, W
0A65  0084     MOVWF FSR
0A66  160A     BSF PCLATH, 0x4
0A67  158A     BSF PCLATH, 0x3
0A68  2000     CALL 0x0
0A69  120A     BCF PCLATH, 0x4
0A6A  158A     BSF PCLATH, 0x3
0A6B  240D     CALL 0x40D
0A6C  120A     BCF PCLATH, 0x4
0A6D  158A     BSF PCLATH, 0x3
0A6E  1C03     BTFSS STATUS, 0x0
0A6F  2B0B     GOTO 0x30B
607:           			width = 0;
0A70  01BE     CLRF width
0A71  01BF     CLRF 0x3F
608:           			do {
609:           				width *= 10;
0A72  300A     MOVLW 0xA
0A73  00A3     MOVWF x
0A74  01A4     CLRF Data
0A75  083F     MOVF 0x3F, W
0A76  00A6     MOVWF x
0A77  083E     MOVF width, W
0A78  00A5     MOVWF y
0A79  2469     CALL 0x469
0A7A  0824     MOVF Data, W
0A7B  00BF     MOVWF 0x3F
0A7C  0823     MOVF x, W
0A7D  00BE     MOVWF width
610:           			   	width += *f++ - '0';
0A7E  0830     MOVF day, W
0A7F  00FF     MOVWF 0x7F
0A80  082F     MOVF sec, W
0A81  0084     MOVWF FSR
0A82  160A     BSF PCLATH, 0x4
0A83  158A     BSF PCLATH, 0x3
0A84  2000     CALL 0x0
0A85  120A     BCF PCLATH, 0x4
0A86  158A     BSF PCLATH, 0x3
0A87  3ED0     ADDLW 0xD0
0A88  00B7     MOVWF f2
0A89  30FF     MOVLW 0xFF
0A8A  1803     BTFSC STATUS, 0x0
0A8B  3000     MOVLW 0x0
0A8C  00B8     MOVWF 0x38
0A8D  0837     MOVF f2, W
0A8E  07BE     ADDWF width, F
0A8F  1803     BTFSC STATUS, 0x0
0A90  0ABF     INCF 0x3F, F
0A91  0838     MOVF 0x38, W
0A92  07BF     ADDWF 0x3F, F
0A93  0AAF     INCF sec, F
0A94  1903     BTFSC STATUS, 0x2
0A95  0AB0     INCF day, F
611:           			} while(isdigit((unsigned)*f));
0A96  0830     MOVF day, W
0A97  00FF     MOVWF 0x7F
0A98  082F     MOVF sec, W
0A99  0084     MOVWF FSR
0A9A  160A     BSF PCLATH, 0x4
0A9B  158A     BSF PCLATH, 0x3
0A9C  2000     CALL 0x0
0A9D  120A     BCF PCLATH, 0x4
0A9E  158A     BSF PCLATH, 0x3
0A9F  240D     CALL 0x40D
0AA0  120A     BCF PCLATH, 0x4
0AA1  158A     BSF PCLATH, 0x3
0AA2  1C03     BTFSS STATUS, 0x0
0AA3  2B0B     GOTO 0x30B
0AA4  2A72     GOTO 0x272
612:           #ifdef	STAR
613:           		} else if(*f == '*') {
614:           			width = va_arg(ap, int);
615:           			f++;
616:           #endif
617:           		}
618:           #endif
619:           #ifdef	PRECISION
620:           		if(*f == '.') {
621:           			flag |= PRECISION;
622:           			f++;
623:           #ifdef	STAR
624:           			if(*f == '*') {
625:           				prec = va_arg(ap, int);
626:           				f++;
627:           			} else
628:           #endif
629:           			{
630:           				prec = 0;
631:           				while(isdigit((unsigned)*f))
632:           					prec = prec*10 + *f++ - '0';
633:           			}
634:           		} else {
635:           			prec = 0;
636:           #ifdef	DEFPREC
637:           			flag |= DEFPREC;
638:           #endif	// DEFPREC
639:           		}
640:           #endif	// PRECISION
641:           #if	defined(__LONG) && defined(LONG)
642:           loop:
643:           #endif
644:           		switch(c = *f++) {
0B0B  0830     MOVF day, W
0B0C  00B8     MOVWF 0x38
0B0D  082F     MOVF sec, W
0B0E  00B7     MOVWF f2
0B0F  0AAF     INCF sec, F
0B10  1903     BTFSC STATUS, 0x2
0B11  0AB0     INCF day, F
0B12  0838     MOVF 0x38, W
0B13  00FF     MOVWF 0x7F
0B14  0837     MOVF f2, W
0B15  0084     MOVWF FSR
0B16  160A     BSF PCLATH, 0x4
0B17  158A     BSF PCLATH, 0x3
0B18  2000     CALL 0x0
0B19  120A     BCF PCLATH, 0x4
0B1A  158A     BSF PCLATH, 0x3
0B1B  00BD     MOVWF c
0B1C  3A00     XORLW 0x0
0B1D  1903     BTFSC STATUS, 0x2
0B1E  2C08     GOTO 0x408
0B1F  3A64     XORLW 0x64
0B20  1903     BTFSC STATUS, 0x2
0B21  2B2C     GOTO 0x32C
0B22  3A0D     XORLW 0xD
0B23  1903     BTFSC STATUS, 0x2
0B24  2B2C     GOTO 0x32C
0B25  3A1A     XORLW 0x1A
0B26  1903     BTFSC STATUS, 0x2
0B27  2AA5     GOTO 0x2A5
0B28  3A06     XORLW 0x6
0B29  1903     BTFSC STATUS, 0x2
0B2A  2B09     GOTO 0x309
0B2B  2A2E     GOTO 0x22E
645:           
646:           		case 0:
647:           			goto alldone;
648:           
649:           #ifdef	LONG
650:           		case 'l':
651:           #ifdef	__LONG
652:           			flag |= LONG;
653:           			goto loop;
654:           #else
655:           			cp = "(non-long printf)";
656:           			goto strings;
657:           #endif
658:           #endif
659:           
660:           #ifdef	FLOATFORMAT
661:           #ifndef	__FLOAT
662:           		case 'E':
663:           		case 'f':
664:           		case 'e':
665:           		case 'G':
666:           		case 'g':
667:           			cp = "(non-float printf)";
668:           			goto strings;
669:           #else
670:           #ifdef	FFMT
671:           		case 'f':
672:           			flag |= FFMT;
673:           			break;
674:           #endif
675:           
676:           #ifdef	EFMT
677:           #ifdef	UPCASE
678:           		case 'E':
679:           			flag |= UPCASE;
680:           #endif
681:           		case 'e':
682:           			flag |= EFMT;
683:           			break;
684:           #endif
685:           
686:           #ifdef	GFMT
687:           #ifdef	UPCASE
688:           		case 'G':
689:           			flag |= UPCASE;
690:           #endif
691:           		case 'g':
692:           			flag |= GFMT;
693:           			break;
694:           #endif	// GFMT
695:           #endif
696:           #endif	// FLOATFORMAT
697:           #ifdef	EIGHT
698:           		case 'o':
699:           #ifdef	MULTRAD
700:           			flag |= EIGHT;
701:           #endif
702:           			break;
703:           #endif
704:           
705:           #ifdef	TEN
706:           		case 'd':
707:           		case 'i':
708:           			break;
709:           #endif
710:           
711:           #ifdef	POINTER
712:           		case 'p':
713:           #if	i8086 && LARGE_DATA
714:           			flag |= LONG;
715:           #elif	_PIC18 && LARGE_DATA
716:           			flag |= POINTER;
717:           #endif
718:           #endif	// POINTER
719:           #ifdef	SIXTEEN
720:           #ifdef	HEXUPCASE
721:           		case 'X':
722:           #ifdef	UPCASE
723:           			flag |= UPCASE;
724:           #endif
725:           #endif
726:           #if	defined(HEXLOWCASE) || !defined(UPCASE)
727:           		case 'x':
728:           #endif
729:           #ifdef	MULTRAD
730:           			flag |= SIXTEEN;
731:           #endif
732:           			break;
733:           #endif	// SIXTEEN
734:           
735:           #if	defined(STRING) || defined(PERCPERC)
736:           #ifdef	STRING
737:           		case 's':
738:           #if	i8086 && SMALL_DATA
739:           			if(flag & LONG)
740:           				cp = va_arg(ap, far char *);
741:           			else
742:           #endif
743:           				cp = va_arg(ap, const char *);
0AA5  083B     MOVF ap, W
0AA6  0084     MOVWF FSR
0AA7  1383     BCF STATUS, 0x7
0AA8  0800     MOVF INDF, W
0AA9  00C0     MOVWF _val
0AAA  3001     MOVLW 0x1
0AAB  00C1     MOVWF 0x41
0AAC  0ABB     INCF ap, F
744:           #endif	// STRING
745:           #if	!defined(__FLOAT) && !defined(CUSTOM_PRINTF)
746:           strings:
747:           #endif
748:           #ifdef	STRING
749:           			if(!cp)
0AAD  0440     IORWF _val, W
0AAE  1D03     BTFSS STATUS, 0x2
0AAF  2AB4     GOTO 0x2B4
750:           				cp = "(null)";
0AB0  3034     MOVLW 0x34
0AB1  00C0     MOVWF _val
0AB2  3099     MOVLW 0x99
0AB3  00C1     MOVWF 0x41
751:           #endif
752:           #if	defined(WIDTH) || defined(PRECISION)
753:           #if	defined(STRING)
754:           			len = 0;
0AB4  01C2     CLRF 0x42
0AB5  01C3     CLRF 0x43
755:           			while(cp[len])
0AB6  0842     MOVF 0x42, W
0AB7  0740     ADDWF _val, W
0AB8  0084     MOVWF FSR
0AB9  0841     MOVF 0x41, W
0ABA  1803     BTFSC STATUS, 0x0
0ABB  0A41     INCF 0x41, W
0ABC  00FF     MOVWF 0x7F
0ABD  160A     BSF PCLATH, 0x4
0ABE  158A     BSF PCLATH, 0x3
0ABF  2000     CALL 0x0
0AC0  120A     BCF PCLATH, 0x4
0AC1  158A     BSF PCLATH, 0x3
0AC2  3800     IORLW 0x0
0AC3  1903     BTFSC STATUS, 0x2
0AC4  2AC9     GOTO 0x2C9
0AC8  2AB6     GOTO 0x2B6
756:           				len++;
0AC5  0AC2     INCF 0x42, F
0AC6  1903     BTFSC STATUS, 0x2
0AC7  0AC3     INCF 0x43, F
757:           #endif
758:           #ifdef	PERCPERC
759:           dostring:
760:           #endif
761:           #ifdef	PRECISION
762:           			if(prec && prec < len)
763:           				len = prec;
764:           #endif	// PRECISION
765:           #ifdef	WIDTH
766:           			if(width > len)
0AC9  083F     MOVF 0x3F, W
0ACA  0243     SUBWF 0x43, W
0ACB  1D03     BTFSS STATUS, 0x2
0ACC  2ACF     GOTO 0x2CF
0ACD  083E     MOVF width, W
0ACE  0242     SUBWF 0x42, W
0ACF  1803     BTFSC STATUS, 0x0
0AD0  2AD8     GOTO 0x2D8
767:           				width -= len;
0AD1  0842     MOVF 0x42, W
0AD2  02BE     SUBWF width, F
0AD3  0843     MOVF 0x43, W
0AD4  1C03     BTFSS STATUS, 0x0
0AD5  03BF     DECF 0x3F, F
0AD6  02BF     SUBWF 0x3F, F
0AD7  2ADA     GOTO 0x2DA
768:           			else
769:           				width = 0;
0AD8  01BE     CLRF width
0AD9  01BF     CLRF 0x3F
770:           #ifdef	LEFT
771:           			if(!(flag & LEFT))
772:           #endif	// LEFT
773:           				while(width--)
0ADA  30FF     MOVLW 0xFF
0ADB  07BE     ADDWF width, F
0ADC  1C03     BTFSS STATUS, 0x0
0ADD  03BF     DECF 0x3F, F
0ADE  0A3E     INCF width, W
0ADF  1903     BTFSC STATUS, 0x2
0AE0  0A3F     INCF 0x3F, W
0AE1  1903     BTFSC STATUS, 0x2
0AE2  2AFD     GOTO 0x2FD
0AE9  2ADA     GOTO 0x2DA
774:           					pputc(' ');
0AE3  0844     MOVF sp, W
0AE4  0084     MOVWF FSR
0AE5  3020     MOVLW 0x20
0AE6  1383     BCF STATUS, 0x7
0AE7  0080     MOVWF INDF
0AE8  0AC4     INCF sp, F
775:           #endif	// WIDTH
776:           			while(len--)
0AFD  3001     MOVLW 0x1
0AFE  02C2     SUBWF 0x42, F
0AFF  3000     MOVLW 0x0
0B00  1C03     BTFSS STATUS, 0x0
0B01  03C3     DECF 0x43, F
0B02  02C3     SUBWF 0x43, F
0B03  0A42     INCF 0x42, W
0B04  1903     BTFSC STATUS, 0x2
0B05  0A43     INCF 0x43, W
0B06  1903     BTFSC STATUS, 0x2
0B07  2A2E     GOTO 0x22E
0B08  2AEA     GOTO 0x2EA
777:           				pputc(*cp++);
0AEA  0841     MOVF 0x41, W
0AEB  00FF     MOVWF 0x7F
0AEC  0840     MOVF _val, W
0AED  0084     MOVWF FSR
0AEE  160A     BSF PCLATH, 0x4
0AEF  158A     BSF PCLATH, 0x3
0AF0  2000     CALL 0x0
0AF1  120A     BCF PCLATH, 0x4
0AF2  158A     BSF PCLATH, 0x3
0AF3  00B7     MOVWF f2
0AF4  0844     MOVF sp, W
0AF5  0084     MOVWF FSR
0AF6  0837     MOVF f2, W
0AF7  1383     BCF STATUS, 0x7
0AF8  0080     MOVWF INDF
0AF9  0AC0     INCF _val, F
0AFA  1903     BTFSC STATUS, 0x2
0AFB  0AC1     INCF 0x41, F
0AFC  0AC4     INCF sp, F
778:           #ifdef	LEFT
779:           			if(flag & LEFT)
780:           				while(width--)
781:           					pputc(' ');
782:           #endif	// LEFT
783:           			continue;
784:           #else	// WIDTH || PRECISION
785:           #if	defined(STRING)
786:           			while(*cp)
787:           				pputc(*cp++);
788:           			continue;
789:           #endif
790:           #endif	// WIDTH || PRECISION
791:           #endif	// defined(STRING) || defined(PERCPERC)
792:           #ifdef	CHAR
793:           		case 'c':
794:           #if	_HOSTED
795:           			val = va_arg(ap, int);
796:           			c = val >> 8;
797:           			if(flag & LONG && c && (unsigned char)c != 0xFF) {
798:           				cbuf[0] = c;
799:           				cbuf[1] = val;
800:           				len = 2;
801:           			} else {
802:           				cbuf[0] = val;
803:           				len = 1;
804:           			}
805:           			cp = cbuf;
806:           			goto dostring;
807:           #else
808:           			c = va_arg(ap, int);
809:           #endif	// _HOSTED
810:           #endif	// CHAR
811:           		default:
812:           #ifdef	PERCPERC
813:           #if	defined(WIDTH) || defined(PRECISION)
814:           			cp = (char *)&c;
815:           			len = 1;
816:           			goto dostring;
817:           #else
818:           			pputc(c);
819:           			continue;
820:           #endif
821:           #else	// PERCPERC
822:           			continue;
823:           #endif
824:           
825:           #ifdef	UNSIGN
826:           		case 'u':
827:           			flag |= UNSIGN;
0B09  173C     BSF flag, 0x6
828:           			break;
0B0A  2B2C     GOTO 0x32C
829:           #endif
830:           
831:           		}
832:           #endif	// ANYFORMAT
833:           #ifdef	__FLOAT
834:           		if(flag & (FLOATFORMAT)) {
835:           #ifdef	DEFPREC
836:           			if(flag & DEFPREC)
837:           #endif
838:           				prec = 6;
839:           			fval = va_arg(ap, double);	// source the floating point value
840:           			if(fval < 0.0) {
841:           				fval = -fval;		// get the absolute value
842:           				flag |= NEGSIGN;
843:           			}
844:           			exp = 0;		/* If the number is zero, the exponent is zero. */
845:           			if( fval!=0) {		/* If the number is non-zero, find the exponent. */
846:           				frexp(fval, &exp);		/* get binary exponent */
847:           				exp--;				/* adjust 0.5 -> 1.0 */
848:           				exp *= 3;
849:           				exp /= 10;			/* estimate decimal exponent */
850:           				if(exp < 0)
851:           					exp--;
852:           				// the following line can cause "recursive call" errors because scale calls
853:           				// ftmul, and is used when evaluating an argument to ftmul
854:           				//integ = fval * scale(-exp);
855:           				integ = scale(-exp);		// replaced with this
856:           				integ *= fval;
857:           				if(integ < 1.0)
858:           					exp--;
859:           				else if(integ >= 10.0)
860:           					exp++;
861:           			}
862:           #if	defined(EFMT) || defined(GFMT)
863:           			if(exp <= 0)	// value is 0.??? (neg expnt) whole characters = 1 (allow zero)
864:           				c = 1;
865:           			else
866:           				c = exp;
867:           			if(
868:           #ifdef	EFMT
869:           					flag & EFMT
870:           #ifdef	GFMT
871:           					||
872:           #endif
873:           #endif
874:           #ifdef	GFMT
875:           					flag & GFMT && (exp < -4 || exp >= (int)prec)
876:           #endif
877:           				) {	/* use e format */
878:           #ifdef	GFMT
879:           				if(prec && flag & GFMT)
880:           					prec--;		/* g format precision includes integer digit */
881:           #endif
882:           				if((unsigned)prec > NDDIG - 2)
883:           					c = NDDIG - 2;
884:           				else
885:           					c = prec;
886:           				if( fval!=0) {	/* Normalise only if the number is non-zero. */
887:           					fval /= scale(exp-c);
888:           #if	DOUBLE
889:           					ival = _dto64i(fval);
890:           					if(fval - _64itod(ival) >= 0.5) {
891:           						fval += 0.5;
892:           						ival = _dto64i(fval);
893:           					}
894:           					if(ival >= fdpowers[c+1]) {
895:           						fval *= 1e-1;
896:           						exp++;
897:           					} else if(ival < fdpowers[c]) {
898:           						fval *= 10.0;
899:           						exp--;
900:           					}
901:           #else	
902:           					if(fval - (double)(unsigned long)fval >= 0.5)
903:           						fval += 0.5;
904:           					if((unsigned long)fval >= fdpowers[c+1]) {
905:           						fval *= 1e-1;
906:           						exp++;
907:           					} else if((unsigned long)fval < fdpowers[c]) {
908:           						fval *= 10.0;
909:           						exp--;
910:           					}
911:           #endif
912:           				}
913:           #if defined(GFMT) && defined(ALTERN)
914:           				if(flag & GFMT && !(flag & ALTERN)) {		/* g format, precision means something different */
915:           					if(prec > (int)(NDDIG))
916:           						prec = NDDIG;
917:           #if	DOUBLE
918:           					ival = _dto64i(fval);
919:           					while(ival != 0.0 && _mod64i10(ival) == 0) {
920:           						prec--;
921:           						ival = _div64(ival, fdpowers[1]);
922:           					}
923:           #else
924:           					val = (unsigned long)fval;
925:           					while(val && val % 10 == 0) {
926:           						prec--;
927:           						val /= 10;
928:           					}
929:           #endif
930:           					if(prec < c) {
931:           						fval /= scale(c-prec);
932:           						c = prec;
933:           					}
934:           
935:           				}
936:           #endif
937:           #ifdef	WIDTH
938:           				width -=  prec + 5;
939:           #ifdef	ALTERN
940:           				if(prec || flag & ALTERN)
941:           					width--;
942:           #endif
943:           				if(flag & NEGSIGN)
944:           					width--;
945:           #if	DBL_MAX_10_EXP >= 100
946:           #if	DBL_MAX_10_EXP >= 1000
947:           				if(exp >= 1000 || exp <= -1000)	/* 4 digit exponent */
948:           					width--;
949:           #endif
950:           				if(exp >= 100 || exp <= -100)	/* 3 digit exponent */
951:           					width--;
952:           #endif
953:           #endif	// WIDTH
954:           #ifdef	FILL
955:           				if(flag & FILL) {
956:           #if defined(MANSIGN) && defined(SPCSIGN)
957:           					if(flag & MANSIGN)
958:           						pputc(flag & SPCSIGN ? '-' : '+');
959:           					else if(flag & SPCSIGN)
960:           						pputc(' ');
961:           #endif
962:           					while(width > 0) {
963:           						pputc('0');
964:           						width--;
965:           					}
966:           				} else
967:           #endif	// FILL
968:           				{
969:           #ifdef	WIDTH
970:           #ifdef	LEFT
971:           					if(!(flag & LEFT))
972:           #endif
973:           						while(width > 0) {
974:           							pputc(' ');
975:           							width--;
976:           						}
977:           #endif	// WIDTH
978:           #ifdef	MANSIGN
979:           					if(flag & MANSIGN)
980:           						putsign();
981:           #else
982:           					if(flag & NEGSIGN)
983:           						pputc('-');
984:           #endif	// MANSIGN
985:           #ifdef	SPCSIGN
986:           					else if(flag & SPCSIGN)
987:           						pputc(' ');
988:           #endif	// SPCSIGN
989:           				}
990:           #if	DOUBLE
991:           				ival = _dto64i(fval);
992:           				pputc(_div64ir(ival, fdpowers[c]) + '0');
993:           #else
994:           				val = (unsigned long)fval;
995:           				pputc(val/dpowers[c] + '0');
996:           				val %= dpowers[c];
997:           #endif
998:           #ifdef	ALTERN
999:           				if(prec || flag & ALTERN)
1000:          #else
1001:          				if(prec)
1002:          #endif
1003:          				{
1004:          					pputc('.');
1005:          					prec -= c;
1006:          					while(c--) {
1007:          #if	DOUBLE
1008:          						pputc('0' + _mod64i10(_div64(ival, fdpowers[c])));
1009:          #else
1010:          #ifdef	GFMT
1011:          						if(flag & GFMT && val == 0) {
1012:          							prec = c = 0;
1013:          							break;
1014:          						}
1015:          #endif
1016:          						pputc('0' + (val/dpowers[c]));
1017:          						val %= dpowers[c];
1018:          #endif
1019:          					}
1020:          					while(prec) {
1021:          						pputc('0');
1022:          						prec--;
1023:          					}
1024:          				}
1025:          #ifdef	UPCASE
1026:          				if(flag & UPCASE)
1027:          					pputc('E');
1028:          				else
1029:          #endif
1030:          					pputc('e');
1031:          				if(exp < 0) {
1032:          					exp = -exp;
1033:          					pputc('-');
1034:          				} else
1035:          					pputc('+');
1036:          #if	DBL_MAX_10_EXP >= 100
1037:          #if	DBL_MAX_10_EXP >= 1000
1038:          				if(exp >= 1000) {
1039:          					pputc(exp / 1000 + '0');
1040:          					exp %= 1000;
1041:          				}
1042:          #endif
1043:          				if(exp >= 100) {
1044:          					pputc(exp / 100 + '0');
1045:          					exp %= 100;
1046:          				}
1047:          #endif
1048:          				pputc(exp / 10 + '0');
1049:          				pputc(exp % 10 + '0');
1050:          #ifdef	LEFT
1051:          				if((flag & LEFT) && width > 0)
1052:          					do
1053:          						pputc(' ');
1054:          					while(--width);
1055:          #endif	// LEFT
1056:          					continue;
1057:          				}
1058:          #endif	// EFMT || GFMT
1059:          				/* here for f format */
1060:          #if	DOUBLE
1061:          #ifdef	GFMT
1062:          				if(flag & GFMT) {
1063:          					if(exp < 0)	// fractional part only
1064:          						prec -= exp-1;
1065:          					ival = _dto64i(fval);
1066:          					for(c = 1 ; c != NDDIG ; c++)
1067:          						if(ival < fdpowers[c])
1068:          							break;
1069:          					if(prec > NDDIG)
1070:          						prec = NDDIG;
1071:          					prec -= c;
1072:          					ival = _dto64i((fval - _64itod(ival)) * scale(prec)+0.5);
1073:          					// see how many zeros are at the end of the fractional part
1074:          					while(prec && _mod64i10(ival) == 0) {
1075:          						prec--;
1076:          						ival = _div64(ival, fdpowers[1]);
1077:          					}
1078:          				}
1079:          #endif	// GFMT
1080:          				if(prec <= (int)NDDIG)
1081:          					fval += fround(prec);
1082:          				if(exp > (int)(NDDIG)-2) {
1083:          					exp -= NDDIG-2;
1084:          					ival = _divto64i(fval, scale(exp));
1085:          					fval = 0.0;
1086:          				} else {
1087:          					ival = _dto64i(fval);
1088:          					fval -= _64itod(ival);
1089:          					exp = 0;
1090:          				}
1091:          				for(c = 1 ; c != NDDIG ; c++)
1092:          					if(ival < fdpowers[c])
1093:          						break;
1094:          #else	// DOUBLE
1095:          #ifdef	GFMT
1096:          				if(flag & GFMT) {
1097:          					if(exp < 0)	// fractional part only
1098:          						prec -= (exp+1);
1099:          					// count number of digits in the integral part (this is for %g)
1100:          					val = (unsigned long)fval;
1101:          					for(c = 0 ; c != NDDIG ; c++)
1102:          						if(val < fdpowers[c])
1103:          							break;
1104:          					prec -= c;		// reduce precision by this
1105:          					if(prec <= NDIG)
1106:          						fval += fround(prec);
1107:          					// get fractional part and count trailing zeros - reduce
1108:          					// prec as required
1109:          					{
1110:          						double	temp;
1111:          						temp = scale(prec);
1112:          						temp *= fval - (double)val;
1113:          						val = (unsigned long)temp;
1114:          					}
1115:          					while(prec && val % 10 == 0) {
1116:          						val /= 10;
1117:          						prec--;
1118:          					}
1119:          				} else
1120:          #endif	//GFMT
1121:          					if(prec <= NDIG)
1122:          						fval += fround(prec);
1123:          
1124:          				/* ~4.2e9 is the largest float that will fit into a 32-bit long */
1125:          				if((exp > 9)||(fval != 0 && (unsigned long)fval == 0 && exp > 1)) {
1126:          					// fval is > 4.2e9
1127:          					// new exp must be such that div_to_l() is < 4.2e9
1128:          					// OLD CODE:	if(fval / scale(exp) < 4.294967296){
1129:          					if(integ < 4.294967296){
1130:          						exp -= NDDIG-1;
1131:          					}else{
1132:          						exp -= NDDIG-2;
1133:          					}
1134:          					integ = scale(exp);
1135:          					val = div_to_l_(fval, integ);
1136:           					//val = _div_to_l_(integ, fval);
1137:          					//val = (long)(integ * fval);	// fit as much signifigant data into the long as it can hold
1138:          					fval = 0.0;	// There will be no fractional component
1139:          				} else {
1140:          					val = (unsigned long)fval;
1141:          					fval -= (double)val;
1142:          					exp = 0;
1143:          				}
1144:          				// count digits in integral part
1145:          				for(c = 1 ; c != NDDIG ; c++)
1146:          					if(val < fdpowers[c])
1147:          						break;
1148:          #endif	// DOUBLE
1149:          #ifdef	WIDTH
1150:          				// at this point, c contains the number of whole-number digits to print
1151:          				width -= prec + c + exp;
1152:          				if(
1153:          #ifdef	ALTERN
1154:          						flag & ALTERN ||
1155:          #endif
1156:          						prec)
1157:          					width--;		// allow for decimal point
1158:          				if(flag & NEGSIGN)
1159:          					width--;
1160:          #endif	// WIDTH
1161:          #ifdef	FILL
1162:          				if(flag & FILL) {
1163:          #ifdef	MANSIGN
1164:          					if(flag & MANSIGN)
1165:          #else
1166:          					if(flag & NEGSIGN)
1167:          #endif	// MANSIGN
1168:          						putsign();
1169:          #if defined(MANSIGN) && defined(SPCSIGN)
1170:          					else
1171:          #endif
1172:          #ifdef	SPCSIGN
1173:          					if(flag & SPCSIGN)
1174:          						pputc(' ');
1175:          #endif	// SPCSIGN
1176:          #ifdef	WIDTH
1177:          					while(width > 0) {
1178:          						pputc('0');
1179:          						width--;
1180:          					}
1181:          #endif	// WIDTH
1182:          				} else
1183:          #endif	// FILL
1184:          				{
1185:          #ifdef	LEFT
1186:          					if(!(flag & LEFT))
1187:          #endif
1188:          #ifdef	WIDTH
1189:          					while(width > 0) {
1190:          						pputc(' ');
1191:          						width--;
1192:          					}
1193:          #endif	// WIDTH
1194:          #ifdef	MANSIGN
1195:          				if(flag & MANSIGN)
1196:          #else
1197:          				if(flag & NEGSIGN)
1198:          #endif	// MANSIGN
1199:          					putsign();
1200:          #ifdef	SPCSIGN
1201:          				else if(flag & SPCSIGN)
1202:          					pputc(' ');
1203:          #endif	// SPCSIGN
1204:          			}
1205:          			while(c--) {
1206:          #if	DOUBLE
1207:          				pputc('0' + _mod64i10(_div64(ival, fdpowers[c])));
1208:          #else
1209:          				{
1210:          					unsigned long vd = val/dpowers[c];
1211:          					vd %= 10;
1212:          					pputc('0' + vd);
1213:          				}
1214:          #endif	// DOUBLE
1215:          			}
1216:          			while(exp > 0) {
1217:          				pputc('0');
1218:          				exp--;
1219:          			}
1220:          			if(prec > (int)(NDDIG-2))
1221:          				c = NDDIG-2;
1222:          			else
1223:          				c = prec;
1224:          			prec -= c;
1225:          #ifdef	ALTERN
1226:          			if(c || flag & ALTERN)
1227:          #else
1228:          			if(c)
1229:          #endif
1230:          				pputc('.');
1231:          #if	DOUBLE
1232:          			ival = _dto64i(fval * scale(c));
1233:          			while(c)
1234:          				pputc('0' + _mod64i10(_div64(ival, fdpowers[--c])));
1235:          #else	// DOUBLE
1236:          			val = (long)(fval * scale(c));
1237:          			while(c--) {
1238:          				unsigned long vd = val/dpowers[c];
1239:          				vd %= 10;
1240:          				pputc('0' + vd);
1241:          				val %= dpowers[c];
1242:          			}
1243:          #endif	// DOUBLE
1244:          			while(prec) {
1245:          				pputc('0');
1246:          				prec--;
1247:          			}
1248:          #ifdef	LEFT
1249:          			if((flag & LEFT) && width > 0)
1250:          				do
1251:          					pputc(' ');
1252:          				while(--width);
1253:          #endif
1254:          			continue;
1255:          		}
1256:          #endif	/* __FLOAT */
1257:          
1258:          #if	defined(TEN)
1259:          #ifdef	BASEM
1260:          		if((flag & BASEM) == TEN)
0B2C  1B3C     BTFSC flag, 0x6
0B2D  2B42     GOTO 0x342
1261:          #endif	//BASEM
1262:          		{
1263:          #ifdef	LONG
1264:          			if(flag & LONG)
1265:          				val = va_arg(ap, long);
1266:          			else
1267:          #endif	// LONG
1268:          				val = (value)va_arg(ap, int);
0B2E  083B     MOVF ap, W
0B2F  0084     MOVWF FSR
0B30  1383     BCF STATUS, 0x7
0B31  0800     MOVF INDF, W
0B32  00C0     MOVWF _val
0B33  0A84     INCF FSR, F
0B34  0800     MOVF INDF, W
0B35  00C1     MOVWF 0x41
0B36  0ABB     INCF ap, F
0B37  0ABB     INCF ap, F
1269:          #ifdef	NEGSIGN
1270:          			if((value)val < 0) {
0B38  1FC1     BTFSS 0x41, 0x7
0B39  2B4C     GOTO 0x34C
1271:          				flag |= NEGSIGN;
0B3A  3003     MOVLW 0x3
0B3B  04BC     IORWF flag, F
1272:          				val = -val;
0B3C  09C0     COMF _val, F
0B3D  09C1     COMF 0x41, F
0B3E  0AC0     INCF _val, F
0B3F  1903     BTFSC STATUS, 0x2
0B40  0AC1     INCF 0x41, F
0B41  2B4C     GOTO 0x34C
1273:          			}
1274:          #endif
1275:          		}
1276:          #ifdef	BASEM
1277:          		else
1278:          #endif
1279:          #endif	// TEN
1280:          
1281:          #if	defined(EIGHT) || defined(SIXTEEN) || defined(UNSIGN)
1282:          		{
1283:          #ifdef	__LONG
1284:          #if	defined(_PIC18) && defined(LARGE_DATA) && defined(POINTER)
1285:          			if(flag & POINTER)
1286:          				val = (unsigned long)va_arg(ap, far char *);
1287:          			else
1288:          #endif
1289:          #ifdef	LONG
1290:          				if(flag & LONG)
1291:          				val = va_arg(ap, unsigned long);
1292:          			else
1293:          #endif	// LONG
1294:          #endif	// __LONG
1295:          				val = va_arg(ap, unsigned);
0B42  083B     MOVF ap, W
0B43  0084     MOVWF FSR
0B44  1383     BCF STATUS, 0x7
0B45  0800     MOVF INDF, W
0B46  00C0     MOVWF _val
0B47  0A84     INCF FSR, F
0B48  0800     MOVF INDF, W
0B49  00C1     MOVWF 0x41
0B4A  0ABB     INCF ap, F
0B4B  0ABB     INCF ap, F
1296:          		}
1297:          #endif	// EIGHT or SIXTEEN or UNSIGN
1298:          #ifdef	PRECISION
1299:          		if(prec == 0 && val == 0)
1300:          			prec++;
1301:          #endif
1302:          #ifdef	MULTRAD
1303:          		switch((unsigned char)(flag & BASEM)) {
1304:          #endif
1305:          #if	defined(TEN) || defined(UNSIGN)
1306:          #ifdef	MULTRAD
1307:          #ifdef	TEN
1308:          		case TEN:
1309:          #endif
1310:          #ifdef	UNSIGN
1311:          		case UNSIGN:
1312:          #endif
1313:          #endif	// MULTRAD
1314:          			for(c = 1 ; c != sizeof dpowers/sizeof dpowers[0] ; c++)
0B4C  01BD     CLRF c
0B4D  0ABD     INCF c, F
0B69  0ABD     INCF c, F
0B6A  083D     MOVF c, W
0B6B  3A05     XORLW 0x5
0B6C  1D03     BTFSS STATUS, 0x2
0B6D  2B4E     GOTO 0x34E
1315:          				if(val < dpowers[c])
0B4E  1003     BCF STATUS, 0x0
0B4F  0D3D     RLF c, W
0B50  3E12     ADDLW 0x12
0B51  0084     MOVWF FSR
0B52  3098     MOVLW 0x98
0B53  1803     BTFSC STATUS, 0x0
0B54  3E01     ADDLW 0x1
0B55  00FF     MOVWF 0x7F
0B56  160A     BSF PCLATH, 0x4
0B57  158A     BSF PCLATH, 0x3
0B58  2000     CALL 0x0
0B59  120A     BCF PCLATH, 0x4
0B5A  158A     BSF PCLATH, 0x3
0B5B  00B7     MOVWF f2
0B5C  160A     BSF PCLATH, 0x4
0B5D  158A     BSF PCLATH, 0x3
0B5E  2000     CALL 0x0
0B5F  120A     BCF PCLATH, 0x4
0B60  158A     BSF PCLATH, 0x3
0B61  00B8     MOVWF 0x38
0B62  0241     SUBWF 0x41, W
0B63  1D03     BTFSS STATUS, 0x2
0B64  2B67     GOTO 0x367
0B65  0837     MOVF f2, W
0B66  0240     SUBWF _val, W
0B67  1C03     BTFSS STATUS, 0x0
0B68  2B6E     GOTO 0x36E
1316:          					break;
1317:          #ifdef	MULTRAD
1318:          			break;
1319:          #endif
1320:          #endif	// TEN || UNSIGN
1321:          #ifdef	SIXTEEN
1322:          #ifdef	MULTRAD
1323:          		case SIXTEEN:
1324:          #endif	// MULTRAD
1325:          			for(c = 1 ; c != sizeof hexpowers/sizeof hexpowers[0] ; c++)
1326:          				if(val < hexpowers[c])
1327:          					break;
1328:          #ifdef	MULTRAD
1329:          			break;
1330:          #endif
1331:          #endif
1332:          
1333:          #ifdef	EIGHT
1334:          #ifdef	MULTRAD
1335:          		case EIGHT:
1336:          #endif	// MULTRAD
1337:          			for(c = 1 ; c != sizeof octpowers/sizeof octpowers[0] ; c++)
1338:          				if(val < octpowers[c])
1339:          					break;
1340:          #ifdef	MULTRAD
1341:          			break;
1342:          #endif
1343:          #endif
1344:          #ifdef	MULTRAD
1345:          		}
1346:          #endif
1347:          #ifdef	PRECISION
1348:          		if(c < prec)
1349:          			c = prec;
1350:          		else if(prec < c)
1351:          			prec = c;
1352:          #endif
1353:          #if	defined(WIDTH) && defined(NEGSIGN)
1354:          		if(width && flag & NEGSIGN)
0B6E  083F     MOVF 0x3F, W
0B6F  043E     IORWF width, W
0B70  1903     BTFSC STATUS, 0x2
0B71  2B7A     GOTO 0x37A
0B72  083C     MOVF flag, W
0B73  3903     ANDLW 0x3
0B74  1903     BTFSC STATUS, 0x2
0B75  2B7A     GOTO 0x37A
1355:          			width--;
0B76  30FF     MOVLW 0xFF
0B77  07BE     ADDWF width, F
0B78  1C03     BTFSS STATUS, 0x0
0B79  03BF     DECF 0x3F, F
1356:          #ifdef	PRECISION
1357:          		if(flag & PRECISION) {
1358:          			if(width > prec)
1359:          				width -= prec;
1360:          			else
1361:          				width = 0;
1362:          		}
1363:          #endif
1364:          #ifdef	ALTERN
1365:          #ifdef	EIGHT
1366:          		if((flag & (
1367:          #ifdef	FILL
1368:          						FILL|
1369:          #endif
1370:          							BASEM|ALTERN)) == (EIGHT|ALTERN)) {
1371:          			if(width)
1372:          				width--;
1373:          		} else
1374:          #endif	// EIGHT
1375:          #if	defined(SIXTEEN)
1376:          #ifdef	BASEM
1377:          		if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1378:          #else
1379:          		if(flag & ALTERN) {
1380:          #endif
1381:          			if(width > 2)
1382:          				width -= 2;
1383:          			else
1384:          				width = 0;
1385:          		}
1386:          #endif	// SIXTEEN
1387:          #endif	// ALTERN
1388:          #endif	// WIDTH
1389:          #ifdef	WIDTH
1390:          		if(width > c)
0B7A  083D     MOVF c, W
0B7B  00B7     MOVWF f2
0B7C  01B8     CLRF 0x38
0B7D  1BB7     BTFSC f2, 0x7
0B7E  03B8     DECF 0x38, F
0B7F  0838     MOVF 0x38, W
0B80  3A80     XORLW 0x80
0B81  00B9     MOVWF 0x39
0B82  083F     MOVF 0x3F, W
0B83  3A80     XORLW 0x80
0B84  0239     SUBWF 0x39, W
0B85  1D03     BTFSS STATUS, 0x2
0B86  2B89     GOTO 0x389
0B87  083E     MOVF width, W
0B88  0237     SUBWF f2, W
0B89  1803     BTFSC STATUS, 0x0
0B8A  2B98     GOTO 0x398
1391:          			width -= c;
0B8B  1283     BCF STATUS, 0x5
0B8C  1303     BCF STATUS, 0x6
0B8D  083D     MOVF c, W
0B8E  00B7     MOVWF f2
0B8F  01B8     CLRF 0x38
0B90  1BB7     BTFSC f2, 0x7
0B91  03B8     DECF 0x38, F
0B92  02BE     SUBWF width, F
0B93  0838     MOVF 0x38, W
0B94  1C03     BTFSS STATUS, 0x0
0B95  03BF     DECF 0x3F, F
0B96  02BF     SUBWF 0x3F, F
0B97  2B9C     GOTO 0x39C
1392:          		else
1393:          			width = 0;
0B98  1283     BCF STATUS, 0x5
0B99  1303     BCF STATUS, 0x6
0B9A  01BE     CLRF width
0B9B  01BF     CLRF 0x3F
1394:          #endif
1395:          #ifdef	FILL
1396:          		if(flag & FILL) {
0B9C  1D3C     BTFSS flag, 0x2
0B9D  2BB7     GOTO 0x3B7
1397:          #ifdef	MANSIGN
1398:          			if(flag & MANSIGN)
1399:          				putsign();
1400:          #elif defined(NEGSIGN)
1401:          			if(flag & NEGSIGN)
0B9E  083C     MOVF flag, W
0B9F  3903     ANDLW 0x3
0BA0  1903     BTFSC STATUS, 0x2
0BA1  2BA8     GOTO 0x3A8
1402:          				pputc('-');
0BA2  0844     MOVF sp, W
0BA3  0084     MOVWF FSR
0BA4  302D     MOVLW 0x2D
0BA5  1383     BCF STATUS, 0x7
0BA6  0080     MOVWF INDF
0BA7  0AC4     INCF sp, F
1403:          #endif
1404:          #if defined(MANSIGN) || defined(NEGSIGN) && defined(SPCSIGN)
1405:          			else
1406:          #endif	// MANSIGN
1407:          #ifdef	SPCSIGN
1408:          			if(flag & SPCSIGN)
1409:          				pputc(' ');
1410:          #endif
1411:          #if defined(ALTERN) && defined(SIXTEEN)
1412:          			else if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1413:          				pputc('0');
1414:          #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
1415:          				pputc(flag & UPCASE ? 'X' : 'x');
1416:          #elif defined(HEXUPCASE)
1417:          				pputc('X');
1418:          #else
1419:          				pputc('x');
1420:          #endif	// HEXUPCASE
1421:          			}
1422:          #endif	// ALTERN
1423:          #ifdef	WIDTH
1424:          			if(width)
0BA8  083F     MOVF 0x3F, W
0BA9  043E     IORWF width, W
0BAA  1903     BTFSC STATUS, 0x2
0BAB  2BD3     GOTO 0x3D3
1425:          				do
1426:          					pputc('0');
0BAC  0844     MOVF sp, W
0BAD  0084     MOVWF FSR
0BAE  3030     MOVLW 0x30
0BAF  1383     BCF STATUS, 0x7
0BB0  0080     MOVWF INDF
0BB2  0AC4     INCF sp, F
1427:          				while(--width);
0BB1  30FF     MOVLW 0xFF
0BB3  07BE     ADDWF width, F
0BB4  1C03     BTFSS STATUS, 0x0
0BB5  03BF     DECF 0x3F, F
0BB6  2BA8     GOTO 0x3A8
1428:          #endif	// WIDTH
1429:          		} else
1430:          #endif	//FILL
1431:          		{
1432:          #ifdef	WIDTH
1433:          			if(width
1434:          #ifdef	LEFT
1435:          					&& !(flag & LEFT)
1436:          #endif
1437:          					)
0BB7  083F     MOVF 0x3F, W
0BB8  043E     IORWF width, W
0BB9  1903     BTFSC STATUS, 0x2
0BBA  2BC9     GOTO 0x3C9
1438:          				do
1439:          					pputc(' ');
0BBB  0844     MOVF sp, W
0BBC  0084     MOVWF FSR
0BBD  3020     MOVLW 0x20
0BBE  1383     BCF STATUS, 0x7
0BBF  0080     MOVWF INDF
0BC1  0AC4     INCF sp, F
1440:          				while(--width);
0BC0  30FF     MOVLW 0xFF
0BC2  07BE     ADDWF width, F
0BC3  1C03     BTFSS STATUS, 0x0
0BC4  03BF     DECF 0x3F, F
0BC5  083F     MOVF 0x3F, W
0BC6  043E     IORWF width, W
0BC7  1D03     BTFSS STATUS, 0x2
0BC8  2BBB     GOTO 0x3BB
1441:          #endif	// WIDTH
1442:          #ifdef	MANSIGN
1443:          			if(flag & MANSIGN)
1444:          				putsign();
1445:          #else
1446:          #ifdef	NEGSIGN
1447:          			if(flag & NEGSIGN)
0BC9  083C     MOVF flag, W
0BCA  3903     ANDLW 0x3
0BCB  1903     BTFSC STATUS, 0x2
0BCC  2BD3     GOTO 0x3D3
1448:          				pputc('-');
0BCD  0844     MOVF sp, W
0BCE  0084     MOVWF FSR
0BCF  302D     MOVLW 0x2D
0BD0  1383     BCF STATUS, 0x7
0BD1  0080     MOVWF INDF
0BD2  0AC4     INCF sp, F
1449:          #endif
1450:          #endif	// MANSIGN
1451:          #ifdef	SPCSIGN
1452:          			else if(flag & SPCSIGN)
1453:          				pputc(' ');
1454:          #endif
1455:          #ifdef	ALTERN
1456:          #ifdef	EIGHT
1457:          			if((flag & (BASEM|ALTERN)) == (EIGHT|ALTERN))
1458:          				pputc('0');
1459:          			else
1460:          #endif	// EIGHT
1461:          #ifdef	SIXTEEN
1462:          #ifdef	BASEM
1463:          			if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1464:          #else
1465:          			if(flag & ALTERN) {
1466:          #endif
1467:          				pputc('0');
1468:          #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
1469:          				pputc(flag & UPCASE ? 'X' : 'x');
1470:          #elif defined(HEXUPCASE)
1471:          				pputc('X');
1472:          #else
1473:          				pputc('x');
1474:          #endif
1475:          			}
1476:          #endif	// SIXTEEN
1477:          #endif	// ALTERN
1478:          		}
1479:          #if	defined(SIXTEEN) || defined(TEN) || defined(EIGHT) || defined(UNSIGN)
1480:          #ifndef	PRECISION
1481:          		prec = c;
0BD3  083D     MOVF c, W
0BD4  00BA     MOVWF prec
1482:          #endif
1483:          		while(prec--) {
0BD5  2C04     GOTO 0x404
0C04  03BA     DECF prec, F
0C05  0F3A     INCFSZ prec, W
0C06  2BD6     GOTO 0x3D6
1484:          #ifdef	MULTRAD
1485:          			switch((unsigned char)(flag & BASEM))
1486:          #endif
1487:          			{
1488:          
1489:          #if	defined(TEN) || defined(UNSIGN)
1490:          #ifdef	MULTRAD
1491:          #ifdef	TEN
1492:          		case TEN:
1493:          #endif
1494:          #ifdef	UNSIGN
1495:          		case UNSIGN:
1496:          #endif
1497:          #endif	// MULTRAD
1498:          				c = (val / dpowers[prec]) % 10 + '0';
0BD6  300A     MOVLW 0xA
0BD7  00AA     MOVWF Data
0BD8  01AB     CLRF val
0BD9  1003     BCF STATUS, 0x0
0BDA  0D3A     RLF prec, W
0BDB  3E12     ADDLW 0x12
0BDC  0084     MOVWF FSR
0BDD  3098     MOVLW 0x98
0BDE  1803     BTFSC STATUS, 0x0
0BDF  3E01     ADDLW 0x1
0BE0  00FF     MOVWF 0x7F
0BE1  160A     BSF PCLATH, 0x4
0BE2  158A     BSF PCLATH, 0x3
0BE3  2000     CALL 0x0
0BE4  120A     BCF PCLATH, 0x4
0BE5  158A     BSF PCLATH, 0x3
0BE6  00A3     MOVWF x
0BE7  160A     BSF PCLATH, 0x4
0BE8  158A     BSF PCLATH, 0x3
0BE9  2000     CALL 0x0
0BEA  120A     BCF PCLATH, 0x4
0BEB  158A     BSF PCLATH, 0x3
0BEC  00A4     MOVWF Data
0BED  0841     MOVF 0x41, W
0BEE  00A6     MOVWF x
0BEF  0840     MOVF _val, W
0BF0  00A5     MOVWF y
0BF1  241B     CALL 0x41B
0BF2  120A     BCF PCLATH, 0x4
0BF3  158A     BSF PCLATH, 0x3
0BF4  0824     MOVF Data, W
0BF5  00AD     MOVWF hr
0BF6  0823     MOVF x, W
0BF7  00AC     MOVWF seconds
0BF8  2445     CALL 0x445
0BF9  120A     BCF PCLATH, 0x4
0BFA  158A     BSF PCLATH, 0x3
0BFB  082A     MOVF Data, W
0BFC  3E30     ADDLW 0x30
0BFD  00BD     MOVWF c
1499:          #ifdef	MULTRAD
1500:          				break;
1501:          #endif
1502:          #endif	// TEN || UNSIGN
1503:          
1504:          #ifdef	SIXTEEN
1505:          #ifdef	MULTRAD
1506:          			case SIXTEEN:
1507:          #endif
1508:          			{
1509:          				unsigned char idx = (val / hexpowers[prec]) & 0xF;
1510:          #if	defined(HEXLOWCASE) && defined(HEXUPCASE)
1511:          				c = (flag & UPCASE ? "0123456789ABCDEF" : "0123456789abcdef")[idx];
1512:          #elif	defined(HEXUPCASE)
1513:          				c = "0123456789ABCDEF"[idx];
1514:          #else
1515:          				c = "0123456789abcdef"[idx];
1516:          #endif	//HEXCASE
1517:          			}
1518:          #ifdef	MULTRAD
1519:          				break;
1520:          #endif
1521:          #endif
1522:          
1523:          #ifdef	EIGHT
1524:          #ifdef	MULTRAD
1525:          			case EIGHT:
1526:          #endif	// MULTRAD
1527:          				c = ((val / octpowers[prec]) & 07) + '0';
1528:          #ifdef	MULTRAD
1529:          				break;
1530:          #endif	// MULTRAD
1531:          #endif	// EIGHT
1532:          			}
1533:          			pputc(c);
0BFE  0844     MOVF sp, W
0BFF  0084     MOVWF FSR
0C00  083D     MOVF c, W
0C01  1383     BCF STATUS, 0x7
0C02  0080     MOVWF INDF
0C03  0AC4     INCF sp, F
1534:          		}
1535:          #endif	// 16 or 10 or 8
1536:          #ifdef	LEFT
1537:          		if((flag & LEFT) && width > 0)
1538:          			do
1539:          				pputc(' ');
1540:          			while(--width);
1541:          #endif	// LEFT
1542:          	}
1543:          #ifdef	ANYFORMAT
1544:          alldone:
1545:          #endif	// ANYFORMAT
1546:          #if	!defined(PRINTF) && (defined(SPRINTF) || defined(VSPRINTF))
1547:          	*sp = 0;
0C08  0844     MOVF sp, W
0C09  0084     MOVWF FSR
0C0A  1383     BCF STATUS, 0x7
0C0B  0180     CLRF INDF
1548:          #endif
1549:          	return ccnt;
1550:          }
0C0C  0008     RETURN
1551:          
---  /opt/microchip/xc8/v1.31/sources/common/bmul.c  ----------------------------------------------------
1:             // 8 x 8 bit multiplication with 8 bit result
2:             
3:             unsigned char
4:             __bmul(unsigned char multiplier, unsigned char multiplicand)
0323  00A5     MOVWF y
5:             {
6:             	unsigned char product;
7:             
8:             	product = 0;
0324  01A4     CLRF Data
9:             	do {
10:            		if(multiplier & 1)
0325  0823     MOVF x, W
0326  1825     BTFSC y, 0x0
11:            			product += multiplicand;
0325  0823     MOVF x, W
0327  07A4     ADDWF Data, F
12:            		multiplicand <<= 1;
0328  1003     BCF STATUS, 0x0
0329  0DA3     RLF x, F
13:            		multiplier >>= 1;
032A  1003     BCF STATUS, 0x0
032B  0CA5     RRF y, F
14:            	} while(multiplier != 0);
032C  08A5     MOVF y, F
032D  1D03     BTFSS STATUS, 0x2
032E  2B25     GOTO 0x325
15:            	return product;
032F  0824     MOVF Data, W
16:            }
0330  0008     RETURN
17:            
---  /opt/microchip/xc8/v1.31/sources/common/awmod.c  ---------------------------------------------------
1:             // integer signed unsigned modulus
2:             
3:             signed int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __awmod(signed int divisor, signed int dividend)
7:             #else
8:             __awmod(signed int dividend, signed int divisor)
9:             #endif
10:            {
11:            	unsigned char	counter, sign;
12:            
13:            	sign = 0;
0056  01F6     CLRF Pin
14:            	if(dividend < 0) {
0057  1FF4     BTFSS counter, 0x7
0058  2860     GOTO 0x60
15:            		dividend = -dividend;
0059  09F3     COMF dividend, F
005A  09F4     COMF counter, F
005B  0AF3     INCF dividend, F
005C  1903     BTFSC STATUS, 0x2
005D  0AF4     INCF counter, F
16:            		sign = 1;
005E  01F6     CLRF Pin
005F  0AF6     INCF Pin, F
17:            	}
18:            	if(divisor < 0)
0060  1FF2     BTFSS canal, 0x7
0061  2867     GOTO 0x67
19:            		divisor = -divisor;
0062  09F1     COMF divisor, F
0063  09F2     COMF canal, F
0064  0AF1     INCF divisor, F
0065  1903     BTFSC STATUS, 0x2
0066  0AF2     INCF canal, F
20:            	if(divisor != 0) {
0067  0872     MOVF canal, W
0068  0471     IORWF divisor, W
0069  1903     BTFSC STATUS, 0x2
006A  2886     GOTO 0x86
21:            		counter = 1;
006B  01F5     CLRF counter
22:            		while(((unsigned int)divisor & 0x8000U) == 0) {
006D  1BF2     BTFSC canal, 0x7
006E  2873     GOTO 0x73
0072  286C     GOTO 0x6C
23:            			divisor <<= 1;
006C  0AF5     INCF counter, F
006F  1003     BCF STATUS, 0x0
0070  0DF1     RLF divisor, F
0071  0DF2     RLF canal, F
24:            			counter++;
006C  0AF5     INCF counter, F
25:            		}
26:            		do {
27:            			if((unsigned int)divisor <= (unsigned int)dividend)
0073  0872     MOVF canal, W
0074  0274     SUBWF counter, W
0075  1D03     BTFSS STATUS, 0x2
0076  2879     GOTO 0x79
0077  0871     MOVF divisor, W
0078  0273     SUBWF dividend, W
0079  1C03     BTFSS STATUS, 0x0
007A  2882     GOTO 0x82
28:            				dividend -= divisor;
007B  0871     MOVF divisor, W
007C  02F3     SUBWF dividend, F
007D  0872     MOVF canal, W
007E  1C03     BTFSS STATUS, 0x0
007F  03F4     DECF counter, F
0080  02F4     SUBWF counter, F
29:            			*(unsigned int *)&divisor >>= 1;
0081  1003     BCF STATUS, 0x0
0082  0CF2     RRF canal, F
0083  0CF1     RRF divisor, F
30:            		} while(--counter != 0);
0084  0BF5     DECFSZ counter, F
0085  2873     GOTO 0x73
31:            	}
32:            	if(sign)
0086  0876     MOVF Pin, W
0087  1903     BTFSC STATUS, 0x2
0088  288E     GOTO 0x8E
33:            		dividend = -dividend;
0089  09F3     COMF dividend, F
008A  09F4     COMF counter, F
008B  0AF3     INCF dividend, F
008C  1903     BTFSC STATUS, 0x2
008D  0AF4     INCF counter, F
34:            	return dividend;
008E  0874     MOVF counter, W
008F  00F2     MOVWF canal
0090  0873     MOVF dividend, W
0091  00F1     MOVWF divisor
35:            }
0092  0008     RETURN
---  /media/Utilidades/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V4.X/user.c  ----------------------------
1:             
2:             /******************************************************************************/
3:             /* Files to Include                                                           */
4:             /******************************************************************************/
5:             
6:             #if defined(__XC)
7:                 #include <xc.h>         /* XC8 General Include File */
8:             #elif defined(HI_TECH_C)
9:                 #include <htc.h>        /* HiTech General Include File */
10:            #endif
11:            
12:            #include <stdint.h>         /* For uint8_t definition */
13:            #include <stdbool.h>        /* For true/false definition */
14:            
15:            #include "user.h"
16:            #include "LCDGeneric.h"
17:            /******************************************************************************/
18:            /* User Functions                                                             */
19:            /******************************************************************************/
20:            
21:            /* <Initialize variables in user.h and insert code for user algorithms.> */
22:            
23:            void InitApp(void)
24:            {
25:                /* Initialize User Ports/Peripherals/Project here */
26:            
27:                /* Setup analog functionality and port direction */
28:            
29:                /* Initialize peripherals */
30:            
31:                /* Enable interrupts */
32:            }
33:            
34:            //prototipo de la funcion PUTCH para poder enviar al USART  o al LCD con printf
35:            void putch(char data) {
36:                //la variable envia_por nos indica si el printf envia los datos al lcd o al USART
37:              if (envia_por==LCD)
38:               vLCD_Putc(data);
39:              else{
40:                while( ! TXIF)
41:                continue;
42:                TXREG = data;
43:                }
44:            }
45:            
46:            
47:            int aniobisiesto(unsigned char year)
0FC8  00FB     MOVWF j
48:            {
49:                return ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0);
0FC9  01FA     CLRF Indice
0FCA  0AFA     INCF Indice, F
0FCB  3903     ANDLW 0x3
0FCC  1D03     BTFSS STATUS, 0x2
0FCD  2FD9     GOTO 0x7D9
0FCE  3064     MOVLW 0x64
0FCF  00F1     MOVWF divisor
0FD0  087B     MOVF j, W
0FD1  120A     BCF PCLATH, 0x4
0FD2  158A     BSF PCLATH, 0x3
0FD3  2008     CALL 0x8
0FD4  120A     BCF PCLATH, 0x4
0FD5  158A     BSF PCLATH, 0x3
0FD6  3800     IORLW 0x0
0FD7  1D03     BTFSS STATUS, 0x2
0FD8  2FE7     GOTO 0x7E7
0FD9  3090     MOVLW 0x90
0FDA  00F1     MOVWF divisor
0FDB  3001     MOVLW 0x1
0FDC  00F2     MOVWF canal
0FDD  087B     MOVF j, W
0FDE  00F3     MOVWF dividend
0FDF  01F4     CLRF counter
0FE0  120A     BCF PCLATH, 0x4
0FE1  118A     BCF PCLATH, 0x3
0FE2  2056     CALL 0x56
0FE3  0872     MOVF canal, W
0FE4  0471     IORWF divisor, W
0FE5  1D03     BTFSS STATUS, 0x2
0FE6  01FA     CLRF Indice
0FE7  087A     MOVF Indice, W
0FE8  00F7     MOVWF TipoPin
0FE9  01F8     CLRF Logica
50:            }
0FEA  0008     RETURN
---  /media/Utilidades/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V4.X/usart1.c  --------------------------
1:             
2:             
3:             #if defined(__XC)
4:                 #include <xc.h>         /* XC8 General Include File */
5:             #elif defined(HI_TECH_C)
6:                 #include <htc.h>        /* HiTech General Include File */
7:             #endif
8:             #include "usart1.h"
9:             #include "system.h"
10:            
11:            void configura_USART (void){
12:             /*En este pic si se habilita el USART los dos pines(RX y TX) quedan afectados a
13:                este perifrico y no pueden ser usados como I/O independientes*/
14:                //Calculo la carga del registro en base al baudrate elegido baudrate
15:            //FOSC=_XTAL_FREQ
16:            //X=SPBRG
17:            //BAUDRATE=FOSC/(64(X+1)) //en low speed
18:            //BAUDRATE=FOSC/(16(X+1)) //en high speed
19:            //X=FOSC/64/BAUDRATE-1 en low speed
20:            //X=FOSC/16/BAUDRATE-1 en low speed
21:             //Si FOSC=20MHZ
22:            //X=20000000/64/2400-1
23:            
24:            //X=129 para low speed
25:            SPBRG= _XTAL_FREQ/64/baudrate-1;
0049  3081     MOVLW 0x81
004A  1683     BSF STATUS, 0x5
004B  0099     MOVWF TXREG
26:            //SPBRG=129;
27:                /*TXSTAbits.CSRC=1; Asynchronous mode
28:            Don?t care
29:            Synchronous mode
30:            1 = Master mode (Clock generated internally from BRG)
31:            0 = Slave mode (Clock from external source)*/
32:            
33:            /*TXSTAbits.TX9=0;9-bit Transmit Enable bit
34:                    1 = Selects 9-bit transmission
35:                    0 = Selects 8-bit transmission*/
36:            RCSTAbits.RX9=0; /*9-bit Transmit Enable bit*/
004C  1283     BCF STATUS, 0x5
004D  1318     BCF RCSTA, 0x6
37:            TXSTAbits.SYNC=0;/* USART Mode Select bit
004E  1683     BSF STATUS, 0x5
004F  1218     BCF RCSTA, 0x4
38:            1 = Synchronous mode
39:            0 = Asynchronous mode*/
40:            
41:            
42:            TXSTAbits.BRGH=0; /*High Baud Rate Select bit
0050  1118     BCF RCSTA, 0x2
43:            Asynchronous mode
44:            1 = High speed
45:            0 = Low speed
46:            Synchronous mode
47:            Unused in this mode*/
48:            //TXSTAbits.TX9D=1;// 9th bit of transmit data. Can be parity bit.
49:            //Note: SREN/CREN overrides TXEN in SYNC mode.
50:             
51:            
52:            TXSTAbits.TXEN=1; /*Transmit Enable bit(1)
0051  1698     BSF RCSTA, 0x5
53:            1 = Transmit enabled
54:            0 = Transmit disabled*/
55:            RCSTAbits.CREN=1;
0052  1283     BCF STATUS, 0x5
0053  1618     BSF RCSTA, 0x4
56:            RCSTAbits.SPEN=1;
0054  1798     BSF RCSTA, 0x7
57:            }
0055  0008     RETURN
58:            
59:            
60:            /*/prototipo de la funcion PUTCH para poder enviar al USART con printf
61:            void putch(char data) {
62:             while( ! TXIF)
63:             continue;
64:             TXREG = data;
65:            }*/
66:             char getch(void) {
67:                return RCREG;
68:            }
69:            
70:            bit kbhit (void){ //el ide no reconoce __bit pero funciona
71:                 return RCIF;
72:             }
---  /media/Utilidades/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V4.X/pwm.c  -----------------------------
1:             #include <xc.h>
2:             #include <stdint.h>         /* For uint8_t definition */
3:             #include <stdbool.h>        /* For true/false definition */
4:             #include "system.h"
5:             #include "pwm.h"
6:             #include "user.h"
7:             /*The following steps should be taken when configuring
8:             the CCP module for PWM operation:
9:             1. Set the PWM period by writing to the PR2 register.
10:            2. Set the PWM duty cycle by writing to the
11:            CCPR1L register and CCP1CON<5:4> bits.
12:            3. Make the CCP1 pin an output by clearing the
13:            TRISC<2> bit.
14:            4. Set the TMR2 prescale value and enable Timer2
15:            by writing to T2CON.
16:            5. Configure the CCP1 module for PWM operation.*/
17:            #define FrecuenciaPWM 4880UL
18:            #define PeriodoPWM 1/FrecuenciaPWM
19:            #define PRESCALERTIMER2 4
20:            #define asignaPR2 _XTAL_FREQ/PRESCALERTIMER2/4*PeriodoPWM-1
21:            
22:            void set_periodo_buzzer(void){
23:            //PWM Period = [(PR2) + 1] * 4 * TOSC *(TMR2 Prescale Value)
24:                //PR2=PWM PERIOD/(4*TOSC*TMR2 Prescale Value)-1
25:                //para una frecuencia de __XTAL_FREQ/4=5Mhz
26:                PR2=asignaPR2;//periodo;;//periodo; //asigno el periodo
1674  30FF     MOVLW 0xFF
1675  0092     MOVWF T2CON
27:                T2CONbits.TMR2ON=1; //Habilito el timer2
1676  1283     BCF STATUS, 0x5
1677  1512     BSF T2CON, 0x2
28:                T2CONbits.T2CKPS=1; //prescaler en 4
1678  0812     MOVF T2CON, W
1679  39FC     ANDLW 0xFC
167A  3801     IORLW 0x1
167B  0092     MOVWF T2CON
29:               // CCP1CONbits.CCP1M=0b1100; //Configuro el CCp1 como PWM
30:                RB2=0;
167C  1106     BCF PORTB, 0x2
31:               TRISC2=0;//pongo el pin RC2/PWM1 como salida
167D  1683     BSF STATUS, 0x5
167E  1107     BCF PORTC, 0x2
32:            #warning No olvidar que si el PWM_duty > PWM_period no queda bien definida la frecuencia
33:               set_duty(512);
167F  1283     BCF STATUS, 0x5
34:            }
35:            
36:            /*/PWM Duty Cycle =(CCPR1L:CCP1CON<5:4>)*TOSC*(TMR2 Prescale Value)*/
37:            void set_duty(unsigned int duty){
38:            
39:            #define PWM10Bits
40:                //pwm modo 10bits
41:            #ifdef PWM10Bits
42:                CCPR1L=duty>>2;
1684  0824     MOVF Data, W
1685  00A6     MOVWF x
1686  0823     MOVF x, W
1687  00A5     MOVWF y
1688  1003     BCF STATUS, 0x0
1689  0CA6     RRF x, F
168A  0CA5     RRF y, F
168B  1003     BCF STATUS, 0x0
168C  0CA6     RRF x, F
168D  0CA5     RRF y, F
168E  0825     MOVF y, W
168F  0095     MOVWF CCPR1
43:            #endif
44:            CCP1CON = (CCP1CON & 0xCF) | ((duty <<4) & 0x30);
1690  0823     MOVF x, W
1691  00A5     MOVWF y
1692  0E25     SWAPF y, W
1693  39F0     ANDLW 0xF0
1694  00A5     MOVWF y
1695  3930     ANDLW 0x30
1696  00A6     MOVWF x
1697  0817     MOVF CCP1CON, W
1698  39CF     ANDLW 0xCF
1699  0426     IORWF x, W
169A  0097     MOVWF CCP1CON
45:            
46:            
47:            
48:            }
169B  0008     RETURN
49:            
50:            void buzzer_off(void){
1626  30F0     MOVLW 0xF0
162B  30F0     MOVLW 0xF0
51:              //activapor=0;
52:                CCP1CONbits.CCP1M=0; //desactiva pwm
1626  30F0     MOVLW 0xF0
1627  1283     BCF STATUS, 0x5
1628  0597     ANDWF CCP1CON, F
162B  30F0     MOVLW 0xF0
162C  1283     BCF STATUS, 0x5
162D  1303     BCF STATUS, 0x6
162E  0597     ANDWF CCP1CON, F
53:            PORTCbits.RC2=0; //pongo el pin de reloj en bajo
1629  1107     BCF PORTC, 0x2
162F  1107     BCF PORTC, 0x2
54:            
55:            }
162A  0008     RETURN
1630  0008     RETURN
56:            void buzzer_on(void){
1631  3003     MOVLW 0x3
163B  3003     MOVLW 0x3
57:              activapor=3;
1631  3003     MOVLW 0x3
1632  1683     BSF STATUS, 0x5
1633  1303     BCF STATUS, 0x6
1634  00B4     MOVWF sign
163B  3003     MOVLW 0x3
163C  1683     BSF STATUS, 0x5
163D  1303     BCF STATUS, 0x6
163E  00B4     MOVWF sign
58:                CCP1CONbits.CCP1M=0b1100; //activa pwm
1635  1283     BCF STATUS, 0x5
1636  0817     MOVF CCP1CON, W
1637  39F0     ANDLW 0xF0
1638  380C     IORLW 0xC
1639  0097     MOVWF CCP1CON
163F  1283     BCF STATUS, 0x5
1640  0817     MOVF CCP1CON, W
1641  39F0     ANDLW 0xF0
1642  380C     IORLW 0xC
1643  0097     MOVWF CCP1CON
59:                  }
163A  0008     RETURN
1644  0008     RETURN
---  /media/Utilidades/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V4.X/main.c  ----------------------------
1:             /******************************************************************************/
2:             /* Files to Include                                                           */
3:             /******************************************************************************/
4:             // Real Time Clock & NVRAM
5:             // Hardware isl1208 of Dallas Maxim
6:             // With interface I2C
7:             #ifndef __PICCPRO__
8:             #define __PICCPRO__
9:             #endif
10:            #if defined(__XC)
11:            #include <xc.h>         /* XC8 General Include File */
12:            #elif defined(HI_TECH_C)
13:            #include <htc.h>        /* HiTech General Include File */
14:            #endif
15:            
16:            #include <stdint.h>        /* For uint8_t definition */
17:            #include <stdbool.h>       /* For true/false definition */
18:            #include <stdio.h>
19:            #include "system.h"        /* System funct/params, like osc/peripheral config */
20:            #include "user.h"          /* User funct/params, such as InitApp */
21:            #include "Pulsadores.h"
22:            #include "pwm.h"
23:            #include "adcPic16.h"
24:            /******************************************************************************/
25:            /* User Global Variable Declaration                                           */
26:            /******************************************************************************/
27:            
28:            /* i.e. uint8_t <variable_name>; */
29:            
30:            /******************************************************************************/
31:            /* Main Program                                                               */
32:            /******************************************************************************/
33:            
34:            //#fuses HS,MCLR,NOWDT,NOPROTECT,NOPUT,NOBROWNOUT,NOPBADEN,NOLVP,NOCPD,NODEBUG,NOWRT,NOVREGEN
35:            //#use delay(clock=20000000)
36:            //#use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7)
37:            
38:            // Libreria isl1208.c //////////////////////////////////////////////////////////
39:            
40:            #define RTC_SDA  PIN_B0
41:            #define RTC_SCL  PIN_B1
42:            
43:            #define USE_INTERRUPTS 1
44:            
45:            #include "_isl1208.h"
46:            #include "HardI2C.h"
47:            #include "usart1.h"
48:            #include "LCDGeneric.h"
49:            ///////////////////////////////////////////////////////////////////////////////
50:            
51:            void lee_y_transmite_date_and_time(void) {
52:            
53:                // isl1208_get_day_of_week( sdow);
54:                isl1208_get_date(&fecha.day, &fecha.month, &fecha.yr, &fecha.dow);
00F4  305F     MOVLW 0x5F
00F5  1283     BCF STATUS, 0x5
00F6  00AA     MOVWF Data
00F7  3060     MOVLW 0x60
00F8  00AB     MOVWF val
00F9  3061     MOVLW 0x61
00FA  00AC     MOVWF seconds
00FB  305E     MOVLW 0x5E
00FC  2141     CALL 0x141
00FD  120A     BCF PCLATH, 0x4
00FE  118A     BCF PCLATH, 0x3
55:                isl1208_get_time(&horario.hrs, &horario.min, &horario.sec);
00FF  30E9     MOVLW 0xE9
56:                // printf ("%s %02d/%02d/%02d\r\n ",sdow,fecha.day,fecha.month,fecha.yr);
57:                //printf("%02d:%02d:%02d\r\n", horario.hrs,horario.min,horario.sec);
58:            }
59:            
60:            void main() {
61:                //cuenta30ms=0x100;
62:                ////di();//disable_interrupts(int_global);
63:                TMR1IE = 0; //   disable_interrupts(int_timer1);
034D  1683     BSF STATUS, 0x5
034E  100C     BCF PIR1, 0x0
64:                RCIE = 0; //    disable_interrupts(int_rda);
034F  128C     BCF PIR1, 0x5
65:                RBIE = 0;
0350  118B     BCF INTCON, 0x3
66:            #ifndef _PIC18
67:                INTE = 0; //disable_interrupts(int_ext);
0351  120B     BCF INTCON, 0x4
68:            #endif
69:                ADCON1 = 0x06; //todos puertos digitales
0352  3006     MOVLW 0x6
0353  009F     MOVWF ADCON0
70:            
71:                //setup_counters(RTCC_INTERNAL,RTCC_DIV_2);
72:                T0CS = 0; // TMR0 Clock Source Select bit: internal
0354  1281     BCF TMR0, 0x5
73:            
74:                PSA = 0; //Prescaler is assigned to the Timer0 module
0355  1181     BCF TMR0, 0x3
75:            #ifndef _PIC18
76:                OPTION_REGbits.PS = 0b101; //: Prescaler Rate Select bits 1/64
0356  0801     MOVF TMR0, W
0357  39F8     ANDLW 0xF8
0358  3805     IORLW 0x5
0359  0081     MOVWF TMR0
77:            #endif
78:                //setup_timer_1(T1_INTERNAL | T1_DIV_BY_1);
79:                T1CONbits.T1CKPS = 0;
035A  30CF     MOVLW 0xCF
035B  1283     BCF STATUS, 0x5
035C  0590     ANDWF T1CON, F
80:                T1CONbits.T1OSCEN = 0;
035D  1190     BCF T1CON, 0x3
81:                T1CONbits.T1SYNC = 0;
035E  1110     BCF T1CON, 0x2
82:                T1CONbits.TMR1CS = 0;
035F  1090     BCF T1CON, 0x1
83:                T1CONbits.TMR1ON = 1;
0360  1410     BSF T1CON, 0x0
84:                CCP1CONbits.CCP1M = 0;
0361  30F0     MOVLW 0xF0
0362  0597     ANDWF CCP1CON, F
85:                CCP2CONbits.CCP2M = 0;
0363  059D     ANDWF CCP2CON, F
86:                configura_USART();
0364  120A     BCF PCLATH, 0x4
0365  118A     BCF PCLATH, 0x3
0366  2049     CALL 0x49
0367  120A     BCF PCLATH, 0x4
0368  118A     BCF PCLATH, 0x3
87:            
88:                setup_i2c(I2C_MASTER);
0369  3038     MOVLW 0x38
036A  160A     BSF PCLATH, 0x4
036B  118A     BCF PCLATH, 0x3
036C  2651     CALL 0x651
036D  120A     BCF PCLATH, 0x4
036E  118A     BCF PCLATH, 0x3
89:            
90:                TRISB = 0b00011111;
036F  301F     MOVLW 0x1F
0370  1683     BSF STATUS, 0x5
0371  0086     MOVWF PORTB
91:            
92:            
93:                TRISD = 0x00;
0372  0188     CLRF PORTD
94:                TRISE = 0b00000000;
0373  0189     CLRF PORTE
95:                PORTE = 0;
0374  1283     BCF STATUS, 0x5
0375  0189     CLRF PORTE
96:                vInitLCD();
0376  160A     BSF PCLATH, 0x4
0377  118A     BCF PCLATH, 0x3
0378  26E8     CALL 0x6E8
0379  120A     BCF PCLATH, 0x4
037A  118A     BCF PCLATH, 0x3
97:                TRISB1 = 1;
037B  1683     BSF STATUS, 0x5
037C  1486     BSF PORTB, 0x1
98:                TRISB2 = 1;
037D  1506     BSF PORTB, 0x2
99:                TRISB3 = 1;
037E  1586     BSF PORTB, 0x3
100:               TRISB4 = 1;
037F  1606     BSF PORTB, 0x4
101:               sprintf(cadenaamostrar, "Ini...");
0380  303B     MOVLW 0x3B
0381  1283     BCF STATUS, 0x5
0382  00AF     MOVWF sec
0383  3099     MOVLW 0x99
0384  00B0     MOVWF day
0385  30C8     MOVLW 0xC8
0386  120A     BCF PCLATH, 0x4
0387  158A     BSF PCLATH, 0x3
0388  222B     CALL 0x22B
0389  120A     BCF PCLATH, 0x4
038A  118A     BCF PCLATH, 0x3
102:               vGotoxyLCD(1, 1);
038B  3001     MOVLW 0x1
038C  01A5     CLRF y
038D  0AA5     INCF y, F
038E  160A     BSF PCLATH, 0x4
038F  118A     BCF PCLATH, 0x3
0390  269C     CALL 0x69C
0391  120A     BCF PCLATH, 0x4
0392  118A     BCF PCLATH, 0x3
103:               char *cadena = &cadenaamostrar[0];
0393  30C8     MOVLW 0xC8
0394  1683     BSF STATUS, 0x5
0395  1703     BSF STATUS, 0x6
0396  00B1     MOVWF 0x31
104:               while (*cadena != '\0')
0397  0831     MOVF 0x31, W
0398  0084     MOVWF FSR
0399  1383     BCF STATUS, 0x7
039A  0880     MOVF INDF, F
039B  1903     BTFSC STATUS, 0x2
039C  2BA9     GOTO 0x3A9
03A8  2B97     GOTO 0x397
105:                   vLCD_Putc(*cadena++);
039D  0831     MOVF 0x31, W
039E  0084     MOVWF FSR
039F  0800     MOVF INDF, W
03A0  160A     BSF PCLATH, 0x4
03A1  118A     BCF PCLATH, 0x3
03A2  26BF     CALL 0x6BF
03A3  120A     BCF PCLATH, 0x4
03A4  118A     BCF PCLATH, 0x3
03A5  1683     BSF STATUS, 0x5
03A6  1703     BSF STATUS, 0x6
03A7  0AB1     INCF 0x31, F
106:               vGotoxyLCD(1, 2);
03A9  3002     MOVLW 0x2
03AA  1283     BCF STATUS, 0x5
03AB  1303     BCF STATUS, 0x6
03AC  00A5     MOVWF y
03AD  3001     MOVLW 0x1
03AE  160A     BSF PCLATH, 0x4
03AF  118A     BCF PCLATH, 0x3
03B0  269C     CALL 0x69C
03B1  120A     BCF PCLATH, 0x4
03B2  118A     BCF PCLATH, 0x3
107:               char *cadena = &cadenaamostrar2[0];
03B3  30D8     MOVLW 0xD8
03B4  1683     BSF STATUS, 0x5
03B5  1703     BSF STATUS, 0x6
03B6  00B1     MOVWF 0x31
108:               while (*cadena != '\0')
03B7  0831     MOVF 0x31, W
03B8  0084     MOVWF FSR
03B9  1383     BCF STATUS, 0x7
03BA  0880     MOVF INDF, F
03BB  1903     BTFSC STATUS, 0x2
03BC  2BC9     GOTO 0x3C9
03C8  2BB7     GOTO 0x3B7
109:                   vLCD_Putc(*cadena++);
03BD  0831     MOVF 0x31, W
03BE  0084     MOVWF FSR
03BF  0800     MOVF INDF, W
03C0  160A     BSF PCLATH, 0x4
03C1  118A     BCF PCLATH, 0x3
03C2  26BF     CALL 0x6BF
03C3  120A     BCF PCLATH, 0x4
03C4  118A     BCF PCLATH, 0x3
03C5  1683     BSF STATUS, 0x5
03C6  1703     BSF STATUS, 0x6
03C7  0AB1     INCF 0x31, F
110:               refrescadisplay = 0;
03C9  1303     BCF STATUS, 0x6
03CA  01C4     CLRF sp
111:           
112:           
113:               set_periodo_buzzer(); //configuro el pwm para una frecuencia de 3khz
03CB  160A     BSF PCLATH, 0x4
03CC  118A     BCF PCLATH, 0x3
03CD  2674     CALL 0x674
03CE  120A     BCF PCLATH, 0x4
03CF  118A     BCF PCLATH, 0x3
114:               buzzer_on();
03D0  160A     BSF PCLATH, 0x4
03D1  118A     BCF PCLATH, 0x3
03D2  263B     CALL 0x63B
03D3  120A     BCF PCLATH, 0x4
03D4  118A     BCF PCLATH, 0x3
115:               __delay_ms(200);
03D5  3006     MOVLW 0x6
03D6  00DD     MOVWF 0x5D
03D7  3013     MOVLW 0x13
03D8  00DC     MOVWF 0x5C
03D9  30B1     MOVLW 0xB1
03DA  00DB     MOVWF 0x5B
03DB  0BDB     DECFSZ 0x5B, F
03DC  2BDB     GOTO 0x3DB
03DD  0BDC     DECFSZ 0x5C, F
03DE  2BDB     GOTO 0x3DB
03DF  0BDD     DECFSZ 0x5D, F
03E0  2BDB     GOTO 0x3DB
03E1  2BE2     GOTO 0x3E2
116:               buzzer_off();
03E2  160A     BSF PCLATH, 0x4
03E3  118A     BCF PCLATH, 0x3
03E4  262B     CALL 0x62B
03E5  120A     BCF PCLATH, 0x4
03E6  118A     BCF PCLATH, 0x3
117:               __delay_ms(200);
03E7  3006     MOVLW 0x6
03E8  00DD     MOVWF 0x5D
03E9  3013     MOVLW 0x13
03EA  00DC     MOVWF 0x5C
03EB  30B1     MOVLW 0xB1
03EC  00DB     MOVWF 0x5B
03ED  0BDB     DECFSZ 0x5B, F
03EE  2BED     GOTO 0x3ED
03EF  0BDC     DECFSZ 0x5C, F
03F0  2BED     GOTO 0x3ED
03F1  0BDD     DECFSZ 0x5D, F
03F2  2BED     GOTO 0x3ED
03F3  2BF4     GOTO 0x3F4
118:               buzzer_on();
03F4  160A     BSF PCLATH, 0x4
03F5  118A     BCF PCLATH, 0x3
03F6  263B     CALL 0x63B
03F7  120A     BCF PCLATH, 0x4
03F8  118A     BCF PCLATH, 0x3
119:               __delay_ms(200);
03F9  3006     MOVLW 0x6
03FA  00DD     MOVWF 0x5D
03FB  3013     MOVLW 0x13
03FC  00DC     MOVWF 0x5C
03FD  30B1     MOVLW 0xB1
03FE  00DB     MOVWF 0x5B
03FF  0BDB     DECFSZ 0x5B, F
0400  2BFF     GOTO 0x3FF
0401  0BDC     DECFSZ 0x5C, F
0402  2BFF     GOTO 0x3FF
0403  0BDD     DECFSZ 0x5D, F
0404  2BFF     GOTO 0x3FF
0405  2C06     GOTO 0x406
120:               buzzer_off();
0406  160A     BSF PCLATH, 0x4
0407  118A     BCF PCLATH, 0x3
0408  262B     CALL 0x62B
0409  120A     BCF PCLATH, 0x4
040A  118A     BCF PCLATH, 0x3
121:               //ext_int_edge(2,H_TO_L);
122:           #ifndef _PIC18
123:               INTEDG = 0;
040B  1683     BSF STATUS, 0x5
040C  1301     BCF TMR0, 0x6
124:           
125:               INTE = 1; // enable_interrupts(int_ext2);
040D  160B     BSF INTCON, 0x4
126:           #endif
127:               // flanco=0;
128:           
129:               RCIE = 1; //   enable_interrupts(int_rda);
040E  168C     BSF PIR1, 0x5
130:           
131:               TMR0IE = 1;
040F  168B     BSF INTCON, 0x5
132:               // Inicializa isl1208
133:              // isl1208_init(isl1208_OUT_ENABLED | isl1208_OUT_1_HZ);
134:           
135:               //lee_y_transmite_date_and_time();
136:               // printf ("%s %02d/%02d/%02d\r\n ",sdow,fecha.day,fecha.month,fecha.yr);
137:               // printf("%02d:%02d:%02d\r\n", horario.hrs,horario.min,horario.sec);
138:               // printf("\r\n\n");
139:               // Test de RAM -> primero Write, segundo Read
140:               // printf("NVRAM (W/R)\r\n\n");
141:               /*for(i=start_user_address_nvram;i<end_user_address_nvram;i++){
142:                  isl1208_write_nvram_byte(i,i);
143:               }
144:               isl1208_write_nvram_byte(i,i);
145:               n=0;
146:           
147:               for(i=start_user_address_nvram;i<end_user_address_nvram;i++){
148:                  c=isl1208_read_nvram_byte(i);
149:                  // printf("%X ",c);
150:                  if(++n==0x0f){
151:                     n=0;
152:                 //    printf("\r\n");
153:                  }
154:               }*/
155:               setADCChannel(MIDECORRIENTE);
0410  3000     MOVLW 0x0
0411  160A     BSF PCLATH, 0x4
0412  118A     BCF PCLATH, 0x3
0413  2645     CALL 0x645
0414  120A     BCF PCLATH, 0x4
0415  118A     BCF PCLATH, 0x3
156:               __delay_us(20);
0416  3021     MOVLW 0x21
0417  00DB     MOVWF 0x5B
0418  0BDB     DECFSZ 0x5B, F
0419  2C18     GOTO 0x418
157:               openADC();
041A  160A     BSF PCLATH, 0x4
041B  118A     BCF PCLATH, 0x3
041C  2662     CALL 0x662
041D  120A     BCF PCLATH, 0x4
041E  118A     BCF PCLATH, 0x3
158:               __delay_us(20);
041F  3021     MOVLW 0x21
0420  00DB     MOVWF 0x5B
0421  0BDB     DECFSZ 0x5B, F
0422  2C21     GOTO 0x421
159:               interruptADC_on();
0423  160A     BSF PCLATH, 0x4
0424  118A     BCF PCLATH, 0x3
0425  2622     CALL 0x622
0426  120A     BCF PCLATH, 0x4
0427  118A     BCF PCLATH, 0x3
160:               //startADC();
161:               ei(); //enable_interrupts(global);
0428  178B     BSF INTCON, 0x7
162:                // Inicializa isl1208
163:               isl1208_init(isl1208_OUT_ENABLED | isl1208_OUT_1_HZ);
0429  3010     MOVLW 0x10
042A  120A     BCF PCLATH, 0x4
042B  118A     BCF PCLATH, 0x3
042C  222B     CALL 0x22B
042D  120A     BCF PCLATH, 0x4
042E  118A     BCF PCLATH, 0x3
164:           
165:               lee_y_transmite_date_and_time();
042F  120A     BCF PCLATH, 0x4
0430  118A     BCF PCLATH, 0x3
0431  20F4     CALL 0xF4
0432  120A     BCF PCLATH, 0x4
0433  118A     BCF PCLATH, 0x3
0434  2F1E     GOTO 0x71E
166:           
167:           
168:               while (1) {//
169:                   // di(); //
170:                   switch (menuactual) {
0013  120A     BCF PCLATH, 0x4
0014  118A     BCF PCLATH, 0x3
0015  2C35     GOTO 0x435
0016  120A     BCF PCLATH, 0x4
0017  118A     BCF PCLATH, 0x3
0018  2C99     GOTO 0x499
0019  120A     BCF PCLATH, 0x4
001A  118A     BCF PCLATH, 0x3
001B  2DC1     GOTO 0x5C1
001C  120A     BCF PCLATH, 0x4
001D  118A     BCF PCLATH, 0x3
001E  2CB1     GOTO 0x4B1
001F  120A     BCF PCLATH, 0x4
0020  118A     BCF PCLATH, 0x3
0021  2CB9     GOTO 0x4B9
0022  120A     BCF PCLATH, 0x4
0023  118A     BCF PCLATH, 0x3
0024  2CE1     GOTO 0x4E1
0025  120A     BCF PCLATH, 0x4
0026  118A     BCF PCLATH, 0x3
0027  2CE7     GOTO 0x4E7
0028  120A     BCF PCLATH, 0x4
0029  118A     BCF PCLATH, 0x3
002A  2CEF     GOTO 0x4EF
002B  120A     BCF PCLATH, 0x4
002C  118A     BCF PCLATH, 0x3
002D  2CFD     GOTO 0x4FD
002E  120A     BCF PCLATH, 0x4
002F  118A     BCF PCLATH, 0x3
0030  2D0E     GOTO 0x50E
0031  120A     BCF PCLATH, 0x4
0032  118A     BCF PCLATH, 0x3
0033  2D32     GOTO 0x532
0034  120A     BCF PCLATH, 0x4
0035  118A     BCF PCLATH, 0x3
0036  2D3A     GOTO 0x53A
0037  120A     BCF PCLATH, 0x4
0038  118A     BCF PCLATH, 0x3
0039  2D48     GOTO 0x548
003A  120A     BCF PCLATH, 0x4
003B  118A     BCF PCLATH, 0x3
003C  2D5B     GOTO 0x55B
003D  120A     BCF PCLATH, 0x4
003E  118A     BCF PCLATH, 0x3
003F  2D6F     GOTO 0x56F
0040  120A     BCF PCLATH, 0x4
0041  118A     BCF PCLATH, 0x3
0042  2D86     GOTO 0x586
0043  120A     BCF PCLATH, 0x4
0044  118A     BCF PCLATH, 0x3
0045  2D87     GOTO 0x587
0046  120A     BCF PCLATH, 0x4
0047  118A     BCF PCLATH, 0x3
0048  2D9F     GOTO 0x59F
071E  1683     BSF STATUS, 0x5
071F  1303     BCF STATUS, 0x6
0720  0843     MOVF 0x43, W
0721  0084     MOVWF FSR
0722  3012     MOVLW 0x12
0723  0204     SUBWF FSR, W
0724  1803     BTFSC STATUS, 0x0
0725  2F33     GOTO 0x733
0726  3000     MOVLW 0x0
0727  008A     MOVWF PCLATH
0728  1003     BCF STATUS, 0x0
0729  0D04     RLF FSR, W
072A  0704     ADDWF FSR, W
072B  3E13     ADDLW 0x13
072C  0082     MOVWF PCL
171:                       case MENU_MUESTRAHORA:
172:                       {
173:                           //Se actualiza lo que se muestar en el display, solamente cuando hay cambios en lo que mostrar
174:                           if (!I2Cstate) {
0435  08B1     MOVF 0x31, F
0436  1D03     BTFSS STATUS, 0x2
0437  2C83     GOTO 0x483
175:                               if (flanco) {
0438  087D     MOVF flanco, W
0439  1903     BTFSC STATUS, 0x2
043A  2C63     GOTO 0x463
176:           
177:                                   if (refrescadisplay) lee_y_transmite_date_and_time();
043B  0844     MOVF sp, W
043C  1903     BTFSC STATUS, 0x2
043D  2C43     GOTO 0x443
043E  120A     BCF PCLATH, 0x4
043F  118A     BCF PCLATH, 0x3
0440  20F4     CALL 0xF4
0441  120A     BCF PCLATH, 0x4
0442  118A     BCF PCLATH, 0x3
178:                                   sprintf(cadenaamostrar, "%02d:%02d    ", horario.hrs, horario.min);
0443  3048     MOVLW 0x48
0444  1283     BCF STATUS, 0x5
0445  00AF     MOVWF sec
0446  3098     MOVLW 0x98
0447  00B0     MOVWF day
0448  1683     BSF STATUS, 0x5
0449  086A     MOVF 0x6A, W
044A  1283     BCF STATUS, 0x5
044B  00B1     MOVWF 0x31
044C  01B2     CLRF 0x32
044D  1683     BSF STATUS, 0x5
044E  0869     MOVF 0x69, W
044F  1283     BCF STATUS, 0x5
0450  00B3     MOVWF 0x33
0451  30C8     MOVLW 0xC8
0452  01B4     CLRF sign
0453  120A     BCF PCLATH, 0x4
0454  158A     BSF PCLATH, 0x3
0455  222B     CALL 0x22B
0456  120A     BCF PCLATH, 0x4
0457  118A     BCF PCLATH, 0x3
179:                                   sprintf(cadenaamostrar2, "             ");
0458  302C     MOVLW 0x2C
0459  00AF     MOVWF sec
045A  3098     MOVLW 0x98
045B  00B0     MOVWF day
045C  30D8     MOVLW 0xD8
045D  120A     BCF PCLATH, 0x4
045E  158A     BSF PCLATH, 0x3
045F  222B     CALL 0x22B
0460  120A     BCF PCLATH, 0x4
0461  118A     BCF PCLATH, 0x3
180:                               } else {
0462  2F33     GOTO 0x733
181:                                   sprintf(cadenaamostrar, "%02d %02d    ", horario.hrs, horario.min);
0463  303A     MOVLW 0x3A
0464  1283     BCF STATUS, 0x5
0465  00AF     MOVWF sec
0466  3098     MOVLW 0x98
0467  00B0     MOVWF day
0468  1683     BSF STATUS, 0x5
0469  086A     MOVF 0x6A, W
046A  1283     BCF STATUS, 0x5
046B  00B1     MOVWF 0x31
046C  01B2     CLRF 0x32
046D  1683     BSF STATUS, 0x5
046E  0869     MOVF 0x69, W
046F  1283     BCF STATUS, 0x5
0470  00B3     MOVWF 0x33
0471  30C8     MOVLW 0xC8
0472  01B4     CLRF sign
0473  120A     BCF PCLATH, 0x4
0474  158A     BSF PCLATH, 0x3
0475  222B     CALL 0x22B
0476  120A     BCF PCLATH, 0x4
0477  118A     BCF PCLATH, 0x3
182:                                   sprintf(cadenaamostrar2, "             ");
0478  302C     MOVLW 0x2C
0479  00AF     MOVWF sec
047A  3098     MOVLW 0x98
047B  00B0     MOVWF day
047C  30D8     MOVLW 0xD8
047D  120A     BCF PCLATH, 0x4
047E  158A     BSF PCLATH, 0x3
047F  222B     CALL 0x22B
0480  120A     BCF PCLATH, 0x4
0481  118A     BCF PCLATH, 0x3
0482  2F33     GOTO 0x733
183:                               }
184:                           } else {
185:                               sprintf(cadenaamostrar, "RTC erro");
0483  302B     MOVLW 0x2B
0484  1283     BCF STATUS, 0x5
0485  00AF     MOVWF sec
0486  3099     MOVLW 0x99
0487  00B0     MOVWF day
0488  30C8     MOVLW 0xC8
0489  120A     BCF PCLATH, 0x4
048A  158A     BSF PCLATH, 0x3
048B  222B     CALL 0x22B
048C  120A     BCF PCLATH, 0x4
048D  118A     BCF PCLATH, 0x3
186:                               sprintf(cadenaamostrar2, "             ");
048E  302C     MOVLW 0x2C
048F  00AF     MOVWF sec
0490  3098     MOVLW 0x98
0491  00B0     MOVWF day
0492  30D8     MOVLW 0xD8
0493  120A     BCF PCLATH, 0x4
0494  158A     BSF PCLATH, 0x3
0495  222B     CALL 0x22B
0496  120A     BCF PCLATH, 0x4
0497  118A     BCF PCLATH, 0x3
0498  2F33     GOTO 0x733
187:                           }
188:           
189:           
190:                           break;
191:                       }
192:                       case MENU_MUESTRAFECHA:
193:                       {
194:           
195:                           if (flanco) {
0499  087D     MOVF flanco, W
049A  1903     BTFSC STATUS, 0x2
049B  2F33     GOTO 0x733
196:                               lee_y_transmite_date_and_time();
049C  120A     BCF PCLATH, 0x4
049D  118A     BCF PCLATH, 0x3
049E  20F4     CALL 0xF4
049F  120A     BCF PCLATH, 0x4
04A0  118A     BCF PCLATH, 0x3
197:                               sprintf(cadenaamostrar, "%02d/%02d/%02d ", fecha.day, fecha.month, fecha.yr);
04A1  301C     MOVLW 0x1C
04A2  1283     BCF STATUS, 0x5
04A3  00AF     MOVWF sec
04A4  3098     MOVLW 0x98
04A5  00B0     MOVWF day
04A6  085E     MOVF fecha, W
04A7  00B1     MOVWF 0x31
04A8  01B2     CLRF 0x32
04A9  085F     MOVF 0x5F, W
04AA  00B3     MOVWF 0x33
04AB  01B4     CLRF sign
04AC  0860     MOVF 0x60, W
04AD  00B5     MOVWF exp2
04AE  30C8     MOVLW 0xC8
04AF  01B6     CLRF exp1
04B0  2DB7     GOTO 0x5B7
198:                               sprintf(cadenaamostrar2, "             ");
199:                           }
200:           
201:           
202:                           break;
203:                       }
204:                       case MENU_CONFIGURAHORARIO:
205:                       {
206:           
207:                           if (flanco) {
04B1  087D     MOVF flanco, W
04B2  1903     BTFSC STATUS, 0x2
04B3  2F33     GOTO 0x733
208:                               sprintf(cadenaamostrar, "SET HORA ");
04B4  30D7     MOVLW 0xD7
04B5  1283     BCF STATUS, 0x5
04B6  00AF     MOVWF sec
04B7  3098     MOVLW 0x98
04B8  2DB5     GOTO 0x5B5
209:                               sprintf(cadenaamostrar2, "             ");
210:                           }
211:           
212:                           break;
213:                       }
214:                       case SUBMENU_CONFIGURAHORA:
215:                       {
216:                           modificafecha = HORA;
04B9  01EB     CLRF 0x6B
217:           
218:                           if (flanco || haycambio) {
04BA  08FD     MOVF flanco, F
04BB  1903     BTFSC STATUS, 0x2
04BC  0842     MOVF 0x42, W
04BD  1903     BTFSC STATUS, 0x2
04BE  2D40     GOTO 0x540
219:                               sprintf(cadenaamostrar, "%02d:%02d    ", horario.hrs, horario.min);
04BF  3048     MOVLW 0x48
04C0  1283     BCF STATUS, 0x5
04C1  00AF     MOVWF sec
04C2  3098     MOVLW 0x98
04C3  00B0     MOVWF day
04C4  1683     BSF STATUS, 0x5
04C5  086A     MOVF 0x6A, W
04C6  1283     BCF STATUS, 0x5
04C7  00B1     MOVWF 0x31
04C8  01B2     CLRF 0x32
04C9  1683     BSF STATUS, 0x5
04CA  0869     MOVF 0x69, W
04CB  1283     BCF STATUS, 0x5
04CC  00B3     MOVWF 0x33
04CD  30C8     MOVLW 0xC8
04CE  01B4     CLRF sign
04CF  120A     BCF PCLATH, 0x4
04D0  158A     BSF PCLATH, 0x3
04D1  222B     CALL 0x22B
04D2  120A     BCF PCLATH, 0x4
04D3  118A     BCF PCLATH, 0x3
220:                               sprintf(cadenaamostrar2, "             ");
04D4  302C     MOVLW 0x2C
04D5  00AF     MOVWF sec
04D6  3098     MOVLW 0x98
04D7  00B0     MOVWF day
04D8  30D8     MOVLW 0xD8
04D9  120A     BCF PCLATH, 0x4
04DA  158A     BSF PCLATH, 0x3
04DB  222B     CALL 0x22B
04DC  120A     BCF PCLATH, 0x4
04DD  118A     BCF PCLATH, 0x3
221:                               haycambio = 0;
04DE  1683     BSF STATUS, 0x5
04DF  01C2     CLRF 0x42
222:                           } else {
04E0  2F33     GOTO 0x733
223:                               sprintf(cadenaamostrar, "  :%02d    ", horario.min);
224:                               sprintf(cadenaamostrar2, "             ");
225:                           }
226:                           break;
227:                       }
228:                       case SUBMENU_CONFIGURAMINUTOS:
229:                       {
230:                           modificafecha = MINUTOS;
04E1  01EB     CLRF 0x6B
04E2  0AEB     INCF 0x6B, F
231:           
232:                           if (flanco || haycambio) {
04E3  08FD     MOVF flanco, F
04E4  1D03     BTFSS STATUS, 0x2
04E5  2CBF     GOTO 0x4BF
04E6  2D4C     GOTO 0x54C
233:                               sprintf(cadenaamostrar, "%02d:%02d    ", horario.hrs, horario.min);
234:                               sprintf(cadenaamostrar2, "             ");
235:                               haycambio = 0;
236:                           } else {
237:                               sprintf(cadenaamostrar, "%02d:      ", horario.hrs);
238:                               sprintf(cadenaamostrar2, "             ");
239:                           }
240:                           break;
241:                       }
242:                       case MENU_CONFIGURAFECHA:
243:                       {
244:           
245:                           if (flanco) {
04E7  087D     MOVF flanco, W
04E8  1903     BTFSC STATUS, 0x2
04E9  2F33     GOTO 0x733
246:                               sprintf(cadenaamostrar, "SET FECHA");
04EA  30EB     MOVLW 0xEB
04EB  1283     BCF STATUS, 0x5
04EC  00AF     MOVWF sec
04ED  3098     MOVLW 0x98
04EE  2DB5     GOTO 0x5B5
247:                               sprintf(cadenaamostrar2, "             ");
248:                           }
249:                           break;
250:                       }
251:                       case SUBMENU_CONFIGURADIA:
252:                       {
253:                           modificafecha = DIA;
04EF  3002     MOVLW 0x2
04F0  00EB     MOVWF 0x6B
254:           
255:                           if (flanco || haycambio) {
04F1  08FD     MOVF flanco, F
04F2  1903     BTFSC STATUS, 0x2
04F3  0842     MOVF 0x42, W
04F4  1D03     BTFSS STATUS, 0x2
256:                               sprintf(cadenaamostrar, "%02d/%02d/%02d ", fecha.day, fecha.month, fecha.yr);
04F5  2D15     GOTO 0x515
257:                               sprintf(cadenaamostrar2, "             ");
258:                               haycambio = 0;
259:                           } else {
260:                               sprintf(cadenaamostrar, "  /%02d/%02d ", fecha.month, fecha.yr);
04F6  3072     MOVLW 0x72
04F7  1283     BCF STATUS, 0x5
04F8  00AF     MOVWF sec
04F9  3098     MOVLW 0x98
04FA  00B0     MOVWF day
04FB  085F     MOVF 0x5F, W
04FC  2D0A     GOTO 0x50A
261:                               sprintf(cadenaamostrar2, "             ");
262:                           }
263:                           break;
264:                       }
265:                       case SUBMENU_CONFIGURAMES:
266:                       {
267:                           modificafecha = MES;
04FD  3003     MOVLW 0x3
04FE  00EB     MOVWF 0x6B
268:           
269:                           if (flanco || haycambio) {
04FF  08FD     MOVF flanco, F
0500  1903     BTFSC STATUS, 0x2
0501  0842     MOVF 0x42, W
0502  1D03     BTFSS STATUS, 0x2
270:                               sprintf(cadenaamostrar, "%02d/%02d/%02d ", fecha.day, fecha.month, fecha.yr);
0503  2D15     GOTO 0x515
271:                               sprintf(cadenaamostrar2, "             ");
272:                               haycambio = 0;
273:                           } else {
274:                               sprintf(cadenaamostrar, "%02d/  /%02d ", fecha.day, fecha.yr);
0504  3064     MOVLW 0x64
0505  1283     BCF STATUS, 0x5
0506  00AF     MOVWF sec
0507  3098     MOVLW 0x98
0508  00B0     MOVWF day
0509  085E     MOVF fecha, W
050A  00B1     MOVWF 0x31
050B  01B2     CLRF 0x32
050C  0860     MOVF 0x60, W
050D  2D2E     GOTO 0x52E
275:                               sprintf(cadenaamostrar2, "             ");
276:                           }
277:                           break;
278:                       }
279:                       case SUBMENU_CONFIGURAANIO:
280:                       {
281:                           modificafecha = ANIO;
050E  3004     MOVLW 0x4
050F  00EB     MOVWF 0x6B
282:           
283:                           if (flanco || haycambio) {
0510  08FD     MOVF flanco, F
0511  1903     BTFSC STATUS, 0x2
0512  0842     MOVF 0x42, W
0513  1903     BTFSC STATUS, 0x2
0514  2D25     GOTO 0x525
284:                               sprintf(cadenaamostrar, "%02d/%02d/%02d ", fecha.day, fecha.month, fecha.yr);
0515  301C     MOVLW 0x1C
0516  1283     BCF STATUS, 0x5
0517  00AF     MOVWF sec
0518  3098     MOVLW 0x98
0519  00B0     MOVWF day
051A  085E     MOVF fecha, W
051B  00B1     MOVWF 0x31
051C  01B2     CLRF 0x32
051D  085F     MOVF 0x5F, W
051E  00B3     MOVWF 0x33
051F  01B4     CLRF sign
0520  0860     MOVF 0x60, W
0521  00B5     MOVWF exp2
0522  30C8     MOVLW 0xC8
0523  01B6     CLRF exp1
0524  2CCF     GOTO 0x4CF
285:                               sprintf(cadenaamostrar2, "             ");
286:                               haycambio = 0;
287:                           } else {
288:                               sprintf(cadenaamostrar, "%02d/%02d/   ", fecha.day, fecha.month);
0525  3056     MOVLW 0x56
0526  1283     BCF STATUS, 0x5
0527  00AF     MOVWF sec
0528  3098     MOVLW 0x98
0529  00B0     MOVWF day
052A  085E     MOVF fecha, W
052B  00B1     MOVWF 0x31
052C  01B2     CLRF 0x32
052D  085F     MOVF 0x5F, W
052E  00B3     MOVWF 0x33
052F  30C8     MOVLW 0xC8
0530  01B4     CLRF sign
0531  2DB7     GOTO 0x5B7
289:                               sprintf(cadenaamostrar2, "             ");
290:                           }
291:                           break;
292:                       }
293:                       case MENU_CONFIGURAENCENDIDO:
294:                       {
295:           
296:                           if (flanco) {
0532  087D     MOVF flanco, W
0533  1903     BTFSC STATUS, 0x2
0534  2F33     GOTO 0x733
297:                               sprintf(cadenaamostrar, "SET ENC  ");
0535  30C3     MOVLW 0xC3
0536  1283     BCF STATUS, 0x5
0537  00AF     MOVWF sec
0538  3098     MOVLW 0x98
0539  2DB5     GOTO 0x5B5
298:                               sprintf(cadenaamostrar2, "             ");
299:                           }
300:           
301:                           break;
302:                       }
303:                       case SUBMENU_CONFIGURAHORAENCENDIDO:
304:                       {
305:                           modificafecha = HORA;
053A  01EB     CLRF 0x6B
306:           
307:                           if (flanco || haycambio) {
053B  08FD     MOVF flanco, F
053C  1903     BTFSC STATUS, 0x2
053D  0842     MOVF 0x42, W
053E  1D03     BTFSS STATUS, 0x2
308:                               sprintf(cadenaamostrar, "%02d:%02d    ", horario.hrs, horario.min);
053F  2CBF     GOTO 0x4BF
309:                               sprintf(cadenaamostrar2, "             ");
310:                               haycambio = 0;
311:                           } else {
312:                               sprintf(cadenaamostrar, "  :%02d    ", horario.min);
0540  308C     MOVLW 0x8C
0541  1283     BCF STATUS, 0x5
0542  00AF     MOVWF sec
0543  3098     MOVLW 0x98
0544  00B0     MOVWF day
0545  1683     BSF STATUS, 0x5
0546  0869     MOVF 0x69, W
0547  2D56     GOTO 0x556
313:                               sprintf(cadenaamostrar2, "             ");
314:                           }
315:           
316:                           break;
317:                       }
318:                       case SUBMENU_CONFIGURAMINUTOSENCENDIDO:
319:                       {
320:                           modificafecha = MINUTOS;
0548  01EB     CLRF 0x6B
0549  0AEB     INCF 0x6B, F
321:           
322:                           if (flanco || haycambio) {
054A  08FD     MOVF flanco, F
054B  1903     BTFSC STATUS, 0x2
054C  0842     MOVF 0x42, W
054D  1D03     BTFSS STATUS, 0x2
323:                               sprintf(cadenaamostrar, "%02d:%02d    ", horario.hrs, horario.min);
054E  2CBF     GOTO 0x4BF
324:                               sprintf(cadenaamostrar2, "             ");
325:                               haycambio = 0;
326:                           } else {
327:                               sprintf(cadenaamostrar, "%02d:      ", horario.hrs);
054F  3080     MOVLW 0x80
0550  1283     BCF STATUS, 0x5
0551  00AF     MOVWF sec
0552  3098     MOVLW 0x98
0553  00B0     MOVWF day
0554  1683     BSF STATUS, 0x5
0555  086A     MOVF 0x6A, W
0556  1283     BCF STATUS, 0x5
0557  00B1     MOVWF 0x31
0558  30C8     MOVLW 0xC8
0559  01B2     CLRF 0x32
055A  2DB7     GOTO 0x5B7
328:                               sprintf(cadenaamostrar2, "             ");
329:                           }
330:                           break;
331:                       }
332:           
333:                       case SUBMENU_CONFIGURATIEMPOENCENDIDO:
334:                       {
335:                           modificafecha = TIEMPOENCENDIDO;
055B  3007     MOVLW 0x7
055C  00EB     MOVWF 0x6B
336:           
337:                           if (flanco || haycambio) {
055D  08FD     MOVF flanco, F
055E  1903     BTFSC STATUS, 0x2
055F  0842     MOVF 0x42, W
0560  1903     BTFSC STATUS, 0x2
0561  2D6A     GOTO 0x56A
338:                               sprintf(cadenaamostrar, "ENCEN:%02d", tiempoencendido);
0562  30AE     MOVLW 0xAE
0563  1283     BCF STATUS, 0x5
0564  00AF     MOVWF sec
0565  3098     MOVLW 0x98
0566  00B0     MOVWF day
0567  1683     BSF STATUS, 0x5
0568  0845     MOVF 0x45, W
0569  2D95     GOTO 0x595
339:                               sprintf(cadenaamostrar2, "             ");
340:                               haycambio = 0;
341:                           } else {
342:                               sprintf(cadenaamostrar, "ENCEN:  ");
056A  3010     MOVLW 0x10
056B  1283     BCF STATUS, 0x5
056C  00AF     MOVWF sec
056D  3099     MOVLW 0x99
056E  2DB5     GOTO 0x5B5
343:                               sprintf(cadenaamostrar2, "             ");
344:                           }
345:                           break;
346:                       }
347:                       case SUBMENU_CONFIGURAREPITECADA12HORAS:
348:                       {
349:                           modificafecha = SINO;
056F  3006     MOVLW 0x6
0570  00EB     MOVWF 0x6B
350:           
351:                           if (flanco)
0571  087D     MOVF flanco, W
0572  1903     BTFSC STATUS, 0x2
0573  2D81     GOTO 0x581
352:                               if (banderasino) {
0574  0837     MOVF f2, W
0575  1903     BTFSC STATUS, 0x2
0576  2D7C     GOTO 0x57C
353:                                   sprintf(cadenaamostrar, "REPIT SI");
0577  3019     MOVLW 0x19
0578  1283     BCF STATUS, 0x5
0579  00AF     MOVWF sec
057A  3099     MOVLW 0x99
057B  2DB5     GOTO 0x5B5
354:                                   sprintf(cadenaamostrar2, "             ");
355:                               } else {
356:                                   sprintf(cadenaamostrar, "REPIT NO");
057C  3022     MOVLW 0x22
057D  1283     BCF STATUS, 0x5
057E  00AF     MOVWF sec
057F  3099     MOVLW 0x99
0580  2DB5     GOTO 0x5B5
357:                                   sprintf(cadenaamostrar2, "             ");
358:                               } else {
359:                               sprintf(cadenaamostrar, "REPIT   ");
0581  30FE     MOVLW 0xFE
0582  1283     BCF STATUS, 0x5
0583  00AF     MOVWF sec
0584  3098     MOVLW 0x98
0585  2DB5     GOTO 0x5B5
360:                               sprintf(cadenaamostrar2, "             ");
361:                           }
362:                           break;
363:                       }
364:                       case MENU_CONFIGURAFALLACORRIENTE:
365:                       {
366:                           modificafecha = SINO;
0586  2D9F     GOTO 0x59F
367:           
368:                           if (flanco)
369:                               if (banderasino) {
370:                                   sprintf(cadenaamostrar, "NORMAL A ");
371:                                   sprintf(cadenaamostrar2, "             ");
372:                               } else {
373:                                   sprintf(cadenaamostrar, "NORMAL C ");
374:                                   sprintf(cadenaamostrar2, "             ");
375:                               } else {
376:                               sprintf(cadenaamostrar, "NORMAL   ");
377:                               sprintf(cadenaamostrar2, "             ");
378:                           }
379:                           break;
380:                       }
381:                       case MENU_CONFIGURATIEMPOFALLACORRIENTE:
382:                       {
383:                           modificafecha = TIEMPOFALLA;
0587  3008     MOVLW 0x8
0588  00EB     MOVWF 0x6B
384:           
385:                           if (flanco || haycambio) {
0589  08FD     MOVF flanco, F
058A  1903     BTFSC STATUS, 0x2
058B  0842     MOVF 0x42, W
058C  1903     BTFSC STATUS, 0x2
058D  2D9A     GOTO 0x59A
386:                               sprintf(cadenaamostrar, "FALLA:%02d", tiempofalla);
058E  30A3     MOVLW 0xA3
058F  1283     BCF STATUS, 0x5
0590  00AF     MOVWF sec
0591  3098     MOVLW 0x98
0592  00B0     MOVWF day
0593  1683     BSF STATUS, 0x5
0594  0846     MOVF exp, W
0595  1283     BCF STATUS, 0x5
0596  00B1     MOVWF 0x31
0597  30C8     MOVLW 0xC8
0598  01B2     CLRF 0x32
0599  2CCF     GOTO 0x4CF
387:                               sprintf(cadenaamostrar2, "             ");
388:                               haycambio = 0;
389:                           } else {
390:                               sprintf(cadenaamostrar, "FALLA:  ");
059A  3007     MOVLW 0x7
059B  1283     BCF STATUS, 0x5
059C  00AF     MOVWF sec
059D  3099     MOVLW 0x99
059E  2DB5     GOTO 0x5B5
391:                               sprintf(cadenaamostrar2, "             ");
392:                           }
393:                           break;
394:                       }
395:                       case MENU_CONFIGURAINDICACIONDENIVEL:
396:                       {
397:                           modificafecha = SINO;
059F  3006     MOVLW 0x6
05A0  00EB     MOVWF 0x6B
398:           
399:           
400:                           if (flanco)
05A1  087D     MOVF flanco, W
05A2  1903     BTFSC STATUS, 0x2
05A3  2DB1     GOTO 0x5B1
401:                               if (banderasino) {
05A4  0837     MOVF f2, W
05A5  1903     BTFSC STATUS, 0x2
05A6  2DAC     GOTO 0x5AC
402:                                   sprintf(cadenaamostrar, "NORMAL A ");
05A7  30CD     MOVLW 0xCD
05A8  1283     BCF STATUS, 0x5
05A9  00AF     MOVWF sec
05AA  3098     MOVLW 0x98
05AB  2DB5     GOTO 0x5B5
403:                                   sprintf(cadenaamostrar2, "             ");
404:                               } else {
405:                                   sprintf(cadenaamostrar, "NORMAL C ");
05AC  30E1     MOVLW 0xE1
05AD  1283     BCF STATUS, 0x5
05AE  00AF     MOVWF sec
05AF  3098     MOVLW 0x98
05B0  2DB5     GOTO 0x5B5
406:                                   sprintf(cadenaamostrar2, "             ");
407:                               } else {
408:                               sprintf(cadenaamostrar, "NORMAL   ");
05B1  30B9     MOVLW 0xB9
05B2  1283     BCF STATUS, 0x5
05B3  00AF     MOVWF sec
05B4  3098     MOVLW 0x98
05B5  00B0     MOVWF day
05B6  30C8     MOVLW 0xC8
05B7  120A     BCF PCLATH, 0x4
05B8  158A     BSF PCLATH, 0x3
05B9  222B     CALL 0x22B
05BA  120A     BCF PCLATH, 0x4
05BB  118A     BCF PCLATH, 0x3
409:                               sprintf(cadenaamostrar2, "             ");
05BC  302C     MOVLW 0x2C
05BD  00AF     MOVWF sec
05BE  3098     MOVLW 0x98
05BF  00B0     MOVWF day
05C0  2F16     GOTO 0x716
410:                           }
411:           
412:                           break;
413:                       }
414:                       case MENU_MUESTRAMEDICIONES:
415:                       {
416:                           unsigned int adcenteroI;
417:                           unsigned int adcdecimalI;
418:                           unsigned int adcenteroV;
419:                           mediciondecorriente = (float) medidaI_adc * 50 / 1024;
05C1  1283     BCF STATUS, 0x5
05C2  3080     MOVLW 0x80
05C3  01CC     CLRF f2
05C4  00CD     MOVWF 0x4D
05C5  3044     MOVLW 0x44
05C6  00CE     MOVWF 0x4E
05C7  3048     MOVLW 0x48
05C8  01BD     CLRF c
05C9  00BE     MOVWF width
05CA  3042     MOVLW 0x42
05CB  00BF     MOVWF 0x3F
05CC  1683     BSF STATUS, 0x5
05CD  082E     MOVF min, W
05CE  1283     BCF STATUS, 0x5
05CF  00B1     MOVWF 0x31
05D0  1683     BSF STATUS, 0x5
05D1  082D     MOVF hr, W
05D2  1283     BCF STATUS, 0x5
05D3  00B0     MOVWF day
05D4  120A     BCF PCLATH, 0x4
05D5  158A     BSF PCLATH, 0x3
05D6  2024     CALL 0x24
05D7  120A     BCF PCLATH, 0x4
05D8  118A     BCF PCLATH, 0x3
05D9  0830     MOVF day, W
05DA  00C0     MOVWF _val
05DB  0831     MOVF 0x31, W
05DC  00C1     MOVWF 0x41
05DD  0832     MOVF 0x32, W
05DE  00C2     MOVWF 0x42
05DF  120A     BCF PCLATH, 0x4
05E0  158A     BSF PCLATH, 0x3
05E1  20B2     CALL 0xB2
05E2  120A     BCF PCLATH, 0x4
05E3  118A     BCF PCLATH, 0x3
05E4  083D     MOVF c, W
05E5  00CF     MOVWF f1
05E6  083E     MOVF width, W
05E7  00D0     MOVWF 0x50
05E8  083F     MOVF 0x3F, W
05E9  00D1     MOVWF 0x51
05EA  120A     BCF PCLATH, 0x4
05EB  158A     BSF PCLATH, 0x3
05EC  204A     CALL 0x4A
05ED  120A     BCF PCLATH, 0x4
05EE  118A     BCF PCLATH, 0x3
05EF  084C     MOVF f2, W
05F0  1683     BSF STATUS, 0x5
05F1  00AA     MOVWF Data
05F2  1283     BCF STATUS, 0x5
05F3  084D     MOVF 0x4D, W
05F4  1683     BSF STATUS, 0x5
05F5  00AB     MOVWF val
05F6  1283     BCF STATUS, 0x5
05F7  084E     MOVF 0x4E, W
05F8  1683     BSF STATUS, 0x5
05F9  00AC     MOVWF seconds
420:                           float mediciondevoltaje = (float) medidaV_adc * 440 / 1024;
05FA  1283     BCF STATUS, 0x5
05FB  3080     MOVLW 0x80
05FC  01CC     CLRF f2
05FD  00CD     MOVWF 0x4D
05FE  3044     MOVLW 0x44
05FF  00CE     MOVWF 0x4E
0600  30DC     MOVLW 0xDC
0601  01BD     CLRF c
0602  00BE     MOVWF width
0603  3043     MOVLW 0x43
0604  00BF     MOVWF 0x3F
0605  1683     BSF STATUS, 0x5
0606  0830     MOVF day, W
0607  1283     BCF STATUS, 0x5
0608  00B1     MOVWF 0x31
0609  1683     BSF STATUS, 0x5
060A  082F     MOVF sec, W
060B  1283     BCF STATUS, 0x5
060C  00B0     MOVWF day
060D  120A     BCF PCLATH, 0x4
060E  158A     BSF PCLATH, 0x3
060F  2024     CALL 0x24
0610  120A     BCF PCLATH, 0x4
0611  118A     BCF PCLATH, 0x3
0612  0830     MOVF day, W
0613  00C0     MOVWF _val
0614  0831     MOVF 0x31, W
0615  00C1     MOVWF 0x41
0616  0832     MOVF 0x32, W
0617  00C2     MOVWF 0x42
0618  120A     BCF PCLATH, 0x4
0619  158A     BSF PCLATH, 0x3
061A  20B2     CALL 0xB2
061B  120A     BCF PCLATH, 0x4
061C  118A     BCF PCLATH, 0x3
061D  083D     MOVF c, W
061E  00CF     MOVWF f1
061F  083E     MOVF width, W
0620  00D0     MOVWF 0x50
0621  083F     MOVF 0x3F, W
0622  00D1     MOVWF 0x51
0623  120A     BCF PCLATH, 0x4
0624  158A     BSF PCLATH, 0x3
0625  204A     CALL 0x4A
0626  120A     BCF PCLATH, 0x4
0627  118A     BCF PCLATH, 0x3
0628  084C     MOVF f2, W
0629  1683     BSF STATUS, 0x5
062A  1703     BSF STATUS, 0x6
062B  00A5     MOVWF y
062C  1283     BCF STATUS, 0x5
062D  1303     BCF STATUS, 0x6
062E  084D     MOVF 0x4D, W
062F  1683     BSF STATUS, 0x5
0630  1703     BSF STATUS, 0x6
0631  00A6     MOVWF x
0632  1283     BCF STATUS, 0x5
0633  1303     BCF STATUS, 0x6
0634  084E     MOVF 0x4E, W
0635  1683     BSF STATUS, 0x5
0636  1703     BSF STATUS, 0x6
0637  00A7     MOVWF i
421:                           adcenteroI = (unsigned int) mediciondecorriente;
0638  1303     BCF STATUS, 0x6
0639  082A     MOVF Data, W
063A  1283     BCF STATUS, 0x5
063B  00A3     MOVWF x
063C  1683     BSF STATUS, 0x5
063D  082B     MOVF val, W
063E  1283     BCF STATUS, 0x5
063F  00A4     MOVWF Data
0640  1683     BSF STATUS, 0x5
0641  082C     MOVF seconds, W
0642  1283     BCF STATUS, 0x5
0643  00A5     MOVWF y
0644  120A     BCF PCLATH, 0x4
0645  118A     BCF PCLATH, 0x3
0646  2093     CALL 0x93
0647  120A     BCF PCLATH, 0x4
0648  118A     BCF PCLATH, 0x3
0649  0824     MOVF Data, W
064A  1683     BSF STATUS, 0x5
064B  1703     BSF STATUS, 0x6
064C  00AC     MOVWF seconds
064D  1283     BCF STATUS, 0x5
064E  1303     BCF STATUS, 0x6
064F  0823     MOVF x, W
0650  1683     BSF STATUS, 0x5
0651  1703     BSF STATUS, 0x6
0652  00AB     MOVWF val
422:                           adcdecimalI = (unsigned int) ((mediciondecorriente - (unsigned int) mediciondecorriente)*10);
0653  1303     BCF STATUS, 0x6
0654  082A     MOVF Data, W
0655  1283     BCF STATUS, 0x5
0656  00BA     MOVWF prec
0657  1683     BSF STATUS, 0x5
0658  082B     MOVF val, W
0659  1283     BCF STATUS, 0x5
065A  00BB     MOVWF ap
065B  1683     BSF STATUS, 0x5
065C  082C     MOVF seconds, W
065D  1283     BCF STATUS, 0x5
065E  00BC     MOVWF flag
065F  1683     BSF STATUS, 0x5
0660  082A     MOVF Data, W
0661  1283     BCF STATUS, 0x5
0662  00A3     MOVWF x
0663  1683     BSF STATUS, 0x5
0664  082B     MOVF val, W
0665  1283     BCF STATUS, 0x5
0666  00A4     MOVWF Data
0667  1683     BSF STATUS, 0x5
0668  082C     MOVF seconds, W
0669  1283     BCF STATUS, 0x5
066A  00A5     MOVWF y
066B  120A     BCF PCLATH, 0x4
066C  118A     BCF PCLATH, 0x3
066D  2093     CALL 0x93
066E  120A     BCF PCLATH, 0x4
066F  118A     BCF PCLATH, 0x3
0670  0824     MOVF Data, W
0671  00B1     MOVWF 0x31
0672  0823     MOVF x, W
0673  00B0     MOVWF day
0674  120A     BCF PCLATH, 0x4
0675  158A     BSF PCLATH, 0x3
0676  2024     CALL 0x24
0677  120A     BCF PCLATH, 0x4
0678  118A     BCF PCLATH, 0x3
0679  0830     MOVF day, W
067A  00B7     MOVWF f2
067B  0831     MOVF 0x31, W
067C  00B8     MOVWF 0x38
067D  0832     MOVF 0x32, W
067E  00B9     MOVWF 0x39
067F  120A     BCF PCLATH, 0x4
0680  158A     BSF PCLATH, 0x3
0681  2034     CALL 0x34
0682  120A     BCF PCLATH, 0x4
0683  118A     BCF PCLATH, 0x3
0684  0837     MOVF f2, W
0685  00C0     MOVWF _val
0686  0838     MOVF 0x38, W
0687  00C1     MOVWF 0x41
0688  0839     MOVF 0x39, W
0689  00C2     MOVWF 0x42
068A  3020     MOVLW 0x20
068B  01BD     CLRF c
068C  00BE     MOVWF width
068D  3041     MOVLW 0x41
068E  00BF     MOVWF 0x3F
068F  120A     BCF PCLATH, 0x4
0690  158A     BSF PCLATH, 0x3
0691  20B2     CALL 0xB2
0692  120A     BCF PCLATH, 0x4
0693  118A     BCF PCLATH, 0x3
0694  083D     MOVF c, W
0695  1683     BSF STATUS, 0x5
0696  1703     BSF STATUS, 0x6
0697  00A8     MOVWF data
0698  1283     BCF STATUS, 0x5
0699  1303     BCF STATUS, 0x6
069A  083E     MOVF width, W
069B  1683     BSF STATUS, 0x5
069C  1703     BSF STATUS, 0x6
069D  00A9     MOVWF dato
069E  1283     BCF STATUS, 0x5
069F  1303     BCF STATUS, 0x6
06A0  083F     MOVF 0x3F, W
06A1  1683     BSF STATUS, 0x5
06A2  1703     BSF STATUS, 0x6
06A3  00AA     MOVWF Data
06A4  0828     MOVF data, W
06A5  1283     BCF STATUS, 0x5
06A6  1303     BCF STATUS, 0x6
06A7  00A3     MOVWF x
06A8  1683     BSF STATUS, 0x5
06A9  1703     BSF STATUS, 0x6
06AA  0829     MOVF dato, W
06AB  1283     BCF STATUS, 0x5
06AC  1303     BCF STATUS, 0x6
06AD  00A4     MOVWF Data
06AE  1683     BSF STATUS, 0x5
06AF  1703     BSF STATUS, 0x6
06B0  082A     MOVF Data, W
06B1  1283     BCF STATUS, 0x5
06B2  1303     BCF STATUS, 0x6
06B3  00A5     MOVWF y
06B4  120A     BCF PCLATH, 0x4
06B5  118A     BCF PCLATH, 0x3
06B6  2093     CALL 0x93
06B7  120A     BCF PCLATH, 0x4
06B8  118A     BCF PCLATH, 0x3
06B9  0824     MOVF Data, W
06BA  1683     BSF STATUS, 0x5
06BB  1703     BSF STATUS, 0x6
06BC  00AE     MOVWF min
06BD  1283     BCF STATUS, 0x5
06BE  1303     BCF STATUS, 0x6
06BF  0823     MOVF x, W
06C0  1683     BSF STATUS, 0x5
06C1  1703     BSF STATUS, 0x6
06C2  00AD     MOVWF hr
423:                           adcenteroV = (unsigned int) mediciondevoltaje;
06C3  0825     MOVF y, W
06C4  1283     BCF STATUS, 0x5
06C5  1303     BCF STATUS, 0x6
06C6  00A3     MOVWF x
06C7  1683     BSF STATUS, 0x5
06C8  1703     BSF STATUS, 0x6
06C9  0826     MOVF x, W
06CA  1283     BCF STATUS, 0x5
06CB  1303     BCF STATUS, 0x6
06CC  00A4     MOVWF Data
06CD  1683     BSF STATUS, 0x5
06CE  1703     BSF STATUS, 0x6
06CF  0827     MOVF i, W
06D0  1283     BCF STATUS, 0x5
06D1  1303     BCF STATUS, 0x6
06D2  00A5     MOVWF y
06D3  120A     BCF PCLATH, 0x4
06D4  118A     BCF PCLATH, 0x3
06D5  2093     CALL 0x93
06D6  120A     BCF PCLATH, 0x4
06D7  118A     BCF PCLATH, 0x3
06D8  0824     MOVF Data, W
06D9  1683     BSF STATUS, 0x5
06DA  1703     BSF STATUS, 0x6
06DB  00B0     MOVWF day
06DC  1283     BCF STATUS, 0x5
06DD  1303     BCF STATUS, 0x6
06DE  0823     MOVF x, W
06DF  1683     BSF STATUS, 0x5
06E0  1703     BSF STATUS, 0x6
06E1  00AF     MOVWF sec
424:                           sprintf(cadenaamostrar, "%2u.%uA   ", (unsigned int) adcenteroI, (unsigned int) adcdecimalI);
06E2  3098     MOVLW 0x98
06E3  1283     BCF STATUS, 0x5
06E4  1303     BCF STATUS, 0x6
06E5  00AF     MOVWF sec
06E6  3098     MOVLW 0x98
06E7  00B0     MOVWF day
06E8  1683     BSF STATUS, 0x5
06E9  1703     BSF STATUS, 0x6
06EA  082C     MOVF seconds, W
06EB  1283     BCF STATUS, 0x5
06EC  1303     BCF STATUS, 0x6
06ED  00B2     MOVWF 0x32
06EE  1683     BSF STATUS, 0x5
06EF  1703     BSF STATUS, 0x6
06F0  082B     MOVF val, W
06F1  1283     BCF STATUS, 0x5
06F2  1303     BCF STATUS, 0x6
06F3  00B1     MOVWF 0x31
06F4  1683     BSF STATUS, 0x5
06F5  1703     BSF STATUS, 0x6
06F6  082E     MOVF min, W
06F7  1283     BCF STATUS, 0x5
06F8  1303     BCF STATUS, 0x6
06F9  00B4     MOVWF sign
06FA  1683     BSF STATUS, 0x5
06FB  1703     BSF STATUS, 0x6
06FC  082D     MOVF hr, W
06FD  1283     BCF STATUS, 0x5
06FE  1303     BCF STATUS, 0x6
06FF  00B3     MOVWF 0x33
0700  30C8     MOVLW 0xC8
0701  120A     BCF PCLATH, 0x4
0702  158A     BSF PCLATH, 0x3
0703  222B     CALL 0x22B
0704  120A     BCF PCLATH, 0x4
0705  118A     BCF PCLATH, 0x3
425:                            sprintf(cadenaamostrar2, "%3uV    ", (unsigned int) adcenteroV);
0706  30F5     MOVLW 0xF5
0707  00AF     MOVWF sec
0708  3098     MOVLW 0x98
0709  00B0     MOVWF day
070A  1683     BSF STATUS, 0x5
070B  1703     BSF STATUS, 0x6
070C  0830     MOVF day, W
070D  1283     BCF STATUS, 0x5
070E  1303     BCF STATUS, 0x6
070F  00B2     MOVWF 0x32
0710  1683     BSF STATUS, 0x5
0711  1703     BSF STATUS, 0x6
0712  082F     MOVF sec, W
0713  1283     BCF STATUS, 0x5
0714  1303     BCF STATUS, 0x6
0715  00B1     MOVWF 0x31
0716  30D8     MOVLW 0xD8
0717  120A     BCF PCLATH, 0x4
0718  158A     BSF PCLATH, 0x3
0719  222B     CALL 0x22B
071A  120A     BCF PCLATH, 0x4
071B  118A     BCF PCLATH, 0x3
426:                           break;
071C  1683     BSF STATUS, 0x5
071D  2F33     GOTO 0x733
427:                       }
428:                       default:
429:                           break;
430:                   };
431:           
432:           
433:                   switch (activabomba) {
0733  1683     BSF STATUS, 0x5
0734  0833     MOVF 0x33, W
0735  3A00     XORLW 0x0
0736  1903     BTFSC STATUS, 0x2
0737  2F30     GOTO 0x730
0738  3A01     XORLW 0x1
0739  1903     BTFSC STATUS, 0x2
073A  2F2D     GOTO 0x72D
073B  2F3C     GOTO 0x73C
434:                       case ENCIENDEBOMBA:
435:                       {
436:                           salidabomba = 1;
072D  1283     BCF STATUS, 0x5
072E  1407     BSF PORTC, 0x0
437:                           break;
072F  2F3C     GOTO 0x73C
438:                       }
439:                       case APAGABOMBA:
440:                       {
441:                           salidabomba = 0;
0730  1283     BCF STATUS, 0x5
0731  1007     BCF PORTC, 0x0
442:                           break;
0732  2F3C     GOTO 0x73C
443:                       }
444:                   }
445:                   switch (estadobomba) {
073C  1683     BSF STATUS, 0x5
073D  083F     MOVF 0x3F, W
073E  3A00     XORLW 0x0
073F  1903     BTFSC STATUS, 0x2
0740  2F45     GOTO 0x745
0741  3A01     XORLW 0x1
0742  1903     BTFSC STATUS, 0x2
0743  2F45     GOTO 0x745
0744  2F45     GOTO 0x745
446:                       case BOMBAAPAGADA:
447:                       {
448:           
449:                           break;
450:                       }
451:                       case BOMBAENCENDIDA:
452:                       {
453:           
454:                           break;
455:                       }
456:           
457:           
458:                   }
459:                   switch (estadonivel) {
0745  0841     MOVF 0x41, W
0746  3A00     XORLW 0x0
0747  1903     BTFSC STATUS, 0x2
0748  2F4D     GOTO 0x74D
0749  3A01     XORLW 0x1
074A  1903     BTFSC STATUS, 0x2
074B  2F4D     GOTO 0x74D
074C  2F4D     GOTO 0x74D
460:                       case NIVELNORMAL:
461:                       {
462:           
463:                           break;
464:                       }
465:                       case NIVELBAJO:
466:                       {
467:           
468:                           break;
469:                       }
470:                       default:
471:                           break;
472:                   }
473:           
474:                   switch (estadofalla) {
074D  0840     MOVF _val, W
074E  3A00     XORLW 0x0
074F  1903     BTFSC STATUS, 0x2
0750  2F55     GOTO 0x755
0751  3A01     XORLW 0x1
0752  1903     BTFSC STATUS, 0x2
0753  2F55     GOTO 0x755
0754  2F55     GOTO 0x755
475:                       case CORRIENTENORMAL:
476:                       {
477:                           break;
478:                       }
479:                       case FALLACORRIENTE:
480:                       {
481:                           break;
482:                       }
483:           
484:                   }
485:                   //TODO borrAr esta linea
486:                   refrescadisplay = 1;
0755  01C4     CLRF sp
0756  0AC4     INCF sp, F
487:                   if (refrescadisplay) {
0757  1903     BTFSC STATUS, 0x2
0758  2F9A     GOTO 0x79A
488:                       vGotoxyLCD(1, 1);
0759  1283     BCF STATUS, 0x5
075A  3001     MOVLW 0x1
075B  01A5     CLRF y
075C  0AA5     INCF y, F
075D  160A     BSF PCLATH, 0x4
075E  118A     BCF PCLATH, 0x3
075F  269C     CALL 0x69C
0760  120A     BCF PCLATH, 0x4
0761  118A     BCF PCLATH, 0x3
489:                       char *cadena = &cadenaamostrar[0];
0762  30C8     MOVLW 0xC8
0763  1683     BSF STATUS, 0x5
0764  1703     BSF STATUS, 0x6
0765  00B2     MOVWF 0x32
490:                       while (*cadena != '\0')
0766  0832     MOVF 0x32, W
0767  0084     MOVWF FSR
0768  1383     BCF STATUS, 0x7
0769  0880     MOVF INDF, F
076A  1903     BTFSC STATUS, 0x2
076B  2F78     GOTO 0x778
0777  2F66     GOTO 0x766
491:                           vLCD_Putc(*cadena++);
076C  0832     MOVF 0x32, W
076D  0084     MOVWF FSR
076E  0800     MOVF INDF, W
076F  160A     BSF PCLATH, 0x4
0770  118A     BCF PCLATH, 0x3
0771  26BF     CALL 0x6BF
0772  120A     BCF PCLATH, 0x4
0773  118A     BCF PCLATH, 0x3
0774  1683     BSF STATUS, 0x5
0775  1703     BSF STATUS, 0x6
0776  0AB2     INCF 0x32, F
492:                       vGotoxyLCD(1, 2);
0778  3002     MOVLW 0x2
0779  1283     BCF STATUS, 0x5
077A  1303     BCF STATUS, 0x6
077B  00A5     MOVWF y
077C  3001     MOVLW 0x1
077D  160A     BSF PCLATH, 0x4
077E  118A     BCF PCLATH, 0x3
077F  269C     CALL 0x69C
0780  120A     BCF PCLATH, 0x4
0781  118A     BCF PCLATH, 0x3
493:               char *cadena = &cadenaamostrar2[0];
0782  30D8     MOVLW 0xD8
0783  1683     BSF STATUS, 0x5
0784  1703     BSF STATUS, 0x6
0785  00B2     MOVWF 0x32
494:               while (*cadena != '\0')
0786  0832     MOVF 0x32, W
0787  0084     MOVWF FSR
0788  1383     BCF STATUS, 0x7
0789  0880     MOVF INDF, F
078A  1903     BTFSC STATUS, 0x2
078B  2F98     GOTO 0x798
0797  2F86     GOTO 0x786
495:                   vLCD_Putc(*cadena++);
078C  0832     MOVF 0x32, W
078D  0084     MOVWF FSR
078E  0800     MOVF INDF, W
078F  160A     BSF PCLATH, 0x4
0790  118A     BCF PCLATH, 0x3
0791  26BF     CALL 0x6BF
0792  120A     BCF PCLATH, 0x4
0793  118A     BCF PCLATH, 0x3
0794  1683     BSF STATUS, 0x5
0795  1703     BSF STATUS, 0x6
0796  0AB2     INCF 0x32, F
496:                       
497:                       refrescadisplay = 0;
0798  1303     BCF STATUS, 0x6
0799  01C4     CLRF sp
498:                   }
499:           
500:                   //convierto el valor decimal a float
501:                   //para una entrada de 3.3V la lectura es 1023
502:                   //para 0 V la lectura es 0
503:                   //para una maxima lectura quiero que en el display se observe 50A
504:                   //como deseo que tambien me muetre los decimales.
505:                   //como la resolucion es 1024, cada bit corresponde a 50A/1024=0.048828125A
506:                   //cada 20 muestras tengo aproximdamente 1A
507:           
508:                   if (bandera_startglobal) {
079A  0836     MOVF exp1, W
079B  1903     BTFSC STATUS, 0x2
079C  2F9F     GOTO 0x79F
509:                       bandera_grabafechay_hora = 1;
079D  01B5     CLRF exp2
079E  0AB5     INCF exp2, F
510:           
511:                   }
512:                   if (!bandera_startglobal && bandera_grabafechay_hora) {
079F  08B6     MOVF exp1, F
07A0  1D03     BTFSS STATUS, 0x2
07A1  2FBC     GOTO 0x7BC
07A2  0835     MOVF exp2, W
07A3  1903     BTFSC STATUS, 0x2
07A4  2FBC     GOTO 0x7BC
513:           
514:                       isl1208_set_date_time(fecha.day, fecha.month, fecha.yr, fecha.dow, horario.hrs, horario.min, 00);
07A5  1283     BCF STATUS, 0x5
07A6  085F     MOVF 0x5F, W
07A7  00AA     MOVWF Data
07A8  0860     MOVF 0x60, W
07A9  00AB     MOVWF val
07AA  0861     MOVF 0x61, W
07AB  00AC     MOVWF seconds
07AC  1683     BSF STATUS, 0x5
07AD  086A     MOVF 0x6A, W
07AE  1283     BCF STATUS, 0x5
07AF  00AD     MOVWF hr
07B0  1683     BSF STATUS, 0x5
07B1  0869     MOVF 0x69, W
07B2  1283     BCF STATUS, 0x5
07B3  00AE     MOVWF min
07B4  01AF     CLRF sec
07B5  085E     MOVF fecha, W
07B6  120A     BCF PCLATH, 0x4
07B7  118A     BCF PCLATH, 0x3
07B8  21E1     CALL 0x1E1
07B9  120A     BCF PCLATH, 0x4
07BA  118A     BCF PCLATH, 0x3
515:                       bandera_grabafechay_hora = 0;
07BB  01B5     CLRF exp2
516:                   }
517:           
518:           
519:           
520:           
521:           
522:           
523:           
524:           
525:           
526:           
527:           
528:                   NOP();
07BC  0000     NOP
529:                   NOP();
07BD  0000     NOP
530:           
531:               }
532:           }
533:           
---  /media/Utilidades/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V4.X/interrupts.c  ----------------------
1:             
2:             /******************************************************************************/
3:             /*Files to Include                                                            */
4:             /******************************************************************************/
5:             
6:             #if defined(__XC)
7:             #include <xc.h>         /* XC8 General Include File */
8:             #elif defined(HI_TECH_C)
9:             #include <htc.h>        /* HiTech General Include File */
10:            #endif
11:            #include <stdbool.h>        /* For true/false definition */
12:            #include <stdint.h>
13:            #include "user.h"
14:            #include "system.h"
15:            
16:            #include "Pulsadores.h"
17:            #include "pwm.h"
18:            #include "adcPic16.h"
19:            /* Interrupt Routines                                                         */
20:            /******************************************************************************/
21:            
22:            /* Baseline devices don't have interrupts. Note that some PIC16's 
23:             * are baseline devices.  Unfortunately the baseline detection macro is 
24:             * _PIC12 */
25:            #ifndef _PIC18
26:            #ifndef _PIC12
27:            
28:            void interrupt isr(void) {
0004  00FE     MOVWF 0x7E
0005  0E03     SWAPF STATUS, W
0006  1283     BCF STATUS, 0x5
0007  1303     BCF STATUS, 0x6
0008  00A0     MOVWF 0x20
0009  0804     MOVF FSR, W
000A  00A1     MOVWF 0x21
000B  080A     MOVF PCLATH, W
000C  00A2     MOVWF 0x22
000D  120A     BCF PCLATH, 0x4
000E  158A     BSF PCLATH, 0x3
000F  2C82     GOTO 0x482
0010  120A     BCF PCLATH, 0x4
0011  118A     BCF PCLATH, 0x3
0012  2FBF     GOTO 0x7BF
29:                
30:                // di();
31:                if (RCIF) {
0C82  1E8C     BTFSS PIR1, 0x5
0C83  2C86     GOTO 0x486
32:                    //rec=0x00;
33:                    //  rec=RCREG;//rec=getc();
34:                    //  rec=0x00;
35:                    RCIF = 0;
0C84  128C     BCF PIR1, 0x5
36:                } else if (ADIF) {
0C85  2EF0     GOTO 0x6F0
0C86  1F0C     BTFSS PIR1, 0x6
0C87  2CAB     GOTO 0x4AB
37:            
38:                    if (getADCChannel() == MIDECORRIENTE) {
0C88  27F7     CALL 0x7F7
0C89  120A     BCF PCLATH, 0x4
0C8A  158A     BSF PCLATH, 0x3
0C8B  3800     IORLW 0x0
0C8C  1D03     BTFSS STATUS, 0x2
0C8D  2C9A     GOTO 0x49A
39:                        medidaI_adc = adcRead();
0C8E  27C1     CALL 0x7C1
0C8F  120A     BCF PCLATH, 0x4
0C90  158A     BSF PCLATH, 0x3
0C91  0872     MOVF canal, W
0C92  00AE     MOVWF min
0C93  0871     MOVF divisor, W
0C94  00AD     MOVWF hr
40:                        setADCChannel(MIDETENSION);
0C95  3001     MOVLW 0x1
0C96  27EB     CALL 0x7EB
0C97  120A     BCF PCLATH, 0x4
0C98  158A     BSF PCLATH, 0x3
41:                    } else {
0C99  2CA5     GOTO 0x4A5
42:                        setADCChannel(MIDECORRIENTE);
0C9A  3000     MOVLW 0x0
0C9B  27EB     CALL 0x7EB
0C9C  120A     BCF PCLATH, 0x4
0C9D  158A     BSF PCLATH, 0x3
43:                        medidaV_adc = adcRead();
0C9E  27C1     CALL 0x7C1
0C9F  120A     BCF PCLATH, 0x4
0CA0  158A     BSF PCLATH, 0x3
0CA1  0872     MOVF canal, W
0CA2  00B0     MOVWF day
0CA3  0871     MOVF divisor, W
0CA4  00AF     MOVWF sec
44:                    }
45:                    ADIF = 0;
0CA5  1283     BCF STATUS, 0x5
0CA6  130C     BCF PIR1, 0x6
46:                    cambio_de_canal=1;
0CA7  1683     BSF STATUS, 0x5
0CA8  01B8     CLRF 0x38
0CA9  0AB8     INCF 0x38, F
47:                } else if (INTF) { // INTERRUPCION por EXT2 Clock Out --------------------------------------------
0CAA  2EF0     GOTO 0x6F0
0CAB  1C8B     BTFSS INTCON, 0x1
0CAC  2CBA     GOTO 0x4BA
48:                    if (INTEDG == 1) {
0CAD  1683     BSF STATUS, 0x5
0CAE  1F01     BTFSS TMR0, 0x6
0CAF  2CB3     GOTO 0x4B3
49:                        //      ext_int_edge(2,H_TO_L);
50:                        INTEDG = 0;
0CB0  1301     BCF TMR0, 0x6
51:                        flanco = 0;
0CB1  01FD     CLRF flanco
52:                        //PORTEbits.RE0 = 1; //output_high(PIN_E0);
53:                    } else {
0CB2  2CB6     GOTO 0x4B6
54:                        //   ext_int_edge(2,L_TO_H);
55:                        INTEDG = 1;
0CB3  1701     BSF TMR0, 0x6
56:                        flanco = 1;
0CB4  01FD     CLRF flanco
0CB5  0AFD     INCF flanco, F
57:                        // PORTEbits.RE0 = 0; //output_low(PIN_E0);
58:                        //      flanco=1;
59:            
60:                    }
61:                    refrescadisplay = 1;
0CB6  01C4     CLRF sp
0CB7  0AC4     INCF sp, F
62:                    INTF = 0;
0CB8  108B     BCF INTCON, 0x1
63:                } else if (INTCONbits.T0IF) {
0CB9  2EF0     GOTO 0x6F0
0CBA  1D0B     BTFSS INTCON, 0x2
0CBB  2EF0     GOTO 0x6F0
64:            
65:                    //Interrupcion por desborde del timer0. Tal como esta configurado, se el timer desborda cada
66:                    //0.003264seg o sea 3.264 ms, por lo tanto para que pase alrededor de 0.5segundo, se debe entrar 150 veces
67:                    //como con un unsigned int no funciona uso unsigned char y solo hasta 150
68:                    //cada 3ms realizamos una conversion analogica para obtener la medida de corriente
69:                    if (cambio_de_canal)
0CBC  1683     BSF STATUS, 0x5
0CBD  0838     MOVF 0x38, W
0CBE  1903     BTFSC STATUS, 0x2
0CBF  2CC2     GOTO 0x4C2
70:                        cambio_de_canal=0;
0CC0  01B8     CLRF 0x38
0CC1  2CC5     GOTO 0x4C5
71:                    else
72:                    startADC();
0CC2  27FD     CALL 0x7FD
0CC3  120A     BCF PCLATH, 0x4
0CC4  158A     BSF PCLATH, 0x3
73:                    if (cuenta40ms < 12) {
0CC5  300C     MOVLW 0xC
0CC6  1683     BSF STATUS, 0x5
0CC7  0239     SUBWF 0x39, W
0CC8  1803     BTFSC STATUS, 0x0
0CC9  2CCC     GOTO 0x4CC
74:                        cuenta40ms++;
0CCA  0AB9     INCF 0x39, F
75:                    } else {
0CCB  2D01     GOTO 0x501
76:                        cuenta40ms = 0;
0CCC  01B9     CLRF 0x39
77:                        if (activapor > 0) {
0CCD  0834     MOVF sign, W
0CCE  1903     BTFSC STATUS, 0x2
0CCF  2CD2     GOTO 0x4D2
78:                            activapor--;
0CD0  03B4     DECF sign, F
79:                        } else {
0CD1  2CD9     GOTO 0x4D9
80:                            buzzer_off();
0CD2  160A     BSF PCLATH, 0x4
0CD3  118A     BCF PCLATH, 0x3
0CD4  2626     CALL 0x626
0CD5  120A     BCF PCLATH, 0x4
0CD6  158A     BSF PCLATH, 0x3
81:                            activapor = 0;
0CD7  1683     BSF STATUS, 0x5
0CD8  01B4     CLRF sign
82:                        }
83:                        if (cuenta500ms < 11) {
0CD9  300B     MOVLW 0xB
0CDA  023A     SUBWF prec, W
0CDB  1803     BTFSC STATUS, 0x0
0CDC  2CDF     GOTO 0x4DF
84:                            cuenta500ms++;
0CDD  0ABA     INCF prec, F
85:            
86:            
87:                        } else {
0CDE  2D01     GOTO 0x501
88:                            TRISDbits.TRISD3=0;
0CDF  1188     BCF PORTD, 0x3
89:                           
90:                            PORTDbits.RD3=~PORTDbits.RD3;
0CE0  3008     MOVLW 0x8
0CE1  1283     BCF STATUS, 0x5
0CE2  0688     XORWF PORTD, F
91:                            cuenta500ms = 0;
0CE3  1683     BSF STATUS, 0x5
0CE5  01BA     CLRF prec
92:            
93:                            if (cuentasegundos < 60) {
0CE4  303C     MOVLW 0x3C
0CE6  023E     SUBWF width, W
0CE7  1803     BTFSC STATUS, 0x0
0CE8  2CEB     GOTO 0x4EB
94:            
95:                                cuentasegundos++;
0CE9  0ABE     INCF width, F
96:                            } else {
0CEA  2D01     GOTO 0x501
97:                                cuentasegundos = 0;
0CEB  303C     MOVLW 0x3C
0CEC  01BE     CLRF width
98:                                if (cuentaminutos < 60) {
0CEB  303C     MOVLW 0x3C
0CED  023D     SUBWF c, W
0CEE  1803     BTFSC STATUS, 0x0
0CEF  2CF2     GOTO 0x4F2
99:                                    cuentaminutos++;
0CF0  0ABD     INCF c, F
100:                               } else {
0CF1  2D01     GOTO 0x501
101:                                   cuentaminutos = 0;
0CF2  3018     MOVLW 0x18
0CF3  01BD     CLRF c
102:                                   if (cuentahoras < 24) {
0CF2  3018     MOVLW 0x18
0CF4  023C     SUBWF flag, W
0CF5  1803     BTFSC STATUS, 0x0
0CF6  2CF9     GOTO 0x4F9
103:                                       cuentahoras++;
0CF7  0ABC     INCF flag, F
104:                                   } else
0CF8  2CFA     GOTO 0x4FA
105:                                       cuentahoras = 0;
0CF9  01BC     CLRF flag
106:                                   if (cuentadias < 30) {
0CFA  301E     MOVLW 0x1E
0CFB  023B     SUBWF ap, W
0CFC  1803     BTFSC STATUS, 0x0
0CFD  2D00     GOTO 0x500
107:                                       cuentadias++;
0CFE  0ABB     INCF ap, F
108:                                   } else {
0CFF  2D01     GOTO 0x501
109:                                       cuentadias = 0;
0D00  01BB     CLRF ap
110:                                   }
111:                               }
112:           
113:                           }
114:                       }
115:                   }
116:           
117:           
118:                   //interrupcion_pulsadores();
119:                   static char maximodia;
120:                   //TODO calculo de los segundos y minutos que pasaron
121:           
122:           
123:                   if (Pulsacion(0, BOTON_Subir, CON_REPETICION, LOGICA_INVERSA)) {
0D01  3000     MOVLW 0x0
0D02  1283     BCF STATUS, 0x5
0D03  1886     BTFSC PORTB, 0x1
0D04  3001     MOVLW 0x1
0D05  00F6     MOVWF Pin
0D06  3000     MOVLW 0x0
0D07  01F7     CLRF TipoPin
0D08  0AF7     INCF TipoPin, F
0D09  01F8     CLRF Logica
0D0A  0AF8     INCF Logica, F
0D0B  26FB     CALL 0x6FB
0D0C  120A     BCF PCLATH, 0x4
0D0D  158A     BSF PCLATH, 0x3
0D0E  3A00     XORLW 0x0
0D0F  1903     BTFSC STATUS, 0x2
0D10  2DE0     GOTO 0x5E0
124:           
125:                       refrescadisplay = 1;
0D11  1683     BSF STATUS, 0x5
0D12  1303     BCF STATUS, 0x6
0D13  01C4     CLRF sp
0D14  0AC4     INCF sp, F
126:                       switch (modificafecha) {
0D15  2D81     GOTO 0x581
0D81  086B     MOVF 0x6B, W
0D82  0084     MOVWF FSR
0D83  3009     MOVLW 0x9
0D84  0204     SUBWF FSR, W
0D85  1803     BTFSC STATUS, 0x0
0D86  2D8E     GOTO 0x58E
0D87  3010     MOVLW 0x10
0D88  008A     MOVWF PCLATH
0D89  1003     BCF STATUS, 0x0
0D8A  0D04     RLF FSR, W
0D8B  0704     ADDWF FSR, W
0D8C  3E00     ADDLW 0x0
0D8D  0082     MOVWF PCL
1000  120A     BCF PCLATH, 0x4
1001  158A     BSF PCLATH, 0x3
1002  2D24     GOTO 0x524
1003  120A     BCF PCLATH, 0x4
1004  158A     BSF PCLATH, 0x3
1005  2D16     GOTO 0x516
1006  120A     BCF PCLATH, 0x4
1007  158A     BSF PCLATH, 0x3
1008  2D32     GOTO 0x532
1009  120A     BCF PCLATH, 0x4
100A  158A     BSF PCLATH, 0x3
100B  2D42     GOTO 0x542
100C  120A     BCF PCLATH, 0x4
100D  158A     BSF PCLATH, 0x3
100E  2D50     GOTO 0x550
100F  120A     BCF PCLATH, 0x4
1010  158A     BSF PCLATH, 0x3
1011  2D8E     GOTO 0x58E
1012  120A     BCF PCLATH, 0x4
1013  158A     BSF PCLATH, 0x3
1014  2D5F     GOTO 0x55F
1015  120A     BCF PCLATH, 0x4
1016  158A     BSF PCLATH, 0x3
1017  2D65     GOTO 0x565
1018  120A     BCF PCLATH, 0x4
1019  158A     BSF PCLATH, 0x3
101A  2D73     GOTO 0x573
127:                           case MINUTOS:
0D16  303C     MOVLW 0x3C
128:                               haycambio = 1;
0D17  01C2     CLRF 0x42
0D18  0AC2     INCF 0x42, F
129:                               if (horario.min < 60) horario.min++;
0D16  303C     MOVLW 0x3C
0D19  0269     SUBWF 0x69, W
0D1A  1803     BTFSC STATUS, 0x0
0D1B  2D1E     GOTO 0x51E
0D1C  0AE9     INCF 0x69, F
0D1D  2D8E     GOTO 0x58E
130:                               else
131:                                   if (horario.min == 60) horario.min = 0;
0D1E  0869     MOVF 0x69, W
0D1F  3A3C     XORLW 0x3C
0D20  1D03     BTFSS STATUS, 0x2
0D21  2D8E     GOTO 0x58E
0D22  01E9     CLRF 0x69
0D23  2D8E     GOTO 0x58E
132:                               break;
133:                           case HORA:
0D24  3017     MOVLW 0x17
134:                               haycambio = 1;
0D25  01C2     CLRF 0x42
0D26  0AC2     INCF 0x42, F
135:                               if (horario.hrs < 23) horario.hrs++;
0D24  3017     MOVLW 0x17
0D27  026A     SUBWF 0x6A, W
0D28  1803     BTFSC STATUS, 0x0
0D29  2D2C     GOTO 0x52C
0D2A  0AEA     INCF 0x6A, F
0D2B  2D8E     GOTO 0x58E
136:                               else
137:                                   if (horario.hrs == 23) horario.hrs = 0;
0D2C  086A     MOVF 0x6A, W
0D2D  3A17     XORLW 0x17
0D2E  1D03     BTFSS STATUS, 0x2
0D2F  2D8E     GOTO 0x58E
0D30  01EA     CLRF 0x6A
0D31  2D8E     GOTO 0x58E
138:                               break;
139:                           case DIA:
140:                               haycambio = 1;
0D32  01C2     CLRF 0x42
0D33  0AC2     INCF 0x42, F
141:                               if (fecha.day < maximodia) fecha.day++;
0D34  0847     MOVF f3_as_product, W
0D35  1283     BCF STATUS, 0x5
0D36  025E     SUBWF fecha, W
0D37  1C03     BTFSS STATUS, 0x0
0D38  2D40     GOTO 0x540
142:                               else
143:                                   if (fecha.day == maximodia) fecha.day = 1;
0D39  085E     MOVF fecha, W
0D3A  1683     BSF STATUS, 0x5
0D3B  0647     XORWF f3_as_product, W
0D3C  1D03     BTFSS STATUS, 0x2
0D3D  2D8E     GOTO 0x58E
0D3E  1283     BCF STATUS, 0x5
0D3F  01DE     CLRF fecha
0D40  0ADE     INCF fecha, F
0D41  2D8E     GOTO 0x58E
144:                               break;
145:                           case MES:
0D42  300C     MOVLW 0xC
146:                               haycambio = 1;
0D43  01C2     CLRF 0x42
0D44  0AC2     INCF 0x42, F
147:                               if (fecha.month < 12) fecha.month++;
0D42  300C     MOVLW 0xC
0D45  1283     BCF STATUS, 0x5
0D46  025F     SUBWF 0x5F, W
0D47  1C03     BTFSS STATUS, 0x0
0D48  2D4E     GOTO 0x54E
148:                               else
149:                                   if (fecha.month == 12) fecha.month = 1;
0D49  085F     MOVF 0x5F, W
0D4A  3A0C     XORLW 0xC
0D4B  1D03     BTFSS STATUS, 0x2
0D4C  2D8E     GOTO 0x58E
0D4D  01DF     CLRF 0x5F
0D4E  0ADF     INCF 0x5F, F
0D4F  2D8E     GOTO 0x58E
150:                               break;
151:                           case ANIO:
0D50  3063     MOVLW 0x63
152:                               haycambio = 1;
0D51  01C2     CLRF 0x42
0D52  0AC2     INCF 0x42, F
153:                               if (fecha.yr < 99) fecha.yr++; //solamente vamos hasta el ao 00
0D50  3063     MOVLW 0x63
0D53  1283     BCF STATUS, 0x5
0D54  0260     SUBWF 0x60, W
0D55  1803     BTFSC STATUS, 0x0
0D56  2D59     GOTO 0x559
0D57  0AE0     INCF 0x60, F
0D58  2D8E     GOTO 0x58E
154:                               else
155:                                   if (fecha.yr == 99) fecha.yr = 0; //solamente contamos desde el ao 99
0D59  0860     MOVF 0x60, W
0D5A  3A63     XORLW 0x63
0D5B  1D03     BTFSS STATUS, 0x2
0D5C  2D8E     GOTO 0x58E
0D5D  01E0     CLRF 0x60
0D5E  2D8E     GOTO 0x58E
156:                               break;
157:                           case SINO:
158:                               banderasino = !banderasino;
0D5F  3000     MOVLW 0x0
0D60  08B7     MOVF f2, F
0D61  1903     BTFSC STATUS, 0x2
0D62  3001     MOVLW 0x1
0D63  00B7     MOVWF f2
159:                               break;
0D64  2D8E     GOTO 0x58E
160:                           case TIEMPOENCENDIDO:
0D65  303C     MOVLW 0x3C
161:                               haycambio = 1;
0D66  01C2     CLRF 0x42
0D67  0AC2     INCF 0x42, F
162:                               if (tiempoencendido < TIEMPOMAXIMOENCENDIDO) tiempoencendido++; //
0D65  303C     MOVLW 0x3C
0D68  0245     SUBWF 0x45, W
0D69  1803     BTFSC STATUS, 0x0
0D6A  2D6D     GOTO 0x56D
0D6B  0AC5     INCF 0x45, F
0D6C  2D8E     GOTO 0x58E
163:                               else
164:                                   if (tiempoencendido == TIEMPOMAXIMOENCENDIDO) tiempoencendido = 0;
0D6D  0845     MOVF 0x45, W
0D6E  3A3C     XORLW 0x3C
0D6F  1D03     BTFSS STATUS, 0x2
0D70  2D8E     GOTO 0x58E
0D71  01C5     CLRF 0x45
0D72  2D8E     GOTO 0x58E
165:                               break;
166:                           case TIEMPOFALLA:
0D73  301E     MOVLW 0x1E
167:                               haycambio = 1;
0D74  01C2     CLRF 0x42
0D75  0AC2     INCF 0x42, F
168:                               if (tiempofalla < TIEMPOMAXIMOFALLA) tiempofalla++; //
0D73  301E     MOVLW 0x1E
0D76  0246     SUBWF exp, W
0D77  1803     BTFSC STATUS, 0x0
0D78  2D7B     GOTO 0x57B
0D79  0AC6     INCF exp, F
0D7A  2D8E     GOTO 0x58E
169:                               else
170:                                   if (tiempofalla == TIEMPOMAXIMOFALLA) tiempofalla = 0;
0D7B  0846     MOVF exp, W
0D7C  3A1E     XORLW 0x1E
0D7D  1D03     BTFSS STATUS, 0x2
0D7E  2D8E     GOTO 0x58E
0D7F  01C6     CLRF exp
0D80  2D8E     GOTO 0x58E
171:                               break;
172:           
173:                           default:
174:                               break;
175:                       }
176:                       if (aniobisiesto(fecha.yr) && fecha.month == 2) {
0D8E  1283     BCF STATUS, 0x5
0D8F  0860     MOVF 0x60, W
0D90  27C8     CALL 0x7C8
0D91  120A     BCF PCLATH, 0x4
0D92  158A     BSF PCLATH, 0x3
0D93  0878     MOVF Logica, W
0D94  0477     IORWF TipoPin, W
0D95  1903     BTFSC STATUS, 0x2
0D96  2D9D     GOTO 0x59D
0D97  085F     MOVF 0x5F, W
0D98  3A02     XORLW 0x2
0D99  1D03     BTFSS STATUS, 0x2
0D9A  2D9D     GOTO 0x59D
177:                           maximodia = 29;
0D9B  301D     MOVLW 0x1D
0D9C  2DA2     GOTO 0x5A2
178:                       } else if (fecha.month == 2)
0D9D  085F     MOVF 0x5F, W
0D9E  3A02     XORLW 0x2
0D9F  1D03     BTFSS STATUS, 0x2
0DA0  2DA4     GOTO 0x5A4
179:                           maximodia = 28;
0DA1  301C     MOVLW 0x1C
0DA2  1683     BSF STATUS, 0x5
0DA3  00C7     MOVWF f3_as_product
180:                       if (fecha.month == 4 || fecha.month == 6 || fecha.month == 9 || fecha.month == 11) {
0DA4  1283     BCF STATUS, 0x5
0DA5  085F     MOVF 0x5F, W
0DA6  3A04     XORLW 0x4
0DA7  1903     BTFSC STATUS, 0x2
0DA8  2DB5     GOTO 0x5B5
0DA9  085F     MOVF 0x5F, W
0DAA  3A06     XORLW 0x6
0DAB  1903     BTFSC STATUS, 0x2
0DAC  2DB5     GOTO 0x5B5
0DAD  085F     MOVF 0x5F, W
0DAE  3A09     XORLW 0x9
0DAF  1903     BTFSC STATUS, 0x2
0DB0  2DB5     GOTO 0x5B5
0DB1  085F     MOVF 0x5F, W
0DB2  3A0B     XORLW 0xB
0DB3  1D03     BTFSS STATUS, 0x2
0DB4  2DB8     GOTO 0x5B8
181:                           maximodia = 30;
0DB5  301E     MOVLW 0x1E
0DB6  1683     BSF STATUS, 0x5
0DB7  00C7     MOVWF f3_as_product
182:                       }
183:                       if (fecha.month == 1 || fecha.month == 3 || fecha.month == 5 || fecha.month == 7 || fecha.month == 8 || fecha.month == 10 || fecha.month == 12) {
0DB8  1283     BCF STATUS, 0x5
0DB9  035F     DECF 0x5F, W
0DBA  1903     BTFSC STATUS, 0x2
0DBB  2DD4     GOTO 0x5D4
0DBC  085F     MOVF 0x5F, W
0DBD  3A03     XORLW 0x3
0DBE  1903     BTFSC STATUS, 0x2
0DBF  2DD4     GOTO 0x5D4
0DC0  085F     MOVF 0x5F, W
0DC1  3A05     XORLW 0x5
0DC2  1903     BTFSC STATUS, 0x2
0DC3  2DD4     GOTO 0x5D4
0DC4  085F     MOVF 0x5F, W
0DC5  3A07     XORLW 0x7
0DC6  1903     BTFSC STATUS, 0x2
0DC7  2DD4     GOTO 0x5D4
0DC8  085F     MOVF 0x5F, W
0DC9  3A08     XORLW 0x8
0DCA  1903     BTFSC STATUS, 0x2
0DCB  2DD4     GOTO 0x5D4
0DCC  085F     MOVF 0x5F, W
0DCD  3A0A     XORLW 0xA
0DCE  1903     BTFSC STATUS, 0x2
0DCF  2DD4     GOTO 0x5D4
0DD0  085F     MOVF 0x5F, W
0DD1  3A0C     XORLW 0xC
0DD2  1D03     BTFSS STATUS, 0x2
0DD3  2DD7     GOTO 0x5D7
184:                           maximodia = 31;
0DD4  301F     MOVLW 0x1F
0DD5  1683     BSF STATUS, 0x5
0DD6  00C7     MOVWF f3_as_product
185:                       }
186:                       if (fecha.day > maximodia)
0DD7  1283     BCF STATUS, 0x5
0DD8  085E     MOVF fecha, W
0DD9  1683     BSF STATUS, 0x5
0DDA  0247     SUBWF f3_as_product, W
0DDB  1803     BTFSC STATUS, 0x0
0DDC  2DE0     GOTO 0x5E0
187:                           fecha.day = maximodia;
0DDD  0847     MOVF f3_as_product, W
0DDE  1283     BCF STATUS, 0x5
0DDF  00DE     MOVWF fecha
188:                   }
189:                   if (Pulsacion(1, BOTON_Bajar, CON_REPETICION, LOGICA_INVERSA)) {
0DE0  3000     MOVLW 0x0
0DE1  1283     BCF STATUS, 0x5
0DE2  1303     BCF STATUS, 0x6
0DE3  1906     BTFSC PORTB, 0x2
0DE4  3001     MOVLW 0x1
0DE5  00F6     MOVWF Pin
0DE6  3001     MOVLW 0x1
0DE7  01F7     CLRF TipoPin
0DE8  0AF7     INCF TipoPin, F
0DE9  01F8     CLRF Logica
0DEA  0AF8     INCF Logica, F
0DEB  26FB     CALL 0x6FB
0DEC  120A     BCF PCLATH, 0x4
0DED  158A     BSF PCLATH, 0x3
0DEE  3A00     XORLW 0x0
0DEF  1903     BTFSC STATUS, 0x2
0DF0  2EBB     GOTO 0x6BB
190:           
191:                       refrescadisplay = 1;
0DF1  1683     BSF STATUS, 0x5
0DF2  1303     BCF STATUS, 0x6
0DF3  01C4     CLRF sp
0DF4  0AC4     INCF sp, F
192:                       switch (modificafecha) {
0DF5  2E5C     GOTO 0x65C
0E5C  086B     MOVF 0x6B, W
0E5D  0084     MOVWF FSR
0E5E  3009     MOVLW 0x9
0E5F  0204     SUBWF FSR, W
0E60  1803     BTFSC STATUS, 0x0
0E61  2E69     GOTO 0x669
0E62  3010     MOVLW 0x10
0E63  008A     MOVWF PCLATH
0E64  1003     BCF STATUS, 0x0
0E65  0D04     RLF FSR, W
0E66  0704     ADDWF FSR, W
0E67  3E1B     ADDLW 0x1B
0E68  0082     MOVWF PCL
101B  120A     BCF PCLATH, 0x4
193:                           case MINUTOS:
194:                               haycambio = 1;
0DF6  01C2     CLRF 0x42
0DF7  0AC2     INCF 0x42, F
195:                               if (horario.min > 0) horario.min--;
0DF8  0869     MOVF 0x69, W
0DF9  1903     BTFSC STATUS, 0x2
0DFA  2DFD     GOTO 0x5FD
0DFB  03E9     DECF 0x69, F
0DFC  2E69     GOTO 0x669
196:                               else
197:                                   if (horario.min == 0) horario.min = 59;
0DFD  08E9     MOVF 0x69, F
0DFE  1D03     BTFSS STATUS, 0x2
0DFF  2E69     GOTO 0x669
0E00  303B     MOVLW 0x3B
0E01  00E9     MOVWF 0x69
0E02  2E69     GOTO 0x669
198:                               break;
199:                           case HORA:
200:                               haycambio = 1;
0E03  01C2     CLRF 0x42
0E04  0AC2     INCF 0x42, F
201:                               if (horario.hrs > 0) horario.hrs--;
0E05  086A     MOVF 0x6A, W
0E06  1903     BTFSC STATUS, 0x2
0E07  2E0A     GOTO 0x60A
0E08  03EA     DECF 0x6A, F
0E09  2E69     GOTO 0x669
202:                               else
203:                                   if (horario.hrs == 0) horario.hrs = 23;
0E0A  08EA     MOVF 0x6A, F
0E0B  1D03     BTFSS STATUS, 0x2
0E0C  2E69     GOTO 0x669
0E0D  3017     MOVLW 0x17
0E0E  00EA     MOVWF 0x6A
0E0F  2E69     GOTO 0x669
204:                               break;
205:                           case DIA:
0E10  3002     MOVLW 0x2
206:                               haycambio = 1;
0E11  01C2     CLRF 0x42
0E12  0AC2     INCF 0x42, F
207:                               if (fecha.day > 1) fecha.day--;
0E10  3002     MOVLW 0x2
0E13  1283     BCF STATUS, 0x5
0E14  025E     SUBWF fecha, W
0E15  1C03     BTFSS STATUS, 0x0
0E16  2E19     GOTO 0x619
0E17  03DE     DECF fecha, F
0E18  2E69     GOTO 0x669
208:                               else
209:                                   if (fecha.day == 1) fecha.day = maximodia;
0E19  0B5E     DECFSZ fecha, W
0E1A  2E69     GOTO 0x669
0E1B  1683     BSF STATUS, 0x5
0E1C  0847     MOVF f3_as_product, W
0E1D  1283     BCF STATUS, 0x5
0E1E  00DE     MOVWF fecha
0E1F  2E69     GOTO 0x669
210:                               break;
211:                           case MES:
0E20  3002     MOVLW 0x2
212:                               haycambio = 1;
0E21  01C2     CLRF 0x42
0E22  0AC2     INCF 0x42, F
213:                               if (fecha.month > 1) fecha.month--;
0E20  3002     MOVLW 0x2
0E23  1283     BCF STATUS, 0x5
0E24  025F     SUBWF 0x5F, W
0E25  1C03     BTFSS STATUS, 0x0
0E26  2E29     GOTO 0x629
0E27  03DF     DECF 0x5F, F
0E28  2E69     GOTO 0x669
214:                               else
215:                                   if (fecha.month == 1) fecha.month = 12;
0E29  0B5F     DECFSZ 0x5F, W
0E2A  2E69     GOTO 0x669
0E2B  300C     MOVLW 0xC
0E2C  00DF     MOVWF 0x5F
0E2D  2E69     GOTO 0x669
216:                               break;
217:                           case ANIO:
218:                               haycambio = 1;
0E2E  01C2     CLRF 0x42
0E2F  0AC2     INCF 0x42, F
219:                               if (fecha.yr > 0) fecha.yr--; //solamente vamos hasta el ao 00
0E30  1283     BCF STATUS, 0x5
0E31  0860     MOVF 0x60, W
0E32  1903     BTFSC STATUS, 0x2
0E33  2E36     GOTO 0x636
0E34  03E0     DECF 0x60, F
0E35  2E69     GOTO 0x669
220:                               else
221:                                   if (fecha.yr == 0) fecha.yr = 99; //solamente contamos desde el ao 99
0E36  08E0     MOVF 0x60, F
0E37  1D03     BTFSS STATUS, 0x2
0E38  2E69     GOTO 0x669
0E39  3063     MOVLW 0x63
0E3A  00E0     MOVWF 0x60
0E3B  2E69     GOTO 0x669
222:                               break;
223:                           case SINO:
224:                               banderasino = !banderasino;
0E3C  3000     MOVLW 0x0
0E3D  08B7     MOVF f2, F
0E3E  1903     BTFSC STATUS, 0x2
0E3F  3001     MOVLW 0x1
0E40  00B7     MOVWF f2
225:                               break;
0E41  2E69     GOTO 0x669
226:                           case TIEMPOENCENDIDO:
227:                               haycambio = 1;
0E42  01C2     CLRF 0x42
0E43  0AC2     INCF 0x42, F
228:                               if (tiempoencendido > 0) tiempoencendido--; //
0E44  0845     MOVF 0x45, W
0E45  1903     BTFSC STATUS, 0x2
0E46  2E49     GOTO 0x649
0E47  03C5     DECF 0x45, F
0E48  2E69     GOTO 0x669
229:                               else
230:                                   if (tiempoencendido == 0) tiempoencendido = TIEMPOMAXIMOENCENDIDO;
0E49  08C5     MOVF 0x45, F
0E4A  1D03     BTFSS STATUS, 0x2
0E4B  2E69     GOTO 0x669
0E4C  303C     MOVLW 0x3C
0E4D  00C5     MOVWF 0x45
0E4E  2E69     GOTO 0x669
231:                               break;
232:                           case TIEMPOFALLA:
233:                               haycambio = 1;
0E4F  01C2     CLRF 0x42
0E50  0AC2     INCF 0x42, F
234:                               if (tiempofalla > 0) tiempofalla--; //
0E51  0846     MOVF exp, W
0E52  1903     BTFSC STATUS, 0x2
0E53  2E56     GOTO 0x656
0E54  03C6     DECF exp, F
0E55  2E69     GOTO 0x669
235:                               else
236:                                   if (tiempofalla == 0) tiempofalla = TIEMPOMAXIMOFALLA;
0E56  08C6     MOVF exp, F
0E57  1D03     BTFSS STATUS, 0x2
0E58  2E69     GOTO 0x669
0E59  301E     MOVLW 0x1E
0E5A  00C6     MOVWF exp
0E5B  2E69     GOTO 0x669
237:                               break;
238:                           default:
239:                               break;
240:                       }
241:                       if (aniobisiesto(fecha.yr) && fecha.month == 2) {
0E69  1283     BCF STATUS, 0x5
0E6A  0860     MOVF 0x60, W
0E6B  27C8     CALL 0x7C8
0E6C  120A     BCF PCLATH, 0x4
0E6D  158A     BSF PCLATH, 0x3
0E6E  0878     MOVF Logica, W
0E6F  0477     IORWF TipoPin, W
0E70  1903     BTFSC STATUS, 0x2
0E71  2E78     GOTO 0x678
0E72  085F     MOVF 0x5F, W
0E73  3A02     XORLW 0x2
0E74  1D03     BTFSS STATUS, 0x2
0E75  2E78     GOTO 0x678
242:                           maximodia = 29;
0E76  301D     MOVLW 0x1D
0E77  2E7D     GOTO 0x67D
243:                       } else if (fecha.month == 2)
0E78  085F     MOVF 0x5F, W
0E79  3A02     XORLW 0x2
0E7A  1D03     BTFSS STATUS, 0x2
0E7B  2E7F     GOTO 0x67F
244:                           maximodia = 28;
0E7C  301C     MOVLW 0x1C
0E7D  1683     BSF STATUS, 0x5
0E7E  00C7     MOVWF f3_as_product
245:                       if (fecha.month == 4 || fecha.month == 6 || fecha.month == 9 || fecha.month == 11) {
0E7F  1283     BCF STATUS, 0x5
0E80  085F     MOVF 0x5F, W
0E81  3A04     XORLW 0x4
0E82  1903     BTFSC STATUS, 0x2
0E83  2E90     GOTO 0x690
0E84  085F     MOVF 0x5F, W
0E85  3A06     XORLW 0x6
0E86  1903     BTFSC STATUS, 0x2
0E87  2E90     GOTO 0x690
0E88  085F     MOVF 0x5F, W
0E89  3A09     XORLW 0x9
0E8A  1903     BTFSC STATUS, 0x2
0E8B  2E90     GOTO 0x690
0E8C  085F     MOVF 0x5F, W
0E8D  3A0B     XORLW 0xB
0E8E  1D03     BTFSS STATUS, 0x2
0E8F  2E93     GOTO 0x693
246:                           maximodia = 30;
0E90  301E     MOVLW 0x1E
0E91  1683     BSF STATUS, 0x5
0E92  00C7     MOVWF f3_as_product
247:                       }
248:                       if (fecha.month == 1 || fecha.month == 3 || fecha.month == 5 || fecha.month == 7 || fecha.month == 8 || fecha.month == 10 || fecha.month == 12) {
0E93  1283     BCF STATUS, 0x5
0E94  035F     DECF 0x5F, W
0E95  1903     BTFSC STATUS, 0x2
0E96  2EAF     GOTO 0x6AF
0E97  085F     MOVF 0x5F, W
0E98  3A03     XORLW 0x3
0E99  1903     BTFSC STATUS, 0x2
0E9A  2EAF     GOTO 0x6AF
0E9B  085F     MOVF 0x5F, W
0E9C  3A05     XORLW 0x5
0E9D  1903     BTFSC STATUS, 0x2
0E9E  2EAF     GOTO 0x6AF
0E9F  085F     MOVF 0x5F, W
0EA0  3A07     XORLW 0x7
0EA1  1903     BTFSC STATUS, 0x2
0EA2  2EAF     GOTO 0x6AF
0EA3  085F     MOVF 0x5F, W
0EA4  3A08     XORLW 0x8
0EA5  1903     BTFSC STATUS, 0x2
0EA6  2EAF     GOTO 0x6AF
0EA7  085F     MOVF 0x5F, W
0EA8  3A0A     XORLW 0xA
0EA9  1903     BTFSC STATUS, 0x2
0EAA  2EAF     GOTO 0x6AF
0EAB  085F     MOVF 0x5F, W
0EAC  3A0C     XORLW 0xC
0EAD  1D03     BTFSS STATUS, 0x2
0EAE  2EB2     GOTO 0x6B2
249:                           maximodia = 31;
0EAF  301F     MOVLW 0x1F
0EB0  1683     BSF STATUS, 0x5
0EB1  00C7     MOVWF f3_as_product
250:                       }
251:                       if (fecha.day > maximodia)
0EB2  1283     BCF STATUS, 0x5
0EB3  085E     MOVF fecha, W
0EB4  1683     BSF STATUS, 0x5
0EB5  0247     SUBWF f3_as_product, W
0EB6  1803     BTFSC STATUS, 0x0
0EB7  2EBB     GOTO 0x6BB
252:                           fecha.day = maximodia;
0EB8  0847     MOVF f3_as_product, W
0EB9  1283     BCF STATUS, 0x5
0EBA  00DE     MOVWF fecha
253:                   }
254:           
255:                   //bandera_modificaglobal=0;
256:                   /*  if (Pulsacion(3, Modifica, SIN_REPETICION, LOGICA_INVERSA)) {
257:                          refrescadisplay = 1;
258:                         if (modificafecha < ANIO)
259:                             modificafecha = modificafecha + 1;
260:                         else
261:                             modificafecha = HORA;
262:                         //bandera_modificaglobal=1;
263:           
264:                     }*/
265:           
266:                   bandera_startglobal = 0;
0EBB  1683     BSF STATUS, 0x5
0EBC  1303     BCF STATUS, 0x6
0EBE  01B6     CLRF exp1
267:                   if (Pulsacion(3, BOTON_MENU, INMEDIATO, LOGICA_INVERSA)) {
0EBD  3000     MOVLW 0x0
0EBF  1283     BCF STATUS, 0x5
0EC0  1986     BTFSC PORTB, 0x3
0EC1  3001     MOVLW 0x1
0EC2  00F6     MOVWF Pin
0EC3  3002     MOVLW 0x2
0EC4  00F7     MOVWF TipoPin
0EC5  3003     MOVLW 0x3
0EC6  01F8     CLRF Logica
0EC7  0AF8     INCF Logica, F
0EC8  26FB     CALL 0x6FB
0EC9  120A     BCF PCLATH, 0x4
0ECA  158A     BSF PCLATH, 0x3
0ECB  3A00     XORLW 0x0
0ECC  1903     BTFSC STATUS, 0x2
0ECD  2ED2     GOTO 0x6D2
268:           
269:                       bandera_startglobal = 1;
0ECE  1683     BSF STATUS, 0x5
0ECF  1303     BCF STATUS, 0x6
0ED0  01B6     CLRF exp1
0ED1  0AB6     INCF exp1, F
270:                   }
271:           
272:                   if (Pulsacion(4, BOTON_MENU, SIN_REPETICION/*INMEDIATO*/, LOGICA_INVERSA)) {
0ED2  3000     MOVLW 0x0
0ED3  1283     BCF STATUS, 0x5
0ED4  1303     BCF STATUS, 0x6
0ED5  1986     BTFSC PORTB, 0x3
0ED6  3001     MOVLW 0x1
0ED7  00F6     MOVWF Pin
0ED8  3004     MOVLW 0x4
0ED9  01F7     CLRF TipoPin
0EDA  01F8     CLRF Logica
0EDB  0AF8     INCF Logica, F
0EDC  26FB     CALL 0x6FB
0EDD  120A     BCF PCLATH, 0x4
0EDE  158A     BSF PCLATH, 0x3
0EDF  3A00     XORLW 0x0
0EE0  1903     BTFSC STATUS, 0x2
0EE1  2EEF     GOTO 0x6EF
273:           
274:                       buzzer_on();
0EE2  160A     BSF PCLATH, 0x4
0EE3  118A     BCF PCLATH, 0x3
0EE4  2631     CALL 0x631
0EE5  120A     BCF PCLATH, 0x4
0EE6  158A     BSF PCLATH, 0x3
275:                       if (menuactual < ULTIMOMENU)
0EE7  3011     MOVLW 0x11
0EE8  1683     BSF STATUS, 0x5
0EE9  0243     SUBWF 0x43, W
0EEA  1803     BTFSC STATUS, 0x0
0EEB  2EEE     GOTO 0x6EE
276:                           menuactual++;
0EEC  0AC3     INCF 0x43, F
0EED  2EEF     GOTO 0x6EF
277:                       else
278:                           menuactual = 0;
0EEE  01C3     CLRF 0x43
279:                   }
280:                   INTCONbits.T0IF = 0;
0EEF  110B     BCF INTCON, 0x2
281:               } else {
282:                   ///interrupciones no contempladas
283:               }
284:           
285:               /* This code stub shows general interrupt handling.  Note that these
286:               conditional statements are not handled within 3 seperate if blocks.
287:               Do not use a seperate if block for each interrupt flag to avoid run
288:               time errors. */
289:           
290:           #if 0
291:           
292:               /* Add interrupt routine code here. */
293:           
294:               /* Determine which flag generated the interrupt */
295:               if (<Interrupt Flag 1 >) {
296:                   <Interrupt Flag 1 = 0 >; /* Clear Interrupt Flag 1 */
297:               } else if (<Interrupt Flag 2 >) {
298:                   <Interrupt Flag 2 = 0 >; /* Clear Interrupt Flag 2 */
299:               } else {
300:                   /* Unhandled interrupts */
301:               }
302:           
303:           #endif
304:           
305:           }
0EF0  1283     BCF STATUS, 0x5
306:           #endif
307:           
308:           
309:           #endif
---  /media/Utilidades/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V4.X/adcPic16.c  ------------------------
1:             #include <xc.h>
2:             #include <stdint.h>
3:             #include <stdbool.h>
4:             #include "system.h"
5:             #include "user.h"
6:             #include "adcPic16.h"
7:             
8:             
9:             void setADCChannel(char canal){
0FEB  00F2     MOVWF canal
1645  1283     BCF STATUS, 0x5
1646  00A4     MOVWF Data
10:             ADCON0bits.CHS = canal;     //Selecciono el canal AD0
0FEC  00F1     MOVWF divisor
0FED  0DF1     RLF divisor, F
0FEE  0DF1     RLF divisor, F
0FEF  0DF1     RLF divisor, F
0FF0  1283     BCF STATUS, 0x5
0FF1  081F     MOVF ADCON0, W
0FF2  0671     XORWF divisor, W
0FF3  39C7     ANDLW 0xC7
0FF4  0671     XORWF divisor, W
0FF5  009F     MOVWF ADCON0
1647  00A3     MOVWF x
1648  0DA3     RLF x, F
1649  0DA3     RLF x, F
164A  0DA3     RLF x, F
164B  081F     MOVF ADCON0, W
164C  0623     XORWF x, W
164D  39C7     ANDLW 0xC7
164E  0623     XORWF x, W
164F  009F     MOVWF ADCON0
11:            };
0FF6  0008     RETURN
1650  0008     RETURN
12:            
13:            char getADCChannel(void){
14:             return ADCON0bits.CHS;     //Selecciono el canal AD0
0FF7  0C1F     RRF ADCON0, W
0FF8  00F1     MOVWF divisor
0FF9  0CF1     RRF divisor, F
0FFA  0C71     RRF divisor, W
0FFB  3907     ANDLW 0x7
15:            };
0FFC  0008     RETURN
16:            void openADC(void){
17:            #ifndef _PIC18
18:                TRISA0=1;//configuro como entrada para el ADC0
1662  1683     BSF STATUS, 0x5
1663  1303     BCF STATUS, 0x6
1664  1405     BSF PORTA, 0x0
19:                TRISA1=1;//configuro como entrada para el ADC1
1665  1485     BSF PORTA, 0x1
20:                TRISA3=1; //Configuro como entrada para Vref+
1666  1585     BSF PORTA, 0x3
21:            
22:                ADCON1bits.PCFG=0b101; //An3 como VREF+ , AN0 y AN1 como entrada analogica, AN0 Corriente, AN1 Tension de red
1667  081F     MOVF ADCON0, W
1668  39F0     ANDLW 0xF0
1669  3805     IORLW 0x5
166A  009F     MOVWF ADCON0
23:                ADCON1bits.ADFM=1; //justificado a la derecha
166B  179F     BSF ADCON0, 0x7
24:                ADCON1bits.ADCS2=1;
166C  171F     BSF ADCON0, 0x6
25:                ADCON0bits.ADCS=0b10; //Tosc/64
166D  1283     BCF STATUS, 0x5
166E  081F     MOVF ADCON0, W
166F  393F     ANDLW 0x3F
1670  3880     IORLW 0x80
1671  009F     MOVWF ADCON0
26:                ADCON0bits.ADON=1; //Activo el ADC
1672  141F     BSF ADCON0, 0x0
27:            #endif
28:            }
1673  0008     RETURN
29:            
30:            unsigned int adcRead(void){
31:                
32:                return ((unsigned int)ADRESH<<8)|ADRESL;
0FC1  081E     MOVF ADRESH, W
0FC2  00F2     MOVWF canal
0FC3  01F1     CLRF divisor
0FC4  1683     BSF STATUS, 0x5
0FC5  081E     MOVF ADRESH, W
0FC6  04F1     IORWF divisor, F
33:            }
0FC7  0008     RETURN
34:            
35:            void startADC(void) {
36:                ADCON0bits.GO_DONE=1;
0FFD  1283     BCF STATUS, 0x5
0FFE  151F     BSF ADCON0, 0x2
37:            }
0FFF  0008     RETURN
38:            void interruptADC_on(void) {
39:                ADIE=1;
1622  1683     BSF STATUS, 0x5
1623  1303     BCF STATUS, 0x6
1624  170C     BSF PIR1, 0x6
40:            }
1625  0008     RETURN
41:            void interruptADC_off(void) {
42:                ADIE=0;
43:            }
---  /media/Utilidades/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V4.X/_isl1208.c  ------------------------
1:             ///////////////////////////////////////////////////////////////////////////////////////
2:             ///                               isl1208.C                                           ///
3:             ///                     Driver for Real Time Clock                                   ///
4:             ///                     modified by Redpic 08/2006                                   ///
5:             ///                  http://picmania.garcia-cuervo.com                               ///
6:             ///                                                                                  ///
7:             /// void isl1208_init(val)                                                            ///
8:             ///                  - Enable oscillator without clearing the seconds register       ///
9:             ///                    used when PIC loses power and isl1208 run from 3V BAT          ///
10:            ///                  - Config Control Register with next parameters:                 ///
11:            ///                     isl1208_ALL_DISABLED          All disabled                    ///
12:            ///                     isl1208_OUT_ON_DISABLED_HIHG  Out to Hight on Disable Out     ///
13:            ///                     isl1208_OUT_ENABLED           Out Enabled                     ///
14:            ///                     isl1208_OUT_1_HZ              Freq. Out to 1 Hz               ///
15:            ///                     isl1208_OUT_4_KHZ             Freq. Out to 4.096 Khz          ///
16:            ///                     isl1208_OUT_8_KHZ             Freq. Out to 8.192 Khz          ///
17:            ///                     isl1208_OUT_32_KHZ            Freq. Out to 32.768 Khz         ///
18:            ///                                                                                  ///
19:            ///                     Example init:                                                ///
20:            ///                     isl1208_init(isl1208_ALL_DISABLED);                            ///
21:            ///                     isl1208_init(isl1208_OUT_ENABLED | isl1208_OUT_1_HZ);           ///
22:            ///                                                                                  ///
23:            /// void isl1208_set_date_time(day,mth,year,dow,hour,min,sec) - Set the date/time     ///
24:            ///                                                                                  ///
25:            /// void isl1208_get_date(day,mth,year,dow)                   - Get the date          ///
26:            ///                                                                                  ///
27:            /// void isl1208_get_time(hr,min,sec)                         - Get the time          ///
28:            ///                                                                                  ///
29:            /// char isl1208_read_nvram_unsigned char(char addr)                   - Read unsigned char in address  ///
30:            ///                                                                                  ///
31:            /// void isl1208_write_nvram_unsigned char(char addr, char value)      - Write unsigned char in address ///
32:            ///                                                                                  ///
33:            /// void isl1208_get_day_of_week(char* ptr)                   - Get string Day Of Week///
34:            ///                                                                                  ///
35:            /// If defined USE_INTERRUPTS all functions disable Global Interrupts on starts and  ///
36:            ///                           enable Global on ends else usar can do it hiself       ///
37:            ///                                                                                  ///
38:            ///////////////////////////////////////////////////////////////////////////////////////
39:            
40:            #include <xc.h>
41:            #include <stdio.h>
42:            #include <stdbool.h>       /* For true/false definition */
43:            #include "system.h"        /* System funct/params, like osc/peripheral config */
44:            #include "HardI2C.h"
45:            #include "_isl1208.h"
46:            
47:            bool ISL1208_ready(void)
48:            {
49:               bool ack;
50:               
51:               start_i2c();            // If the write command is acknowledged,
52:               ack = write_i2c(0xDE);  // then the device is ready.
53:               stop_i2c();
54:               return !ack;     // Invert ACK returned so TRUE = ACK OK
55:            }
56:            
57:            
58:            
59:            void isl1208_init(unsigned char val){
022B  1283     BCF STATUS, 0x5
022C  00AB     MOVWF val
60:            
61:               unsigned char seconds = 0;
62:            
63:            #ifndef USE_INTERRUPTS
64:            	//di();
65:            #endif
66:            
67:               start_i2c();
022D  22B2     CALL 0x2B2
022E  120A     BCF PCLATH, 0x4
022F  118A     BCF PCLATH, 0x3
68:              I2Cstate=write_i2c(0xDE);
0230  30DE     MOVLW 0xDE
0231  227A     CALL 0x27A
0232  120A     BCF PCLATH, 0x4
0233  118A     BCF PCLATH, 0x3
0234  1683     BSF STATUS, 0x5
0235  00B1     MOVWF 0x31
69:              write_i2c(0x00);
0236  3000     MOVLW 0x0
0237  227A     CALL 0x27A
0238  120A     BCF PCLATH, 0x4
0239  118A     BCF PCLATH, 0x3
70:               rstart_i2c();
023A  22EF     CALL 0x2EF
023B  120A     BCF PCLATH, 0x4
023C  118A     BCF PCLATH, 0x3
71:              write_i2c(0xDF);
023D  30DF     MOVLW 0xDF
023E  227A     CALL 0x27A
023F  120A     BCF PCLATH, 0x4
0240  118A     BCF PCLATH, 0x3
72:               seconds = isl1208_bcd2bin(read_i2c(NOACK));
0241  3001     MOVLW 0x1
0242  2187     CALL 0x187
0243  120A     BCF PCLATH, 0x4
0244  118A     BCF PCLATH, 0x3
0245  22CC     CALL 0x2CC
0246  120A     BCF PCLATH, 0x4
0247  118A     BCF PCLATH, 0x3
0248  00AC     MOVWF seconds
73:               stop_i2c();
0249  22D6     CALL 0x2D6
024A  120A     BCF PCLATH, 0x4
024B  118A     BCF PCLATH, 0x3
74:               seconds &= 0x7F;
024C  1283     BCF STATUS, 0x5
024E  13AC     BCF seconds, 0x7
75:            
76:               __delay_us(3);
024D  3004     MOVLW 0x4
024F  00AA     MOVWF Data
0250  0BAA     DECFSZ Data, F
0251  2A50     GOTO 0x250
0252  2A53     GOTO 0x253
77:            
78:                start_i2c();
0253  22B2     CALL 0x2B2
0254  120A     BCF PCLATH, 0x4
0255  118A     BCF PCLATH, 0x3
79:               write_i2c(0xDE);
0256  30DE     MOVLW 0xDE
0257  227A     CALL 0x27A
0258  120A     BCF PCLATH, 0x4
0259  118A     BCF PCLATH, 0x3
80:               write_i2c(0x00);
025A  3000     MOVLW 0x0
025B  227A     CALL 0x27A
025C  120A     BCF PCLATH, 0x4
025D  118A     BCF PCLATH, 0x3
81:               write_i2c(isl1208_bin2bcd(seconds));
025E  1283     BCF STATUS, 0x5
025F  082C     MOVF seconds, W
0260  22A1     CALL 0x2A1
0261  120A     BCF PCLATH, 0x4
0262  118A     BCF PCLATH, 0x3
0263  227A     CALL 0x27A
0264  120A     BCF PCLATH, 0x4
0265  118A     BCF PCLATH, 0x3
82:               stop_i2c();
0266  22D6     CALL 0x2D6
0267  120A     BCF PCLATH, 0x4
0268  118A     BCF PCLATH, 0x3
83:               start_i2c();
0269  22B2     CALL 0x2B2
026A  120A     BCF PCLATH, 0x4
026B  118A     BCF PCLATH, 0x3
84:               write_i2c(0xDE);
026C  30DE     MOVLW 0xDE
026D  227A     CALL 0x27A
026E  120A     BCF PCLATH, 0x4
026F  118A     BCF PCLATH, 0x3
85:               write_i2c(0x07);
0270  3007     MOVLW 0x7
0271  227A     CALL 0x27A
0272  120A     BCF PCLATH, 0x4
0273  118A     BCF PCLATH, 0x3
86:               write_i2c(val);
0274  1283     BCF STATUS, 0x5
0275  082B     MOVF val, W
0276  227A     CALL 0x27A
0277  120A     BCF PCLATH, 0x4
0278  118A     BCF PCLATH, 0x3
87:               stop_i2c();
0279  2AD6     GOTO 0x2D6
88:            
89:            #ifndef USE_INTERRUPTS
90:            	//ei();
91:            #endif
92:            
93:            }
94:            
95:            void isl1208_set_date_time(unsigned char day, unsigned char mth, unsigned char year, unsigned char dow, unsigned char hr, unsigned char min, unsigned char sec){
01E1  00B0     MOVWF day
96:            
97:            #ifndef USE_INTERRUPTS
98:              //di();
99:            #endif
100:           
101:             sec &= 0x7F;
01E3  13AF     BCF sec, 0x7
102:             hr &= 0x3F;
01E2  303F     MOVLW 0x3F
01E4  05AD     ANDWF hr, F
103:           
104:             start_i2c();
01E5  22B2     CALL 0x2B2
01E6  120A     BCF PCLATH, 0x4
01E7  118A     BCF PCLATH, 0x3
105:             I2Cstate=write_i2c(0xDE);
01E8  30DE     MOVLW 0xDE
01E9  227A     CALL 0x27A
01EA  120A     BCF PCLATH, 0x4
01EB  118A     BCF PCLATH, 0x3
01EC  1683     BSF STATUS, 0x5
01ED  00B1     MOVWF 0x31
106:             write_i2c(0x00);
01EE  3000     MOVLW 0x0
01EF  227A     CALL 0x27A
01F0  120A     BCF PCLATH, 0x4
01F1  118A     BCF PCLATH, 0x3
107:             write_i2c(isl1208_bin2bcd(sec));
01F2  1283     BCF STATUS, 0x5
01F3  082F     MOVF sec, W
01F4  22A1     CALL 0x2A1
01F5  120A     BCF PCLATH, 0x4
01F6  118A     BCF PCLATH, 0x3
01F7  227A     CALL 0x27A
01F8  120A     BCF PCLATH, 0x4
01F9  118A     BCF PCLATH, 0x3
108:             write_i2c(isl1208_bin2bcd(min));
01FA  1283     BCF STATUS, 0x5
01FB  082E     MOVF min, W
01FC  22A1     CALL 0x2A1
01FD  120A     BCF PCLATH, 0x4
01FE  118A     BCF PCLATH, 0x3
01FF  227A     CALL 0x27A
0200  120A     BCF PCLATH, 0x4
0201  118A     BCF PCLATH, 0x3
109:             write_i2c(isl1208_bin2bcd(hr));
0202  1283     BCF STATUS, 0x5
0203  082D     MOVF hr, W
0204  22A1     CALL 0x2A1
0205  120A     BCF PCLATH, 0x4
0206  118A     BCF PCLATH, 0x3
0207  227A     CALL 0x27A
0208  120A     BCF PCLATH, 0x4
0209  118A     BCF PCLATH, 0x3
110:             write_i2c(isl1208_bin2bcd(dow));
020A  1283     BCF STATUS, 0x5
020B  082C     MOVF seconds, W
020C  22A1     CALL 0x2A1
020D  120A     BCF PCLATH, 0x4
020E  118A     BCF PCLATH, 0x3
020F  227A     CALL 0x27A
0210  120A     BCF PCLATH, 0x4
0211  118A     BCF PCLATH, 0x3
111:             write_i2c(isl1208_bin2bcd(day));
0212  1283     BCF STATUS, 0x5
0213  0830     MOVF day, W
0214  22A1     CALL 0x2A1
0215  120A     BCF PCLATH, 0x4
0216  118A     BCF PCLATH, 0x3
0217  227A     CALL 0x27A
0218  120A     BCF PCLATH, 0x4
0219  118A     BCF PCLATH, 0x3
112:             write_i2c(isl1208_bin2bcd(mth));
021A  1283     BCF STATUS, 0x5
021B  082A     MOVF Data, W
021C  22A1     CALL 0x2A1
021D  120A     BCF PCLATH, 0x4
021E  118A     BCF PCLATH, 0x3
021F  227A     CALL 0x27A
0220  120A     BCF PCLATH, 0x4
0221  118A     BCF PCLATH, 0x3
113:             write_i2c(isl1208_bin2bcd(year));
0222  1283     BCF STATUS, 0x5
0223  082B     MOVF val, W
0224  22A1     CALL 0x2A1
0225  120A     BCF PCLATH, 0x4
0226  118A     BCF PCLATH, 0x3
0227  227A     CALL 0x27A
0228  120A     BCF PCLATH, 0x4
0229  118A     BCF PCLATH, 0x3
114:             stop_i2c();
022A  2AD6     GOTO 0x2D6
115:           
116:           #ifndef USE_INTERRUPTS
117:            //  ei();
118:           #endif
119:           
120:           }
121:           
122:           void isl1208_get_date(unsigned char* day, unsigned char* mth, unsigned char* year, unsigned char *dow){
0141  00AD     MOVWF hr
123:           
124:           #ifndef USE_INTERRUPTS
125:             // di();
126:           #endif
127:           
128:             start_i2c();
0142  22B2     CALL 0x2B2
0143  120A     BCF PCLATH, 0x4
0144  118A     BCF PCLATH, 0x3
129:             I2Cstate=write_i2c(0xDE);
0145  30DE     MOVLW 0xDE
0146  227A     CALL 0x27A
0147  120A     BCF PCLATH, 0x4
0148  118A     BCF PCLATH, 0x3
0149  1683     BSF STATUS, 0x5
014A  00B1     MOVWF 0x31
130:             write_i2c(0x03);
014B  3003     MOVLW 0x3
014C  227A     CALL 0x27A
014D  120A     BCF PCLATH, 0x4
014E  118A     BCF PCLATH, 0x3
131:             
132:             rstart_i2c();
014F  22EF     CALL 0x2EF
0150  120A     BCF PCLATH, 0x4
0151  118A     BCF PCLATH, 0x3
133:             write_i2c(0xDF);
0152  30DF     MOVLW 0xDF
0153  227A     CALL 0x27A
0154  120A     BCF PCLATH, 0x4
0155  118A     BCF PCLATH, 0x3
134:             *dow = isl1208_bcd2bin(read_i2c(ACK) & 0x07);
0156  1283     BCF STATUS, 0x5
0157  082C     MOVF seconds, W
0158  0084     MOVWF FSR
0159  3000     MOVLW 0x0
015A  2187     CALL 0x187
015B  120A     BCF PCLATH, 0x4
015C  118A     BCF PCLATH, 0x3
015D  3907     ANDLW 0x7
015E  22CC     CALL 0x2CC
015F  120A     BCF PCLATH, 0x4
0160  118A     BCF PCLATH, 0x3
0161  1383     BCF STATUS, 0x7
0162  0080     MOVWF INDF
135:             *day  = isl1208_bcd2bin(read_i2c(ACK) & 0x3f);
0163  082D     MOVF hr, W
0164  0084     MOVWF FSR
0165  3000     MOVLW 0x0
0166  2187     CALL 0x187
0167  120A     BCF PCLATH, 0x4
0168  118A     BCF PCLATH, 0x3
0169  393F     ANDLW 0x3F
016A  22CC     CALL 0x2CC
016B  120A     BCF PCLATH, 0x4
016C  118A     BCF PCLATH, 0x3
016D  1383     BCF STATUS, 0x7
016E  0080     MOVWF INDF
136:             *mth  = isl1208_bcd2bin(read_i2c(ACK) & 0x1f);
016F  082A     MOVF Data, W
0170  0084     MOVWF FSR
0171  3000     MOVLW 0x0
0172  2187     CALL 0x187
0173  120A     BCF PCLATH, 0x4
0174  118A     BCF PCLATH, 0x3
0175  391F     ANDLW 0x1F
0176  22CC     CALL 0x2CC
0177  120A     BCF PCLATH, 0x4
0178  118A     BCF PCLATH, 0x3
0179  1383     BCF STATUS, 0x7
017A  0080     MOVWF INDF
137:             *year = isl1208_bcd2bin(read_i2c(NOACK));
017B  082B     MOVF val, W
017C  0084     MOVWF FSR
017D  3001     MOVLW 0x1
017E  2187     CALL 0x187
017F  120A     BCF PCLATH, 0x4
0180  118A     BCF PCLATH, 0x3
0181  22CC     CALL 0x2CC
0182  120A     BCF PCLATH, 0x4
0183  118A     BCF PCLATH, 0x3
0184  1383     BCF STATUS, 0x7
0185  0080     MOVWF INDF
138:           stop_i2c();
0186  2AD6     GOTO 0x2D6
139:           #ifndef USE_INTERRUPTS
140:            // ei();
141:           #endif
142:           
143:           }
144:           
145:           void isl1208_get_time(unsigned char *hr, unsigned char* min, unsigned char *sec){
0106  00AC     MOVWF seconds
146:           
147:           #ifndef USE_INTERRUPTS
148:             // di();
149:           #endif
150:           
151:             start_i2c();
0107  22B2     CALL 0x2B2
0108  120A     BCF PCLATH, 0x4
0109  118A     BCF PCLATH, 0x3
152:             I2Cstate=write_i2c(0xDE);
010A  30DE     MOVLW 0xDE
010B  227A     CALL 0x27A
010C  120A     BCF PCLATH, 0x4
010D  118A     BCF PCLATH, 0x3
010E  1683     BSF STATUS, 0x5
010F  00B1     MOVWF 0x31
153:             write_i2c(0x00);
0110  3000     MOVLW 0x0
0111  227A     CALL 0x27A
0112  120A     BCF PCLATH, 0x4
0113  118A     BCF PCLATH, 0x3
154:            
155:             rstart_i2c();
0114  22EF     CALL 0x2EF
0115  120A     BCF PCLATH, 0x4
0116  118A     BCF PCLATH, 0x3
156:             write_i2c(0xDF);
0117  30DF     MOVLW 0xDF
0118  227A     CALL 0x27A
0119  120A     BCF PCLATH, 0x4
011A  118A     BCF PCLATH, 0x3
157:           *sec = isl1208_bcd2bin(read_i2c(ACK) & 0x7f);
011B  1283     BCF STATUS, 0x5
011C  082B     MOVF val, W
011D  0084     MOVWF FSR
011E  3000     MOVLW 0x0
011F  2187     CALL 0x187
0120  120A     BCF PCLATH, 0x4
0121  118A     BCF PCLATH, 0x3
0122  397F     ANDLW 0x7F
0123  22CC     CALL 0x2CC
0124  120A     BCF PCLATH, 0x4
0125  118A     BCF PCLATH, 0x3
0126  1383     BCF STATUS, 0x7
0127  0080     MOVWF INDF
158:           * min = isl1208_bcd2bin(read_i2c(ACK) & 0x7f);
0128  082A     MOVF Data, W
0129  0084     MOVWF FSR
012A  3000     MOVLW 0x0
012B  2187     CALL 0x187
012C  120A     BCF PCLATH, 0x4
012D  118A     BCF PCLATH, 0x3
012E  397F     ANDLW 0x7F
012F  22CC     CALL 0x2CC
0130  120A     BCF PCLATH, 0x4
0131  118A     BCF PCLATH, 0x3
0132  1383     BCF STATUS, 0x7
0133  0080     MOVWF INDF
159:           * hr  = isl1208_bcd2bin(read_i2c(NOACK) & 0x3f);
0134  082C     MOVF seconds, W
0135  0084     MOVWF FSR
0136  3001     MOVLW 0x1
0137  2187     CALL 0x187
0138  120A     BCF PCLATH, 0x4
0139  118A     BCF PCLATH, 0x3
013A  393F     ANDLW 0x3F
013B  22CC     CALL 0x2CC
013C  120A     BCF PCLATH, 0x4
013D  118A     BCF PCLATH, 0x3
013E  1383     BCF STATUS, 0x7
013F  0080     MOVWF INDF
160:             stop_i2c();
0140  2AD6     GOTO 0x2D6
161:           
162:           #ifndef USE_INTERRUPTS
163:             // ei();
164:           #endif
165:           
166:           }
167:           
168:           
169:           char isl1208_read_nvram_byte (char addr){
170:           
171:              char retval;
172:           
173:           #ifndef USE_INTERRUPTS
174:             // di();
175:           #endif
176:           
177:              start_i2c();
178:              I2Cstate=write_i2c(0xDE);
179:              write_i2c(addr);
180:             
181:              rstart_i2c();
182:              write_i2c(0xDF);
183:              retval = read_i2c(NOACK);
184:              stop_i2c();
185:           
186:              
187:           
188:           #ifndef USE_INTERRUPTS
189:             // ei();
190:           #endif
191:           return(retval);
192:           }
193:           
194:           void isl1208_write_nvram_byte (char addr, char value){
195:           
196:           #ifndef USE_INTERRUPTS
197:              //di();
198:           #endif
199:           
200:              start_i2c();
201:              I2Cstate=write_i2c(0xDE);
202:              write_i2c(addr);
203:              write_i2c(value);
204:              stop_i2c();
205:           
206:           #ifndef USE_INTERRUPTS
207:             // ei();
208:           #endif
209:           
210:           }
211:           
212:           void isl1208_get_day_of_week(char* ptr){
213:           
214:              unsigned char *plday;
215:              unsigned char *plmonth;
216:              unsigned char *plyr;
217:              unsigned char *pldow;
218:              unsigned char lday=0;
219:              unsigned char lmonth=0;
220:              unsigned char lyr=0;
221:              unsigned char ldow=0;
222:              plday=&lday;
223:              plmonth=&lmonth;
224:              plyr=&lyr;
225:              pldow=&ldow;
226:              isl1208_get_date(plday,plmonth,plyr,pldow);
227:              sprintf(ptr,"%s",days_of_week[*pldow-1]);
228:           }
229:           
230:           ///////////////////////////////////////////////////////////////////////////////
231:           
232:           unsigned char isl1208_bin2bcd(unsigned char binary_value){
02A1  00A9     MOVWF dato
233:               return ((binary_value / 10) << 4) + binary_value % 10;
02A2  300A     MOVLW 0xA
02A3  00A3     MOVWF x
02A4  0829     MOVF dato, W
02A5  2308     CALL 0x308
02A6  120A     BCF PCLATH, 0x4
02A7  118A     BCF PCLATH, 0x3
02A8  00A8     MOVWF data
02A9  0E28     SWAPF data, W
02AA  39F0     ANDLW 0xF0
02AB  00A8     MOVWF data
02AC  300A     MOVLW 0xA
02AD  00A3     MOVWF x
02AE  0829     MOVF dato, W
02AF  2331     CALL 0x331
02B0  0728     ADDWF data, W
234:           
235:           /*unsigned char temp;
236:             unsigned char retval;
237:           
238:             temp = binary_value;
239:             retval = 0;
240:             while(1){
241:               if(temp >= 10){
242:                 temp -= 10;
243:                 retval += 0x10;
244:               }else{
245:                 retval += temp;
246:                 break;
247:               }
248:             }
249:             return(retval);*/
250:           }
02B1  0008     RETURN
251:           
252:           unsigned char isl1208_bcd2bin(unsigned char bcd_value){
02CC  00A7     MOVWF i
253:               return (bcd_value & 0x0F) + (bcd_value >> 4) * 10;
02CD  390F     ANDLW 0xF
02CE  00A6     MOVWF x
02CF  300A     MOVLW 0xA
02D0  00A3     MOVWF x
02D1  0E27     SWAPF i, W
02D2  390F     ANDLW 0xF
02D3  2323     CALL 0x323
02D4  0726     ADDWF x, W
254:             /*unsigned char temp;
255:           
256:             temp = bcd_value;
257:             temp >>= 1;
258:             temp &= 0x78;
259:             return(temp + (temp >> 2) + (bcd_value & 0x0f));*/
260:           }
02D5  0008     RETURN
261:           
262:           
263:           /*unsigned int ISL1208::bcd2bin(unsigned char val)
264:           {
265:               return (val & 0x0F) + (val >> 4) * 10;
266:           }
267:           
268:           char ISL1208::bin2bcd(unsigned int val)
269:           {
270:               return ((val / 10) << 4) + val % 10;
271:           }*/
272:           ///////////////////////////////////////////////////////////////////////////////
273:           
274:           
275:           
276:           
---  /media/Utilidades/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V4.X/Pulsadores.c  ----------------------
1:             //Programa de gestin de pulsadores por Nocturno adaptado a xc8 por Pablo F. Manieri
2:             
3:             #include <xc.h>
4:             #include <stdint.h>
5:             #include <stdbool.h>
6:             #include "system.h"
7:             #include "user.h"
8:             #include "Pulsadores.h"
9:             
10:            /****** HARDWARE ********
11:            BOTON_Subir       	RB1
12:            BOTON_Bajar       	RB2
13:            BOTON_MENU       	RB3
14:            BOTON_FUNCION 	RB4
15:            BOTON_OK		RB5
16:            **************************/
17:            
18:            bool Pulsacion(unsigned char Indice, unsigned char Pin, unsigned char TipoPin, bool Logica) {
0EFB  00FA     MOVWF Indice
19:               /*
20:                  Esta funcin gestiona las entradas de pulsador, mediante el control de un retardo
21:                  antirrebotes y con la opcin de autorrepeticin de hasta 4 velocidades
22:                  
23:                  Para que funcione, hay que dimensionar la variable Entradas con el n de pulsadores
24:                  que queramos controlar.
25:                  
26:                  ENTRADAS
27:                     Indice: hace referencia al n de pulsador a chequear
28:                     Pin: indica el estado del pin del pulsador (lgica inversa)
29:                     TipoPIN:
30:                        TipoPin=0   -> No tiene autorrepeticin
31:                        TipoPin=1   -> Pin con autorrepeticin
32:                     
33:                  SALIDA
34:                     La funcin devuelve un 1 si el pulsador est en condiciones de ser procesado
35:                     y un 0 en caso contrario.
36:                  
37:               */
38:               static unsigned int Entradas[5]={0,0,0,0,0};  // Dimensionar en funcin del n de pulsadores
39:               unsigned int j;
40:              bool resultado=0;
0EFC  01F9     CLRF resultado
41:               
42:               j=Entradas[Indice];  // Como leemos muchas veces el array, lo pasamos a variable local para 
0EFD  1003     BCF STATUS, 0x0
0EFE  0D7A     RLF Indice, W
0EFF  3EA0     ADDLW 0xA0
0F00  0084     MOVWF FSR
0F01  1383     BCF STATUS, 0x7
0F02  0800     MOVF INDF, W
0F03  00FB     MOVWF j
0F04  0A84     INCF FSR, F
0F05  0800     MOVF INDF, W
0F06  00FC     MOVWF 0x7C
43:                                    // incrementar la velocidad de ejecucin
44:                                    
45:               // Si se detecta pulsacin y antes no haba, devolvemos un 1 en resultado
46:               if ((((!Pin && Logica==LOGICA_INVERSA) || (Pin && Logica==LOGICA_DIRECTA)) && (j==0))) {
0F07  08F6     MOVF Pin, F
0F08  1903     BTFSC STATUS, 0x2
0F09  0378     DECF Logica, W
0F0A  1903     BTFSC STATUS, 0x2
0F0B  2F12     GOTO 0x712
0F0C  0876     MOVF Pin, W
0F0D  1903     BTFSC STATUS, 0x2
0F0E  2F1B     GOTO 0x71B
0F0F  08F8     MOVF Logica, F
0F10  1D03     BTFSS STATUS, 0x2
0F11  2F1B     GOTO 0x71B
0F12  087C     MOVF 0x7C, W
0F13  047B     IORWF j, W
0F14  1D03     BTFSS STATUS, 0x2
0F15  2F1B     GOTO 0x71B
47:                     resultado=1;
0F16  01F9     CLRF resultado
0F17  0AF9     INCF resultado, F
48:                     j=1;
0F18  01FB     CLRF j
0F19  0AFB     INCF j, F
0F1A  01FC     CLRF 0x7C
49:               };
50:               
51:               // Cada vez que se entra a la funcin se incrementa una unidad el array
52:               if (j>0) 
0F1B  087C     MOVF 0x7C, W
0F1C  047B     IORWF j, W
0F1D  1903     BTFSC STATUS, 0x2
0F1E  2F28     GOTO 0x728
53:                     Entradas[Indice]++;
0F1F  1003     BCF STATUS, 0x0
0F20  0D7A     RLF Indice, W
0F21  3EA0     ADDLW 0xA0
0F22  0084     MOVWF FSR
0F23  3001     MOVLW 0x1
0F24  0780     ADDWF INDF, F
0F25  0A84     INCF FSR, F
0F26  1803     BTFSC STATUS, 0x0
0F27  0A80     INCF INDF, F
54:               
55:               // Si se detecta que ya no se est pulsando, inicializamos a 0 el array
56:               if (((Pin && Logica==LOGICA_INVERSA) || (!Pin && Logica==LOGICA_DIRECTA)) && j>ANTIRREBOTES)
0F28  0876     MOVF Pin, W
0F29  1903     BTFSC STATUS, 0x2
0F2A  2F2E     GOTO 0x72E
0F2B  0378     DECF Logica, W
0F2C  1903     BTFSC STATUS, 0x2
0F2D  2F34     GOTO 0x734
0F2E  08F6     MOVF Pin, F
0F2F  1D03     BTFSS STATUS, 0x2
0F30  2F42     GOTO 0x742
0F31  08F8     MOVF Logica, F
0F32  1D03     BTFSS STATUS, 0x2
0F33  2F42     GOTO 0x742
0F34  3000     MOVLW 0x0
0F35  027C     SUBWF 0x7C, W
0F36  3015     MOVLW 0x15
0F37  1903     BTFSC STATUS, 0x2
0F38  027B     SUBWF j, W
0F39  1C03     BTFSS STATUS, 0x0
0F3A  2F42     GOTO 0x742
57:                  Entradas[Indice]=0;
0F3B  1003     BCF STATUS, 0x0
0F3C  0D7A     RLF Indice, W
0F3D  3EA0     ADDLW 0xA0
0F3E  0084     MOVWF FSR
0F3F  0180     CLRF INDF
0F40  0A84     INCF FSR, F
0F41  0180     CLRF INDF
58:                  
59:               if (TipoPin) { // Si el pulsador tiene autorrepeticin
0F42  0877     MOVF TipoPin, W
0F43  1903     BTFSC STATUS, 0x2
0F44  2F91     GOTO 0x791
60:                 // Cuando se supera el n de ciclos 4, devolveremos un 1 con la frecuencia VELOCIDAD4
61:                   if ((j>=CAMBIO4) && !(j%VELOCIDAD4)){
0F45  300F     MOVLW 0xF
0F46  027C     SUBWF 0x7C, W
0F47  30A0     MOVLW 0xA0
0F48  1903     BTFSC STATUS, 0x2
0F49  027B     SUBWF j, W
0F4A  1803     BTFSC STATUS, 0x0
0F4B  187B     BTFSC j, 0x0
0F4C  2F52     GOTO 0x752
62:                       resultado=1;
0F4D  01F9     CLRF resultado
0F4E  0AF9     INCF resultado, F
63:                  }else
0F4F  1283     BCF STATUS, 0x5
0F50  1303     BCF STATUS, 0x6
0F51  2F91     GOTO 0x791
64:                   // Cuando se supera el n de ciclos 3, devolveremos un 1 con la frecuencia VELOCIDAD3
65:                  if ((j>=CAMBIO3) && !(j%VELOCIDAD3)){           
0F52  3007     MOVLW 0x7
0F53  027C     SUBWF 0x7C, W
0F54  30D0     MOVLW 0xD0
0F55  1903     BTFSC STATUS, 0x2
0F56  027B     SUBWF j, W
0F57  1C03     BTFSS STATUS, 0x0
0F58  2F67     GOTO 0x767
0F59  300A     MOVLW 0xA
0F5A  00F1     MOVWF divisor
0F5B  01F2     CLRF canal
0F5C  087C     MOVF 0x7C, W
0F5D  00F4     MOVWF counter
0F5E  087B     MOVF j, W
0F5F  00F3     MOVWF dividend
0F60  279D     CALL 0x79D
0F61  120A     BCF PCLATH, 0x4
0F62  158A     BSF PCLATH, 0x3
0F63  0872     MOVF canal, W
0F64  0471     IORWF divisor, W
0F65  1903     BTFSC STATUS, 0x2
0F66  2F4D     GOTO 0x74D
66:                     resultado=1;
67:                  } else 
68:                     // Cuando se supera el n de ciclos 2, devolveremos un 1 con la frecuencia VELOCIDAD2
69:                     if ((j>=CAMBIO2) && !(j%VELOCIDAD2)){
0F67  3001     MOVLW 0x1
0F68  027C     SUBWF 0x7C, W
0F69  30F4     MOVLW 0xF4
0F6A  1903     BTFSC STATUS, 0x2
0F6B  027B     SUBWF j, W
0F6C  1C03     BTFSS STATUS, 0x0
0F6D  2F7C     GOTO 0x77C
0F6E  3032     MOVLW 0x32
0F6F  00F1     MOVWF divisor
0F70  01F2     CLRF canal
0F71  087C     MOVF 0x7C, W
0F72  00F4     MOVWF counter
0F73  087B     MOVF j, W
0F74  00F3     MOVWF dividend
0F75  279D     CALL 0x79D
0F76  120A     BCF PCLATH, 0x4
0F77  158A     BSF PCLATH, 0x3
0F78  0872     MOVF canal, W
0F79  0471     IORWF divisor, W
0F7A  1903     BTFSC STATUS, 0x2
0F7B  2F4D     GOTO 0x74D
70:                        resultado=1;
71:                  } else
72:                     // Cuando se supera el n de ciclos 1, devolveremos un 1 con la frecuencia VELOCIDAD1
73:                     if ((j>CAMBIO1) && !(j%VELOCIDAD1)){
0F7C  3000     MOVLW 0x0
0F7D  027C     SUBWF 0x7C, W
0F7E  3065     MOVLW 0x65
0F7F  1903     BTFSC STATUS, 0x2
0F80  027B     SUBWF j, W
0F81  1C03     BTFSS STATUS, 0x0
0F82  2F91     GOTO 0x791
0F83  3064     MOVLW 0x64
0F84  00F1     MOVWF divisor
0F85  01F2     CLRF canal
0F86  087C     MOVF 0x7C, W
0F87  00F4     MOVWF counter
0F88  087B     MOVF j, W
0F89  00F3     MOVWF dividend
0F8A  279D     CALL 0x79D
0F8B  120A     BCF PCLATH, 0x4
0F8C  158A     BSF PCLATH, 0x3
0F8D  0872     MOVF canal, W
0F8E  0471     IORWF divisor, W
0F8F  1903     BTFSC STATUS, 0x2
0F90  2F4D     GOTO 0x74D
74:                        resultado=1;
75:                  };
76:               }
77:               if ((TipoPin==INMEDIATO)&&(j>=1))
0F91  0877     MOVF TipoPin, W
0F92  3A02     XORLW 0x2
0F93  1D03     BTFSS STATUS, 0x2
0F94  2F9B     GOTO 0x79B
0F95  087C     MOVF 0x7C, W
0F96  047B     IORWF j, W
0F97  1903     BTFSC STATUS, 0x2
0F98  2F9B     GOTO 0x79B
78:                   resultado=1;
0F99  01F9     CLRF resultado
0F9A  0AF9     INCF resultado, F
79:               return (resultado);
0F9B  0879     MOVF resultado, W
80:            }
0F9C  0008     RETURN
81:            
82:            
83:               
84:            
---  /media/Utilidades/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V4.X/LCDGeneric.c  ----------------------
1:             /**
2:                \version: 1.0
3:             
4:                
5:                \author Suky (Casanova Alejandro) 
6:                \web www.infopic.comlu.com
7:                \date 16/08/10
8:             
9:             
10:            ///////////////////////////////////////////////////////////////////////////
11:            ////                                                                   ////
12:            ////                                                                   ////
13:            ////        (C) Copyright 2010 www.infopic.comlu.com                   ////
14:            //// Este cdigo puede ser usado, modificado y distribuido libremente  ////
15:            //// sin eliminar esta cabecera y  sin garanta de ningn tipo.        ////
16:            ////                                                                   ////
17:            ////                                                                   ////
18:            /////////////////////////////////////////////////////////////////////////// 
19:               
20:             *- Version Log --------------------------------------------------------------*
21:             *   Fecha       Autor                Comentarios                             *
22:             *----------------------------------------------------------------------------*
23:             * 16/08/10      Suky               Original (Rev 1.0)                        *
24:             * 20/08/10      Suky               Se incluye CodeVisionAVR                  *
25:             *----------------------------------------------------------------------------* */
26:            #include "xc.h"
27:            #include "system.h"
28:            #include "LCDGeneric.h"
29:            
30:            UINT8 NLinea;
31:            
32:            UINT8 ui8BusyLCD(void){
33:            
34:            #ifdef LCD_USE_RW
35:            	 LCD_DATA_PIN_7 = 0;
17CE  1388     BCF PORTD, 0x7
36:            	 LCD_DATA_PIN_6 = 0;
17CF  1308     BCF PORTD, 0x6
37:            	 LCD_DATA_PIN_5 = 0;
17D0  1288     BCF PORTD, 0x5
38:            	 LCD_DATA_PIN_4 = 0;
17D1  1208     BCF PORTD, 0x4
39:            
40:                 LCD_TRIS_DATA_PIN_7 = CONFIG_INPUT;
17D2  1683     BSF STATUS, 0x5
17D3  1788     BSF PORTD, 0x7
41:                 LCD_TRIS_DATA_PIN_6 = CONFIG_INPUT;
17D4  1708     BSF PORTD, 0x6
42:                 LCD_TRIS_DATA_PIN_5 = CONFIG_INPUT;
17D5  1688     BSF PORTD, 0x5
43:                 LCD_TRIS_DATA_PIN_4 = CONFIG_INPUT;
17D6  1608     BSF PORTD, 0x4
44:            
45:                 LCD_RW_PIN = 1;    
17D7  1283     BCF STATUS, 0x5
17D8  1488     BSF PORTD, 0x1
46:                 LCD_RS_PIN = 0; 
17D9  1008     BCF PORTD, 0x0
47:            	 LCD_E_PIN=1;         
17DA  1508     BSF PORTD, 0x2
48:                 __delay_1us();
17DB  2FDC     GOTO 0x7DC
17DC  2FDD     GOTO 0x7DD
17DD  0000     NOP
49:            
50:                 if(LCD_READ_PIN_7==1){
17DE  1283     BCF STATUS, 0x5
17DF  1303     BCF STATUS, 0x6
17E0  1F88     BTFSS PORTD, 0x7
17E1  2FF1     GOTO 0x7F1
51:                      LCD_E_PIN = 0; 
17E2  1108     BCF PORTD, 0x2
52:            		  __delay_1us();
17E3  2FE4     GOTO 0x7E4
17E4  2FE5     GOTO 0x7E5
17E5  0000     NOP
53:            		  LCD_E_PIN = 1;
17E6  1283     BCF STATUS, 0x5
17E7  1303     BCF STATUS, 0x6
17E8  1508     BSF PORTD, 0x2
54:            		  __delay_1us();
17E9  2FEA     GOTO 0x7EA
17EA  2FEB     GOTO 0x7EB
17EB  0000     NOP
55:            		  LCD_E_PIN = 0;
17EC  1283     BCF STATUS, 0x5
17ED  1303     BCF STATUS, 0x6
17EE  1108     BCF PORTD, 0x2
56:                  	  LCD_RW_PIN = 0; 
17EF  1088     BCF PORTD, 0x1
57:                      return 1;
17F0  3401     RETLW 0x1
58:                 }else{
59:                      LCD_E_PIN = 0;
17F1  1108     BCF PORTD, 0x2
60:            		  __delay_1us();
17F2  2FF3     GOTO 0x7F3
17F3  2FF4     GOTO 0x7F4
17F4  0000     NOP
61:            		  LCD_E_PIN = 1;
17F5  1283     BCF STATUS, 0x5
17F6  1303     BCF STATUS, 0x6
17F7  1508     BSF PORTD, 0x2
62:            		  __delay_1us();
17F8  2FF9     GOTO 0x7F9
17F9  2FFA     GOTO 0x7FA
17FA  0000     NOP
63:            		  LCD_E_PIN = 0;
17FB  1283     BCF STATUS, 0x5
17FC  1303     BCF STATUS, 0x6
17FD  1108     BCF PORTD, 0x2
64:            		  LCD_RW_PIN = 0;       
17FE  1088     BCF PORTD, 0x1
65:                      return 0;
17FF  3400     RETLW 0x0
66:                 }
67:            #else
68:            	 __delay_100us();
69:            	 return 0;
70:            #endif
71:            }
72:            
73:            void vWriteLCD(UINT8 Data,UINT8 Type){
175D  00A4     MOVWF Data
74:            
75:            #ifdef LCD_USE_3PINES
76:            	UINT8 i, data_temp;
77:            #endif
78:            
79:            	while(ui8BusyLCD());
175E  27CE     CALL 0x7CE
175F  160A     BSF PCLATH, 0x4
1760  118A     BCF PCLATH, 0x3
1761  3800     IORLW 0x0
1762  1D03     BTFSS STATUS, 0x2
1763  2F5E     GOTO 0x75E
80:            
81:            	#ifndef LCD_USE_3PINES
82:            		#ifdef LCD_USE_RW
83:            			LCD_RW_PIN = 0;
1764  1088     BCF PORTD, 0x1
84:            		#endif   
85:            		if(Type){
1765  0823     MOVF x, W
1766  1903     BTFSC STATUS, 0x2
1767  2F6A     GOTO 0x76A
86:            			LCD_RS_PIN=1;
1768  1408     BSF PORTD, 0x0
87:            		}else{
1769  2F6B     GOTO 0x76B
88:            			LCD_RS_PIN = 0;
176A  1008     BCF PORTD, 0x0
89:            		}	  
90:            		LCD_TRIS_DATA_PIN_7 = CONFIG_OUTPUT;
176B  1683     BSF STATUS, 0x5
176C  1388     BCF PORTD, 0x7
91:            		LCD_TRIS_DATA_PIN_6 = CONFIG_OUTPUT;
176D  1308     BCF PORTD, 0x6
92:            		LCD_TRIS_DATA_PIN_5 = CONFIG_OUTPUT;
176E  1288     BCF PORTD, 0x5
93:            		LCD_TRIS_DATA_PIN_4 = CONFIG_OUTPUT;
176F  1208     BCF PORTD, 0x4
94:            		
95:            		LCD_DATA_PIN_7 = !!(Data & 0x80);
1770  1283     BCF STATUS, 0x5
1771  1FA4     BTFSS Data, 0x7
1772  2F77     GOTO 0x777
1773  1283     BCF STATUS, 0x5
1774  1303     BCF STATUS, 0x6
1775  1788     BSF PORTD, 0x7
1776  2F7A     GOTO 0x77A
1777  1283     BCF STATUS, 0x5
1778  1303     BCF STATUS, 0x6
1779  1388     BCF PORTD, 0x7
96:            		LCD_DATA_PIN_6 = !!(Data & 0x40);
177A  1F24     BTFSS Data, 0x6
177B  2F80     GOTO 0x780
177C  1283     BCF STATUS, 0x5
177D  1303     BCF STATUS, 0x6
177E  1708     BSF PORTD, 0x6
177F  2F83     GOTO 0x783
1780  1283     BCF STATUS, 0x5
1781  1303     BCF STATUS, 0x6
1782  1308     BCF PORTD, 0x6
97:            		LCD_DATA_PIN_5 = !!(Data & 0x20);
1783  1EA4     BTFSS Data, 0x5
1784  2F89     GOTO 0x789
1785  1283     BCF STATUS, 0x5
1786  1303     BCF STATUS, 0x6
1787  1688     BSF PORTD, 0x5
1788  2F8C     GOTO 0x78C
1789  1283     BCF STATUS, 0x5
178A  1303     BCF STATUS, 0x6
178B  1288     BCF PORTD, 0x5
98:            		LCD_DATA_PIN_4 = !!(Data & 0x10);
178C  1E24     BTFSS Data, 0x4
178D  2F92     GOTO 0x792
178E  1283     BCF STATUS, 0x5
178F  1303     BCF STATUS, 0x6
1790  1608     BSF PORTD, 0x4
1791  2F95     GOTO 0x795
1792  1283     BCF STATUS, 0x5
1793  1303     BCF STATUS, 0x6
1794  1208     BCF PORTD, 0x4
99:            	#else
100:           		data_temp=(Data>>4);  // Rs es bit 4
101:           		if(Type){
102:           			data_temp|=0x10;
103:           		}
104:           		for(i=0;i<8;i++){
105:           			LCD_DATA_PIN=!!(data_temp & 0x80);
106:           			data_temp<<=1;
107:           			LCD_CLOCK_PIN=1;
108:           			__delay_1us();
109:           			LCD_CLOCK_PIN=0;
110:           		}
111:           	#endif
112:           	__delay_1Cycle();
1795  0000     NOP
113:           	LCD_E_PIN = 1;
1796  1283     BCF STATUS, 0x5
1797  1303     BCF STATUS, 0x6
1798  1508     BSF PORTD, 0x2
114:           	__delay_1us();
1799  2F9A     GOTO 0x79A
179A  2F9B     GOTO 0x79B
179B  0000     NOP
115:           	LCD_E_PIN = 0;
179C  1283     BCF STATUS, 0x5
179D  1303     BCF STATUS, 0x6
179E  1108     BCF PORTD, 0x2
116:           	#ifndef LCD_USE_3PINES	
117:           		LCD_DATA_PIN_7 = !!(Data & 0x08);
179F  1DA4     BTFSS Data, 0x3
17A0  2FA5     GOTO 0x7A5
17A1  1283     BCF STATUS, 0x5
17A2  1303     BCF STATUS, 0x6
17A3  1788     BSF PORTD, 0x7
17A4  2FA8     GOTO 0x7A8
17A5  1283     BCF STATUS, 0x5
17A6  1303     BCF STATUS, 0x6
17A7  1388     BCF PORTD, 0x7
118:           		LCD_DATA_PIN_6 = !!(Data & 0x04);
17A8  1D24     BTFSS Data, 0x2
17A9  2FAE     GOTO 0x7AE
17AA  1283     BCF STATUS, 0x5
17AB  1303     BCF STATUS, 0x6
17AC  1708     BSF PORTD, 0x6
17AD  2FB1     GOTO 0x7B1
17AE  1283     BCF STATUS, 0x5
17AF  1303     BCF STATUS, 0x6
17B0  1308     BCF PORTD, 0x6
119:           		LCD_DATA_PIN_5 = !!(Data & 0x02);
17B1  1CA4     BTFSS Data, 0x1
17B2  2FB7     GOTO 0x7B7
17B3  1283     BCF STATUS, 0x5
17B4  1303     BCF STATUS, 0x6
17B5  1688     BSF PORTD, 0x5
17B6  2FBA     GOTO 0x7BA
17B7  1283     BCF STATUS, 0x5
17B8  1303     BCF STATUS, 0x6
17B9  1288     BCF PORTD, 0x5
120:           		LCD_DATA_PIN_4 = !!(Data & 0x01);
17BA  1C24     BTFSS Data, 0x0
17BB  2FC0     GOTO 0x7C0
17BC  1283     BCF STATUS, 0x5
17BD  1303     BCF STATUS, 0x6
17BE  1608     BSF PORTD, 0x4
17BF  2FC3     GOTO 0x7C3
17C0  1283     BCF STATUS, 0x5
17C1  1303     BCF STATUS, 0x6
17C2  1208     BCF PORTD, 0x4
121:           	#else
122:           		data_temp=(Data&0x0F);  // Rs es bit 4
123:           		if(Type){
124:           			data_temp|=0x10;
125:           		}
126:           		for(i=0;i<8;i++){
127:           			LCD_DATA_PIN=!!(data_temp & 0x80);
128:           			data_temp<<=1;
129:           			LCD_CLOCK_PIN=1;
130:           			__delay_1us();
131:           			LCD_CLOCK_PIN=0;
132:           		}
133:           	#endif
134:           	__delay_1Cycle();	
17C3  0000     NOP
135:           	LCD_E_PIN = 1;
17C4  1283     BCF STATUS, 0x5
17C5  1303     BCF STATUS, 0x6
17C6  1508     BSF PORTD, 0x2
136:           	__delay_1us();
17C7  2FC8     GOTO 0x7C8
17C8  2FC9     GOTO 0x7C9
17C9  0000     NOP
137:           	LCD_E_PIN = 0;
17CA  1283     BCF STATUS, 0x5
17CB  1303     BCF STATUS, 0x6
17CC  1108     BCF PORTD, 0x2
138:           	
139:           } 
17CD  0008     RETURN
140:           
141:           void vInitLCD(){
142:           UINT8 i;
143:           #ifdef LCD_USE_3PINES
144:           	UINT8 temp;
145:           #endif
146:           
147:           	for(i=0;i<8;i++){__delay_2ms();}
16E8  01A7     CLRF i
16E9  300D     MOVLW 0xD
16EA  00A6     MOVWF x
16EB  30FB     MOVLW 0xFB
16EC  00A5     MOVWF y
16ED  0BA5     DECFSZ y, F
16EE  2EED     GOTO 0x6ED
16EF  0BA6     DECFSZ x, F
16F0  2EED     GOTO 0x6ED
16F1  2EF2     GOTO 0x6F2
16F2  1283     BCF STATUS, 0x5
16F3  1303     BCF STATUS, 0x6
16F4  3008     MOVLW 0x8
16F5  0AA7     INCF i, F
16F6  0227     SUBWF i, W
16F7  1C03     BTFSS STATUS, 0x0
16F8  2EE9     GOTO 0x6E9
148:           	NLinea=1;
16F9  1683     BSF STATUS, 0x5
16FA  01B2     CLRF 0x32
16FB  0AB2     INCF 0x32, F
149:           	
150:           #ifndef LCD_USE_3PINES
151:           /* ** Configuracin de pines ** */	
152:           	LCD_DATA_PIN_7 = 0;
16FC  1283     BCF STATUS, 0x5
16FD  1388     BCF PORTD, 0x7
153:           	LCD_DATA_PIN_6 = 0;
16FE  1308     BCF PORTD, 0x6
154:           	LCD_DATA_PIN_5 = 0;
16FF  1288     BCF PORTD, 0x5
155:           	LCD_DATA_PIN_4 = 0;
1700  1208     BCF PORTD, 0x4
156:           	#ifdef LCD_USE_RW
157:           		LCD_RW_PIN = 0;
1701  1088     BCF PORTD, 0x1
158:           	#endif
159:           	LCD_RS_PIN = 0;
1702  1008     BCF PORTD, 0x0
160:           	LCD_E_PIN = 0;
1703  1108     BCF PORTD, 0x2
161:           	
162:           	LCD_TRIS_DATA_PIN_7 = CONFIG_OUTPUT;
1704  1683     BSF STATUS, 0x5
1705  1388     BCF PORTD, 0x7
163:           	LCD_TRIS_DATA_PIN_6 = CONFIG_OUTPUT;
1706  1308     BCF PORTD, 0x6
164:           	LCD_TRIS_DATA_PIN_5 = CONFIG_OUTPUT;
1707  1288     BCF PORTD, 0x5
165:           	LCD_TRIS_DATA_PIN_4 = CONFIG_OUTPUT;
1708  1208     BCF PORTD, 0x4
166:           	#ifdef LCD_USE_RW	
167:           		LCD_TRIS_RW = CONFIG_OUTPUT;
1709  1088     BCF PORTD, 0x1
168:           	#endif
169:           	LCD_TRIS_RS = CONFIG_OUTPUT;
170A  1008     BCF PORTD, 0x0
170:           	LCD_TRIS_E = CONFIG_OUTPUT;
170B  1108     BCF PORTD, 0x2
171:           #else
172:           	LCD_DATA_PIN = 0;
173:           	LCD_CLOCK_PIN = 0;
174:           	LCD_E_PIN = 0;
175:           
176:           	LCD_TRIS_DATA = CONFIG_OUTPUT;
177:           	LCD_TRIS_CLOCK = CONFIG_OUTPUT;
178:           	LCD_TRIS_E = CONFIG_OUTPUT;
179:           	
180:           	for(i=0;i<8;i++){
181:           		LCD_DATA_PIN=0;
182:           		LCD_CLOCK_PIN=1;
183:           		__delay_1us();
184:           		LCD_CLOCK_PIN=0;
185:           	}
186:           #endif
187:           /* ** INICIALIZACION ** */     
188:           #ifndef LCD_USE_3PINES
189:           	LCD_DATA_PIN_5 = 1;
170C  1283     BCF STATUS, 0x5
170D  1688     BSF PORTD, 0x5
190:           	LCD_DATA_PIN_4 = 1;
170E  1608     BSF PORTD, 0x4
191:           #else
192:           	temp=0x03;
193:           	for(i=0;i<8;i++){
194:           		LCD_DATA_PIN=!!(temp & 0x80);
195:           		temp<<=1;
196:           		LCD_CLOCK_PIN=1;
197:           		__delay_1us();
198:           		LCD_CLOCK_PIN=0;
199:           	}
200:           #endif
201:           	for(i=0;i<3;i++){
170F  01A7     CLRF i
1726  1283     BCF STATUS, 0x5
1727  1303     BCF STATUS, 0x6
1728  3003     MOVLW 0x3
1729  0AA7     INCF i, F
172A  0227     SUBWF i, W
172B  1C03     BTFSS STATUS, 0x0
172C  2F10     GOTO 0x710
202:           		LCD_E_PIN = 1;
1710  1508     BSF PORTD, 0x2
203:           		__delay_2ms();
1711  300D     MOVLW 0xD
1712  00A6     MOVWF x
1713  30FB     MOVLW 0xFB
1714  00A5     MOVWF y
1715  0BA5     DECFSZ y, F
1716  2F15     GOTO 0x715
1717  0BA6     DECFSZ x, F
1718  2F15     GOTO 0x715
1719  2F1A     GOTO 0x71A
204:           		LCD_E_PIN = 0;
171A  1283     BCF STATUS, 0x5
171B  1303     BCF STATUS, 0x6
171C  1108     BCF PORTD, 0x2
205:           	 	__delay_2ms();
171D  300D     MOVLW 0xD
171E  00A6     MOVWF x
171F  30FB     MOVLW 0xFB
1720  00A5     MOVWF y
1721  0BA5     DECFSZ y, F
1722  2F21     GOTO 0x721
1723  0BA6     DECFSZ x, F
1724  2F21     GOTO 0x721
1725  2F26     GOTO 0x726
206:           	}
207:           #ifndef LCD_USE_3PINES
208:           	LCD_DATA_PIN_4 = 0;
172D  1208     BCF PORTD, 0x4
209:           #else
210:           	temp=0x02;
211:           	for(i=0;i<8;i++){
212:           		LCD_DATA_PIN=!!(temp & 0x80);
213:           		temp<<=1;
214:           		LCD_CLOCK_PIN=1;
215:           		__delay_1us();
216:           		LCD_CLOCK_PIN=0;
217:           	}
218:           #endif
219:           	LCD_E_PIN = 1;
172E  1508     BSF PORTD, 0x2
220:           	__delay_1us();
172F  2F30     GOTO 0x730
1730  2F31     GOTO 0x731
1731  0000     NOP
221:           	LCD_E_PIN = 0;
1732  1283     BCF STATUS, 0x5
1733  1303     BCF STATUS, 0x6
1734  1108     BCF PORTD, 0x2
222:           
223:           	vWriteLCD(0x20 | (LcdType<<2),LCD_COMMAND);  // Tipo display.-  
1735  3028     MOVLW 0x28
1736  01A3     CLRF x
1737  275D     CALL 0x75D
1738  160A     BSF PCLATH, 0x4
1739  118A     BCF PCLATH, 0x3
224:           	__delay_2ms();     
173A  300D     MOVLW 0xD
173B  00A6     MOVWF x
173C  30FB     MOVLW 0xFB
173D  00A5     MOVWF y
173E  0BA5     DECFSZ y, F
173F  2F3E     GOTO 0x73E
1740  0BA6     DECFSZ x, F
1741  2F3E     GOTO 0x73E
1742  2F43     GOTO 0x743
225:           	vWriteLCD(0x01,LCD_COMMAND);	// Borramos display.-   
1743  1283     BCF STATUS, 0x5
1744  1303     BCF STATUS, 0x6
1745  3001     MOVLW 0x1
1746  01A3     CLRF x
1747  275D     CALL 0x75D
1748  160A     BSF PCLATH, 0x4
1749  118A     BCF PCLATH, 0x3
226:           	__delay_2ms();           
174A  300D     MOVLW 0xD
174B  00A6     MOVWF x
174C  30FB     MOVLW 0xFB
174D  00A5     MOVWF y
174E  0BA5     DECFSZ y, F
174F  2F4E     GOTO 0x74E
1750  0BA6     DECFSZ x, F
1751  2F4E     GOTO 0x74E
1752  2F53     GOTO 0x753
227:           	vWriteLCD(0x06,LCD_COMMAND);	// Incrementa cursor.-
1753  1283     BCF STATUS, 0x5
1754  1303     BCF STATUS, 0x6
1755  3006     MOVLW 0x6
1756  01A3     CLRF x
1757  275D     CALL 0x75D
1758  160A     BSF PCLATH, 0x4
1759  118A     BCF PCLATH, 0x3
228:           	vWriteLCD(0x0C,LCD_COMMAND);	// Encendemos display.-
175A  300C     MOVLW 0xC
229:           }
230:           
231:           
232:           void vLCD_Putc(UINT8 Data){
16BF  1283     BCF STATUS, 0x5
16C0  1303     BCF STATUS, 0x6
16C1  00AA     MOVWF Data
233:           	
234:           	switch(Data){
16C2  3A0A     XORLW 0xA
16C3  1903     BTFSC STATUS, 0x2
16C4  2EDD     GOTO 0x6DD
16C5  3A06     XORLW 0x6
16C6  1903     BTFSC STATUS, 0x2
16C7  2ECA     GOTO 0x6CA
16C8  2EE4     GOTO 0x6E4
235:           		case '\f':
236:           			vWriteLCD(0x01,LCD_COMMAND);
16CA  3001     MOVLW 0x1
16CB  01A3     CLRF x
16CC  275D     CALL 0x75D
16CD  160A     BSF PCLATH, 0x4
16CE  118A     BCF PCLATH, 0x3
237:           			NLinea=1;
16CF  1683     BSF STATUS, 0x5
16D1  01B2     CLRF 0x32
16D2  0AB2     INCF 0x32, F
238:           			__delay_2ms();
16D0  300D     MOVLW 0xD
16D3  1283     BCF STATUS, 0x5
16D4  00A9     MOVWF dato
16D5  30FB     MOVLW 0xFB
16D6  00A8     MOVWF data
16D7  0BA8     DECFSZ data, F
16D8  2ED7     GOTO 0x6D7
16D9  0BA9     DECFSZ dato, F
16DA  2ED7     GOTO 0x6D7
16DB  2EDC     GOTO 0x6DC
239:           		break;
16DC  0008     RETURN
240:           		case '\n':
241:           			vGotoxyLCD(1,++NLinea);			
16DD  1683     BSF STATUS, 0x5
16DE  0AB2     INCF 0x32, F
16DF  0832     MOVF 0x32, W
16E0  1283     BCF STATUS, 0x5
16E1  00A5     MOVWF y
16E2  3001     MOVLW 0x1
16E3  2E9C     GOTO 0x69C
242:           		break;
243:           		default:
244:           			vWriteLCD(Data,LCD_DATA);
16E4  01A3     CLRF x
16E5  0AA3     INCF x, F
16E6  082A     MOVF Data, W
16E7  2F5D     GOTO 0x75D
245:           	}
246:           } 
16C9  0008     RETURN
247:           
248:           void vGotoxyLCD(UINT8 x,UINT8 y){
169C  00A6     MOVWF x
249:           UINT8 Direccion;
250:           
251:           	switch(y){
169D  2EA9     GOTO 0x6A9
16A9  0825     MOVF y, W
16AA  3A01     XORLW 0x1
16AB  1903     BTFSC STATUS, 0x2
16AC  2E9E     GOTO 0x69E
16AD  3A03     XORLW 0x3
16AE  1903     BTFSC STATUS, 0x2
16AF  2EA3     GOTO 0x6A3
16B0  2E9E     GOTO 0x69E
252:           		case 1:Direccion = LCD_LINE_1_ADDRESS;NLinea=1;break;
169E  01A7     CLRF i
169F  1683     BSF STATUS, 0x5
16A0  01B2     CLRF 0x32
16A1  0AB2     INCF 0x32, F
16A2  2EB1     GOTO 0x6B1
253:           		case 2:Direccion = LCD_LINE_2_ADDRESS;NLinea=2;break;
16A3  3040     MOVLW 0x40
16A4  00A7     MOVWF i
16A5  3002     MOVLW 0x2
16A6  1683     BSF STATUS, 0x5
16A7  00B2     MOVWF 0x32
16A8  2EB1     GOTO 0x6B1
254:           		#ifdef LCD_4LINES
255:           		case 3:Direccion = LCD_LINE_3_ADDRESS;NLinea=3;break;
256:           		case 4:Direccion = LCD_LINE_4_ADDRESS;NLinea=4;break;
257:           		#endif
258:           		default:Direccion = LCD_LINE_1_ADDRESS;NLinea=1;break;
259:           	}
260:           
261:           	Direccion+=x-1;
16B1  1283     BCF STATUS, 0x5
16B2  0826     MOVF x, W
16B3  3EFF     ADDLW 0xFF
16B4  07A7     ADDWF i, F
262:           	while(ui8BusyLCD());
16B5  27CE     CALL 0x7CE
16B6  160A     BSF PCLATH, 0x4
16B7  118A     BCF PCLATH, 0x3
16B8  3800     IORLW 0x0
16B9  1D03     BTFSS STATUS, 0x2
16BA  2EB5     GOTO 0x6B5
263:           	vWriteLCD(0x80|Direccion,LCD_COMMAND);
16BB  01A3     CLRF x
264:           }
265:           
266:           void vPuts_LCD(UINT8 *buffer){
267:           
268:           
269:               while(*buffer != '\0')    {
270:                  // vLCD_Putc(*buffer++);;
271:                   vWriteLCD(*buffer++,LCD_DATA);
272:               }
273:           }
274:           
275:           void vBlinkingLCD(void){
276:           	vWriteLCD(0b1101,LCD_COMMAND);
277:           }
278:           void vnoBlinkingLCD(void){
279:           	vWriteLCD(0b1100,LCD_COMMAND);
280:           }
---  /media/Utilidades/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V4.X/HardI2C.c  -------------------------
1:             /**************************************************************************
2:             *      Libreria para protocolo I2C Master por HardWare para HiTech        *
3:             ***************************************************************************
4:             
5:             ***************************************************************************
6:             *                                                                         *
7:             * Antes de incluir este archivo en nuestro programa hay que definir       *
8:             * algunos parametros. Estos son                                           *
9:             *                                                                         *
10:            * PIC_CLK        (se usa para calcular el valor de SSPADD)                *     
11:            * I2C_BAUD       (velocidad de transferencia)                             *
12:            *                                                                         *
13:            ***************************************************************************
14:            
15:            ***************************************************************************
16:            *                                                                         *
17:            * En esta libreria se encuentran las siguientes funciones                 *
18:            *                                                                         *
19:            * setup_i2c(char)               (inicializa el puerto I2C)                *
20:            * start_i2c()                   (envia start, inicia transmision)         *
21:            * rstar_i2c()                   (envia restart, reinicia transmision)     *
22:            * stop_i2c()                    (envia stop, termina transmision)         *
23:            * write_i2c(char)               (envia un byte)                           *
24:            * read_i2c(char)                (recibe un byte y envia ack o noack)      *
25:            *                                                                         *
26:            *  La funcion write_i2c() devuelve 0 si el dispositivo responde o 1 si el *
27:            * dispositivo no responde.                                                *
28:            *                                                                         *
29:            *  A la funcion read_i2c() hay que pasarle 0 si se quiere responder al    *
30:            * disipositivo o 1 si no se quiere responder                              *
31:            *                                                                         *
32:            *  En esta libreria estan definidos los parametros I2C_MASTER, I2C_SLAVE, *
33:            * I2C_10BIT_ADDRESS. Eston son utilizados en la funcion setup_i2c(char)   *
34:            *                                                                         *
35:            *  Tambien estan definidos ACK y NOACK que son los utilizados para        *
36:            * responder o no al dispositivo                                           *
37:            *                                                                         *
38:            ***************************************************************************
39:            
40:            * Ejemplo de configuracion y utilizacion
41:            
42:             #define PIC_CLK   10000000   // cristal 10MHz
43:             #define I2C_BAUD  100000     // velocidad 100 KHz
44:             #include "HardI2c.c"
45:            
46:             void main (void);
47:             {
48:               unsigned char respuesta;
49:               unsigned char dato;  
50:             
51:               ......
52:               ......
53:               ......
54:               setup_i2c (I2C_MASTER);
55:               start_i2c();
56:               respuesta = write_i2c (0b10101110);    // comunicacion para escribir en una 24C02C
57:               if (respuesta == ACK)
58:               {
59:                 write_i2c (0x00);                    // indico la direccion a escribir
60:                 write_i2c (0xF5);                    // escribo el dato F5
61:                 write_i2c (0x06);                    // escribo el dato 06
62:               }
63:               stop_i2c();
64:            
65:               // colocar un delay necesario para que termine de grabar la memoria
66:            
67:               start_i2c();
68:               respuesta = write_i2c (0b10101110);    // comunicacion para escribir en una 24C02C
69:               if (respuesta == ACK)
70:               {
71:                 write_i2c (0x00);                    // indico la direccion de memoria
72:                 rstart_i2c();                       // reinicio la transmisin
73:                 respuesta = write_i2c (0b10101111);  // comunicacion para leer en una 24C02C
74:                 if (respuesta == ACK)
75:                 {
76:                   dato = read_i2c (ACK);             // leo el dato y respondo
77:                   dato = read_i2c (NOACK);           // leo el dato y no respondo
78:                 }
79:               }
80:               stop_i2c();
81:             }
82:            
83:            */
84:            #include <xc.h>
85:            #include <stdbool.h>       /* For true/false definition */
86:            #include "system.h"        /* System funct/params, like osc/peripheral config */
87:            #include "HardI2C.h"
88:            
89:            
90:            #if defined (PIC_CLK) && defined (I2C_BAUD)
91:            
92:            void setup_i2c (char x)
1651  00A3     MOVWF x
93:             {
94:                TRISC3 = 1;
1652  1683     BSF STATUS, 0x5
1653  1587     BSF PORTC, 0x3
95:            #ifndef _PIC18
96:                TRISC4 = 1;
1654  1607     BSF PORTC, 0x4
97:            
98:                SSPSTAT = 0;
1655  0194     CLRF SSPCON
99:                SSPCON = x;
1656  1283     BCF STATUS, 0x5
1657  0823     MOVF x, W
1658  0094     MOVWF SSPCON
100:               
101:               SSPCON2 = 0;
1659  1683     BSF STATUS, 0x5
165A  0191     CLRF TMR2
102:               #endif
103:              // SSPCON2bits.RCEN=1;
104:               if (SSPM3 == 1) SSPADD = (unsigned char)((PIC_CLK/(4*I2C_BAUD)) - 1);
165B  1283     BCF STATUS, 0x5
165C  1D94     BTFSS SSPCON, 0x3
165D  0008     RETURN
165E  300B     MOVLW 0xB
165F  1683     BSF STATUS, 0x5
1660  0093     MOVWF SSPBUF
105:           
106:           }
1661  0008     RETURN
107:           
108:             char start_i2c (void)
109:             { 
110:               while (( SSPCON2 & 0x1F ) | R_nW );
02B2  1003     BCF STATUS, 0x0
02B3  1683     BSF STATUS, 0x5
02B4  1303     BCF STATUS, 0x6
02B5  1914     BTFSC SSPCON, 0x2
02B6  1403     BSF STATUS, 0x0
02B7  3000     MOVLW 0x0
02B8  1803     BTFSC STATUS, 0x0
02B9  3001     MOVLW 0x1
02BA  1283     BCF STATUS, 0x5
02BB  00A3     MOVWF x
02BC  301F     MOVLW 0x1F
02BD  01A4     CLRF Data
02BE  1683     BSF STATUS, 0x5
02BF  0511     ANDWF TMR2, W
02C0  1283     BCF STATUS, 0x5
02C1  00A5     MOVWF y
02C2  0423     IORWF x, W
02C3  00A6     MOVWF x
02C4  0824     MOVF Data, W
02C5  00A7     MOVWF i
02C6  0426     IORWF x, W
02C7  1D03     BTFSS STATUS, 0x2
02C8  2AB2     GOTO 0x2B2
111:               SEN = 1;
02C9  1683     BSF STATUS, 0x5
02CA  1411     BSF TMR2, 0x0
112:               return !BCLIF;
113:             }
02CB  0008     RETURN
114:           
115:             void rstart_i2c (void)
116:             {
117:               while (( SSPCON2 & 0x1F ) | R_nW );
02EF  1003     BCF STATUS, 0x0
02F0  1683     BSF STATUS, 0x5
02F1  1914     BTFSC SSPCON, 0x2
02F2  1403     BSF STATUS, 0x0
02F3  3000     MOVLW 0x0
02F4  1803     BTFSC STATUS, 0x0
02F5  3001     MOVLW 0x1
02F6  1283     BCF STATUS, 0x5
02F7  00A3     MOVWF x
02F8  301F     MOVLW 0x1F
02F9  01A4     CLRF Data
02FA  1683     BSF STATUS, 0x5
02FB  0511     ANDWF TMR2, W
02FC  1283     BCF STATUS, 0x5
02FD  00A5     MOVWF y
02FE  0423     IORWF x, W
02FF  00A6     MOVWF x
0300  0824     MOVF Data, W
0301  00A7     MOVWF i
0302  0426     IORWF x, W
0303  1D03     BTFSS STATUS, 0x2
0304  2AEF     GOTO 0x2EF
118:               RSEN = 1;
0305  1683     BSF STATUS, 0x5
0306  1491     BSF TMR2, 0x1
119:             }
0307  0008     RETURN
120:           
121:             void stop_i2c (void)
122:             {
123:               while (( SSPCON2 & 0x1F ) | R_nW );
02D6  1003     BCF STATUS, 0x0
02D7  1683     BSF STATUS, 0x5
02D8  1914     BTFSC SSPCON, 0x2
02D9  1403     BSF STATUS, 0x0
02DA  3000     MOVLW 0x0
02DB  1803     BTFSC STATUS, 0x0
02DC  3001     MOVLW 0x1
02DD  1283     BCF STATUS, 0x5
02DE  00A3     MOVWF x
02DF  301F     MOVLW 0x1F
02E0  01A4     CLRF Data
02E1  1683     BSF STATUS, 0x5
02E2  0511     ANDWF TMR2, W
02E3  1283     BCF STATUS, 0x5
02E4  00A5     MOVWF y
02E5  0423     IORWF x, W
02E6  00A6     MOVWF x
02E7  0824     MOVF Data, W
02E8  00A7     MOVWF i
02E9  0426     IORWF x, W
02EA  1D03     BTFSS STATUS, 0x2
02EB  2AD6     GOTO 0x2D6
124:               PEN = 1;
02EC  1683     BSF STATUS, 0x5
02ED  1511     BSF TMR2, 0x2
125:             }
02EE  0008     RETURN
126:           
127:             char write_i2c (unsigned char data)
027A  1283     BCF STATUS, 0x5
027B  00A8     MOVWF data
128:             {
129:               if (SSPM3 == 1)
027C  1D94     BTFSS SSPCON, 0x3
027D  2A9D     GOTO 0x29D
130:               {
131:                 while (( SSPCON2 & 0x1F ) | R_nW );
027E  1003     BCF STATUS, 0x0
027F  1683     BSF STATUS, 0x5
0280  1914     BTFSC SSPCON, 0x2
0281  1403     BSF STATUS, 0x0
0282  3000     MOVLW 0x0
0283  1803     BTFSC STATUS, 0x0
0284  3001     MOVLW 0x1
0285  1283     BCF STATUS, 0x5
0286  00A3     MOVWF x
0287  301F     MOVLW 0x1F
0288  01A4     CLRF Data
0289  1683     BSF STATUS, 0x5
028A  0511     ANDWF TMR2, W
028B  1283     BCF STATUS, 0x5
028C  00A5     MOVWF y
028D  0423     IORWF x, W
028E  00A6     MOVWF x
028F  0824     MOVF Data, W
0290  00A7     MOVWF i
0291  0426     IORWF x, W
0292  1D03     BTFSS STATUS, 0x2
0293  2A7E     GOTO 0x27E
132:                 SSPBUF = data;
0294  0828     MOVF data, W
0295  0093     MOVWF SSPBUF
133:                 while (R_nW == 1);
0296  1683     BSF STATUS, 0x5
0297  1914     BTFSC SSPCON, 0x2
0298  2A96     GOTO 0x296
134:                 //while(ACKSTAT==1);
135:                 return ACKSTAT;
0299  3000     MOVLW 0x0
029A  1B11     BTFSC TMR2, 0x6
029B  3001     MOVLW 0x1
029C  0008     RETURN
136:               }
137:               else
138:               {
139:                 SSPBUF = data;
029D  0828     MOVF data, W
029E  0093     MOVWF SSPBUF
140:                 CKP = 1;
029F  1614     BSF SSPCON, 0x4
141:                 return 0;
02A0  3400     RETLW 0x0
142:               }
143:             }
144:           
145:             unsigned char read_i2c (unsigned char respuesta)
0187  1283     BCF STATUS, 0x5
0188  00A8     MOVWF data
146:             {
147:               unsigned char dato;
148:           
149:               if (SSPM3 == 1)
0189  1D94     BTFSS SSPCON, 0x3
018A  29DE     GOTO 0x1DE
150:               {
151:                 while (( SSPCON2 & 0x1F ) | R_nW );
018B  1003     BCF STATUS, 0x0
018C  1683     BSF STATUS, 0x5
018D  1914     BTFSC SSPCON, 0x2
018E  1403     BSF STATUS, 0x0
018F  3000     MOVLW 0x0
0190  1803     BTFSC STATUS, 0x0
0191  3001     MOVLW 0x1
0192  1283     BCF STATUS, 0x5
0193  00A3     MOVWF x
0194  301F     MOVLW 0x1F
0195  01A4     CLRF Data
0196  1683     BSF STATUS, 0x5
0197  0511     ANDWF TMR2, W
0198  1283     BCF STATUS, 0x5
0199  00A5     MOVWF y
019A  0423     IORWF x, W
019B  00A6     MOVWF x
019C  0824     MOVF Data, W
019D  00A7     MOVWF i
019E  0426     IORWF x, W
019F  1D03     BTFSS STATUS, 0x2
01A0  298B     GOTO 0x18B
152:                 RCEN = 1;
01A1  1683     BSF STATUS, 0x5
01A2  1591     BSF TMR2, 0x3
153:                 while (( SSPCON2 & 0x1F ) | R_nW );
01A3  1003     BCF STATUS, 0x0
01A4  1683     BSF STATUS, 0x5
01A5  1914     BTFSC SSPCON, 0x2
01A6  1403     BSF STATUS, 0x0
01A7  3000     MOVLW 0x0
01A8  1803     BTFSC STATUS, 0x0
01A9  3001     MOVLW 0x1
01AA  1283     BCF STATUS, 0x5
01AB  00A3     MOVWF x
01AC  301F     MOVLW 0x1F
01AD  01A4     CLRF Data
01AE  1683     BSF STATUS, 0x5
01AF  0511     ANDWF TMR2, W
01B0  1283     BCF STATUS, 0x5
01B1  00A5     MOVWF y
01B2  0423     IORWF x, W
01B3  00A6     MOVWF x
01B4  0824     MOVF Data, W
01B5  00A7     MOVWF i
01B6  0426     IORWF x, W
01B7  1D03     BTFSS STATUS, 0x2
01B8  29A3     GOTO 0x1A3
154:                 dato = SSPBUF;
01B9  0813     MOVF SSPBUF, W
01BA  00A9     MOVWF dato
155:                 while (( SSPCON2 & 0x1F ) | R_nW );
01BB  1003     BCF STATUS, 0x0
01BC  1683     BSF STATUS, 0x5
01BD  1914     BTFSC SSPCON, 0x2
01BE  1403     BSF STATUS, 0x0
01BF  3000     MOVLW 0x0
01C0  1803     BTFSC STATUS, 0x0
01C1  3001     MOVLW 0x1
01C2  1283     BCF STATUS, 0x5
01C3  00A3     MOVWF x
01C4  301F     MOVLW 0x1F
01C5  01A4     CLRF Data
01C6  1683     BSF STATUS, 0x5
01C7  0511     ANDWF TMR2, W
01C8  1283     BCF STATUS, 0x5
01C9  00A5     MOVWF y
01CA  0423     IORWF x, W
01CB  00A6     MOVWF x
01CC  0824     MOVF Data, W
01CD  00A7     MOVWF i
01CE  0426     IORWF x, W
01CF  1D03     BTFSS STATUS, 0x2
01D0  29BB     GOTO 0x1BB
156:                 ACKDT = respuesta;
01D1  1C28     BTFSS data, 0x0
01D2  29D7     GOTO 0x1D7
01D3  1683     BSF STATUS, 0x5
01D4  1303     BCF STATUS, 0x6
01D5  1691     BSF TMR2, 0x5
01D6  29DA     GOTO 0x1DA
01D7  1683     BSF STATUS, 0x5
01D8  1303     BCF STATUS, 0x6
01D9  1291     BCF TMR2, 0x5
157:                 ACKEN = 1;
01DA  1611     BSF TMR2, 0x4
158:                 return dato;
01DB  1283     BCF STATUS, 0x5
01DC  0829     MOVF dato, W
01DD  0008     RETURN
159:               }
160:               else
161:               {
162:                 dato = SSPBUF;
01DE  0813     MOVF SSPBUF, W
01DF  00A9     MOVWF dato
163:                 return dato;
164:               }
165:             }
01E0  0008     RETURN
166:           #else
167:             #error Faltan definir parametros
168:           #endif
