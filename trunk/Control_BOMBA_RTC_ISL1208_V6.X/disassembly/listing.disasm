Disassembly Listing for Control_BOMBA_RTC_ISL1208_V6
Generated From:
/home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/dist/ISL1208_XC8_16f877a/production/Control_BOMBA_RTC_ISL1208_V6.X.production.cof
25/01/2015 11:45:27

---  /opt/microchip/xc8/v1.31/sources/pic/ftdiv.c  ------------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (C) 2006 HI-TECH Software
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_dividend	(*(unsigned short long *)&f1)
11:            #define	f2_as_divisor	(*(unsigned short long *)&f2)
12:            #define	f3_as_quot	(*(unsigned short long *)&f3)
13:            
14:            // floating addition
15:            #ifdef _OLDLIB
16:            #define	cntr		sign2
17:            float
18:            __ftdiv(float f2, float f1)
19:            {
20:            	unsigned char	exp1, exp2, sign1, sign2;
21:            	float	f3;
22:            	
23:            	f3_as_quot = 0;
24:            	sign1 = __ftunpack(&f1_as_dividend, &exp1);
25:            	if(exp1 == 0)
26:            		return f3;
27:            	sign2 = __ftunpack(&f2_as_divisor, &exp2);
28:            	if(exp2 == 0)
29:            		return f3;
30:            	exp1 -= exp2-127+8;	// compute new exponent
31:            	sign1 ^= sign2;
32:            	cntr = 16+8;
33:            	do {
34:            		f3_as_quot <<= 1;
35:            		if(f1_as_dividend >= f2_as_divisor) {
36:            			f1_as_dividend -= f2_as_divisor;
37:            			f3_as_quot |= 1;
38:            		}
39:            		f1_as_dividend <<= 1;
40:            	} while(--cntr != 0);
41:            	__ftpack(&f3_as_quot, exp1);
42:            	if(sign1)
43:            		f3_as_quot |= 0x800000;
44:            	return f3;
45:            }
46:            #else
47:            #define	exp2	sign
48:            float
49:            __ftdiv(float f2, float f1)
50:            {
51:            	unsigned char	exp, sign, cntr;
52:            	float	f3;
53:            	
54:            	// unpack the operands
55:            	if((exp = f1_as_dividend >> 15) == 0)
13F2  084F     MOVF f1, W
13F3  00D2     MOVWF prec
13F4  0850     MOVF 0x50, W
13F5  00D3     MOVWF ap
13F6  0851     MOVF 0x51, W
13F7  00D4     MOVWF flag
13F8  1003     BCF STATUS, 0x0
13F9  0D53     RLF ap, W
13FA  0D54     RLF flag, W
13FB  00D9     MOVWF exp
13FC  08D9     MOVF exp, F
13FD  1D03     BTFSS STATUS, 0x2
13FE  2C03     GOTO 0x403
56:            		return 0.0;
13FF  01CC     CLRF f2
1400  01CD     CLRF 0x4D
1401  01CE     CLRF 0x4E
1402  0008     RETURN
57:            	if((exp2 = f2_as_divisor >> 15) == 0)
1403  084C     MOVF f2, W
1404  00D2     MOVWF prec
1405  084D     MOVF 0x4D, W
1406  00D3     MOVWF ap
1407  084E     MOVF 0x4E, W
1408  00D4     MOVWF flag
1409  1003     BCF STATUS, 0x0
140A  0D53     RLF ap, W
140B  0D54     RLF flag, W
140C  00DA     MOVWF c
140D  08DA     MOVF c, F
140E  1D03     BTFSS STATUS, 0x2
140F  2C14     GOTO 0x414
58:            		return 0.0;
1410  01CC     CLRF f2
1411  01CD     CLRF 0x4D
1412  01CE     CLRF 0x4E
1413  0008     RETURN
59:            	f3_as_quot = 0;
1415  01D6     CLRF f3
1416  01D7     CLRF _val
1417  01D8     CLRF 0x58
60:            	exp -= exp2-127+8;	// compute new exponent
1414  3089     MOVLW 0x89
1418  075A     ADDWF c, W
1419  00D2     MOVWF prec
141A  02D9     SUBWF exp, F
61:            	sign = f1_as_dividend >> 16;
141B  0851     MOVF 0x51, W
141C  00DA     MOVWF c
62:            	sign ^= (unsigned char)(f2_as_divisor >> 16);
141D  084E     MOVF 0x4E, W
141E  06DA     XORWF c, F
63:            	sign &= 0x80;
141F  3080     MOVLW 0x80
1420  05DA     ANDWF c, F
64:            	f1_as_dividend |= 0x8000UL;
1422  17D0     BSF 0x50, 0x7
65:            	f1_as_dividend &= 0xFFFFUL;
1423  01D1     CLRF 0x51
66:            	f2_as_divisor |= 0x8000UL;
1424  17CD     BSF 0x4D, 0x7
67:            	f2_as_divisor &= 0xFFFFUL;
1425  01CE     CLRF 0x4E
68:            	cntr = 16+8;
1421  3018     MOVLW 0x18
1426  00D5     MOVWF width
69:            	do {
70:            		f3_as_quot <<= 1;
1427  1003     BCF STATUS, 0x0
1428  0DD6     RLF f3, F
1429  0DD7     RLF _val, F
142A  0DD8     RLF 0x58, F
71:            		if(f1_as_dividend >= f2_as_divisor) {
142B  084E     MOVF 0x4E, W
142C  0251     SUBWF 0x51, W
142D  1D03     BTFSS STATUS, 0x2
142E  2C35     GOTO 0x435
142F  084D     MOVF 0x4D, W
1430  0250     SUBWF 0x50, W
1431  1D03     BTFSS STATUS, 0x2
1432  2C35     GOTO 0x435
1433  084C     MOVF f2, W
1434  024F     SUBWF f1, W
1435  1C03     BTFSS STATUS, 0x0
1436  2C43     GOTO 0x443
72:            			f1_as_dividend -= f2_as_divisor;
1437  084C     MOVF f2, W
1438  02CF     SUBWF f1, F
1439  084D     MOVF 0x4D, W
143A  1C03     BTFSS STATUS, 0x0
143B  0F4D     INCFSZ 0x4D, W
143C  02D0     SUBWF 0x50, F
143D  084E     MOVF 0x4E, W
143E  1C03     BTFSS STATUS, 0x0
143F  0A4E     INCF 0x4E, W
1440  02D1     SUBWF 0x51, F
73:            			f3_as_quot |= 1;
1441  1456     BSF f3, 0x0
74:            		}
75:            		f1_as_dividend <<= 1;
1442  1003     BCF STATUS, 0x0
1443  0DCF     RLF f1, F
1444  0DD0     RLF 0x50, F
1445  0DD1     RLF 0x51, F
76:            	} while(--cntr != 0);
1446  0BD5     DECFSZ width, F
1447  2C27     GOTO 0x427
77:            	return __ftpack(f3_as_quot, exp, sign);
1448  0856     MOVF f3, W
1449  00A3     MOVWF x
144A  0857     MOVF _val, W
144B  00A4     MOVWF dato
144C  0858     MOVF 0x58, W
144D  00A5     MOVWF y
144E  0859     MOVF exp, W
144F  00A6     MOVWF x
1450  085A     MOVF c, W
1451  00A7     MOVWF i
1452  2595     CALL 0x595
1453  0823     MOVF x, W
1454  00CC     MOVWF f2
1455  0824     MOVF dato, W
1456  00CD     MOVWF 0x4D
1457  0825     MOVF y, W
1458  00CE     MOVWF 0x4E
78:            }
1459  0008     RETURN
79:            #endif	
---  /opt/microchip/xc8/v1.31/sources/common/wmul.c  ----------------------------------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             unsigned int
3:             __wmul(unsigned int multiplier, unsigned int multiplicand)
4:             {
5:                     unsigned int product;
6:             
7:             #ifdef _PIC18
8:             
9:             #define LOWBYTE(x)  (*(unsigned char *)(&x))
10:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
11:            
12:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
13:            /*
14:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
15:                   a  b
16:            *      c  d
17:            -----------
18:                 |   bd
19:                 |ad  0
20:                 |bc  0
21:            +  ac| 0  0 (we ignore this intermediate product
22:                         because it does not affect the low 16 bits of the result)
23:            ===========
24:             */
25:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
26:                    product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
27:                    product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
28:            
29:            #else
30:            
31:            	product = 0;
1799  01A7     CLRF i
179A  01A8     CLRF mth
32:            	do {
33:            		if(multiplier & 1)
179B  1C23     BTFSS x, 0x0
179C  2FA3     GOTO 0x7A3
34:            			product += multiplicand;
179D  0825     MOVF y, W
179E  07A7     ADDWF i, F
179F  1803     BTFSC STATUS, 0x0
17A0  0AA8     INCF mth, F
17A1  0826     MOVF x, W
17A2  07A8     ADDWF mth, F
35:            		multiplicand <<= 1;
17A3  1003     BCF STATUS, 0x0
17A4  0DA5     RLF y, F
17A5  0DA6     RLF x, F
36:            		multiplier >>= 1;
17A6  1003     BCF STATUS, 0x0
17A7  0CA4     RRF dato, F
17A8  0CA3     RRF x, F
37:            	} while(multiplier != 0);
17A9  0824     MOVF dato, W
17AA  0423     IORWF x, W
17AB  1D03     BTFSS STATUS, 0x2
17AC  2F9B     GOTO 0x79B
38:            
39:            #endif
40:                    return product;
17AD  0828     MOVF mth, W
17AE  00A4     MOVWF dato
17AF  0827     MOVF i, W
17B0  00A3     MOVWF x
41:            }
17B1  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/lwtoft.c  --------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            
11:            // Convert unsigned int to float
12:            
13:            #ifdef _OLDLIB
14:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
15:            float
16:            __lwtoft(unsigned int c)
17:            {
18:            	float	f1;
19:            	
20:            	if(c == 0)
21:            		return 0.0;
22:            	f1_as_mant1 = c;
23:            	__ftpack(&f1_as_mant1, 127+15);
24:            	return f1;
25:            }
26:            #else
27:            float
28:            __lwtoft(unsigned int c)
29:            {
30:            	return __ftpack(c, 127+15, 0);
13CC  0830     MOVF c, W
13CD  00A3     MOVWF x
13CE  0831     MOVF divisor, W
13CF  00A4     MOVWF dato
13D0  308E     MOVLW 0x8E
13D1  01A5     CLRF y
13D2  00A6     MOVWF x
13D3  01A7     CLRF i
13D4  2595     CALL 0x595
13D5  0823     MOVF x, W
13D6  00B0     MOVWF c
13D7  0824     MOVF dato, W
13D8  00B1     MOVWF divisor
13D9  0825     MOVF y, W
13DA  00B2     MOVWF 0x32
31:            }
13DB  0008     RETURN
32:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/lwmod.c  ---------------------------------------------------
1:             // word unsigned modulus
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwmod(unsigned int divisor, unsigned int dividend)
0F76  0871     MOVF canal, W
17DC  082B     MOVF sec, W
7:             #else
8:             __lwmod(unsigned int dividend, unsigned int divisor)
9:             #endif
10:            {
11:            	unsigned char	counter;
12:            
13:            	if(divisor != 0) {
0F76  0871     MOVF canal, W
0F77  0470     IORWF divisor, W
0F78  1903     BTFSC STATUS, 0x2
0F79  2F95     GOTO 0x795
17DC  082B     MOVF sec, W
17DD  042A     IORWF Data, W
17DE  1903     BTFSC STATUS, 0x2
17DF  2FFB     GOTO 0x7FB
14:            		counter = 1;
0F7A  01F4     CLRF counter
17E0  01AE     CLRF sign
15:            		while((divisor & 0x8000) == 0) {
0F7C  1BF1     BTFSC canal, 0x7
0F7D  2F82     GOTO 0x782
0F81  2F7B     GOTO 0x77B
17E2  1BAB     BTFSC sec, 0x7
17E3  2FE8     GOTO 0x7E8
17E7  2FE1     GOTO 0x7E1
16:            			divisor <<= 1;
0F7B  0AF4     INCF counter, F
0F7E  1003     BCF STATUS, 0x0
0F7F  0DF0     RLF divisor, F
0F80  0DF1     RLF canal, F
17E1  0AAE     INCF sign, F
17E4  1003     BCF STATUS, 0x0
17E5  0DAA     RLF Data, F
17E6  0DAB     RLF sec, F
17:            			counter++;
0F7B  0AF4     INCF counter, F
17E1  0AAE     INCF sign, F
18:            		}
19:            		do {
20:            			if(divisor <= dividend)
0F82  0871     MOVF canal, W
0F83  0273     SUBWF counter, W
0F84  1D03     BTFSS STATUS, 0x2
0F85  2F88     GOTO 0x788
0F86  0870     MOVF divisor, W
0F87  0272     SUBWF dividend, W
0F88  1C03     BTFSS STATUS, 0x0
0F89  2F91     GOTO 0x791
17E8  082B     MOVF sec, W
17E9  022D     SUBWF day, W
17EA  1D03     BTFSS STATUS, 0x2
17EB  2FEE     GOTO 0x7EE
17EC  082A     MOVF Data, W
17ED  022C     SUBWF hr, W
17EE  1C03     BTFSS STATUS, 0x0
17EF  2FF7     GOTO 0x7F7
21:            				dividend -= divisor;
0F8A  0870     MOVF divisor, W
0F8B  02F2     SUBWF dividend, F
0F8C  0871     MOVF canal, W
0F8D  1C03     BTFSS STATUS, 0x0
0F8E  03F3     DECF counter, F
0F8F  02F3     SUBWF counter, F
17F0  082A     MOVF Data, W
17F1  02AC     SUBWF hr, F
17F2  082B     MOVF sec, W
17F3  1C03     BTFSS STATUS, 0x0
17F4  03AD     DECF day, F
17F5  02AD     SUBWF day, F
22:            			divisor >>= 1;
0F90  1003     BCF STATUS, 0x0
0F91  0CF1     RRF canal, F
0F92  0CF0     RRF divisor, F
17F6  1003     BCF STATUS, 0x0
17F7  0CAB     RRF sec, F
17F8  0CAA     RRF Data, F
23:            		} while(--counter != 0);
0F93  0BF4     DECFSZ counter, F
0F94  2F82     GOTO 0x782
17F9  0BAE     DECFSZ sign, F
17FA  2FE8     GOTO 0x7E8
24:            	}
25:            	return dividend;
0F95  0873     MOVF counter, W
0F96  00F1     MOVWF canal
0F97  0872     MOVF dividend, W
0F98  00F0     MOVWF divisor
17FB  082D     MOVF day, W
17FC  00AB     MOVWF sec
17FD  082C     MOVF hr, W
17FE  00AA     MOVWF Data
26:            }
0F99  0008     RETURN
17FF  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/lwdiv.c  ---------------------------------------------------
1:             // word unsigned division
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwdiv(unsigned int divisor, unsigned int dividend)
7:             #else
8:             __lwdiv(unsigned int dividend, unsigned int divisor)
9:             #endif
10:            {
11:            	unsigned int	quotient;
12:            	unsigned char	counter;
13:            
14:            	quotient = 0;
17B2  01A7     CLRF i
17B3  01A8     CLRF mth
15:            	if(divisor != 0) {
17B4  0824     MOVF dato, W
17B5  0423     IORWF x, W
17B6  1903     BTFSC STATUS, 0x2
17B7  2FD7     GOTO 0x7D7
16:            		counter = 1;
17B8  01A9     CLRF year
17:            		while((divisor & 0x8000) == 0) {
17BA  1BA4     BTFSC dato, 0x7
17BB  2FC0     GOTO 0x7C0
17BF  2FB9     GOTO 0x7B9
18:            			divisor <<= 1;
17B9  0AA9     INCF year, F
17BC  1003     BCF STATUS, 0x0
17BD  0DA3     RLF x, F
17BE  0DA4     RLF dato, F
19:            			counter++;
17B9  0AA9     INCF year, F
20:            		}
21:            		do {
22:            			quotient <<= 1;
17C0  1003     BCF STATUS, 0x0
17C1  0DA7     RLF i, F
17C2  0DA8     RLF mth, F
23:            			if(divisor <= dividend) {
17C3  0824     MOVF dato, W
17C4  0226     SUBWF x, W
17C5  1D03     BTFSS STATUS, 0x2
17C6  2FC9     GOTO 0x7C9
17C7  0823     MOVF x, W
17C8  0225     SUBWF y, W
17C9  1C03     BTFSS STATUS, 0x0
17CA  2FD3     GOTO 0x7D3
24:            				dividend -= divisor;
17CB  0823     MOVF x, W
17CC  02A5     SUBWF y, F
17CD  0824     MOVF dato, W
17CE  1C03     BTFSS STATUS, 0x0
17CF  03A6     DECF x, F
17D0  02A6     SUBWF x, F
25:            				quotient |= 1;
17D1  1427     BSF i, 0x0
26:            			}
27:            			divisor >>= 1;
17D2  1003     BCF STATUS, 0x0
17D3  0CA4     RRF dato, F
17D4  0CA3     RRF x, F
28:            		} while(--counter != 0);
17D5  0BA9     DECFSZ year, F
17D6  2FC0     GOTO 0x7C0
29:            	}
30:            	return quotient;
17D7  0828     MOVF mth, W
17D8  00A4     MOVWF dato
17D9  0827     MOVF i, W
17DA  00A3     MOVWF x
31:            }
17DB  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/lbmod.c  ---------------------------------------------------
1:             // byte unsigned modulus
2:             
3:             unsigned char
4:             __lbmod(unsigned char dividend, unsigned char divisor)
0C11  00A5     MOVWF y
0FC2  00F2     MOVWF dividend
5:             {
6:             	unsigned char	rem;
7:             	unsigned char	counter;
8:             
9:             	counter = 8;
0C12  3008     MOVLW 0x8
0C13  00A6     MOVWF x
0FC3  3008     MOVLW 0x8
0FC4  00F3     MOVWF counter
10:            	rem = 0;
0C14  01A7     CLRF i
0FC5  01F4     CLRF counter
11:            	do {
12:            		rem = (rem << 1) | (dividend >> 7);
0C15  0825     MOVF y, W
0C16  00A4     MOVWF dato
0C17  3007     MOVLW 0x7
0C18  1003     BCF STATUS, 0x0
0C19  0CA4     RRF dato, F
0C1A  3EFF     ADDLW 0xFF
0C1B  1003     BCF STATUS, 0x0
0C1C  1D03     BTFSS STATUS, 0x2
0C1D  2C19     GOTO 0x419
0C1E  0D27     RLF i, W
0C1F  0424     IORWF dato, W
0C20  00A7     MOVWF i
0FC6  0872     MOVF dividend, W
0FC7  00F1     MOVWF canal
0FC8  3007     MOVLW 0x7
0FC9  1003     BCF STATUS, 0x0
0FCA  0CF1     RRF canal, F
0FCB  3EFF     ADDLW 0xFF
0FCC  1003     BCF STATUS, 0x0
0FCD  1D03     BTFSS STATUS, 0x2
0FCE  2FCA     GOTO 0x7CA
0FCF  0D74     RLF counter, W
0FD0  0471     IORWF canal, W
0FD1  00F4     MOVWF counter
13:            		dividend <<= 1;
0C21  1003     BCF STATUS, 0x0
0C22  0DA5     RLF y, F
0FD2  1003     BCF STATUS, 0x0
0FD3  0DF2     RLF dividend, F
14:            		if(divisor <= rem)
0C23  0823     MOVF x, W
0C24  0227     SUBWF i, W
0C25  1C03     BTFSS STATUS, 0x0
0C26  2C29     GOTO 0x429
0FD4  0870     MOVF divisor, W
0FD5  0274     SUBWF counter, W
0FD6  1C03     BTFSS STATUS, 0x0
0FD7  2FDA     GOTO 0x7DA
15:            			rem -= divisor;
0C27  0823     MOVF x, W
0C28  02A7     SUBWF i, F
0FD8  0870     MOVF divisor, W
0FD9  02F4     SUBWF counter, F
16:            	} while(--counter != 0);
0C29  0BA6     DECFSZ x, F
0C2A  2C15     GOTO 0x415
0FDA  0BF3     DECFSZ counter, F
0FDB  2FC6     GOTO 0x7C6
17:            	return rem;
0C2B  0827     MOVF i, W
0FDC  0874     MOVF counter, W
18:            }
0C2C  0008     RETURN
0FDD  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/lbdiv.c  ---------------------------------------------------
1:             // byte unsigned division
2:             
3:             unsigned char
4:             __lbdiv(unsigned char dividend, unsigned char divisor)
0BAA  00A4     MOVWF dato
5:             {
6:             	unsigned char	quotient;
7:             	unsigned char	counter;
8:             
9:             	quotient = 0;
0BAB  01A6     CLRF x
10:            	if(divisor != 0) {
0BAC  0823     MOVF x, W
0BAD  1903     BTFSC STATUS, 0x2
0BAE  2BC3     GOTO 0x3C3
11:            		counter = 1;
0BAF  01A5     CLRF y
12:            		while((divisor & 0x80) == 0) {
0BB1  1BA3     BTFSC x, 0x7
0BB2  2BB6     GOTO 0x3B6
0BB5  2BB0     GOTO 0x3B0
13:            			divisor <<= 1;
0BB3  1003     BCF STATUS, 0x0
0BB4  0DA3     RLF x, F
14:            			counter++;
0BB0  0AA5     INCF y, F
15:            		}
16:            		do {
17:            			quotient <<= 1;
0BB6  1003     BCF STATUS, 0x0
0BB7  0DA6     RLF x, F
18:            			if(divisor <= dividend) {
0BB8  0823     MOVF x, W
0BB9  0224     SUBWF dato, W
0BBA  1C03     BTFSS STATUS, 0x0
0BBB  2BC0     GOTO 0x3C0
19:            				dividend -= divisor;
0BBC  0823     MOVF x, W
0BBD  02A4     SUBWF dato, F
20:            				quotient |= 1;
0BBE  1426     BSF x, 0x0
21:            			}
22:            			divisor >>= 1;
0BBF  1003     BCF STATUS, 0x0
0BC0  0CA3     RRF x, F
23:            		} while(--counter != 0);
0BC1  0BA5     DECFSZ y, F
0BC2  2BB6     GOTO 0x3B6
24:            	}
25:            	return quotient;
0BC3  0826     MOVF x, W
26:            }
0BC4  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/isdigit.c  -------------------------------------------------
1:             #include	<ctype.h>
2:             
3:             #ifndef isdigit
4:             
5:             #ifdef _CTYPE_BIT_FUNCS_
6:             
7:             bit
8:             isdigit(char c)
178B  00A4     MOVWF dato
9:             #else
10:            int
11:            isdigit(int c)
12:            #endif
13:            {
14:            	return c <= '9' && c >= '0';
178C  303A     MOVLW 0x3A
178D  01A3     CLRF x
178E  0224     SUBWF dato, W
178F  1803     BTFSC STATUS, 0x0
1790  2F97     GOTO 0x797
1791  3030     MOVLW 0x30
1792  0224     SUBWF dato, W
1793  1C03     BTFSS STATUS, 0x0
1794  2F97     GOTO 0x797
1795  01A3     CLRF x
1796  0AA3     INCF x, F
1797  0C23     RRF x, W
15:            }
1798  0008     RETURN
16:            
17:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/fttol.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
11:            
12:            // Convert float to long
13:            
14:            #ifdef _OLDLIB
15:            long
16:            __fttol(float f1)
17:            {
18:            	unsigned char	sign1, exp1;
19:            	unsigned long	lval;
20:            
21:            	sign1 = __ftunpack(&f1_as_mant1, &exp1);
22:            	lval = f1_as_mant1;
23:            	exp1 -= 127+15;
24:            	if((signed char)exp1 < 0) {
25:            		if((signed char)exp1 < -15)
26:            			return 0;
27:            		do
28:            			lval >>= 1;
29:            		while(++exp1 != 0);
30:            	} else {
31:            		if(exp1 >= 32)
32:            			return 00;
33:            		while(exp1 != 0) {
34:            			lval <<= 1;
35:            			exp1--;
36:            		}
37:            	}
38:            	if(sign1)
39:            		lval = -lval;
40:            	return lval;
41:            }
42:            #else
43:            long
44:            __fttol(float f1)
45:            {
46:            	unsigned char	sign1, exp1;
47:            	unsigned long	lval;
48:            
49:            	if((exp1 = f1_as_mant1 >> 15) == 0)
06F2  0823     MOVF x, W
06F3  00A7     MOVWF i
06F4  0824     MOVF dato, W
06F5  00A8     MOVWF mth
06F6  0825     MOVF y, W
06F7  00A9     MOVWF year
06F8  1003     BCF STATUS, 0x0
06F9  0D28     RLF mth, W
06FA  0D29     RLF year, W
06FB  00AF     MOVWF quotient
06FC  08AF     MOVF quotient, F
06FD  1D03     BTFSS STATUS, 0x2
06FE  2F04     GOTO 0x704
50:            		return 0;
06FF  01A3     CLRF x
0700  01A4     CLRF dato
0701  01A5     CLRF y
0702  01A6     CLRF x
0703  0008     RETURN
51:            	sign1 = f1_as_mant1 >> 23;
0704  0823     MOVF x, W
0705  00A7     MOVWF i
0706  0824     MOVF dato, W
0707  00A8     MOVWF mth
0708  0825     MOVF y, W
0709  00A9     MOVWF year
070A  3017     MOVLW 0x17
070B  1003     BCF STATUS, 0x0
070C  0CA9     RRF year, F
070D  0CA8     RRF mth, F
070E  0CA7     RRF i, F
070F  3EFF     ADDLW 0xFF
0710  1D03     BTFSS STATUS, 0x2
0711  2F0B     GOTO 0x70B
0712  0827     MOVF i, W
0713  00AA     MOVWF Data
52:            	f1_as_mant1 |= 0x8000UL;
0714  17A4     BSF dato, 0x7
53:            	f1_as_mant1 &= 0xFFFFUL;
0715  01A5     CLRF y
54:            	lval = f1_as_mant1;
0716  0823     MOVF x, W
0717  00AB     MOVWF sec
0718  0824     MOVF dato, W
0719  00AC     MOVWF hr
071A  0825     MOVF y, W
071B  00AD     MOVWF day
071D  01AE     CLRF sign
55:            	exp1 -= 127+15;
071C  308E     MOVLW 0x8E
071E  02AF     SUBWF quotient, F
56:            	if((signed char)exp1 < 0) {
071F  1FAF     BTFSS quotient, 0x7
0720  2F2E     GOTO 0x72E
57:            		if((signed char)exp1 < -15)
0721  082F     MOVF quotient, W
0722  3A80     XORLW 0x80
0723  3E8F     ADDLW 0x8F
0724  1C03     BTFSS STATUS, 0x0
0725  2EFF     GOTO 0x6FF
58:            			return 0;
59:            		do
60:            			lval >>= 1;
0726  1003     BCF STATUS, 0x0
0727  0CAE     RRF sign, F
0728  0CAD     RRF day, F
0729  0CAC     RRF hr, F
072A  0CAB     RRF sec, F
61:            		while(++exp1 != 0);
072B  0FAF     INCFSZ quotient, F
072C  2F26     GOTO 0x726
072D  2F3C     GOTO 0x73C
62:            	} else {
63:            		if(exp1 >= 24)
072E  3018     MOVLW 0x18
072F  022F     SUBWF quotient, W
0730  1803     BTFSC STATUS, 0x0
0731  2EFF     GOTO 0x6FF
64:            			return 0;
65:            		while(exp1 != 0) {
0732  08AF     MOVF quotient, F
073B  2F32     GOTO 0x732
66:            			lval <<= 1;
0735  1003     BCF STATUS, 0x0
0736  0DAB     RLF sec, F
0737  0DAC     RLF hr, F
0738  0DAD     RLF day, F
0739  0DAE     RLF sign, F
67:            			exp1--;
073A  03AF     DECF quotient, F
68:            		}
0732  08AF     MOVF quotient, F
0733  1903     BTFSC STATUS, 0x2
0734  2F3C     GOTO 0x73C
69:            	}
70:            	if(sign1)
073C  082A     MOVF Data, W
073D  1903     BTFSC STATUS, 0x2
073E  2F4A     GOTO 0x74A
71:            		lval = -lval;
073F  09AB     COMF sec, F
0740  09AC     COMF hr, F
0741  09AD     COMF day, F
0742  09AE     COMF sign, F
0743  0AAB     INCF sec, F
0744  1903     BTFSC STATUS, 0x2
0745  0AAC     INCF hr, F
0746  1903     BTFSC STATUS, 0x2
0747  0AAD     INCF day, F
0748  1903     BTFSC STATUS, 0x2
0749  0AAE     INCF sign, F
72:            	return lval;
074A  082E     MOVF sign, W
074B  00A6     MOVWF x
074C  082D     MOVF day, W
074D  00A5     MOVWF y
074E  082C     MOVF hr, W
074F  00A4     MOVWF dato
0750  082B     MOVF sec, W
0751  00A3     MOVWF x
73:            }
0752  0008     RETURN
74:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/ftsub.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
11:            #define	f2_as_mant2	(*(unsigned short long *)&f2)
12:            
13:            // floating addition
14:            
15:            float
16:            #ifdef __PICC__
17:            #warning TODO: update cgpic and this file to use the other prototype
18:            __ftsub(float f2, float f1)
19:            #else
20:            __ftsub(float f1, float f2)
21:            #endif
22:            {
23:            	f2_as_mant2 ^= 0x800000;
13DC  3080     MOVLW 0x80
13DD  06B9     XORWF 0x39, F
24:            	return __ftadd(f1, f2);
13DE  083A     MOVF f1, W
13DF  00AB     MOVWF sec
13E0  083B     MOVF 0x3B, W
13E1  00AC     MOVWF hr
13E2  083C     MOVF 0x3C, W
13E3  00AD     MOVWF day
13E4  0837     MOVF mes, W
13E5  00AE     MOVWF sign
13E6  0838     MOVF anio, W
13E7  00AF     MOVWF quotient
13E8  0839     MOVF 0x39, W
13E9  00B0     MOVWF c
13EA  24D5     CALL 0x4D5
13EB  082B     MOVF sec, W
13EC  00B7     MOVWF mes
13ED  082C     MOVF hr, W
13EE  00B8     MOVWF anio
13EF  082D     MOVF day, W
13F0  00B9     MOVWF 0x39
25:            }
13F1  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/ftmul.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_plier	(*(unsigned short long *)&f1)
11:            #define	f2_as_plicand	(*(unsigned short long *)&f2)
12:            
13:            // floating addition
14:            
15:            #ifdef _OLDLIB
16:            #define	f3_as_product		(*(unsigned short long *)&f3)
17:            float
18:            __ftmul(float f1, float f2)
19:            {
20:            	unsigned char	exp1, sign1, cntr;
21:            	float	f3;
22:            	
23:            	f3_as_product = 0;
24:            	sign1 = __ftunpack(&f1_as_plier, &exp1);
25:            	sign1 ^= __ftunpack(&f2_as_plicand, &cntr);
26:            	if(cntr == 0 || exp1 == 0)
27:            		return f3;
28:            	exp1 += cntr-127-6;	// compute new exponent
29:            	cntr = 7;
30:            	do {
31:            		if(f1_as_plier & 1)
32:            			f3_as_product += f2_as_plicand;
33:            		f1_as_plier >>= 1;
34:            		f2_as_plicand <<= 1;
35:            	} while(--cntr != 0);
36:            	cntr = 9;
37:            	do {
38:            		if(f1_as_plier & 1)
39:            			f3_as_product += f2_as_plicand;
40:            		f1_as_plier >>= 1;
41:            		f3_as_product >>= 1;
42:            	} while(--cntr != 0);
43:            	__ftpack(&f3_as_product, exp1);
44:            	if(sign1)
45:            		f3_as_product |= 0x800000;
46:            	return f3;
47:            }
48:            #else
49:            #define	exp2	sign
50:            float
51:            __ftmul(float f1, float f2)
52:            {
53:            	unsigned char	exp, sign, cntr;
54:            	unsigned short long	f3_as_product;
55:            
56:            	if((exp = f1_as_plier >> 15) == 0)
145A  083D     MOVF f1, W
145B  00C3     MOVWF dow
145C  083E     MOVF 0x3E, W
145D  00C4     MOVWF a
145E  083F     MOVF 0x3F, W
145F  00C5     MOVWF dia
1460  1003     BCF STATUS, 0x0
1461  0D44     RLF a, W
1462  0D45     RLF dia, W
1463  00C6     MOVWF y
1464  08C6     MOVF y, F
1465  1D03     BTFSS STATUS, 0x2
1466  2C6B     GOTO 0x46B
57:            		return 0.0;
1467  01BD     CLRF f1
1468  01BE     CLRF 0x3E
1469  01BF     CLRF 0x3F
146A  0008     RETURN
58:            	if((exp2 = f2_as_plicand >> 15) == 0)
146B  0840     MOVF f2, W
146C  00C3     MOVWF dow
146D  0841     MOVF 0x41, W
146E  00C4     MOVWF a
146F  0842     MOVF m, W
1470  00C5     MOVWF dia
1471  1003     BCF STATUS, 0x0
1472  0D44     RLF a, W
1473  0D45     RLF dia, W
1474  00CB     MOVWF sign
1475  08CB     MOVF sign, F
1476  1D03     BTFSS STATUS, 0x2
1477  2C7C     GOTO 0x47C
59:            		return 0.0;
1478  01BD     CLRF f1
1479  01BE     CLRF 0x3E
147A  01BF     CLRF 0x3F
147B  0008     RETURN
60:            	exp += exp2-127-6;	// compute new exponent
147C  084B     MOVF sign, W
147D  3E7B     ADDLW 0x7B
147E  07C6     ADDWF y, F
61:            	sign = f1_as_plier >> 16;
147F  083F     MOVF 0x3F, W
1480  00CB     MOVWF sign
62:            	sign ^= (unsigned char)(f2_as_plicand >> 16);
1481  0842     MOVF m, W
1482  06CB     XORWF sign, F
63:            	sign &= 0x80;
1483  3080     MOVLW 0x80
1484  05CB     ANDWF sign, F
64:            	f1_as_plier |= 0x8000UL;
1486  17BE     BSF 0x3E, 0x7
65:            	//f1_as_plier &= 0xFFFFUL;		// not required
66:            	f2_as_plicand |= 0x8000UL;
1487  17C1     BSF 0x41, 0x7
67:            	f2_as_plicand &= 0xFFFFUL;
1488  01C2     CLRF m
68:            	f3_as_product = 0;
1489  01C7     CLRF f
148A  01C8     CLRF 0x48
148B  01C9     CLRF 0x49
69:            	cntr = 7;
1485  3007     MOVLW 0x7
148C  00CA     MOVWF cntr
70:            	do {
71:            		if(f1_as_plier & 1)
148D  1C3D     BTFSS f1, 0x0
148E  2C9D     GOTO 0x49D
72:            			f3_as_product += f2_as_plicand;
148F  0840     MOVF f2, W
1490  07C7     ADDWF f, F
1491  0841     MOVF 0x41, W
1492  1103     BCF STATUS, 0x2
1493  1803     BTFSC STATUS, 0x0
1494  0A41     INCF 0x41, W
1495  1D03     BTFSS STATUS, 0x2
1496  07C8     ADDWF 0x48, F
1497  0842     MOVF m, W
1498  1103     BCF STATUS, 0x2
1499  1803     BTFSC STATUS, 0x0
149A  0A42     INCF m, W
149B  1D03     BTFSS STATUS, 0x2
149C  07C9     ADDWF 0x49, F
73:            		f1_as_plier >>= 1;
149D  1003     BCF STATUS, 0x0
149E  0CBF     RRF 0x3F, F
149F  0CBE     RRF 0x3E, F
14A0  0CBD     RRF f1, F
74:            		f2_as_plicand <<= 1;
14A1  1003     BCF STATUS, 0x0
14A2  0DC0     RLF f2, F
14A3  0DC1     RLF 0x41, F
14A4  0DC2     RLF m, F
75:            	} while(--cntr != 0);
14A5  0BCA     DECFSZ cntr, F
14A6  2C8D     GOTO 0x48D
76:            	cntr = 9;
14A7  3009     MOVLW 0x9
14A8  00CA     MOVWF cntr
77:            	do {
78:            		if(f1_as_plier & 1)
14A9  1C3D     BTFSS f1, 0x0
14AA  2CB9     GOTO 0x4B9
79:            			f3_as_product += f2_as_plicand;
14AB  0840     MOVF f2, W
14AC  07C7     ADDWF f, F
14AD  0841     MOVF 0x41, W
14AE  1103     BCF STATUS, 0x2
14AF  1803     BTFSC STATUS, 0x0
14B0  0A41     INCF 0x41, W
14B1  1D03     BTFSS STATUS, 0x2
14B2  07C8     ADDWF 0x48, F
14B3  0842     MOVF m, W
14B4  1103     BCF STATUS, 0x2
14B5  1803     BTFSC STATUS, 0x0
14B6  0A42     INCF m, W
14B7  1D03     BTFSS STATUS, 0x2
14B8  07C9     ADDWF 0x49, F
80:            		f1_as_plier >>= 1;
14B9  1003     BCF STATUS, 0x0
14BA  0CBF     RRF 0x3F, F
14BB  0CBE     RRF 0x3E, F
14BC  0CBD     RRF f1, F
81:            		f3_as_product >>= 1;
14BD  1003     BCF STATUS, 0x0
14BE  0CC9     RRF 0x49, F
14BF  0CC8     RRF 0x48, F
14C0  0CC7     RRF f, F
82:            	} while(--cntr != 0);
14C1  0BCA     DECFSZ cntr, F
14C2  2CA9     GOTO 0x4A9
83:            	return __ftpack(f3_as_product, exp, sign);
14C3  0847     MOVF f, W
14C4  00A3     MOVWF x
14C5  0848     MOVF 0x48, W
14C6  00A4     MOVWF dato
14C7  0849     MOVF 0x49, W
14C8  00A5     MOVWF y
14C9  0846     MOVF y, W
14CA  00A6     MOVWF x
14CB  084B     MOVF sign, W
14CC  00A7     MOVWF i
14CD  2595     CALL 0x595
14CE  0823     MOVF x, W
14CF  00BD     MOVWF f1
14D0  0824     MOVF dato, W
14D1  00BE     MOVWF 0x3E
14D2  0825     MOVF y, W
14D3  00BF     MOVWF 0x3F
84:            }
14D4  0008     RETURN
85:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/ftge.c  ----------------------------------------------------
1:             #define	f1	(*(unsigned short long *)&ff1)
2:             #define	f2	(*(unsigned short long *)&ff2)
3:             bit
4:             __ftge(float ff1, float ff2)
5:             {
6:             	if(f1 &  0x800000UL)
07C6  1FA5     BTFSS y, 0x7
07C7  2FD5     GOTO 0x7D5
7:             		f1 = 0x800000UL - f1;
07C8  0823     MOVF x, W
07C9  3C00     SUBLW 0x0
07CA  00A3     MOVWF x
07CB  0824     MOVF dato, W
07CC  1C03     BTFSS STATUS, 0x0
07CD  0F24     INCFSZ dato, W
07CE  3C00     SUBLW 0x0
07CF  00A4     MOVWF dato
07D0  0825     MOVF y, W
07D1  1C03     BTFSS STATUS, 0x0
07D2  0F25     INCFSZ y, W
07D3  3C80     SUBLW 0x80
07D4  00A5     MOVWF y
8:             	if(f2 &  0x800000UL)
07D5  1FA8     BTFSS mth, 0x7
07D6  2FE4     GOTO 0x7E4
9:             		f2 = 0x800000UL - f2;
07D7  0826     MOVF x, W
07D8  3C00     SUBLW 0x0
07D9  00A6     MOVWF x
07DA  0827     MOVF i, W
07DB  1C03     BTFSS STATUS, 0x0
07DC  0F27     INCFSZ i, W
07DD  3C00     SUBLW 0x0
07DE  00A7     MOVWF i
07DF  0828     MOVF mth, W
07E0  1C03     BTFSS STATUS, 0x0
07E1  0F28     INCFSZ mth, W
07E2  3C80     SUBLW 0x80
07E3  00A8     MOVWF mth
10:            	f1 ^= 0x800000UL;
07E4  3080     MOVLW 0x80
07E5  06A5     XORWF y, F
11:            	f2 ^= 0x800000UL;
07E6  06A8     XORWF mth, F
12:            	return f1 >= f2;
07E7  0828     MOVF mth, W
13:            }
---  /opt/microchip/xc8/v1.31/sources/common/ftadd.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned short long *)&f1)
11:            #define	f2_as_mant2	(*(unsigned short long *)&f2)
12:            
13:            // floating addition
14:            #ifdef _OLDLIB
15:            float
16:            __ftadd(float f1, float f2)
17:            {
18:            	unsigned char	exp1, exp2, sign1, sign2, cntr;
19:            	
20:            	if(sizeof(f1_as_mant1) != 3)
21:            		return 0;
22:            	sign1 = __ftunpack(&f1_as_mant1, &exp1);
23:            	if(exp1 == 0)
24:            		return f2;
25:            	sign2 = __ftunpack(&f2_as_mant2, &exp2);
26:            	if(exp2 != 0) {
27:            		cntr = 6;
28:            		// determine the smaller number. 
29:            		if(exp1 < exp2) {
30:            			if((unsigned char)(exp2-exp1) > sizeof(f1)*8) {
31:            				// return f2
32:            				f1_as_mant1 = 0;
33:            				exp1 = exp2;
34:            				sign1 = sign2;
35:            			} else {
36:            				// f1 has the smaller exponent - we can shift f2_as_mant2 up to 6 bits
37:            				// left, decrementing exp2.
38:            				do {
39:            					f2_as_mant2 <<= 1;
40:            					exp2--;
41:            				} while(exp2 != exp1 && --cntr != 0);
42:            				while(exp1 != exp2) {
43:            					f1_as_mant1 >>= 1;
44:            					exp1++;
45:            				}
46:            			}
47:            		} else if(exp1 != exp2) {
48:            			if((unsigned char)(exp1-exp2) > sizeof(f1)*8)
49:            				f2_as_mant2 = 0;
50:            			else {
51:            				// f2 has the smaller exponent - we can shift f1_as_mant1 up to 6 bits
52:            				// left, decrementing exp2.
53:            				do {
54:            					f1_as_mant1 <<= 1;
55:            					exp1--;
56:            				} while(exp2 != exp1 && --cntr != 0);
57:            				while(exp1 != exp2) {
58:            					f2_as_mant2 >>= 1;
59:            					exp2++;
60:            				}
61:            			}
62:            		}
63:            		if(sign1 != 0) { 
64:            			f1_as_mant1 ^= 0xFFFFFF;
65:            			f1_as_mant1++;
66:            		}
67:            		if(sign2 != 0) {
68:            			f2_as_mant2 ^= 0xFFFFFF;
69:            			f2_as_mant2++;
70:            		}
71:            		sign1 = 0;
72:            		f1_as_mant1 += f2_as_mant2;
73:            		if(f1_as_mant1 & 0x800000) {
74:            			f1_as_mant1 ^= 0xFFFFFF;
75:            			f1_as_mant1++;
76:            			sign1 = 1;
77:            		}
78:            	}
79:            	__ftpack(&f1_as_mant1, exp1);
80:            	if(sign1)
81:            		f1_as_mant1 ^= 0x800000;
82:            	return f1;
83:            }
84:            #else
85:            float
86:            __ftadd(float f1, float f2)
87:            {
88:            	unsigned char	exp1, exp2, sign;
89:            
90:            	exp1 = f1_as_mant1 >> 15;
14D5  082B     MOVF sec, W
14D6  00B1     MOVWF divisor
14D7  082C     MOVF hr, W
14D8  00B2     MOVWF 0x32
14D9  082D     MOVF day, W
14DA  00B3     MOVWF dividend
14DB  1003     BCF STATUS, 0x0
14DC  0D32     RLF 0x32, W
14DD  0D33     RLF dividend, W
14DE  00B6     MOVWF sign
91:            	exp2 = f2_as_mant2 >> 15;
14DF  082E     MOVF sign, W
14E0  00B1     MOVWF divisor
14E1  082F     MOVF quotient, W
14E2  00B2     MOVWF 0x32
14E3  0830     MOVF c, W
14E4  00B3     MOVWF dividend
14E5  1003     BCF STATUS, 0x0
14E6  0D32     RLF 0x32, W
14E7  0D33     RLF dividend, W
14E8  00B5     MOVWF counter
92:            	if(exp1 == 0 || exp1 < exp2  && (unsigned char)(exp2-exp1) > sizeof(f1)*8)
14E9  0836     MOVF sign, W
14EA  1903     BTFSC STATUS, 0x2
14EB  2CF8     GOTO 0x4F8
14EC  0835     MOVF counter, W
14ED  0236     SUBWF sign, W
14EE  0835     MOVF counter, W
14EF  1803     BTFSC STATUS, 0x0
14F0  2D00     GOTO 0x500
14F1  00B1     MOVWF divisor
14F2  0836     MOVF sign, W
14F3  02B1     SUBWF divisor, F
14F4  3019     MOVLW 0x19
14F5  0231     SUBWF divisor, W
14F6  1C03     BTFSS STATUS, 0x0
14F7  2CFF     GOTO 0x4FF
93:            		return f2;
14F8  082E     MOVF sign, W
14F9  00AB     MOVWF sec
14FA  082F     MOVF quotient, W
14FB  00AC     MOVWF hr
14FC  0830     MOVF c, W
14FD  00AD     MOVWF day
14FE  0008     RETURN
94:            	if(exp2 == 0 || exp1 > exp2  && (unsigned char)(exp1-exp2) > sizeof(f1)*8)
14FF  0835     MOVF counter, W
1500  1903     BTFSC STATUS, 0x2
1501  0008     RETURN
1502  0836     MOVF sign, W
1503  0235     SUBWF counter, W
1504  1803     BTFSC STATUS, 0x0
1505  2D0E     GOTO 0x50E
1506  0836     MOVF sign, W
1507  00B1     MOVWF divisor
1508  0835     MOVF counter, W
1509  02B1     SUBWF divisor, F
150A  3019     MOVLW 0x19
150B  0231     SUBWF divisor, W
150C  1803     BTFSC STATUS, 0x0
150D  0008     RETURN
95:            		return f1;
96:            	sign = 6;
150E  3006     MOVLW 0x6
150F  00B4     MOVWF sign
97:            	if(f1_as_mant1 & 0x800000L)
1510  1BAD     BTFSC day, 0x7
98:            		sign |= 0x80;
1511  17B4     BSF sign, 0x7
99:            	if(f2_as_mant2 & 0x800000L)
1512  1BB0     BTFSC c, 0x7
100:           		sign |= 0x40;
1513  1734     BSF sign, 0x6
101:           	f1_as_mant1 |= 0x8000UL;
1514  17AC     BSF hr, 0x7
102:           	f1_as_mant1 &= 0xFFFFUL;
1515  01AD     CLRF day
103:           	f2_as_mant2 |= 0x8000UL;
1516  17AF     BSF quotient, 0x7
104:           	f2_as_mant2 &= 0xFFFFUL;
1517  01B0     CLRF c
105:           	// determine the smaller number. 
106:           	if(exp1 < exp2) {
1518  0835     MOVF counter, W
1519  0236     SUBWF sign, W
151A  1803     BTFSC STATUS, 0x0
151B  2D35     GOTO 0x535
107:           		// f1 has the smaller exponent - we can shift f2_as_mant2 up to 6 bits
108:           		// left, decrementing exp2.
109:           		do {
110:           			f2_as_mant2 <<= 1;
151C  1003     BCF STATUS, 0x0
151D  0DAE     RLF sign, F
151E  0DAF     RLF quotient, F
151F  0DB0     RLF c, F
111:           			exp2--;
1520  03B5     DECF counter, F
112:           		} while(exp2 != exp1 && --sign & 7);
1521  0835     MOVF counter, W
1522  0636     XORWF sign, W
1523  1903     BTFSC STATUS, 0x2
1524  2D30     GOTO 0x530
1525  03B4     DECF sign, F
1526  0834     MOVF sign, W
1527  3907     ANDLW 0x7
1528  1903     BTFSC STATUS, 0x2
1529  2D30     GOTO 0x530
152A  2D1C     GOTO 0x51C
113:           		while(exp1 != exp2) {
1530  0836     MOVF sign, W
1531  0635     XORWF counter, W
1532  1903     BTFSC STATUS, 0x2
1533  2D51     GOTO 0x551
1534  2D2B     GOTO 0x52B
114:           			f1_as_mant1 >>= 1;
152B  1003     BCF STATUS, 0x0
152C  0CAD     RRF day, F
152D  0CAC     RRF hr, F
152E  0CAB     RRF sec, F
115:           			exp1++;
152F  0AB6     INCF sign, F
116:           		}
117:           	} else if(exp1 > exp2) {
1535  0836     MOVF sign, W
1536  0235     SUBWF counter, W
1537  1803     BTFSC STATUS, 0x0
1538  2D51     GOTO 0x551
118:           		// f2 has the smaller exponent - we can shift f1_as_mant1 up to 6 bits
119:           		// left, decrementing exp2.
120:           		do {
121:           			f1_as_mant1 <<= 1;
1539  1003     BCF STATUS, 0x0
153A  0DAB     RLF sec, F
153B  0DAC     RLF hr, F
153C  0DAD     RLF day, F
122:           			exp1--;
153D  03B6     DECF sign, F
123:           		} while(exp2 != exp1 && --sign & 7);
153E  0835     MOVF counter, W
153F  0636     XORWF sign, W
1540  1903     BTFSC STATUS, 0x2
1541  2D4D     GOTO 0x54D
1542  03B4     DECF sign, F
1543  0834     MOVF sign, W
1544  3907     ANDLW 0x7
1545  1903     BTFSC STATUS, 0x2
1546  2D4D     GOTO 0x54D
1547  2D39     GOTO 0x539
124:           		while(exp1 != exp2) {
154D  0836     MOVF sign, W
154E  0635     XORWF counter, W
154F  1D03     BTFSS STATUS, 0x2
1550  2D48     GOTO 0x548
125:           			f2_as_mant2 >>= 1;
1548  1003     BCF STATUS, 0x0
1549  0CB0     RRF c, F
154A  0CAF     RRF quotient, F
154B  0CAE     RRF sign, F
126:           			exp2++;
154C  0AB5     INCF counter, F
127:           		}
128:           	}
129:           	if(sign & 0x80) { 
1551  1FB4     BTFSS sign, 0x7
1552  2D5C     GOTO 0x55C
130:           		// complement and add 1
131:           		f1_as_mant1 ^= 0xFFFFFFUL;
1553  30FF     MOVLW 0xFF
1554  06AB     XORWF sec, F
1555  06AC     XORWF hr, F
1556  06AD     XORWF day, F
132:           		f1_as_mant1++;
1557  0AAB     INCF sec, F
1558  1903     BTFSC STATUS, 0x2
1559  0AAC     INCF hr, F
155A  1903     BTFSC STATUS, 0x2
155B  0AAD     INCF day, F
133:           	}
134:           	if(sign & 0x40) {
155C  1F34     BTFSS sign, 0x6
155D  2D67     GOTO 0x567
135:           		// complement and add 1
136:           		f2_as_mant2 ^= 0xFFFFFFUL;
155E  30FF     MOVLW 0xFF
155F  06AE     XORWF sign, F
1560  06AF     XORWF quotient, F
1561  06B0     XORWF c, F
137:           		f2_as_mant2++;
1562  0AAE     INCF sign, F
1563  1903     BTFSC STATUS, 0x2
1564  0AAF     INCF quotient, F
1565  1903     BTFSC STATUS, 0x2
1566  0AB0     INCF c, F
138:           	}
139:           	sign = 0;
1567  01B4     CLRF sign
140:           	f2_as_mant2 += f1_as_mant1;
1568  082B     MOVF sec, W
1569  07AE     ADDWF sign, F
156A  082C     MOVF hr, W
156B  1103     BCF STATUS, 0x2
156C  1803     BTFSC STATUS, 0x0
156D  0A2C     INCF hr, W
156E  1D03     BTFSS STATUS, 0x2
156F  07AF     ADDWF quotient, F
1570  082D     MOVF day, W
1571  1103     BCF STATUS, 0x2
1572  1803     BTFSC STATUS, 0x0
1573  0A2D     INCF day, W
1574  1D03     BTFSS STATUS, 0x2
1575  07B0     ADDWF c, F
141:           	if(f2_as_mant2 & 0x800000UL) {
1576  1FB0     BTFSS c, 0x7
1577  2D83     GOTO 0x583
142:           		f2_as_mant2 ^= 0xFFFFFFUL;
1578  30FF     MOVLW 0xFF
1579  06AE     XORWF sign, F
157A  06AF     XORWF quotient, F
157B  06B0     XORWF c, F
143:           		f2_as_mant2++;
157C  0AAE     INCF sign, F
157D  1903     BTFSC STATUS, 0x2
157E  0AAF     INCF quotient, F
157F  1903     BTFSC STATUS, 0x2
1580  0AB0     INCF c, F
144:           		sign = 1;
1581  01B4     CLRF sign
1582  0AB4     INCF sign, F
145:           	}
146:           	return __ftpack(f2_as_mant2, exp1, sign);
1583  082E     MOVF sign, W
1584  00A3     MOVWF x
1585  082F     MOVF quotient, W
1586  00A4     MOVWF dato
1587  0830     MOVF c, W
1588  00A5     MOVWF y
1589  0836     MOVF sign, W
158A  00A6     MOVWF x
158B  0834     MOVF sign, W
158C  00A7     MOVWF i
158D  2595     CALL 0x595
158E  0823     MOVF x, W
158F  00AB     MOVWF sec
1590  0824     MOVF dato, W
1591  00AC     MOVWF hr
1592  0825     MOVF y, W
1593  00AD     MOVWF day
147:           
148:           }
1594  0008     RETURN
149:           #endif
---  /opt/microchip/xc8/v1.31/sources/common/float.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             #include	"ftarith.h"
7:             
8:             
9:             //	unpack the operand pointed to. Store the exponent into the location pointed to by exp,
10:            //	and return the sign (zero is positive)
11:            
12:            #ifdef _OLDLIB
13:            
14:            unsigned char
15:            __ftunpack(unsigned short long * arg, unsigned char * exp)
16:            {
17:            	unsigned char	sign;
18:            
19:            	*exp = sign = *arg >> 15;
20:            	if(sign == 0) {
21:            		*arg = 0;
22:            		return 0;
23:            	}
24:            	sign = 0;
25:            	*arg |= 0x8000;
26:            	if(*arg & 0x800000)
27:            		sign++;
28:            	*arg &= 0xFFFF;
29:            	return sign;
30:            }
31:            
32:            // normalize and pack the supplied argument into floating point format
33:            
34:            void
35:            __ftpack(unsigned short long * arg, unsigned char exp)
36:            {
37:            	if(exp == 0 || *arg == 0) {
38:            		*arg = 0;
39:            		return;
40:            	}
41:            	while(*arg & 0xFE0000UL) {
42:            		exp++;
43:            		*arg >>= 1;
44:            	}
45:            	while(*arg & 0xFF0000UL) {
46:            		exp++;
47:            		(*arg)++;
48:            		*arg >>= 1;
49:            	}
50:            	while(!(*arg & 0x8000UL)) {
51:            		exp--;
52:            		*arg <<= 1;
53:            	}
54:            	if(!(exp & 1))
55:            		*arg &= ~0x8000L;
56:            	exp >>= 1;
57:            	*arg |= (unsigned short long)exp << 16;
58:            }
59:            
60:            #else
61:            float
62:            __ftpack(unsigned short long arg, unsigned char exp, unsigned char sign)
63:            {
64:            	if(exp == 0 || arg == 0)
1595  0826     MOVF x, W
1596  1903     BTFSC STATUS, 0x2
1597  2D9D     GOTO 0x59D
1598  0825     MOVF y, W
1599  0424     IORWF dato, W
159A  0423     IORWF x, W
159B  1D03     BTFSS STATUS, 0x2
159C  2DA6     GOTO 0x5A6
65:            		return 0.0;
159D  01A3     CLRF x
159E  01A4     CLRF dato
159F  01A5     CLRF y
15A0  0008     RETURN
66:            	while(arg & 0xFE0000UL) {
15A6  30FE     MOVLW 0xFE
15A7  0525     ANDWF y, W
15A8  1903     BTFSC STATUS, 0x2
15A9  2DB5     GOTO 0x5B5
15AA  2DA1     GOTO 0x5A1
67:            		exp++;
15A1  0AA6     INCF x, F
68:            		arg >>= 1;
15A2  1003     BCF STATUS, 0x0
15A3  0CA5     RRF y, F
15A4  0CA4     RRF dato, F
15A5  0CA3     RRF x, F
69:            	}
70:            	while(arg & 0xFF0000UL) {
15B5  30FF     MOVLW 0xFF
15B6  0525     ANDWF y, W
15B7  1903     BTFSC STATUS, 0x2
15B8  2DBF     GOTO 0x5BF
15B9  2DAB     GOTO 0x5AB
71:            		exp++;
15AB  0AA6     INCF x, F
72:            		(arg)++;
15AC  0AA3     INCF x, F
15AD  1903     BTFSC STATUS, 0x2
15AE  0AA4     INCF dato, F
15AF  1903     BTFSC STATUS, 0x2
15B0  0AA5     INCF y, F
73:            		arg >>= 1;
15B1  1003     BCF STATUS, 0x0
15B2  0CA5     RRF y, F
15B3  0CA4     RRF dato, F
15B4  0CA3     RRF x, F
74:            	}
75:            	while(!(arg & 0x8000UL)) {
15BF  1FA4     BTFSS dato, 0x7
15C0  2DBA     GOTO 0x5BA
76:            		exp--;
15BA  03A6     DECF x, F
77:            		arg <<= 1;
15BB  1003     BCF STATUS, 0x0
15BC  0DA3     RLF x, F
15BD  0DA4     RLF dato, F
15BE  0DA5     RLF y, F
78:            	}
79:            	if(!(exp & 1))
15C1  1C26     BTFSS x, 0x0
80:            		arg &= ~0x8000L;
15C2  13A4     BCF dato, 0x7
81:            	exp >>= 1;
15C3  1003     BCF STATUS, 0x0
15C4  0CA6     RRF x, F
82:            	arg |= (unsigned short long)exp << 16;
15C5  0826     MOVF x, W
15C6  00AA     MOVWF Data
15C7  01A9     CLRF year
15C8  01A8     CLRF mth
15C9  0828     MOVF mth, W
15CA  04A3     IORWF x, F
15CB  0829     MOVF year, W
15CC  04A4     IORWF dato, F
15CD  082A     MOVF Data, W
15CE  04A5     IORWF y, F
83:            	if (sign)
15CF  0827     MOVF i, W
15D0  1D03     BTFSS STATUS, 0x2
84:            		arg |= 0x800000UL;
15D1  17A5     BSF y, 0x7
85:               return *(float*)&arg;	
86:            }
15D2  0008     RETURN
87:            
88:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/doprnt.c  --------------------------------------------------
1:             #include	<stdio.h>
2:             #include	<ctype.h>
3:             #include	<stdlib.h>
4:             #include	<string.h>
5:             #include	<stdarg.h>
6:             #include	<conio.h>
7:             #include	<sys.h>
8:             #include	<math.h>
9:             #include	<float.h>
10:            
11:            // disable unused variable warnings
12:            // the compiler will optimize them away, so no harm is done
13:            #pragma warning disable 350
14:            
15:            /*
16:             *	doprnt - versions depends on conditional compilation.
17:             *	Can be customized with defines.
18:             *
19:             *	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
20:             *
21:             *	$Header$
22:             *
23:             */
24:            
25:            #ifndef	CUSTOM_PRINTF
26:            
27:             // define all flags, thus enabling all features
28:            
29:            #define	BASEM	0xC0
30:            #define	OPTSIGN	0x00
31:            #define	SPCSIGN	0x01
32:            #define	MANSIGN	0x02
33:            #define	NEGSIGN	0x03
34:            #define	FILL	0x04
35:            #define	LEFT	0x08
36:            #define	LONG	0x10
37:            #define	UPCASE	0x20
38:            #define	TEN		0x00
39:            #define	EIGHT	0x40
40:            #define	SIXTEEN	0x80
41:            #define	UNSIGN	0xC0
42:            #ifdef	__FLOAT
43:            #define	EFMT	0x100
44:            #define	GFMT	0x200
45:            #define	FFMT	0x400
46:            #endif	// __FLOAT
47:            #define	ALTERN	0x800
48:            #define POINTER	0x2000
49:            #define HEXUPCASE
50:            #define HEXLOWCASE
51:            
52:             // defines for ifdef only, not used as flags
53:            #define	WIDTH	1		// width used
54:            #define	STAR	1		// width or precision as an arg
55:            #define	STRING	1		// %s used
56:            #define	CHAR	1		// %c used
57:            #define	PERCPERC	1	// %% used
58:            #define	SPRINTF	1		// sprintf is used
59:            #define	PRINTF	1		// printf is used
60:            #define	MULTRAD	1		// handle multiple radices
61:            #define	RETVALUE	1	// return value is needed
62:            
63:            #else	// CUSTOM_PRINTF
64:            
65:            #if	defined(HEXUPCASE) || defined(HEXLOWCASE)
66:            #define	SIXTEEN
67:            #endif
68:            
69:            #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
70:            #ifndef UPCASE
71:            #define	UPCASE
72:            #endif
73:            #endif
74:            
75:             // make sure we have the right values for each define
76:            #ifdef	OPTSIGN
77:            #undef	OPTSIGN
78:            #define	OPTSIGN	0x00
79:            #endif
80:            #ifdef	SPCSIGN
81:            #undef	SPCSIGN
82:            #define	SPCSIGN	0x01
83:            #endif
84:            #ifdef	MANSIGN
85:            #undef	MANSIGN
86:            #define	MANSIGN	0x02
87:            #define	SPCSIGN	0x01
88:            #endif
89:            #ifdef	NEGSIGN
90:            #undef	NEGSIGN
91:            #define	NEGSIGN	0x03
92:            #endif
93:            #ifdef	FILL
94:            #define	WIDTH	1
95:            #undef	FILL
96:            #define	FILL	0x04
97:            #endif
98:            #ifdef	LEFT
99:            #undef	LEFT
100:            // LEFT without WIDTH is meaningless
101:           #ifdef	WIDTH
102:           #define	LEFT	0x08
103:           #endif
104:           #endif
105:           #ifdef	LONG
106:           #undef	LONG
107:           #define	LONG	0x10
108:           #define	__LONG	1
109:           #endif
110:           #ifdef	UPCASE
111:           #undef	UPCASE
112:           #define	UPCASE	0x20
113:           #endif
114:           #ifdef	TEN	
115:           #undef	TEN	
116:           #define	TEN		0x00
117:           #endif
118:           #ifdef	EIGHT
119:           #undef	EIGHT
120:           #define	EIGHT	0x40
121:           #endif
122:           #ifdef	SIXTEEN
123:           #undef	SIXTEEN
124:           #define	SIXTEEN	0x80
125:           #endif
126:           #ifdef	UNSIGN
127:           #undef	UNSIGN
128:           #define	UNSIGN	0xC0
129:           #endif
130:           #ifdef	EFMT
131:           #undef	EFMT
132:           #define	EFMT	0x100
133:           #endif
134:           #ifdef	GFMT
135:           #undef	GFMT
136:           #define	GFMT	0x200
137:           #endif
138:           #ifdef	FFMT
139:           #undef	FFMT
140:           #define	FFMT	0x400
141:           #endif
142:           #ifdef	ALTERN
143:           #undef	ALTERN
144:           #define	ALTERN	0x800
145:           #endif
146:           #ifdef	POINTER
147:           #undef	POINTER
148:           #define POINTER	0x2000
149:           #ifndef	SIXTEEN
150:           #define	SIXTEEN	0x80
151:           #endif
152:           #endif
153:           #ifdef	PRECISION
154:           #undef	PRECISION
155:           #define PRECISION	0x4000
156:           #endif
157:           
158:           #if	defined(TEN) && !defined(EIGHT) && !defined(SIXTEEN) && defined(UNSIGN)
159:           #undef	UNSIGN
160:           #define	UNSIGN	0x40
161:           #define	BASEM	UNSIGN
162:           #endif
163:           #if	defined(UNSIGN) && (defined(EIGHT) || defined(SIXTEEN))
164:           #define	MULTRAD	1
165:           #define	BASEM	(UNSIGN)
166:           #endif
167:           #if	defined(TEN) && !defined(SIXTEEN) && defined(EIGHT) && !defined(UNSIGN)
168:           #define	BASEM	EIGHT
169:           #define	MULTRAD	1
170:           #endif
171:           #if	defined(TEN) && defined(SIXTEEN) && !defined(EIGHT) && !defined(UNSIGN)
172:           #define	BASEM	SIXTEEN
173:           #define	MULTRAD	1
174:           #endif
175:           #if	defined(SIXTEEN) && defined(EIGHT) && !defined(BASEM)
176:           #define	BASEM	(SIXTEEN|EIGHT)
177:           #define	MULTRAD	1
178:           #endif
179:           
180:           #endif
181:           
182:            // float code needs these flags
183:           #if	defined(EFMT) || defined(GFMT) || defined(FFMT)
184:           #ifndef	__FLOAT
185:           #define	__FLOAT	1
186:           #endif
187:           #define	FLOATFORMAT	0x700
188:           #ifdef	PRECISION
189:           #define	DEFPREC	0x1000
190:           #endif
191:           #endif
192:           
193:           #ifdef	__FLOAT
194:           //#ifndef	MANSIGN
195:           //#define	MANSIGN	0x02
196:           //#endif
197:           //#ifndef	SPCSIGN
198:           //#define	SPCSIGN	0x01
199:           //#endif
200:           #ifndef	NEGSIGN
201:           #define	NEGSIGN	0x03
202:           #endif
203:           //#ifndef	WIDTH
204:           //#define	WIDTH	1
205:           //#endif
206:           #endif
207:           
208:           #ifdef	SPCSIGN
209:           #define	putsign()	pputc(flag & SPCSIGN ? '-' : '+')
210:           #else
211:           #define	putsign()	pputc('-')
212:           #endif	// SPCSIGN
213:           
214:           // were there ANY % formats defined?
215:           #if	defined(FLOATFORMAT) || defined(TEN) || defined(EIGHT) || defined(SIXTEEN) || \
216:           	defined(CHAR) || defined(POINTER) || defined(STRING) || defined(UNSIGN) || defined(PERCPERC)
217:           #define	ANYFORMAT
218:           #else
219:           #undef	ANYFORMAT
220:           #endif
221:           
222:           #ifdef	CHAR
223:           #ifndef	PERCPERC
224:           #define	PERCPERC
225:           #endif
226:           #endif
227:           
228:           #if	!defined(PRINTF) && !defined(VPRINTF) && !defined(SPRINTF) && !defined(VSPRINTF)
229:           #error	Must define at least one of PRINTF SPRINTF or VSPRINTF
230:           #endif
231:           
232:           #if	i8086 && SMALL_DATA
233:           #define	CONST	far
234:           #else
235:           #define	CONST	const
236:           #endif
237:           
238:            /* we don't need plus signs, use minus signs only if we have floats or signed ints */
239:           
240:           #if	!defined(NEGSIGN) && defined(TEN)
241:           #define	NEGSIGN	0x03
242:           #endif
243:           
244:           #ifndef	RETVALUE
245:           #define	INCR_CNT	/*nix */
246:           #else
247:           #define	INCR_CNT	,(++ccnt)
248:           #endif
249:           
250:           #if	defined(EFMT) || defined(GFMT) || defined(FFMT) || defined(ALTERN) || defined(DEFPREC) || defined(POINTER)
251:           #define	FLAG_SIZE	unsigned short
252:           #else
253:           #define	FLAG_SIZE	unsigned char
254:           #endif
255:           
256:           
257:           #if	(sizeof(long) == sizeof(int) || defined(__FLOAT)) && !defined(__LONG)
258:           #define	__LONG	1
259:           #endif
260:           
261:           #if	sizeof(double) == sizeof(long) && DBL_MAX_EXP == 128
262:           #undef	frexp
263:           #define	frexp(val, ptr) (void)(*(ptr) = (unsigned char)((*(unsigned long *)&val >> 23) & 255) - 126)
264:           #elif	defined(_PSOC_)
265:           #undef	frexp
266:           #define	frexp(val, ptr) (void)(*(ptr) = ((unsigned char)(*(unsigned short long *)&val >> 15)) - 126)
267:           #elif	sizeof(double) == 3 && DBL_MAX_EXP == 128
268:           #undef	frexp
269:           #define	frexp(val, ptr) (void)(*(ptr) = ((*(unsigned long *)&val >> 15) & 255) - 126)
270:           #endif
271:           
272:           #if	defined(__FLOAT) && sizeof(double) == 8
273:           #define	DOUBLE	1
274:           
275:           extern double	_dto64i(double);
276:           extern double	_64itod(double);
277:           extern double	_div64(double, double);
278:           extern double	_divto64i(double, double);
279:           extern unsigned	_div64ir(double, double);
280:           extern unsigned	_mod64i10(double);
281:           
282:           #else
283:           #define	DOUBLE	0
284:           #endif
285:           
286:           #ifdef	__LONG
287:           #define	value	long
288:           #define	NDIG	12		/* max number of digits to be printed */
289:           #else
290:           #define	value	int
291:           #define	NDIG	6		/* max number of digits to be printed */
292:           #endif
293:           
294:           #if	DOUBLE
295:           union {
296:           	unsigned long	ul[40];
297:           	double		db[20];
298:           }	_fdp =
299:           {
300:           #if	!defined(BIG_ENDIAN) && !defined(LITTLE_ENDIAN)
301:           #error Neither BIG_ENDIAN or LITTLE_ENDIAN has been set
302:           #endif
303:           #if	BIG_ENDIAN
304:           	0x00000000,0x00000001,
305:           	0x00000000,0x0000000A,
306:           	0x00000000,0x00000064,
307:           	0x00000000,0x000003E8,
308:           	0x00000000,0x00002710,
309:           	0x00000000,0x000186A0,
310:           	0x00000000,0x000F4240,
311:           	0x00000000,0x00989680,
312:           	0x00000000,0x05F5E100,
313:           	0x00000000,0x3B9ACA00,
314:           	0x00000002,0x540BE400,
315:           	0x00000017,0x4876E800,
316:           	0x000000E8,0xD4A51000,
317:           	0x00000918,0x4E72A000,
318:           	0x00005AF3,0x107A4000,
319:           	0x00038D7E,0xA4C68000,
320:           	0x002386F2,0x6FC10000,
321:           	0x01634578,0x5D8A0000,
322:           	0x0DE0B6B3,0xA7640000,
323:           	0x8AC72304,0x89E80000,
324:           #else
325:           	0x00000001,0x00000000,
326:           	0x0000000A,0x00000000,
327:           	0x00000064,0x00000000,
328:           	0x000003E8,0x00000000,
329:           	0x00002710,0x00000000,
330:           	0x000186A0,0x00000000,
331:           	0x000F4240,0x00000000,
332:           	0x00989680,0x00000000,
333:           	0x05F5E100,0x00000000,
334:           	0x3B9ACA00,0x00000000,
335:           	0x540BE400,0x00000002,
336:           	0x4876E800,0x00000017,
337:           	0xD4A51000,0x000000E8,
338:           	0x4E72A000,0x00000918,
339:           	0x107A4000,0x00005AF3,
340:           	0xA4C68000,0x00038D7E,
341:           	0x6FC10000,0x002386F2,
342:           	0x5D8A0000,0x01634578,
343:           	0xA7640000,0x0DE0B6B3,
344:           	0x89E80000,0x8AC72304,
345:           #endif
346:           };
347:           
348:           #define	fdpowers	_fdp.db
349:           
350:           #else
351:           #define	fdpowers	dpowers
352:           #endif
353:           #if defined(TEN) || defined(__FLOAT) || defined (UNSIGN)
354:           const static unsigned value	dpowers[] =	{1, 10, 100, 1000, 10000,
355:           #ifdef	__LONG
356:           						 100000, 1000000, 10000000, 100000000,
357:           						 1000000000
358:           #endif
359:           							 };
360:           #endif
361:           #ifdef	SIXTEEN
362:           const static unsigned value	hexpowers[] =	{1, 0x10, 0x100, 0x1000,
363:           #if	__LONG
364:           						 0x10000, 0x100000, 0x1000000, 0x10000000
365:           #endif
366:           							};
367:           #endif
368:           #ifdef	EIGHT
369:           const static unsigned value	octpowers[] =	{1, 010, 0100, 01000, 010000, 0100000,
370:           #ifdef	__LONG
371:           						01000000,
372:           						 010000000, 0100000000, 01000000000, 010000000000,
373:           						 0100000000000
374:           #endif
375:           							};
376:           #endif
377:           
378:           #ifdef	__FLOAT
379:           
380:           #define	NDDIG	(sizeof fdpowers/sizeof fdpowers[0])
381:           
382:           #if	DBL_MAX_10_EXP > 120
383:           #define	expon	int
384:           #else
385:           #define	expon	signed char
386:           #endif
387:           
388:           extern const double	_powers_[], _npowers_[];
389:           #ifdef	z80
390:           #define	_div_to_l_(a, b)	((unsigned long)((a)/(b)))
391:           #else
392:           extern unsigned long	_div_to_l_(double, double);
393:           #ifdef	_OMNI_CODE_
394:           extern unsigned long	_tdiv_to_l_(float, float);
395:           #ifdef	_HTKC_
396:           #pragma callname _div_to_l_ double
397:           #pragma callname _tdiv_to_l_ float
398:           #endif
399:           #define	div_to_l_(a,b)	((sizeof(double)== 3) ? _tdiv_to_l_(a,b) : _div_to_l_(a,b))
400:           #else
401:           #define	div_to_l_	_div_to_l_
402:           #endif
403:           #endif
404:           
405:           /* this routine returns a value to round to the number of decimal
406:           	places specified */
407:           #if __FLOAT
408:           static double
409:           fround(unsigned char prec)
410:           {
411:           	/* prec is guaranteed to be less than NDIG */
412:           
413:           	if(prec>=110)
414:           		return 0.5 * _npowers_[prec/100+18] * _npowers_[(prec%100)/10+9] * _npowers_[prec%10];
415:           	else if(prec > 10)
416:           		return 0.5 * _npowers_[prec/10+9] * _npowers_[prec%10];
417:           	return 0.5 * _npowers_[prec];
418:           }
419:           #endif
420:           
421:           /* this routine returns a scaling factor equal to 1 to the decimal
422:              power supplied */
423:           
424:           static double
425:           scale(expon scl)
426:           {
427:           
428:           	if(scl < 0) {
429:           		scl = -scl;
430:           		if(scl>=110)
431:           			return _npowers_[scl/100+18] * _npowers_[(scl%100)/10+9] * _npowers_[scl%10];
432:           		else if(scl > 10)
433:           			return _npowers_[scl/10+9] * _npowers_[scl%10];
434:           		return _npowers_[scl];
435:           	}
436:           	if(scl>=110)
437:           		return _powers_[scl/100+18] * _powers_[(scl%100)/10+9] * _powers_[scl%10];
438:           	else if(scl > 10)
439:           		return _powers_[scl/10+9] * _powers_[scl%10];
440:           	return _powers_[scl];
441:           }
442:           
443:           
444:           #endif	/* __FLOAT */
445:           
446:           
447:           
448:           #ifdef	_HOSTED
449:           #define	pputc(c)	(putc(c, fp) != EOF && ++ccnt)
450:           int
451:           vfprintf(FILE * fp, register const  char * f, register va_list ap)
452:           {
453:           	char		cbuf[2];
454:           #else	/* _HOSTED */
455:           int
456:           #if	defined(VPRINTF) || (defined(PRINTF) && (defined(SPRINTF) || defined(VSPRINTF)))
457:           #define	pputc(c)	if(pb->func) (pb->func(c))INCR_CNT; else ((*pb->ptr++ = c)INCR_CNT)
458:           _doprnt(struct __prbuf * pb, register const  char * f, register va_list ap)
459:           {
460:           #endif
461:           
462:           #if	defined(PRINTF) && !(defined(SPRINTF) || defined(VSPRINTF))
463:           #define	pputc(c)	(putch(c) INCR_CNT)
464:           printf(const char * f, ...)
465:           {
466:           	va_list	ap;
467:           #define	NEED_START
468:           #endif
469:           
470:           #if	!defined(PRINTF) && defined(VSPRINTF)
471:           
472:           #ifdef	SPRINTF
473:           sprintf(char * sp, const char * f, ...)
474:           {
475:           	va_list	ap;
476:           
477:           	va_start(ap, f);
478:           	vsprintf(sp, f, ap);
479:           	va_end(ap);
480:           }
481:           int
482:           #endif	// SPRINTF
483:           
484:           #define	pputc(c)	((*sp++ = (c))INCR_CNT)
485:           vsprintf(char * sp, register const  char * f, register va_list ap)
486:           {
487:           #define NEED_START
488:           #endif	// VSPRINTF
489:           
490:           #if	!defined(PRINTF) && defined(SPRINTF) && !defined(VSPRINTF)
491:           #define	pputc(c)	((*sp++ = (c))INCR_CNT)
492:           sprintf(char * sp, const  char * f, ...)
15D3  00DB     MOVWF sp
493:           {
494:           	va_list	ap;
495:           #define	NEED_START
496:           #endif
497:           #endif	// HOSTED
498:           
499:           	signed char		c;
500:           #if	defined(WIDTH) || defined(__FLOAT)
501:           	int		width;
502:           #endif
503:           #ifdef	__LONG
504:           	int		prec;
505:           #else
506:           	signed char	prec;
507:           #endif
508:           	FLAG_SIZE	flag;
509:           #ifdef	RETVALUE
510:           	int		ccnt = 0;
511:           #else
512:           #define	ccnt	0
513:           #endif
514:           #ifdef	__FLOAT
515:           	char	d;
516:           	double	fval, integ;
517:           	int		exp;
518:           	double		ival;
519:           	union {
520:           		unsigned value	_val;
521:           		struct {
522:           		    CONST char *	_cp;
523:           		    unsigned	_len;
524:           		}		_str;
525:           	}		_val;
526:           #else	// __FLOAT
527:           	union {
528:           		unsigned value	_val;
529:           		struct {
530:           		    CONST char *	_cp;
531:           		    unsigned	_len;
532:           		}		_str;
533:           	}		_val;
534:           #endif	// __FLOAT
535:           
536:           #define	val	_val._val
537:           #define	cp	_val._str._cp
538:           #define	len	_val._str._len
539:           
540:           	
541:           #ifdef	NEED_START
542:           	va_start(ap, f);
15D4  3049     MOVLW 0x49
15D5  00D3     MOVWF ap
543:           #endif
544:           
545:           	while(c = *f++) {
15D6  0848     MOVF 0x48, W
15D7  00D0     MOVWF 0x50
15D8  0847     MOVF f, W
15D9  00CF     MOVWF f1
15DA  0AC7     INCF f, F
15DB  1903     BTFSC STATUS, 0x2
15DC  0AC8     INCF 0x48, F
15DD  0850     MOVF 0x50, W
15DE  00FF     MOVWF 0x7F
15DF  084F     MOVF f1, W
15E0  0084     MOVWF FSR
15E1  160A     BSF PCLATH, 0x4
15E2  158A     BSF PCLATH, 0x3
15E3  2000     CALL 0x0
15E4  160A     BSF PCLATH, 0x4
15E5  118A     BCF PCLATH, 0x3
15E6  00DA     MOVWF c
15E7  08DA     MOVF c, F
15E8  1903     BTFSC STATUS, 0x2
15E9  2F86     GOTO 0x786
1785  2DD6     GOTO 0x5D6
546:           #ifdef	ANYFORMAT
547:           		if(c != '%')
15EA  085A     MOVF c, W
15EB  3A25     XORLW 0x25
15EC  1903     BTFSC STATUS, 0x2
15ED  2DF5     GOTO 0x5F5
548:           #endif	//ANYFORMAT
549:           		{
550:           			pputc(c);
15EE  085B     MOVF sp, W
15EF  0084     MOVWF FSR
15F0  085A     MOVF c, W
15F1  1383     BCF STATUS, 0x7
15F2  0080     MOVWF INDF
15F3  0ADB     INCF sp, F
551:           			continue;
15F4  2DD6     GOTO 0x5D6
552:           		}
553:           #ifdef	ANYFORMAT
554:           #ifdef	WIDTH
555:           		width = 0;
15F5  01D5     CLRF width
15F6  01D6     CLRF f3
556:           #endif
557:           		flag = 0;
15F7  01D4     CLRF flag
15F8  2DFD     GOTO 0x5FD
558:           #if	defined(LEFT) || defined(SPCSIGN) || defined(MANSIGN) || defined(ALTERN) || defined(FILL)
559:           		for(;;) {
560:           			switch(*f) {
15FD  0848     MOVF 0x48, W
15FE  00FF     MOVWF 0x7F
15FF  0847     MOVF f, W
1600  0084     MOVWF FSR
1601  160A     BSF PCLATH, 0x4
1602  158A     BSF PCLATH, 0x3
1603  2000     CALL 0x0
1604  160A     BSF PCLATH, 0x4
1605  118A     BCF PCLATH, 0x3
1606  3A30     XORLW 0x30
1607  1903     BTFSC STATUS, 0x2
1608  2DF9     GOTO 0x5F9
1609  2E0A     GOTO 0x60A
561:           #ifdef	LEFT
562:           			case '-':
563:           				flag |= LEFT;
564:           				f++;
565:           				continue;
566:           #endif
567:           
568:           #ifdef	SPCSIGN
569:           			case ' ':
570:           				flag |= SPCSIGN;
571:           				f++;
572:           				continue;
573:           #endif
574:           
575:           #ifdef	MANSIGN
576:           			case '+':
577:           				flag |= MANSIGN;
578:           				f++;
579:           				continue;
580:           #endif
581:           #ifdef	ALTERN
582:           			case '#':
583:           				flag |= ALTERN;
584:           				f++;
585:           				continue;
586:           #endif
587:           #ifdef	FILL
588:           			case '0':
589:           				flag |= FILL;
15F9  1554     BSF flag, 0x2
590:           				f++;
15FA  0AC7     INCF f, F
15FB  1903     BTFSC STATUS, 0x2
15FC  0AC8     INCF 0x48, F
591:           				continue;
592:           #endif
593:           			}
594:           			break;
595:           		}
596:           #endif
597:           #if	defined(MANSIGN) && defined(SPCSIGN)
598:           		if(flag & MANSIGN)
599:           			flag &= ~SPCSIGN;
600:           #endif
601:           #if	defined(LEFT) && defined(FILL)
602:           		if(flag & LEFT)
603:           			flag &= ~FILL;
604:           #endif
605:           #ifdef	WIDTH
606:           		if(isdigit((unsigned)*f)) {
160A  0848     MOVF 0x48, W
160B  00FF     MOVWF 0x7F
160C  0847     MOVF f, W
160D  0084     MOVWF FSR
160E  160A     BSF PCLATH, 0x4
160F  158A     BSF PCLATH, 0x3
1610  2000     CALL 0x0
1611  160A     BSF PCLATH, 0x4
1612  118A     BCF PCLATH, 0x3
1613  278B     CALL 0x78B
1614  160A     BSF PCLATH, 0x4
1615  118A     BCF PCLATH, 0x3
1616  1C03     BTFSS STATUS, 0x0
1617  2E8D     GOTO 0x68D
607:           			width = 0;
1618  01D5     CLRF width
1619  01D6     CLRF f3
608:           			do {
609:           				width *= 10;
161A  300A     MOVLW 0xA
161B  00A3     MOVWF x
161C  01A4     CLRF dato
161D  0856     MOVF f3, W
161E  00A6     MOVWF x
161F  0855     MOVF width, W
1620  00A5     MOVWF y
1621  2799     CALL 0x799
1622  0824     MOVF dato, W
1623  00D6     MOVWF f3
1624  0823     MOVF x, W
1625  00D5     MOVWF width
610:           			   	width += *f++ - '0';
1626  0848     MOVF 0x48, W
1627  00FF     MOVWF 0x7F
1628  0847     MOVF f, W
1629  0084     MOVWF FSR
162A  160A     BSF PCLATH, 0x4
162B  158A     BSF PCLATH, 0x3
162C  2000     CALL 0x0
162D  160A     BSF PCLATH, 0x4
162E  118A     BCF PCLATH, 0x3
162F  3ED0     ADDLW 0xD0
1630  00CF     MOVWF f1
1631  30FF     MOVLW 0xFF
1632  1803     BTFSC STATUS, 0x0
1633  3000     MOVLW 0x0
1634  00D0     MOVWF 0x50
1635  084F     MOVF f1, W
1636  07D5     ADDWF width, F
1637  1803     BTFSC STATUS, 0x0
1638  0AD6     INCF f3, F
1639  0850     MOVF 0x50, W
163A  07D6     ADDWF f3, F
163B  0AC7     INCF f, F
163C  1903     BTFSC STATUS, 0x2
163D  0AC8     INCF 0x48, F
611:           			} while(isdigit((unsigned)*f));
163E  0848     MOVF 0x48, W
163F  00FF     MOVWF 0x7F
1640  0847     MOVF f, W
1641  0084     MOVWF FSR
1642  160A     BSF PCLATH, 0x4
1643  158A     BSF PCLATH, 0x3
1644  2000     CALL 0x0
1645  160A     BSF PCLATH, 0x4
1646  118A     BCF PCLATH, 0x3
1647  278B     CALL 0x78B
1648  160A     BSF PCLATH, 0x4
1649  118A     BCF PCLATH, 0x3
164A  1C03     BTFSS STATUS, 0x0
164B  2E8D     GOTO 0x68D
164C  2E1A     GOTO 0x61A
612:           #ifdef	STAR
613:           		} else if(*f == '*') {
614:           			width = va_arg(ap, int);
615:           			f++;
616:           #endif
617:           		}
618:           #endif
619:           #ifdef	PRECISION
620:           		if(*f == '.') {
621:           			flag |= PRECISION;
622:           			f++;
623:           #ifdef	STAR
624:           			if(*f == '*') {
625:           				prec = va_arg(ap, int);
626:           				f++;
627:           			} else
628:           #endif
629:           			{
630:           				prec = 0;
631:           				while(isdigit((unsigned)*f))
632:           					prec = prec*10 + *f++ - '0';
633:           			}
634:           		} else {
635:           			prec = 0;
636:           #ifdef	DEFPREC
637:           			flag |= DEFPREC;
638:           #endif	// DEFPREC
639:           		}
640:           #endif	// PRECISION
641:           #if	defined(__LONG) && defined(LONG)
642:           loop:
643:           #endif
644:           		switch(c = *f++) {
168D  0848     MOVF 0x48, W
168E  00D0     MOVWF 0x50
168F  0847     MOVF f, W
1690  00CF     MOVWF f1
1691  0AC7     INCF f, F
1692  1903     BTFSC STATUS, 0x2
1693  0AC8     INCF 0x48, F
1694  0850     MOVF 0x50, W
1695  00FF     MOVWF 0x7F
1696  084F     MOVF f1, W
1697  0084     MOVWF FSR
1698  160A     BSF PCLATH, 0x4
1699  158A     BSF PCLATH, 0x3
169A  2000     CALL 0x0
169B  160A     BSF PCLATH, 0x4
169C  118A     BCF PCLATH, 0x3
169D  00DA     MOVWF c
169E  3A00     XORLW 0x0
169F  1903     BTFSC STATUS, 0x2
16A0  2F86     GOTO 0x786
16A1  3A64     XORLW 0x64
16A2  1903     BTFSC STATUS, 0x2
16A3  2EAB     GOTO 0x6AB
16A4  3A0D     XORLW 0xD
16A5  1903     BTFSC STATUS, 0x2
16A6  2EAB     GOTO 0x6AB
16A7  3A1C     XORLW 0x1C
16A8  1903     BTFSC STATUS, 0x2
16A9  2E8B     GOTO 0x68B
16AA  2E85     GOTO 0x685
645:           
646:           		case 0:
647:           			goto alldone;
648:           
649:           #ifdef	LONG
650:           		case 'l':
651:           #ifdef	__LONG
652:           			flag |= LONG;
653:           			goto loop;
654:           #else
655:           			cp = "(non-long printf)";
656:           			goto strings;
657:           #endif
658:           #endif
659:           
660:           #ifdef	FLOATFORMAT
661:           #ifndef	__FLOAT
662:           		case 'E':
663:           		case 'f':
664:           		case 'e':
665:           		case 'G':
666:           		case 'g':
667:           			cp = "(non-float printf)";
668:           			goto strings;
669:           #else
670:           #ifdef	FFMT
671:           		case 'f':
672:           			flag |= FFMT;
673:           			break;
674:           #endif
675:           
676:           #ifdef	EFMT
677:           #ifdef	UPCASE
678:           		case 'E':
679:           			flag |= UPCASE;
680:           #endif
681:           		case 'e':
682:           			flag |= EFMT;
683:           			break;
684:           #endif
685:           
686:           #ifdef	GFMT
687:           #ifdef	UPCASE
688:           		case 'G':
689:           			flag |= UPCASE;
690:           #endif
691:           		case 'g':
692:           			flag |= GFMT;
693:           			break;
694:           #endif	// GFMT
695:           #endif
696:           #endif	// FLOATFORMAT
697:           #ifdef	EIGHT
698:           		case 'o':
699:           #ifdef	MULTRAD
700:           			flag |= EIGHT;
701:           #endif
702:           			break;
703:           #endif
704:           
705:           #ifdef	TEN
706:           		case 'd':
707:           		case 'i':
708:           			break;
709:           #endif
710:           
711:           #ifdef	POINTER
712:           		case 'p':
713:           #if	i8086 && LARGE_DATA
714:           			flag |= LONG;
715:           #elif	_PIC18 && LARGE_DATA
716:           			flag |= POINTER;
717:           #endif
718:           #endif	// POINTER
719:           #ifdef	SIXTEEN
720:           #ifdef	HEXUPCASE
721:           		case 'X':
722:           #ifdef	UPCASE
723:           			flag |= UPCASE;
724:           #endif
725:           #endif
726:           #if	defined(HEXLOWCASE) || !defined(UPCASE)
727:           		case 'x':
728:           #endif
729:           #ifdef	MULTRAD
730:           			flag |= SIXTEEN;
731:           #endif
732:           			break;
733:           #endif	// SIXTEEN
734:           
735:           #if	defined(STRING) || defined(PERCPERC)
736:           #ifdef	STRING
737:           		case 's':
738:           #if	i8086 && SMALL_DATA
739:           			if(flag & LONG)
740:           				cp = va_arg(ap, far char *);
741:           			else
742:           #endif
743:           				cp = va_arg(ap, const char *);
744:           #endif	// STRING
745:           #if	!defined(__FLOAT) && !defined(CUSTOM_PRINTF)
746:           strings:
747:           #endif
748:           #ifdef	STRING
749:           			if(!cp)
750:           				cp = "(null)";
751:           #endif
752:           #if	defined(WIDTH) || defined(PRECISION)
753:           #if	defined(STRING)
754:           			len = 0;
755:           			while(cp[len])
756:           				len++;
757:           #endif
758:           #ifdef	PERCPERC
759:           dostring:
760:           #endif
761:           #ifdef	PRECISION
762:           			if(prec && prec < len)
763:           				len = prec;
764:           #endif	// PRECISION
765:           #ifdef	WIDTH
766:           			if(width > len)
164D  0856     MOVF f3, W
164E  0259     SUBWF exp, W
164F  1D03     BTFSS STATUS, 0x2
1650  2E53     GOTO 0x653
1651  0855     MOVF width, W
1652  0258     SUBWF 0x58, W
1653  1803     BTFSC STATUS, 0x0
1654  2E5C     GOTO 0x65C
767:           				width -= len;
1655  0858     MOVF 0x58, W
1656  02D5     SUBWF width, F
1657  0859     MOVF exp, W
1658  1C03     BTFSS STATUS, 0x0
1659  03D6     DECF f3, F
165A  02D6     SUBWF f3, F
165B  2E5E     GOTO 0x65E
768:           			else
769:           				width = 0;
165C  01D5     CLRF width
165D  01D6     CLRF f3
770:           #ifdef	LEFT
771:           			if(!(flag & LEFT))
772:           #endif	// LEFT
773:           				while(width--)
165E  30FF     MOVLW 0xFF
165F  07D5     ADDWF width, F
1660  1C03     BTFSS STATUS, 0x0
1661  03D6     DECF f3, F
1662  0A55     INCF width, W
1663  1903     BTFSC STATUS, 0x2
1664  0A56     INCF f3, W
1665  1903     BTFSC STATUS, 0x2
1666  2E79     GOTO 0x679
166D  2E5E     GOTO 0x65E
774:           					pputc(' ');
1667  085B     MOVF sp, W
1668  0084     MOVWF FSR
1669  3020     MOVLW 0x20
166A  1383     BCF STATUS, 0x7
166B  0080     MOVWF INDF
166C  0ADB     INCF sp, F
775:           #endif	// WIDTH
776:           			while(len--)
1679  3001     MOVLW 0x1
167A  02D8     SUBWF 0x58, F
167B  3000     MOVLW 0x0
167C  1C03     BTFSS STATUS, 0x0
167D  03D9     DECF exp, F
167E  02D9     SUBWF exp, F
167F  0A58     INCF 0x58, W
1680  1903     BTFSC STATUS, 0x2
1681  0A59     INCF exp, W
1682  1903     BTFSC STATUS, 0x2
1683  2DD6     GOTO 0x5D6
1684  2E6E     GOTO 0x66E
777:           				pputc(*cp++);
166E  0857     MOVF _val, W
166F  0084     MOVWF FSR
1670  1383     BCF STATUS, 0x7
1671  0800     MOVF INDF, W
1672  00CF     MOVWF f1
1673  085B     MOVF sp, W
1674  0084     MOVWF FSR
1675  084F     MOVF f1, W
1676  0080     MOVWF INDF
1677  0AD7     INCF _val, F
1678  0ADB     INCF sp, F
778:           #ifdef	LEFT
779:           			if(flag & LEFT)
780:           				while(width--)
781:           					pputc(' ');
782:           #endif	// LEFT
783:           			continue;
784:           #else	// WIDTH || PRECISION
785:           #if	defined(STRING)
786:           			while(*cp)
787:           				pputc(*cp++);
788:           			continue;
789:           #endif
790:           #endif	// WIDTH || PRECISION
791:           #endif	// defined(STRING) || defined(PERCPERC)
792:           #ifdef	CHAR
793:           		case 'c':
794:           #if	_HOSTED
795:           			val = va_arg(ap, int);
796:           			c = val >> 8;
797:           			if(flag & LONG && c && (unsigned char)c != 0xFF) {
798:           				cbuf[0] = c;
799:           				cbuf[1] = val;
800:           				len = 2;
801:           			} else {
802:           				cbuf[0] = val;
803:           				len = 1;
804:           			}
805:           			cp = cbuf;
806:           			goto dostring;
807:           #else
808:           			c = va_arg(ap, int);
809:           #endif	// _HOSTED
810:           #endif	// CHAR
811:           		default:
812:           #ifdef	PERCPERC
813:           #if	defined(WIDTH) || defined(PRECISION)
814:           			cp = (char *)&c;
1685  305A     MOVLW 0x5A
1686  00D7     MOVWF _val
815:           			len = 1;
1687  01D8     CLRF 0x58
1688  0AD8     INCF 0x58, F
1689  01D9     CLRF exp
816:           			goto dostring;
168A  2E4D     GOTO 0x64D
817:           #else
818:           			pputc(c);
819:           			continue;
820:           #endif
821:           #else	// PERCPERC
822:           			continue;
823:           #endif
824:           
825:           #ifdef	UNSIGN
826:           		case 'u':
827:           			flag |= UNSIGN;
168B  1754     BSF flag, 0x6
828:           			break;
168C  2EAB     GOTO 0x6AB
829:           #endif
830:           
831:           		}
832:           #endif	// ANYFORMAT
833:           #ifdef	__FLOAT
834:           		if(flag & (FLOATFORMAT)) {
835:           #ifdef	DEFPREC
836:           			if(flag & DEFPREC)
837:           #endif
838:           				prec = 6;
839:           			fval = va_arg(ap, double);	// source the floating point value
840:           			if(fval < 0.0) {
841:           				fval = -fval;		// get the absolute value
842:           				flag |= NEGSIGN;
843:           			}
844:           			exp = 0;		/* If the number is zero, the exponent is zero. */
845:           			if( fval!=0) {		/* If the number is non-zero, find the exponent. */
846:           				frexp(fval, &exp);		/* get binary exponent */
847:           				exp--;				/* adjust 0.5 -> 1.0 */
848:           				exp *= 3;
849:           				exp /= 10;			/* estimate decimal exponent */
850:           				if(exp < 0)
851:           					exp--;
852:           				// the following line can cause "recursive call" errors because scale calls
853:           				// ftmul, and is used when evaluating an argument to ftmul
854:           				//integ = fval * scale(-exp);
855:           				integ = scale(-exp);		// replaced with this
856:           				integ *= fval;
857:           				if(integ < 1.0)
858:           					exp--;
859:           				else if(integ >= 10.0)
860:           					exp++;
861:           			}
862:           #if	defined(EFMT) || defined(GFMT)
863:           			if(exp <= 0)	// value is 0.??? (neg expnt) whole characters = 1 (allow zero)
864:           				c = 1;
865:           			else
866:           				c = exp;
867:           			if(
868:           #ifdef	EFMT
869:           					flag & EFMT
870:           #ifdef	GFMT
871:           					||
872:           #endif
873:           #endif
874:           #ifdef	GFMT
875:           					flag & GFMT && (exp < -4 || exp >= (int)prec)
876:           #endif
877:           				) {	/* use e format */
878:           #ifdef	GFMT
879:           				if(prec && flag & GFMT)
880:           					prec--;		/* g format precision includes integer digit */
881:           #endif
882:           				if((unsigned)prec > NDDIG - 2)
883:           					c = NDDIG - 2;
884:           				else
885:           					c = prec;
886:           				if( fval!=0) {	/* Normalise only if the number is non-zero. */
887:           					fval /= scale(exp-c);
888:           #if	DOUBLE
889:           					ival = _dto64i(fval);
890:           					if(fval - _64itod(ival) >= 0.5) {
891:           						fval += 0.5;
892:           						ival = _dto64i(fval);
893:           					}
894:           					if(ival >= fdpowers[c+1]) {
895:           						fval *= 1e-1;
896:           						exp++;
897:           					} else if(ival < fdpowers[c]) {
898:           						fval *= 10.0;
899:           						exp--;
900:           					}
901:           #else	
902:           					if(fval - (double)(unsigned long)fval >= 0.5)
903:           						fval += 0.5;
904:           					if((unsigned long)fval >= fdpowers[c+1]) {
905:           						fval *= 1e-1;
906:           						exp++;
907:           					} else if((unsigned long)fval < fdpowers[c]) {
908:           						fval *= 10.0;
909:           						exp--;
910:           					}
911:           #endif
912:           				}
913:           #if defined(GFMT) && defined(ALTERN)
914:           				if(flag & GFMT && !(flag & ALTERN)) {		/* g format, precision means something different */
915:           					if(prec > (int)(NDDIG))
916:           						prec = NDDIG;
917:           #if	DOUBLE
918:           					ival = _dto64i(fval);
919:           					while(ival != 0.0 && _mod64i10(ival) == 0) {
920:           						prec--;
921:           						ival = _div64(ival, fdpowers[1]);
922:           					}
923:           #else
924:           					val = (unsigned long)fval;
925:           					while(val && val % 10 == 0) {
926:           						prec--;
927:           						val /= 10;
928:           					}
929:           #endif
930:           					if(prec < c) {
931:           						fval /= scale(c-prec);
932:           						c = prec;
933:           					}
934:           
935:           				}
936:           #endif
937:           #ifdef	WIDTH
938:           				width -=  prec + 5;
939:           #ifdef	ALTERN
940:           				if(prec || flag & ALTERN)
941:           					width--;
942:           #endif
943:           				if(flag & NEGSIGN)
944:           					width--;
945:           #if	DBL_MAX_10_EXP >= 100
946:           #if	DBL_MAX_10_EXP >= 1000
947:           				if(exp >= 1000 || exp <= -1000)	/* 4 digit exponent */
948:           					width--;
949:           #endif
950:           				if(exp >= 100 || exp <= -100)	/* 3 digit exponent */
951:           					width--;
952:           #endif
953:           #endif	// WIDTH
954:           #ifdef	FILL
955:           				if(flag & FILL) {
956:           #if defined(MANSIGN) && defined(SPCSIGN)
957:           					if(flag & MANSIGN)
958:           						pputc(flag & SPCSIGN ? '-' : '+');
959:           					else if(flag & SPCSIGN)
960:           						pputc(' ');
961:           #endif
962:           					while(width > 0) {
963:           						pputc('0');
964:           						width--;
965:           					}
966:           				} else
967:           #endif	// FILL
968:           				{
969:           #ifdef	WIDTH
970:           #ifdef	LEFT
971:           					if(!(flag & LEFT))
972:           #endif
973:           						while(width > 0) {
974:           							pputc(' ');
975:           							width--;
976:           						}
977:           #endif	// WIDTH
978:           #ifdef	MANSIGN
979:           					if(flag & MANSIGN)
980:           						putsign();
981:           #else
982:           					if(flag & NEGSIGN)
983:           						pputc('-');
984:           #endif	// MANSIGN
985:           #ifdef	SPCSIGN
986:           					else if(flag & SPCSIGN)
987:           						pputc(' ');
988:           #endif	// SPCSIGN
989:           				}
990:           #if	DOUBLE
991:           				ival = _dto64i(fval);
992:           				pputc(_div64ir(ival, fdpowers[c]) + '0');
993:           #else
994:           				val = (unsigned long)fval;
995:           				pputc(val/dpowers[c] + '0');
996:           				val %= dpowers[c];
997:           #endif
998:           #ifdef	ALTERN
999:           				if(prec || flag & ALTERN)
1000:          #else
1001:          				if(prec)
1002:          #endif
1003:          				{
1004:          					pputc('.');
1005:          					prec -= c;
1006:          					while(c--) {
1007:          #if	DOUBLE
1008:          						pputc('0' + _mod64i10(_div64(ival, fdpowers[c])));
1009:          #else
1010:          #ifdef	GFMT
1011:          						if(flag & GFMT && val == 0) {
1012:          							prec = c = 0;
1013:          							break;
1014:          						}
1015:          #endif
1016:          						pputc('0' + (val/dpowers[c]));
1017:          						val %= dpowers[c];
1018:          #endif
1019:          					}
1020:          					while(prec) {
1021:          						pputc('0');
1022:          						prec--;
1023:          					}
1024:          				}
1025:          #ifdef	UPCASE
1026:          				if(flag & UPCASE)
1027:          					pputc('E');
1028:          				else
1029:          #endif
1030:          					pputc('e');
1031:          				if(exp < 0) {
1032:          					exp = -exp;
1033:          					pputc('-');
1034:          				} else
1035:          					pputc('+');
1036:          #if	DBL_MAX_10_EXP >= 100
1037:          #if	DBL_MAX_10_EXP >= 1000
1038:          				if(exp >= 1000) {
1039:          					pputc(exp / 1000 + '0');
1040:          					exp %= 1000;
1041:          				}
1042:          #endif
1043:          				if(exp >= 100) {
1044:          					pputc(exp / 100 + '0');
1045:          					exp %= 100;
1046:          				}
1047:          #endif
1048:          				pputc(exp / 10 + '0');
1049:          				pputc(exp % 10 + '0');
1050:          #ifdef	LEFT
1051:          				if((flag & LEFT) && width > 0)
1052:          					do
1053:          						pputc(' ');
1054:          					while(--width);
1055:          #endif	// LEFT
1056:          					continue;
1057:          				}
1058:          #endif	// EFMT || GFMT
1059:          				/* here for f format */
1060:          #if	DOUBLE
1061:          #ifdef	GFMT
1062:          				if(flag & GFMT) {
1063:          					if(exp < 0)	// fractional part only
1064:          						prec -= exp-1;
1065:          					ival = _dto64i(fval);
1066:          					for(c = 1 ; c != NDDIG ; c++)
1067:          						if(ival < fdpowers[c])
1068:          							break;
1069:          					if(prec > NDDIG)
1070:          						prec = NDDIG;
1071:          					prec -= c;
1072:          					ival = _dto64i((fval - _64itod(ival)) * scale(prec)+0.5);
1073:          					// see how many zeros are at the end of the fractional part
1074:          					while(prec && _mod64i10(ival) == 0) {
1075:          						prec--;
1076:          						ival = _div64(ival, fdpowers[1]);
1077:          					}
1078:          				}
1079:          #endif	// GFMT
1080:          				if(prec <= (int)NDDIG)
1081:          					fval += fround(prec);
1082:          				if(exp > (int)(NDDIG)-2) {
1083:          					exp -= NDDIG-2;
1084:          					ival = _divto64i(fval, scale(exp));
1085:          					fval = 0.0;
1086:          				} else {
1087:          					ival = _dto64i(fval);
1088:          					fval -= _64itod(ival);
1089:          					exp = 0;
1090:          				}
1091:          				for(c = 1 ; c != NDDIG ; c++)
1092:          					if(ival < fdpowers[c])
1093:          						break;
1094:          #else	// DOUBLE
1095:          #ifdef	GFMT
1096:          				if(flag & GFMT) {
1097:          					if(exp < 0)	// fractional part only
1098:          						prec -= (exp+1);
1099:          					// count number of digits in the integral part (this is for %g)
1100:          					val = (unsigned long)fval;
1101:          					for(c = 0 ; c != NDDIG ; c++)
1102:          						if(val < fdpowers[c])
1103:          							break;
1104:          					prec -= c;		// reduce precision by this
1105:          					if(prec <= NDIG)
1106:          						fval += fround(prec);
1107:          					// get fractional part and count trailing zeros - reduce
1108:          					// prec as required
1109:          					{
1110:          						double	temp;
1111:          						temp = scale(prec);
1112:          						temp *= fval - (double)val;
1113:          						val = (unsigned long)temp;
1114:          					}
1115:          					while(prec && val % 10 == 0) {
1116:          						val /= 10;
1117:          						prec--;
1118:          					}
1119:          				} else
1120:          #endif	//GFMT
1121:          					if(prec <= NDIG)
1122:          						fval += fround(prec);
1123:          
1124:          				/* ~4.2e9 is the largest float that will fit into a 32-bit long */
1125:          				if((exp > 9)||(fval != 0 && (unsigned long)fval == 0 && exp > 1)) {
1126:          					// fval is > 4.2e9
1127:          					// new exp must be such that div_to_l() is < 4.2e9
1128:          					// OLD CODE:	if(fval / scale(exp) < 4.294967296){
1129:          					if(integ < 4.294967296){
1130:          						exp -= NDDIG-1;
1131:          					}else{
1132:          						exp -= NDDIG-2;
1133:          					}
1134:          					integ = scale(exp);
1135:          					val = div_to_l_(fval, integ);
1136:           					//val = _div_to_l_(integ, fval);
1137:          					//val = (long)(integ * fval);	// fit as much signifigant data into the long as it can hold
1138:          					fval = 0.0;	// There will be no fractional component
1139:          				} else {
1140:          					val = (unsigned long)fval;
1141:          					fval -= (double)val;
1142:          					exp = 0;
1143:          				}
1144:          				// count digits in integral part
1145:          				for(c = 1 ; c != NDDIG ; c++)
1146:          					if(val < fdpowers[c])
1147:          						break;
1148:          #endif	// DOUBLE
1149:          #ifdef	WIDTH
1150:          				// at this point, c contains the number of whole-number digits to print
1151:          				width -= prec + c + exp;
1152:          				if(
1153:          #ifdef	ALTERN
1154:          						flag & ALTERN ||
1155:          #endif
1156:          						prec)
1157:          					width--;		// allow for decimal point
1158:          				if(flag & NEGSIGN)
1159:          					width--;
1160:          #endif	// WIDTH
1161:          #ifdef	FILL
1162:          				if(flag & FILL) {
1163:          #ifdef	MANSIGN
1164:          					if(flag & MANSIGN)
1165:          #else
1166:          					if(flag & NEGSIGN)
1167:          #endif	// MANSIGN
1168:          						putsign();
1169:          #if defined(MANSIGN) && defined(SPCSIGN)
1170:          					else
1171:          #endif
1172:          #ifdef	SPCSIGN
1173:          					if(flag & SPCSIGN)
1174:          						pputc(' ');
1175:          #endif	// SPCSIGN
1176:          #ifdef	WIDTH
1177:          					while(width > 0) {
1178:          						pputc('0');
1179:          						width--;
1180:          					}
1181:          #endif	// WIDTH
1182:          				} else
1183:          #endif	// FILL
1184:          				{
1185:          #ifdef	LEFT
1186:          					if(!(flag & LEFT))
1187:          #endif
1188:          #ifdef	WIDTH
1189:          					while(width > 0) {
1190:          						pputc(' ');
1191:          						width--;
1192:          					}
1193:          #endif	// WIDTH
1194:          #ifdef	MANSIGN
1195:          				if(flag & MANSIGN)
1196:          #else
1197:          				if(flag & NEGSIGN)
1198:          #endif	// MANSIGN
1199:          					putsign();
1200:          #ifdef	SPCSIGN
1201:          				else if(flag & SPCSIGN)
1202:          					pputc(' ');
1203:          #endif	// SPCSIGN
1204:          			}
1205:          			while(c--) {
1206:          #if	DOUBLE
1207:          				pputc('0' + _mod64i10(_div64(ival, fdpowers[c])));
1208:          #else
1209:          				{
1210:          					unsigned long vd = val/dpowers[c];
1211:          					vd %= 10;
1212:          					pputc('0' + vd);
1213:          				}
1214:          #endif	// DOUBLE
1215:          			}
1216:          			while(exp > 0) {
1217:          				pputc('0');
1218:          				exp--;
1219:          			}
1220:          			if(prec > (int)(NDDIG-2))
1221:          				c = NDDIG-2;
1222:          			else
1223:          				c = prec;
1224:          			prec -= c;
1225:          #ifdef	ALTERN
1226:          			if(c || flag & ALTERN)
1227:          #else
1228:          			if(c)
1229:          #endif
1230:          				pputc('.');
1231:          #if	DOUBLE
1232:          			ival = _dto64i(fval * scale(c));
1233:          			while(c)
1234:          				pputc('0' + _mod64i10(_div64(ival, fdpowers[--c])));
1235:          #else	// DOUBLE
1236:          			val = (long)(fval * scale(c));
1237:          			while(c--) {
1238:          				unsigned long vd = val/dpowers[c];
1239:          				vd %= 10;
1240:          				pputc('0' + vd);
1241:          				val %= dpowers[c];
1242:          			}
1243:          #endif	// DOUBLE
1244:          			while(prec) {
1245:          				pputc('0');
1246:          				prec--;
1247:          			}
1248:          #ifdef	LEFT
1249:          			if((flag & LEFT) && width > 0)
1250:          				do
1251:          					pputc(' ');
1252:          				while(--width);
1253:          #endif
1254:          			continue;
1255:          		}
1256:          #endif	/* __FLOAT */
1257:          
1258:          #if	defined(TEN)
1259:          #ifdef	BASEM
1260:          		if((flag & BASEM) == TEN)
16AB  1B54     BTFSC flag, 0x6
16AC  2EC1     GOTO 0x6C1
1261:          #endif	//BASEM
1262:          		{
1263:          #ifdef	LONG
1264:          			if(flag & LONG)
1265:          				val = va_arg(ap, long);
1266:          			else
1267:          #endif	// LONG
1268:          				val = (value)va_arg(ap, int);
16AD  0853     MOVF ap, W
16AE  0084     MOVWF FSR
16AF  1383     BCF STATUS, 0x7
16B0  0800     MOVF INDF, W
16B1  00D7     MOVWF _val
16B2  0A84     INCF FSR, F
16B3  0800     MOVF INDF, W
16B4  00D8     MOVWF 0x58
16B5  0AD3     INCF ap, F
16B6  0AD3     INCF ap, F
1269:          #ifdef	NEGSIGN
1270:          			if((value)val < 0) {
16B7  1FD8     BTFSS 0x58, 0x7
16B8  2ECB     GOTO 0x6CB
1271:          				flag |= NEGSIGN;
16B9  3003     MOVLW 0x3
16BA  04D4     IORWF flag, F
1272:          				val = -val;
16BB  09D7     COMF _val, F
16BC  09D8     COMF 0x58, F
16BD  0AD7     INCF _val, F
16BE  1903     BTFSC STATUS, 0x2
16BF  0AD8     INCF 0x58, F
16C0  2ECB     GOTO 0x6CB
1273:          			}
1274:          #endif
1275:          		}
1276:          #ifdef	BASEM
1277:          		else
1278:          #endif
1279:          #endif	// TEN
1280:          
1281:          #if	defined(EIGHT) || defined(SIXTEEN) || defined(UNSIGN)
1282:          		{
1283:          #ifdef	__LONG
1284:          #if	defined(_PIC18) && defined(LARGE_DATA) && defined(POINTER)
1285:          			if(flag & POINTER)
1286:          				val = (unsigned long)va_arg(ap, far char *);
1287:          			else
1288:          #endif
1289:          #ifdef	LONG
1290:          				if(flag & LONG)
1291:          				val = va_arg(ap, unsigned long);
1292:          			else
1293:          #endif	// LONG
1294:          #endif	// __LONG
1295:          				val = va_arg(ap, unsigned);
16C1  0853     MOVF ap, W
16C2  0084     MOVWF FSR
16C3  1383     BCF STATUS, 0x7
16C4  0800     MOVF INDF, W
16C5  00D7     MOVWF _val
16C6  0A84     INCF FSR, F
16C7  0800     MOVF INDF, W
16C8  00D8     MOVWF 0x58
16C9  0AD3     INCF ap, F
16CA  0AD3     INCF ap, F
1296:          		}
1297:          #endif	// EIGHT or SIXTEEN or UNSIGN
1298:          #ifdef	PRECISION
1299:          		if(prec == 0 && val == 0)
1300:          			prec++;
1301:          #endif
1302:          #ifdef	MULTRAD
1303:          		switch((unsigned char)(flag & BASEM)) {
1304:          #endif
1305:          #if	defined(TEN) || defined(UNSIGN)
1306:          #ifdef	MULTRAD
1307:          #ifdef	TEN
1308:          		case TEN:
1309:          #endif
1310:          #ifdef	UNSIGN
1311:          		case UNSIGN:
1312:          #endif
1313:          #endif	// MULTRAD
1314:          			for(c = 1 ; c != sizeof dpowers/sizeof dpowers[0] ; c++)
16CB  01DA     CLRF c
16CC  0ADA     INCF c, F
16CD  085A     MOVF c, W
16CE  3A05     XORLW 0x5
16CF  1903     BTFSC STATUS, 0x2
16D0  2EEC     GOTO 0x6EC
1315:          				if(val < dpowers[c])
16D1  1003     BCF STATUS, 0x0
16D2  0D5A     RLF c, W
16D3  3E12     ADDLW 0x12
16D4  0084     MOVWF FSR
16D5  3098     MOVLW 0x98
16D6  1803     BTFSC STATUS, 0x0
16D7  3E01     ADDLW 0x1
16D8  00FF     MOVWF 0x7F
16D9  160A     BSF PCLATH, 0x4
16DA  158A     BSF PCLATH, 0x3
16DB  2000     CALL 0x0
16DC  160A     BSF PCLATH, 0x4
16DD  118A     BCF PCLATH, 0x3
16DE  00CF     MOVWF f1
16DF  160A     BSF PCLATH, 0x4
16E0  158A     BSF PCLATH, 0x3
16E1  2000     CALL 0x0
16E2  160A     BSF PCLATH, 0x4
16E3  118A     BCF PCLATH, 0x3
16E4  00D0     MOVWF 0x50
16E5  0258     SUBWF 0x58, W
16E6  1D03     BTFSS STATUS, 0x2
16E7  2EEA     GOTO 0x6EA
16E8  084F     MOVF f1, W
16E9  0257     SUBWF _val, W
16EA  1803     BTFSC STATUS, 0x0
16EB  2ECC     GOTO 0x6CC
1316:          					break;
1317:          #ifdef	MULTRAD
1318:          			break;
1319:          #endif
1320:          #endif	// TEN || UNSIGN
1321:          #ifdef	SIXTEEN
1322:          #ifdef	MULTRAD
1323:          		case SIXTEEN:
1324:          #endif	// MULTRAD
1325:          			for(c = 1 ; c != sizeof hexpowers/sizeof hexpowers[0] ; c++)
1326:          				if(val < hexpowers[c])
1327:          					break;
1328:          #ifdef	MULTRAD
1329:          			break;
1330:          #endif
1331:          #endif
1332:          
1333:          #ifdef	EIGHT
1334:          #ifdef	MULTRAD
1335:          		case EIGHT:
1336:          #endif	// MULTRAD
1337:          			for(c = 1 ; c != sizeof octpowers/sizeof octpowers[0] ; c++)
1338:          				if(val < octpowers[c])
1339:          					break;
1340:          #ifdef	MULTRAD
1341:          			break;
1342:          #endif
1343:          #endif
1344:          #ifdef	MULTRAD
1345:          		}
1346:          #endif
1347:          #ifdef	PRECISION
1348:          		if(c < prec)
1349:          			c = prec;
1350:          		else if(prec < c)
1351:          			prec = c;
1352:          #endif
1353:          #if	defined(WIDTH) && defined(NEGSIGN)
1354:          		if(width && flag & NEGSIGN)
16EC  0856     MOVF f3, W
16ED  0455     IORWF width, W
16EE  1903     BTFSC STATUS, 0x2
16EF  2EF8     GOTO 0x6F8
16F0  0854     MOVF flag, W
16F1  3903     ANDLW 0x3
16F2  1903     BTFSC STATUS, 0x2
16F3  2EF8     GOTO 0x6F8
1355:          			width--;
16F4  30FF     MOVLW 0xFF
16F5  07D5     ADDWF width, F
16F6  1C03     BTFSS STATUS, 0x0
16F7  03D6     DECF f3, F
1356:          #ifdef	PRECISION
1357:          		if(flag & PRECISION) {
1358:          			if(width > prec)
1359:          				width -= prec;
1360:          			else
1361:          				width = 0;
1362:          		}
1363:          #endif
1364:          #ifdef	ALTERN
1365:          #ifdef	EIGHT
1366:          		if((flag & (
1367:          #ifdef	FILL
1368:          						FILL|
1369:          #endif
1370:          							BASEM|ALTERN)) == (EIGHT|ALTERN)) {
1371:          			if(width)
1372:          				width--;
1373:          		} else
1374:          #endif	// EIGHT
1375:          #if	defined(SIXTEEN)
1376:          #ifdef	BASEM
1377:          		if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1378:          #else
1379:          		if(flag & ALTERN) {
1380:          #endif
1381:          			if(width > 2)
1382:          				width -= 2;
1383:          			else
1384:          				width = 0;
1385:          		}
1386:          #endif	// SIXTEEN
1387:          #endif	// ALTERN
1388:          #endif	// WIDTH
1389:          #ifdef	WIDTH
1390:          		if(width > c)
16F8  085A     MOVF c, W
16F9  00CF     MOVWF f1
16FA  01D0     CLRF 0x50
16FB  1BCF     BTFSC f1, 0x7
16FC  03D0     DECF 0x50, F
16FD  0850     MOVF 0x50, W
16FE  3A80     XORLW 0x80
16FF  00D1     MOVWF 0x51
1700  0856     MOVF f3, W
1701  3A80     XORLW 0x80
1702  0251     SUBWF 0x51, W
1703  1D03     BTFSS STATUS, 0x2
1704  2F07     GOTO 0x707
1705  0855     MOVF width, W
1706  024F     SUBWF f1, W
1707  1803     BTFSC STATUS, 0x0
1708  2F16     GOTO 0x716
1391:          			width -= c;
1709  1283     BCF STATUS, 0x5
170A  1303     BCF STATUS, 0x6
170B  085A     MOVF c, W
170C  00CF     MOVWF f1
170D  01D0     CLRF 0x50
170E  1BCF     BTFSC f1, 0x7
170F  03D0     DECF 0x50, F
1710  02D5     SUBWF width, F
1711  0850     MOVF 0x50, W
1712  1C03     BTFSS STATUS, 0x0
1713  03D6     DECF f3, F
1714  02D6     SUBWF f3, F
1715  2F1A     GOTO 0x71A
1392:          		else
1393:          			width = 0;
1716  1283     BCF STATUS, 0x5
1717  1303     BCF STATUS, 0x6
1718  01D5     CLRF width
1719  01D6     CLRF f3
1394:          #endif
1395:          #ifdef	FILL
1396:          		if(flag & FILL) {
171A  1D54     BTFSS flag, 0x2
171B  2F35     GOTO 0x735
1397:          #ifdef	MANSIGN
1398:          			if(flag & MANSIGN)
1399:          				putsign();
1400:          #elif defined(NEGSIGN)
1401:          			if(flag & NEGSIGN)
171C  0854     MOVF flag, W
171D  3903     ANDLW 0x3
171E  1903     BTFSC STATUS, 0x2
171F  2F26     GOTO 0x726
1402:          				pputc('-');
1720  085B     MOVF sp, W
1721  0084     MOVWF FSR
1722  302D     MOVLW 0x2D
1723  1383     BCF STATUS, 0x7
1724  0080     MOVWF INDF
1725  0ADB     INCF sp, F
1403:          #endif
1404:          #if defined(MANSIGN) || defined(NEGSIGN) && defined(SPCSIGN)
1405:          			else
1406:          #endif	// MANSIGN
1407:          #ifdef	SPCSIGN
1408:          			if(flag & SPCSIGN)
1409:          				pputc(' ');
1410:          #endif
1411:          #if defined(ALTERN) && defined(SIXTEEN)
1412:          			else if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1413:          				pputc('0');
1414:          #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
1415:          				pputc(flag & UPCASE ? 'X' : 'x');
1416:          #elif defined(HEXUPCASE)
1417:          				pputc('X');
1418:          #else
1419:          				pputc('x');
1420:          #endif	// HEXUPCASE
1421:          			}
1422:          #endif	// ALTERN
1423:          #ifdef	WIDTH
1424:          			if(width)
1726  0856     MOVF f3, W
1727  0455     IORWF width, W
1728  1903     BTFSC STATUS, 0x2
1729  2F51     GOTO 0x751
1425:          				do
1426:          					pputc('0');
172A  085B     MOVF sp, W
172B  0084     MOVWF FSR
172C  3030     MOVLW 0x30
172D  1383     BCF STATUS, 0x7
172E  0080     MOVWF INDF
1730  0ADB     INCF sp, F
1427:          				while(--width);
172F  30FF     MOVLW 0xFF
1731  07D5     ADDWF width, F
1732  1C03     BTFSS STATUS, 0x0
1733  03D6     DECF f3, F
1734  2F26     GOTO 0x726
1428:          #endif	// WIDTH
1429:          		} else
1430:          #endif	//FILL
1431:          		{
1432:          #ifdef	WIDTH
1433:          			if(width
1434:          #ifdef	LEFT
1435:          					&& !(flag & LEFT)
1436:          #endif
1437:          					)
1735  0856     MOVF f3, W
1736  0455     IORWF width, W
1737  1903     BTFSC STATUS, 0x2
1738  2F47     GOTO 0x747
1438:          				do
1439:          					pputc(' ');
1739  085B     MOVF sp, W
173A  0084     MOVWF FSR
173B  3020     MOVLW 0x20
173C  1383     BCF STATUS, 0x7
173D  0080     MOVWF INDF
173F  0ADB     INCF sp, F
1440:          				while(--width);
173E  30FF     MOVLW 0xFF
1740  07D5     ADDWF width, F
1741  1C03     BTFSS STATUS, 0x0
1742  03D6     DECF f3, F
1743  0856     MOVF f3, W
1744  0455     IORWF width, W
1745  1D03     BTFSS STATUS, 0x2
1746  2F39     GOTO 0x739
1441:          #endif	// WIDTH
1442:          #ifdef	MANSIGN
1443:          			if(flag & MANSIGN)
1444:          				putsign();
1445:          #else
1446:          #ifdef	NEGSIGN
1447:          			if(flag & NEGSIGN)
1747  0854     MOVF flag, W
1748  3903     ANDLW 0x3
1749  1903     BTFSC STATUS, 0x2
174A  2F51     GOTO 0x751
1448:          				pputc('-');
174B  085B     MOVF sp, W
174C  0084     MOVWF FSR
174D  302D     MOVLW 0x2D
174E  1383     BCF STATUS, 0x7
174F  0080     MOVWF INDF
1750  0ADB     INCF sp, F
1449:          #endif
1450:          #endif	// MANSIGN
1451:          #ifdef	SPCSIGN
1452:          			else if(flag & SPCSIGN)
1453:          				pputc(' ');
1454:          #endif
1455:          #ifdef	ALTERN
1456:          #ifdef	EIGHT
1457:          			if((flag & (BASEM|ALTERN)) == (EIGHT|ALTERN))
1458:          				pputc('0');
1459:          			else
1460:          #endif	// EIGHT
1461:          #ifdef	SIXTEEN
1462:          #ifdef	BASEM
1463:          			if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1464:          #else
1465:          			if(flag & ALTERN) {
1466:          #endif
1467:          				pputc('0');
1468:          #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
1469:          				pputc(flag & UPCASE ? 'X' : 'x');
1470:          #elif defined(HEXUPCASE)
1471:          				pputc('X');
1472:          #else
1473:          				pputc('x');
1474:          #endif
1475:          			}
1476:          #endif	// SIXTEEN
1477:          #endif	// ALTERN
1478:          		}
1479:          #if	defined(SIXTEEN) || defined(TEN) || defined(EIGHT) || defined(UNSIGN)
1480:          #ifndef	PRECISION
1481:          		prec = c;
1751  085A     MOVF c, W
1752  00D2     MOVWF prec
1482:          #endif
1483:          		while(prec--) {
1753  2F82     GOTO 0x782
1782  03D2     DECF prec, F
1783  0F52     INCFSZ prec, W
1784  2F54     GOTO 0x754
1484:          #ifdef	MULTRAD
1485:          			switch((unsigned char)(flag & BASEM))
1486:          #endif
1487:          			{
1488:          
1489:          #if	defined(TEN) || defined(UNSIGN)
1490:          #ifdef	MULTRAD
1491:          #ifdef	TEN
1492:          		case TEN:
1493:          #endif
1494:          #ifdef	UNSIGN
1495:          		case UNSIGN:
1496:          #endif
1497:          #endif	// MULTRAD
1498:          				c = (val / dpowers[prec]) % 10 + '0';
1754  300A     MOVLW 0xA
1755  00AA     MOVWF Data
1756  01AB     CLRF sec
1757  1003     BCF STATUS, 0x0
1758  0D52     RLF prec, W
1759  3E12     ADDLW 0x12
175A  0084     MOVWF FSR
175B  3098     MOVLW 0x98
175C  1803     BTFSC STATUS, 0x0
175D  3E01     ADDLW 0x1
175E  00FF     MOVWF 0x7F
175F  160A     BSF PCLATH, 0x4
1760  158A     BSF PCLATH, 0x3
1761  2000     CALL 0x0
1762  160A     BSF PCLATH, 0x4
1763  118A     BCF PCLATH, 0x3
1764  00A3     MOVWF x
1765  160A     BSF PCLATH, 0x4
1766  158A     BSF PCLATH, 0x3
1767  2000     CALL 0x0
1768  160A     BSF PCLATH, 0x4
1769  118A     BCF PCLATH, 0x3
176A  00A4     MOVWF dato
176B  0858     MOVF 0x58, W
176C  00A6     MOVWF x
176D  0857     MOVF _val, W
176E  00A5     MOVWF y
176F  27B2     CALL 0x7B2
1770  160A     BSF PCLATH, 0x4
1771  118A     BCF PCLATH, 0x3
1772  0824     MOVF dato, W
1773  00AD     MOVWF day
1774  0823     MOVF x, W
1775  00AC     MOVWF hr
1776  27DC     CALL 0x7DC
1777  160A     BSF PCLATH, 0x4
1778  118A     BCF PCLATH, 0x3
1779  082A     MOVF Data, W
177A  3E30     ADDLW 0x30
177B  00DA     MOVWF c
1499:          #ifdef	MULTRAD
1500:          				break;
1501:          #endif
1502:          #endif	// TEN || UNSIGN
1503:          
1504:          #ifdef	SIXTEEN
1505:          #ifdef	MULTRAD
1506:          			case SIXTEEN:
1507:          #endif
1508:          			{
1509:          				unsigned char idx = (val / hexpowers[prec]) & 0xF;
1510:          #if	defined(HEXLOWCASE) && defined(HEXUPCASE)
1511:          				c = (flag & UPCASE ? "0123456789ABCDEF" : "0123456789abcdef")[idx];
1512:          #elif	defined(HEXUPCASE)
1513:          				c = "0123456789ABCDEF"[idx];
1514:          #else
1515:          				c = "0123456789abcdef"[idx];
1516:          #endif	//HEXCASE
1517:          			}
1518:          #ifdef	MULTRAD
1519:          				break;
1520:          #endif
1521:          #endif
1522:          
1523:          #ifdef	EIGHT
1524:          #ifdef	MULTRAD
1525:          			case EIGHT:
1526:          #endif	// MULTRAD
1527:          				c = ((val / octpowers[prec]) & 07) + '0';
1528:          #ifdef	MULTRAD
1529:          				break;
1530:          #endif	// MULTRAD
1531:          #endif	// EIGHT
1532:          			}
1533:          			pputc(c);
177C  085B     MOVF sp, W
177D  0084     MOVWF FSR
177E  085A     MOVF c, W
177F  1383     BCF STATUS, 0x7
1780  0080     MOVWF INDF
1781  0ADB     INCF sp, F
1534:          		}
1535:          #endif	// 16 or 10 or 8
1536:          #ifdef	LEFT
1537:          		if((flag & LEFT) && width > 0)
1538:          			do
1539:          				pputc(' ');
1540:          			while(--width);
1541:          #endif	// LEFT
1542:          	}
1543:          #ifdef	ANYFORMAT
1544:          alldone:
1545:          #endif	// ANYFORMAT
1546:          #if	!defined(PRINTF) && (defined(SPRINTF) || defined(VSPRINTF))
1547:          	*sp = 0;
1786  085B     MOVF sp, W
1787  0084     MOVWF FSR
1788  1383     BCF STATUS, 0x7
1789  0180     CLRF INDF
1548:          #endif
1549:          	return ccnt;
1550:          }
178A  0008     RETURN
1551:          
---  /opt/microchip/xc8/v1.31/sources/common/bmul.c  ----------------------------------------------------
1:             // 8 x 8 bit multiplication with 8 bit result
2:             
3:             unsigned char
4:             __bmul(unsigned char multiplier, unsigned char multiplicand)
0BC5  1283     BCF STATUS, 0x5
0BC6  00A5     MOVWF y
5:             {
6:             	unsigned char product;
7:             
8:             	product = 0;
0BC7  01A4     CLRF dato
9:             	do {
10:            		if(multiplier & 1)
0BC8  0823     MOVF x, W
0BC9  1825     BTFSC y, 0x0
11:            			product += multiplicand;
0BC8  0823     MOVF x, W
0BCA  07A4     ADDWF dato, F
12:            		multiplicand <<= 1;
0BCB  1003     BCF STATUS, 0x0
0BCC  0DA3     RLF x, F
13:            		multiplier >>= 1;
0BCD  1003     BCF STATUS, 0x0
0BCE  0CA5     RRF y, F
14:            	} while(multiplier != 0);
0BCF  08A5     MOVF y, F
0BD0  1D03     BTFSS STATUS, 0x2
0BD1  2BC8     GOTO 0x3C8
15:            	return product;
0BD2  0824     MOVF dato, W
16:            }
0BD3  0008     RETURN
17:            
---  /opt/microchip/xc8/v1.31/sources/common/awmod.c  ---------------------------------------------------
1:             // integer signed unsigned modulus
2:             
3:             signed int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __awmod(signed int divisor, signed int dividend)
0753  01F5     CLRF Pin
0BD4  01B6     CLRF sign
7:             #else
8:             __awmod(signed int dividend, signed int divisor)
9:             #endif
10:            {
11:            	unsigned char	counter, sign;
12:            
13:            	sign = 0;
0753  01F5     CLRF Pin
0BD4  01B6     CLRF sign
14:            	if(dividend < 0) {
0754  1FF3     BTFSS counter, 0x7
0755  2F5D     GOTO 0x75D
0BD5  1FB4     BTFSS sign, 0x7
0BD6  2BDE     GOTO 0x3DE
15:            		dividend = -dividend;
0756  09F2     COMF dividend, F
0757  09F3     COMF counter, F
0758  0AF2     INCF dividend, F
0759  1903     BTFSC STATUS, 0x2
075A  0AF3     INCF counter, F
0BD7  09B3     COMF dividend, F
0BD8  09B4     COMF sign, F
0BD9  0AB3     INCF dividend, F
0BDA  1903     BTFSC STATUS, 0x2
0BDB  0AB4     INCF sign, F
16:            		sign = 1;
075B  01F5     CLRF Pin
075C  0AF5     INCF Pin, F
0BDC  01B6     CLRF sign
0BDD  0AB6     INCF sign, F
17:            	}
18:            	if(divisor < 0)
075D  1FF1     BTFSS canal, 0x7
075E  2F64     GOTO 0x764
0BDE  1FB2     BTFSS 0x32, 0x7
0BDF  2BE5     GOTO 0x3E5
19:            		divisor = -divisor;
075F  09F0     COMF divisor, F
0760  09F1     COMF canal, F
0761  0AF0     INCF divisor, F
0762  1903     BTFSC STATUS, 0x2
0763  0AF1     INCF canal, F
0BE0  09B1     COMF divisor, F
0BE1  09B2     COMF 0x32, F
0BE2  0AB1     INCF divisor, F
0BE3  1903     BTFSC STATUS, 0x2
0BE4  0AB2     INCF 0x32, F
20:            	if(divisor != 0) {
0764  0871     MOVF canal, W
0765  0470     IORWF divisor, W
0766  1903     BTFSC STATUS, 0x2
0767  2F83     GOTO 0x783
0BE5  0832     MOVF 0x32, W
0BE6  0431     IORWF divisor, W
0BE7  1903     BTFSC STATUS, 0x2
0BE8  2C04     GOTO 0x404
21:            		counter = 1;
0768  01F4     CLRF counter
0BE9  01B5     CLRF counter
22:            		while(((unsigned int)divisor & 0x8000U) == 0) {
076A  1BF1     BTFSC canal, 0x7
076B  2F70     GOTO 0x770
076F  2F69     GOTO 0x769
0BEB  1BB2     BTFSC 0x32, 0x7
0BEC  2BF1     GOTO 0x3F1
0BF0  2BEA     GOTO 0x3EA
23:            			divisor <<= 1;
0769  0AF4     INCF counter, F
076C  1003     BCF STATUS, 0x0
076D  0DF0     RLF divisor, F
076E  0DF1     RLF canal, F
0BEA  0AB5     INCF counter, F
0BED  1003     BCF STATUS, 0x0
0BEE  0DB1     RLF divisor, F
0BEF  0DB2     RLF 0x32, F
24:            			counter++;
0769  0AF4     INCF counter, F
0BEA  0AB5     INCF counter, F
25:            		}
26:            		do {
27:            			if((unsigned int)divisor <= (unsigned int)dividend)
0770  0871     MOVF canal, W
0771  0273     SUBWF counter, W
0772  1D03     BTFSS STATUS, 0x2
0773  2F76     GOTO 0x776
0774  0870     MOVF divisor, W
0775  0272     SUBWF dividend, W
0776  1C03     BTFSS STATUS, 0x0
0777  2F7F     GOTO 0x77F
0BF1  0832     MOVF 0x32, W
0BF2  0234     SUBWF sign, W
0BF3  1D03     BTFSS STATUS, 0x2
0BF4  2BF7     GOTO 0x3F7
0BF5  0831     MOVF divisor, W
0BF6  0233     SUBWF dividend, W
0BF7  1C03     BTFSS STATUS, 0x0
0BF8  2C00     GOTO 0x400
28:            				dividend -= divisor;
0778  0870     MOVF divisor, W
0779  02F2     SUBWF dividend, F
077A  0871     MOVF canal, W
077B  1C03     BTFSS STATUS, 0x0
077C  03F3     DECF counter, F
077D  02F3     SUBWF counter, F
0BF9  0831     MOVF divisor, W
0BFA  02B3     SUBWF dividend, F
0BFB  0832     MOVF 0x32, W
0BFC  1C03     BTFSS STATUS, 0x0
0BFD  03B4     DECF sign, F
0BFE  02B4     SUBWF sign, F
29:            			*(unsigned int *)&divisor >>= 1;
077E  1003     BCF STATUS, 0x0
077F  0CF1     RRF canal, F
0780  0CF0     RRF divisor, F
0BFF  1003     BCF STATUS, 0x0
0C00  0CB2     RRF 0x32, F
0C01  0CB1     RRF divisor, F
30:            		} while(--counter != 0);
0781  0BF4     DECFSZ counter, F
0782  2F70     GOTO 0x770
0C02  0BB5     DECFSZ counter, F
0C03  2BF1     GOTO 0x3F1
31:            	}
32:            	if(sign)
0783  0875     MOVF Pin, W
0784  1903     BTFSC STATUS, 0x2
0785  2F8B     GOTO 0x78B
0C04  0836     MOVF sign, W
0C05  1903     BTFSC STATUS, 0x2
0C06  2C0C     GOTO 0x40C
33:            		dividend = -dividend;
0786  09F2     COMF dividend, F
0787  09F3     COMF counter, F
0788  0AF2     INCF dividend, F
0789  1903     BTFSC STATUS, 0x2
078A  0AF3     INCF counter, F
0C07  09B3     COMF dividend, F
0C08  09B4     COMF sign, F
0C09  0AB3     INCF dividend, F
0C0A  1903     BTFSC STATUS, 0x2
0C0B  0AB4     INCF sign, F
34:            	return dividend;
078B  0873     MOVF counter, W
078C  00F1     MOVWF canal
078D  0872     MOVF dividend, W
078E  00F0     MOVWF divisor
0C0C  0834     MOVF sign, W
0C0D  00B2     MOVWF 0x32
0C0E  0833     MOVF dividend, W
0C0F  00B1     MOVWF divisor
35:            }
078F  0008     RETURN
0C10  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/awdiv.c  ---------------------------------------------------
1:             // integer signed division
2:             
3:             signed int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __awdiv(signed int divisor, signed int dividend)
7:             #else
8:             __awdiv(signed int dividend, signed int divisor)
9:             #endif
10:            {
11:            	signed int	quotient;
12:            	unsigned char	counter, sign;
13:            
14:            	sign = 0;
091E  01AE     CLRF sign
15:            	if(divisor < 0) {
091F  1FAA     BTFSS Data, 0x7
0920  2928     GOTO 0x128
16:            		divisor = -divisor;
0921  09A9     COMF year, F
0922  09AA     COMF Data, F
0923  0AA9     INCF year, F
0924  1903     BTFSC STATUS, 0x2
0925  0AAA     INCF Data, F
17:            		sign = 1;
0926  01AE     CLRF sign
0927  0AAE     INCF sign, F
18:            	}
19:            	if(dividend < 0) {
0928  1FAC     BTFSS hr, 0x7
0929  2931     GOTO 0x131
20:            		dividend = -dividend;
092A  09AB     COMF sec, F
092B  09AC     COMF hr, F
092C  0AAB     INCF sec, F
092D  1903     BTFSC STATUS, 0x2
092E  0AAC     INCF hr, F
21:            		sign ^= 1;
092F  3001     MOVLW 0x1
0930  06AE     XORWF sign, F
22:            	}
23:            	quotient = 0;
0931  01AF     CLRF quotient
0932  01B0     CLRF c
24:            	if(divisor != 0) {
0933  082A     MOVF Data, W
0934  0429     IORWF year, W
0935  1903     BTFSC STATUS, 0x2
0936  2956     GOTO 0x156
25:            		counter = 1;
0937  01AD     CLRF day
26:            		while((divisor & 0x8000U) == 0) {
0939  1BAA     BTFSC Data, 0x7
093A  293F     GOTO 0x13F
093E  2938     GOTO 0x138
27:            			divisor <<= 1;
0938  0AAD     INCF day, F
093B  1003     BCF STATUS, 0x0
093C  0DA9     RLF year, F
093D  0DAA     RLF Data, F
28:            			counter++;
0938  0AAD     INCF day, F
29:            		}
30:            		do {
31:            			quotient <<= 1;
093F  1003     BCF STATUS, 0x0
0940  0DAF     RLF quotient, F
0941  0DB0     RLF c, F
32:            			if((unsigned int)divisor <= (unsigned int)dividend) {
0942  082A     MOVF Data, W
0943  022C     SUBWF hr, W
0944  1D03     BTFSS STATUS, 0x2
0945  2948     GOTO 0x148
0946  0829     MOVF year, W
0947  022B     SUBWF sec, W
0948  1C03     BTFSS STATUS, 0x0
0949  2952     GOTO 0x152
33:            				dividend -= divisor;
094A  0829     MOVF year, W
094B  02AB     SUBWF sec, F
094C  082A     MOVF Data, W
094D  1C03     BTFSS STATUS, 0x0
094E  03AC     DECF hr, F
094F  02AC     SUBWF hr, F
34:            				quotient |= 1;
0950  142F     BSF quotient, 0x0
35:            			}
36:            			*(unsigned int *)&divisor >>= 1;
0951  1003     BCF STATUS, 0x0
0952  0CAA     RRF Data, F
0953  0CA9     RRF year, F
37:            		} while(--counter != 0);
0954  0BAD     DECFSZ day, F
0955  293F     GOTO 0x13F
38:            	}
39:            	if(sign)
0956  082E     MOVF sign, W
0957  1903     BTFSC STATUS, 0x2
0958  295E     GOTO 0x15E
40:            		quotient = -quotient;
0959  09AF     COMF quotient, F
095A  09B0     COMF c, F
095B  0AAF     INCF quotient, F
095C  1903     BTFSC STATUS, 0x2
095D  0AB0     INCF c, F
41:            	return quotient;
095E  0830     MOVF c, W
095F  00AA     MOVWF Data
0960  082F     MOVF quotient, W
0961  00A9     MOVWF year
42:            }
0962  0008     RETURN
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/pwm.c  --------------------------------
1:             #include <xc.h>
2:             #include <stdint.h>         /* For uint8_t definition */
3:             #include <stdbool.h>        /* For true/false definition */
4:             #include "system.h"
5:             #include "pwm.h"
6:             #include "user.h"
7:             /*The following steps should be taken when configuring
8:             the CCP module for PWM operation:
9:             1. Set the PWM period by writing to the PR2 register.
10:            2. Set the PWM duty cycle by writing to the
11:            CCPR1L register and CCP1CON<5:4> bits.
12:            3. Make the CCP1 pin an output by clearing the
13:            TRISC<2> bit.
14:            4. Set the TMR2 prescale value and enable Timer2
15:            by writing to T2CON.
16:            5. Configure the CCP1 module for PWM operation.*/
17:            #define FrecuenciaPWM 4880UL
18:            #define PeriodoPWM 1/FrecuenciaPWM
19:            #define PRESCALERTIMER2 4
20:            #define asignaPR2 _XTAL_FREQ/PRESCALERTIMER2/4*PeriodoPWM-1
21:            
22:            void set_periodo_buzzer(void) {
23:                //PWM Period = [(PR2) + 1] * 4 * TOSC *(TMR2 Prescale Value)
24:                //PR2=PWM PERIOD/(4*TOSC*TMR2 Prescale Value)-1
25:                //para una frecuencia de __XTAL_FREQ/4=5Mhz
26:                PR2 = asignaPR2; //periodo;;//periodo; //asigno el periodo
086A  30FF     MOVLW 0xFF
086B  0092     MOVWF T2CON
27:                T2CONbits.TMR2ON = 1; //Habilito el timer2
086C  1283     BCF STATUS, 0x5
086D  1512     BSF T2CON, 0x2
28:                T2CONbits.T2CKPS = 1; //prescaler en 4
086E  0812     MOVF T2CON, W
086F  39FC     ANDLW 0xFC
0870  3801     IORLW 0x1
0871  0092     MOVWF T2CON
29:                // CCP1CONbits.CCP1M=0b1100; //Configuro el CCp1 como PWM
30:                RB2 = 0;
0872  1106     BCF PORTB, 0x2
31:                TRISC2 = 0; //pongo el pin RC2/PWM1 como salida
0873  1683     BSF STATUS, 0x5
0874  1107     BCF PORTC, 0x2
32:            #warning No olvidar que si el PWM_duty > PWM_period no queda bien definida la frecuencia
33:                set_duty(512);
0875  1283     BCF STATUS, 0x5
34:            }
35:            
36:            /*/PWM Duty Cycle =(CCPR1L:CCP1CON<5:4>)*TOSC*(TMR2 Prescale Value)*/
37:            void set_duty(unsigned int duty) {
38:            
39:            #define PWM10Bits
40:                //pwm modo 10bits
41:            #ifdef PWM10Bits
42:                CCPR1L = duty >> 2;
087A  0824     MOVF dato, W
087B  00A6     MOVWF x
087C  0823     MOVF x, W
087D  00A5     MOVWF y
087E  1003     BCF STATUS, 0x0
087F  0CA6     RRF x, F
0880  0CA5     RRF y, F
0881  1003     BCF STATUS, 0x0
0882  0CA6     RRF x, F
0883  0CA5     RRF y, F
0884  0825     MOVF y, W
0885  0095     MOVWF CCPR1
43:            #endif
44:                CCP1CON = (CCP1CON & 0xCF) | ((duty << 4) & 0x30);
0886  0823     MOVF x, W
0887  00A5     MOVWF y
0888  0E25     SWAPF y, W
0889  39F0     ANDLW 0xF0
088A  00A5     MOVWF y
088B  3930     ANDLW 0x30
088C  00A6     MOVWF x
088D  0817     MOVF CCP1CON, W
088E  39CF     ANDLW 0xCF
088F  0426     IORWF x, W
0890  0097     MOVWF CCP1CON
45:            
46:            
47:            
48:            }
0891  0008     RETURN
49:            
50:            void buzzer_off(void) {
0FE7  30F0     MOVLW 0xF0
1263  30F0     MOVLW 0xF0
51:                //activapor=0;
52:                CCP1CONbits.CCP1M = 0; //desactiva pwm
0FE7  30F0     MOVLW 0xF0
0FE8  0597     ANDWF CCP1CON, F
1263  30F0     MOVLW 0xF0
1264  1283     BCF STATUS, 0x5
1265  1303     BCF STATUS, 0x6
1266  0597     ANDWF CCP1CON, F
53:                PORTCbits.RC2 = 0; //pongo el pin de reloj en bajo
0FE9  1107     BCF PORTC, 0x2
1267  1107     BCF PORTC, 0x2
54:            
55:            }
0FEA  0008     RETURN
1268  0008     RETURN
56:            
57:            void buzzer_on(void) {
0FEB  3003     MOVLW 0x3
1269  3003     MOVLW 0x3
58:                activapwmpor = 3;
0FEB  3003     MOVLW 0x3
0FEC  1283     BCF STATUS, 0x5
0FED  1303     BCF STATUS, 0x6
0FEE  00E0     MOVWF activapwmpor
1269  3003     MOVLW 0x3
126A  1283     BCF STATUS, 0x5
126B  1303     BCF STATUS, 0x6
126C  00E0     MOVWF activapwmpor
59:                CCP1CONbits.CCP1M = 0b1100; //activa pwm
0FEF  0817     MOVF CCP1CON, W
0FF0  39F0     ANDLW 0xF0
0FF1  380C     IORLW 0xC
0FF2  0097     MOVWF CCP1CON
126D  0817     MOVF CCP1CON, W
126E  39F0     ANDLW 0xF0
126F  380C     IORLW 0xC
1270  0097     MOVWF CCP1CON
60:            }
0FF3  0008     RETURN
1271  0008     RETURN
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/main.c  -------------------------------
1:             /******************************************************************************/
2:             /* Files to Include                                                           */
3:             /******************************************************************************/
4:             // Real Time Clock & NVRAM
5:             // Hardware isl1208 of Dallas Maxim
6:             // With interface I2C
7:             #ifndef __PICCPRO__
8:             #define __PICCPRO__
9:             #endif
10:            #if defined(__XC)
11:            #include <xc.h>         /* XC8 General Include File */
12:            #elif defined(HI_TECH_C)
13:            #include <htc.h>        /* HiTech General Include File */
14:            #endif
15:            
16:            #include <stdint.h>        /* For uint8_t definition */
17:            #include <stdbool.h>       /* For true/false definition */
18:            #include <stdio.h>
19:            #include "system.h"        /* System funct/params, like osc/peripheral config */
20:            #include "user.h"          /* User funct/params, such as InitApp */
21:            #include "Pulsadores.h"
22:            #include "pwm.h"
23:            #include "adcPic16.h"
24:            /******************************************************************************/
25:            /* User Global Variable Declaration                                           */
26:            /******************************************************************************/
27:            
28:            /* i.e. uint8_t <variable_name>; */
29:            
30:            /******************************************************************************/
31:            /* Main Program                                                               */
32:            /******************************************************************************/
33:            
34:            //#fuses HS,MCLR,NOWDT,NOPROTECT,NOPUT,NOBROWNOUT,NOPBADEN,NOLVP,NOCPD,NODEBUG,NOWRT,NOVREGEN
35:            //#use delay(clock=20000000)
36:            //#use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7)
37:            
38:            
39:            #define USE_INTERRUPTS 1
40:            
41:            #include "_isl1208.h"
42:            #include "HardI2C.h"
43:            #include "usart1.h"
44:            #include "LCDGeneric.h"
45:            ///////////////////////////////////////////////////////////////////////////////
46:            
47:            void lee_y_transmite_date_and_time(void) {
48:                isl1208_get_date(&fecha.day, &fecha.month, &fecha.yr, &fecha.dow);
0892  306A     MOVLW 0x6A
0893  1283     BCF STATUS, 0x5
0894  00A8     MOVWF mth
0895  306B     MOVLW 0x6B
0896  00A9     MOVWF year
0897  306C     MOVLW 0x6C
0898  00AA     MOVWF Data
0899  3069     MOVLW 0x69
089A  2222     CALL 0x222
089B  120A     BCF PCLATH, 0x4
089C  158A     BSF PCLATH, 0x3
49:                isl1208_get_time(&horarioactual.hrs, &horarioactual.min, &horarioactual.sec);
089D  306E     MOVLW 0x6E
50:            }
51:            
52:            void main() {
53:                TMR1IE = 0; //   disable_interrupts(int_timer1);
002D  1683     BSF STATUS, 0x5
002E  100C     BCF PIR1, 0x0
54:                RCIE = 0; //    disable_interrupts(int_rda);
002F  128C     BCF PIR1, 0x5
55:                RBIE = 0;
0030  118B     BCF INTCON, 0x3
56:                INTE = 0; //disable_interrupts(int_ext);
0031  120B     BCF INTCON, 0x4
57:                ADCON1 = 0x06; //todos puertos digitales
0032  3006     MOVLW 0x6
0033  009F     MOVWF ADCON0
58:                //setup_counters(RTCC_INTERNAL,RTCC_DIV_2);
59:                T0CS = 0; // TMR0 Clock Source Select bit: internal
0034  1281     BCF TMR0, 0x5
60:                PSA = 0; //Prescaler is assigned to the Timer0 module
0035  1181     BCF TMR0, 0x3
61:                OPTION_REGbits.PS = 0b101; //: Prescaler Rate Select bits 1/64
0036  0801     MOVF TMR0, W
0037  39F8     ANDLW 0xF8
0038  3805     IORLW 0x5
0039  0081     MOVWF TMR0
62:                //setup_timer_1(T1_INTERNAL | T1_DIV_BY_1);
63:                T1CON = 1;
003A  3001     MOVLW 0x1
003B  1283     BCF STATUS, 0x5
003C  0090     MOVWF T1CON
64:                CCP1CONbits.CCP1M = 0;
003D  30F0     MOVLW 0xF0
003E  0597     ANDWF CCP1CON, F
65:                //configura_USART();
66:                setup_i2c(I2C_MASTER);
003F  3038     MOVLW 0x38
0040  120A     BCF PCLATH, 0x4
0041  158A     BSF PCLATH, 0x3
0042  2044     CALL 0x44
0043  120A     BCF PCLATH, 0x4
0044  118A     BCF PCLATH, 0x3
67:            
68:            
69:                TRISB = 0b00111111; //Configuro las entradas de las teclas y la entrada del reloj
0045  303F     MOVLW 0x3F
0046  1683     BSF STATUS, 0x5
0047  0086     MOVWF PORTB
70:                PORTB = 0;
0048  1283     BCF STATUS, 0x5
0049  0186     CLRF PORTB
71:                TRISC0 = 0; //Configuro el pin de activacion de la bomba como salida
004A  1683     BSF STATUS, 0x5
004B  1007     BCF PORTC, 0x0
72:                TRISD = 0x00;
004C  0188     CLRF PORTD
73:                PORTD = 0;
004D  1283     BCF STATUS, 0x5
004E  0188     CLRF PORTD
74:                TRISE = 0b00000000;
004F  1683     BSF STATUS, 0x5
0050  0189     CLRF PORTE
75:                PORTE = 0;
0051  1283     BCF STATUS, 0x5
0052  0189     CLRF PORTE
76:            
77:                vInitLCD();
0053  160A     BSF PCLATH, 0x4
0054  118A     BCF PCLATH, 0x3
0055  22B6     CALL 0x2B6
0056  120A     BCF PCLATH, 0x4
0057  118A     BCF PCLATH, 0x3
78:                static char * cadena;
79:                sprintf(cadenaamostrar, cadena_esp);
0058  3031     MOVLW 0x31
0059  00C7     MOVWF f
005A  3098     MOVLW 0x98
005B  00C8     MOVWF 0x48
005C  30C0     MOVLW 0xC0
005D  160A     BSF PCLATH, 0x4
005E  118A     BCF PCLATH, 0x3
005F  25D3     CALL 0x5D3
0060  120A     BCF PCLATH, 0x4
0061  118A     BCF PCLATH, 0x3
80:                sprintf(cadenaamostrar2, cadena_esp);
0062  3031     MOVLW 0x31
0063  00C7     MOVWF f
0064  3098     MOVLW 0x98
0065  00C8     MOVWF 0x48
0066  30C8     MOVLW 0xC8
0067  160A     BSF PCLATH, 0x4
0068  118A     BCF PCLATH, 0x3
0069  25D3     CALL 0x5D3
006A  120A     BCF PCLATH, 0x4
006B  118A     BCF PCLATH, 0x3
81:                vGotoxyLCD(1, 1);
006C  3001     MOVLW 0x1
006D  01A5     CLRF y
006E  0AA5     INCF y, F
006F  160A     BSF PCLATH, 0x4
0070  118A     BCF PCLATH, 0x3
0071  2272     CALL 0x272
0072  120A     BCF PCLATH, 0x4
0073  118A     BCF PCLATH, 0x3
82:                cadena = cadenaamostrar;
0074  30C0     MOVLW 0xC0
0075  1683     BSF STATUS, 0x5
0076  00BF     MOVWF 0x3F
83:                while (*cadena != '\0')
0077  083F     MOVF 0x3F, W
0078  0084     MOVWF FSR
0079  1383     BCF STATUS, 0x7
007A  0880     MOVF INDF, F
007B  1903     BTFSC STATUS, 0x2
007C  2889     GOTO 0x89
0088  2877     GOTO 0x77
84:                    vLCD_Putc(*cadena++);
007D  083F     MOVF 0x3F, W
007E  0084     MOVWF FSR
007F  0800     MOVF INDF, W
0080  160A     BSF PCLATH, 0x4
0081  118A     BCF PCLATH, 0x3
0082  2292     CALL 0x292
0083  120A     BCF PCLATH, 0x4
0084  118A     BCF PCLATH, 0x3
0085  1683     BSF STATUS, 0x5
0086  1303     BCF STATUS, 0x6
0087  0ABF     INCF 0x3F, F
85:                vGotoxyLCD(1, 2);
0089  3002     MOVLW 0x2
008A  1283     BCF STATUS, 0x5
008B  00A5     MOVWF y
008C  3001     MOVLW 0x1
008D  160A     BSF PCLATH, 0x4
008E  118A     BCF PCLATH, 0x3
008F  2272     CALL 0x272
0090  120A     BCF PCLATH, 0x4
0091  118A     BCF PCLATH, 0x3
86:                cadena = cadenaamostrar2;
0092  30C8     MOVLW 0xC8
0093  1683     BSF STATUS, 0x5
0094  00BF     MOVWF 0x3F
87:                while (*cadena != '\0')
0095  083F     MOVF 0x3F, W
0096  0084     MOVWF FSR
0097  1383     BCF STATUS, 0x7
0098  0880     MOVF INDF, F
0099  1903     BTFSC STATUS, 0x2
009A  28A7     GOTO 0xA7
00A6  2895     GOTO 0x95
88:                    vLCD_Putc(*cadena++);
009B  083F     MOVF 0x3F, W
009C  0084     MOVWF FSR
009D  0800     MOVF INDF, W
009E  160A     BSF PCLATH, 0x4
009F  118A     BCF PCLATH, 0x3
00A0  2292     CALL 0x292
00A1  120A     BCF PCLATH, 0x4
00A2  118A     BCF PCLATH, 0x3
00A3  1683     BSF STATUS, 0x5
00A4  1303     BCF STATUS, 0x6
00A5  0ABF     INCF 0x3F, F
89:                refrescadisplay = 0;
00A7  300D     MOVLW 0xD
00A8  01BC     CLRF 0x3C
90:                __delay_ms(500);
00A7  300D     MOVLW 0xD
00A9  1283     BCF STATUS, 0x5
00AA  00DE     MOVWF 0x5E
00AB  30AF     MOVLW 0xAF
00AC  00DD     MOVWF 0x5D
00AD  30C1     MOVLW 0xC1
00AE  00DC     MOVWF 0x5C
00AF  0BDC     DECFSZ 0x5C, F
00B0  28AF     GOTO 0xAF
00B1  0BDD     DECFSZ 0x5D, F
00B2  28AF     GOTO 0xAF
00B3  0BDE     DECFSZ 0x5E, F
00B4  28AF     GOTO 0xAF
00B5  0000     NOP
91:                sprintf(cadenaamostrar, "Ini...");
00B6  304E     MOVLW 0x4E
00B7  1283     BCF STATUS, 0x5
00B8  1303     BCF STATUS, 0x6
00B9  00C7     MOVWF f
00BA  3099     MOVLW 0x99
00BB  00C8     MOVWF 0x48
00BC  30C0     MOVLW 0xC0
00BD  160A     BSF PCLATH, 0x4
00BE  118A     BCF PCLATH, 0x3
00BF  25D3     CALL 0x5D3
00C0  120A     BCF PCLATH, 0x4
00C1  118A     BCF PCLATH, 0x3
92:                vGotoxyLCD(1, 1);
00C2  3001     MOVLW 0x1
00C3  01A5     CLRF y
00C4  0AA5     INCF y, F
00C5  160A     BSF PCLATH, 0x4
00C6  118A     BCF PCLATH, 0x3
00C7  2272     CALL 0x272
00C8  120A     BCF PCLATH, 0x4
00C9  118A     BCF PCLATH, 0x3
93:                cadena = cadenaamostrar;
00CA  30C0     MOVLW 0xC0
00CB  1683     BSF STATUS, 0x5
00CC  00BF     MOVWF 0x3F
94:                while (*cadena != '\0')
00CD  083F     MOVF 0x3F, W
00CE  0084     MOVWF FSR
00CF  1383     BCF STATUS, 0x7
00D0  0880     MOVF INDF, F
00D1  1903     BTFSC STATUS, 0x2
00D2  28DF     GOTO 0xDF
00DE  28CD     GOTO 0xCD
95:                    vLCD_Putc(*cadena++);
00D3  083F     MOVF 0x3F, W
00D4  0084     MOVWF FSR
00D5  0800     MOVF INDF, W
00D6  160A     BSF PCLATH, 0x4
00D7  118A     BCF PCLATH, 0x3
00D8  2292     CALL 0x292
00D9  120A     BCF PCLATH, 0x4
00DA  118A     BCF PCLATH, 0x3
00DB  1683     BSF STATUS, 0x5
00DC  1303     BCF STATUS, 0x6
00DD  0ABF     INCF 0x3F, F
96:                vGotoxyLCD(1, 2);
00DF  3002     MOVLW 0x2
00E0  1283     BCF STATUS, 0x5
00E1  00A5     MOVWF y
00E2  3001     MOVLW 0x1
00E3  160A     BSF PCLATH, 0x4
00E4  118A     BCF PCLATH, 0x3
00E5  2272     CALL 0x272
00E6  120A     BCF PCLATH, 0x4
00E7  118A     BCF PCLATH, 0x3
97:                cadena = cadenaamostrar2;
00E8  30C8     MOVLW 0xC8
00E9  1683     BSF STATUS, 0x5
00EA  00BF     MOVWF 0x3F
98:                while (*cadena != '\0')
00EB  083F     MOVF 0x3F, W
00EC  0084     MOVWF FSR
00ED  1383     BCF STATUS, 0x7
00EE  0880     MOVF INDF, F
00EF  1903     BTFSC STATUS, 0x2
00F0  28FD     GOTO 0xFD
00FC  28EB     GOTO 0xEB
99:                    vLCD_Putc(*cadena++);
00F1  083F     MOVF 0x3F, W
00F2  0084     MOVWF FSR
00F3  0800     MOVF INDF, W
00F4  160A     BSF PCLATH, 0x4
00F5  118A     BCF PCLATH, 0x3
00F6  2292     CALL 0x292
00F7  120A     BCF PCLATH, 0x4
00F8  118A     BCF PCLATH, 0x3
00F9  1683     BSF STATUS, 0x5
00FA  1303     BCF STATUS, 0x6
00FB  0ABF     INCF 0x3F, F
100:               refrescadisplay = 0;
00FD  01BC     CLRF 0x3C
101:           
102:           
103:               set_periodo_buzzer(); //configuro el pwm para una frecuencia de 3khz
00FE  120A     BCF PCLATH, 0x4
00FF  158A     BSF PCLATH, 0x3
0100  206A     CALL 0x6A
0101  120A     BCF PCLATH, 0x4
0102  118A     BCF PCLATH, 0x3
104:               buzzer_on();
0103  160A     BSF PCLATH, 0x4
0104  118A     BCF PCLATH, 0x3
0105  2269     CALL 0x269
0106  120A     BCF PCLATH, 0x4
0107  118A     BCF PCLATH, 0x3
105:               __delay_ms(200);
0108  3006     MOVLW 0x6
0109  00DE     MOVWF 0x5E
010A  3013     MOVLW 0x13
010B  00DD     MOVWF 0x5D
010C  30B1     MOVLW 0xB1
010D  00DC     MOVWF 0x5C
010E  0BDC     DECFSZ 0x5C, F
010F  290E     GOTO 0x10E
0110  0BDD     DECFSZ 0x5D, F
0111  290E     GOTO 0x10E
0112  0BDE     DECFSZ 0x5E, F
0113  290E     GOTO 0x10E
0114  2915     GOTO 0x115
106:               buzzer_off();
0115  160A     BSF PCLATH, 0x4
0116  118A     BCF PCLATH, 0x3
0117  2263     CALL 0x263
0118  120A     BCF PCLATH, 0x4
0119  118A     BCF PCLATH, 0x3
107:               __delay_ms(200);
011A  3006     MOVLW 0x6
011B  00DE     MOVWF 0x5E
011C  3013     MOVLW 0x13
011D  00DD     MOVWF 0x5D
011E  30B1     MOVLW 0xB1
011F  00DC     MOVWF 0x5C
0120  0BDC     DECFSZ 0x5C, F
0121  2920     GOTO 0x120
0122  0BDD     DECFSZ 0x5D, F
0123  2920     GOTO 0x120
0124  0BDE     DECFSZ 0x5E, F
0125  2920     GOTO 0x120
0126  2927     GOTO 0x127
108:               buzzer_on();
0127  160A     BSF PCLATH, 0x4
0128  118A     BCF PCLATH, 0x3
0129  2269     CALL 0x269
012A  120A     BCF PCLATH, 0x4
012B  118A     BCF PCLATH, 0x3
109:               __delay_ms(200);
012C  3006     MOVLW 0x6
012D  00DE     MOVWF 0x5E
012E  3013     MOVLW 0x13
012F  00DD     MOVWF 0x5D
0130  30B1     MOVLW 0xB1
0131  00DC     MOVWF 0x5C
0132  0BDC     DECFSZ 0x5C, F
0133  2932     GOTO 0x132
0134  0BDD     DECFSZ 0x5D, F
0135  2932     GOTO 0x132
0136  0BDE     DECFSZ 0x5E, F
0137  2932     GOTO 0x132
0138  2939     GOTO 0x139
110:               buzzer_off();
0139  160A     BSF PCLATH, 0x4
013A  118A     BCF PCLATH, 0x3
013B  2263     CALL 0x263
013C  120A     BCF PCLATH, 0x4
013D  118A     BCF PCLATH, 0x3
111:               //ext_int_edge(2,H_TO_L);
112:               INTEDG = 0;
013E  1683     BSF STATUS, 0x5
013F  1301     BCF TMR0, 0x6
113:               INTE = 1; // enable_interrupts(int_ext2);
0140  160B     BSF INTCON, 0x4
114:               TMR0IE = 1;
0141  168B     BSF INTCON, 0x5
115:               setADCChannel(MIDECORRIENTE);
0142  3000     MOVLW 0x0
0143  120A     BCF PCLATH, 0x4
0144  118A     BCF PCLATH, 0x3
0145  27F2     CALL 0x7F2
0146  120A     BCF PCLATH, 0x4
0147  118A     BCF PCLATH, 0x3
116:               __delay_us(20);
0148  3021     MOVLW 0x21
0149  00DC     MOVWF 0x5C
014A  0BDC     DECFSZ 0x5C, F
014B  294A     GOTO 0x14A
117:               openADC();
014C  120A     BCF PCLATH, 0x4
014D  158A     BSF PCLATH, 0x3
014E  2055     CALL 0x55
014F  120A     BCF PCLATH, 0x4
0150  118A     BCF PCLATH, 0x3
118:               __delay_us(20);
0151  3021     MOVLW 0x21
0152  00DC     MOVWF 0x5C
0153  0BDC     DECFSZ 0x5C, F
0154  2953     GOTO 0x153
119:               interruptADC_on();
0155  160A     BSF PCLATH, 0x4
0156  118A     BCF PCLATH, 0x3
0157  225F     CALL 0x25F
0158  120A     BCF PCLATH, 0x4
0159  118A     BCF PCLATH, 0x3
120:               __delay_ms(500);
015A  300D     MOVLW 0xD
015B  1283     BCF STATUS, 0x5
015C  00DE     MOVWF 0x5E
015D  30AF     MOVLW 0xAF
015E  00DD     MOVWF 0x5D
015F  30C1     MOVLW 0xC1
0160  00DC     MOVWF 0x5C
0161  0BDC     DECFSZ 0x5C, F
0162  2961     GOTO 0x161
0163  0BDD     DECFSZ 0x5D, F
0164  2961     GOTO 0x161
0165  0BDE     DECFSZ 0x5E, F
0166  2961     GOTO 0x161
0167  0000     NOP
121:           
122:           
123:               ADIF = 0;
0168  1283     BCF STATUS, 0x5
0169  1303     BCF STATUS, 0x6
016A  130C     BCF PIR1, 0x6
124:               INTF = 0; // borro las banderas de interrupcion
016B  108B     BCF INTCON, 0x1
125:               TMR0IF = 0;
016C  110B     BCF INTCON, 0x2
126:           
127:               if (ISL1208_ready()) {
016D  120A     BCF PCLATH, 0x4
016E  158A     BSF PCLATH, 0x3
016F  2163     CALL 0x163
0170  120A     BCF PCLATH, 0x4
0171  118A     BCF PCLATH, 0x3
0172  3A00     XORLW 0x0
0173  1903     BTFSC STATUS, 0x2
0174  29C9     GOTO 0x1C9
128:                   sprintf(cadenaamostrar, "RTC OK");
0175  3055     MOVLW 0x55
0176  00C7     MOVWF f
0177  3099     MOVLW 0x99
0178  00C8     MOVWF 0x48
0179  30C0     MOVLW 0xC0
017A  160A     BSF PCLATH, 0x4
017B  118A     BCF PCLATH, 0x3
017C  25D3     CALL 0x5D3
017D  120A     BCF PCLATH, 0x4
017E  118A     BCF PCLATH, 0x3
129:                   vGotoxyLCD(1, 1);
017F  3001     MOVLW 0x1
0180  01A5     CLRF y
0181  0AA5     INCF y, F
0182  160A     BSF PCLATH, 0x4
0183  118A     BCF PCLATH, 0x3
0184  2272     CALL 0x272
0185  120A     BCF PCLATH, 0x4
0186  118A     BCF PCLATH, 0x3
130:                   cadena = cadenaamostrar;
0187  30C0     MOVLW 0xC0
0188  1683     BSF STATUS, 0x5
0189  00BF     MOVWF 0x3F
131:                   while (*cadena != '\0')
018A  083F     MOVF 0x3F, W
018B  0084     MOVWF FSR
018C  1383     BCF STATUS, 0x7
018D  0880     MOVF INDF, F
018E  1903     BTFSC STATUS, 0x2
018F  299C     GOTO 0x19C
019B  298A     GOTO 0x18A
132:                       vLCD_Putc(*cadena++);
0190  083F     MOVF 0x3F, W
0191  0084     MOVWF FSR
0192  0800     MOVF INDF, W
0193  160A     BSF PCLATH, 0x4
0194  118A     BCF PCLATH, 0x3
0195  2292     CALL 0x292
0196  120A     BCF PCLATH, 0x4
0197  118A     BCF PCLATH, 0x3
0198  1683     BSF STATUS, 0x5
0199  1303     BCF STATUS, 0x6
019A  0ABF     INCF 0x3F, F
133:           
134:                   __delay_ms(500);
019C  300D     MOVLW 0xD
019D  1283     BCF STATUS, 0x5
019E  00DE     MOVWF 0x5E
019F  30AF     MOVLW 0xAF
01A0  00DD     MOVWF 0x5D
01A1  30C1     MOVLW 0xC1
01A2  00DC     MOVWF 0x5C
01A3  0BDC     DECFSZ 0x5C, F
01A4  29A3     GOTO 0x1A3
01A5  0BDD     DECFSZ 0x5D, F
01A6  29A3     GOTO 0x1A3
01A7  0BDE     DECFSZ 0x5E, F
01A8  29A3     GOTO 0x1A3
01A9  0000     NOP
135:                   __delay_ms(500);
01AA  300D     MOVLW 0xD
01AB  1283     BCF STATUS, 0x5
01AC  1303     BCF STATUS, 0x6
01AD  00DE     MOVWF 0x5E
01AE  30AF     MOVLW 0xAF
01AF  00DD     MOVWF 0x5D
01B0  30C1     MOVLW 0xC1
01B1  00DC     MOVWF 0x5C
01B2  0BDC     DECFSZ 0x5C, F
01B3  29B2     GOTO 0x1B2
01B4  0BDD     DECFSZ 0x5D, F
01B5  29B2     GOTO 0x1B2
01B6  0BDE     DECFSZ 0x5E, F
01B7  29B2     GOTO 0x1B2
01B8  0000     NOP
136:                   __delay_ms(500);
01B9  300D     MOVLW 0xD
01BA  1283     BCF STATUS, 0x5
01BB  1303     BCF STATUS, 0x6
01BC  00DE     MOVWF 0x5E
01BD  30AF     MOVLW 0xAF
01BE  00DD     MOVWF 0x5D
01BF  30C1     MOVLW 0xC1
01C0  00DC     MOVWF 0x5C
01C1  0BDC     DECFSZ 0x5C, F
01C2  29C1     GOTO 0x1C1
01C3  0BDD     DECFSZ 0x5D, F
01C4  29C1     GOTO 0x1C1
01C5  0BDE     DECFSZ 0x5E, F
01C6  29C1     GOTO 0x1C1
01C7  0000     NOP
137:               } else {
01C8  29F0     GOTO 0x1F0
138:                   sprintf(cadenaamostrar, "RTC ERRO");
01C9  302A     MOVLW 0x2A
01CA  00C7     MOVWF f
01CB  3099     MOVLW 0x99
01CC  00C8     MOVWF 0x48
01CD  30C0     MOVLW 0xC0
01CE  160A     BSF PCLATH, 0x4
01CF  118A     BCF PCLATH, 0x3
01D0  25D3     CALL 0x5D3
01D1  120A     BCF PCLATH, 0x4
01D2  118A     BCF PCLATH, 0x3
139:                   vGotoxyLCD(1, 1);
01D3  3001     MOVLW 0x1
01D4  01A5     CLRF y
01D5  0AA5     INCF y, F
01D6  160A     BSF PCLATH, 0x4
01D7  118A     BCF PCLATH, 0x3
01D8  2272     CALL 0x272
01D9  120A     BCF PCLATH, 0x4
01DA  118A     BCF PCLATH, 0x3
140:                   cadena = cadenaamostrar;
01DB  30C0     MOVLW 0xC0
01DC  1683     BSF STATUS, 0x5
01DD  00BF     MOVWF 0x3F
141:                   while (*cadena != '\0')
01DE  083F     MOVF 0x3F, W
01DF  0084     MOVWF FSR
01E0  1383     BCF STATUS, 0x7
01E1  0880     MOVF INDF, F
01E2  1903     BTFSC STATUS, 0x2
01E3  299C     GOTO 0x19C
01EF  29DE     GOTO 0x1DE
142:                       vLCD_Putc(*cadena++);
01E4  083F     MOVF 0x3F, W
01E5  0084     MOVWF FSR
01E6  0800     MOVF INDF, W
01E7  160A     BSF PCLATH, 0x4
01E8  118A     BCF PCLATH, 0x3
01E9  2292     CALL 0x292
01EA  120A     BCF PCLATH, 0x4
01EB  118A     BCF PCLATH, 0x3
01EC  1683     BSF STATUS, 0x5
01ED  1303     BCF STATUS, 0x6
01EE  0ABF     INCF 0x3F, F
143:           
144:                   __delay_ms(500);
145:                   __delay_ms(500);
146:                   __delay_ms(500);
147:           
148:               };
149:               fecha.day = 1;
01F0  1283     BCF STATUS, 0x5
01F1  1303     BCF STATUS, 0x6
01F3  01E9     CLRF fecha
01F4  0AE9     INCF fecha, F
150:               fecha.month = 1;
01F5  01EA     CLRF 0x6A
01F6  0AEA     INCF 0x6A, F
151:               fecha.yr = 15;
01F2  300F     MOVLW 0xF
01F7  00EB     MOVWF 0x6B
152:               fecha.dow = 4;
01F8  3004     MOVLW 0x4
01F9  00EC     MOVWF 0x6C
153:               isl1208SR.Valor = 0x00;
01FA  1683     BSF STATUS, 0x5
01FB  01BA     CLRF f1
154:               isl1208SR.Valor = ISL1208_Read_status();
01FC  120A     BCF PCLATH, 0x4
01FD  158A     BSF PCLATH, 0x3
01FE  2173     CALL 0x173
01FF  120A     BCF PCLATH, 0x4
0200  118A     BCF PCLATH, 0x3
0201  1683     BSF STATUS, 0x5
0202  00BA     MOVWF f1
155:               if (isl1208SR.RTCF) {//Si se reseteo el RTC, envio directamente a configurar la hora
0203  1C3A     BTFSS f1, 0x0
0204  2A08     GOTO 0x208
156:                   menuactual = MENU_CONFIGURAHORARIO;
0205  3003     MOVLW 0x3
0206  00BB     MOVWF 0x3B
157:           
158:               } else {
0207  2A1E     GOTO 0x21E
159:                   lee_y_transmite_date_and_time();
0208  120A     BCF PCLATH, 0x4
0209  158A     BSF PCLATH, 0x3
020A  2092     CALL 0x92
020B  120A     BCF PCLATH, 0x4
020C  118A     BCF PCLATH, 0x3
160:           
161:                   /*TODO leer el valor de la alarma de encendido en algun lado cuando se cambia el
162:                    valor de horarioenc pero no se guarda
163:                    */
164:                   isl1208_get_time_enc(&horarioenc.hrs, &horarioenc.min, &horarioenc.sec);
020D  30D5     MOVLW 0xD5
020E  1283     BCF STATUS, 0x5
020F  00A8     MOVWF mth
0210  30D4     MOVLW 0xD4
0211  00A9     MOVWF year
0212  30D6     MOVLW 0xD6
0213  120A     BCF PCLATH, 0x4
0214  158A     BSF PCLATH, 0x3
0215  21E9     CALL 0x1E9
0216  120A     BCF PCLATH, 0x4
0217  118A     BCF PCLATH, 0x3
165:                   isl1208_get_dow_enc(&fechaenc.dow);
0218  30D3     MOVLW 0xD3
0219  120A     BCF PCLATH, 0x4
021A  158A     BSF PCLATH, 0x3
021B  218E     CALL 0x18E
021C  120A     BCF PCLATH, 0x4
021D  118A     BCF PCLATH, 0x3
166:           
167:                   if (isl1208SR.ALM) {
168:                       //TODO se activo la alarma cuando estaba apagado, procesar
169:           
170:                   }
171:               }
172:               ei(); //enable_interrupts(global);
021E  178B     BSF INTCON, 0x7
021F  2D1A     GOTO 0x51A
173:               // Inicializa isl1208
174:               //TODO   isl1208_init(isl1208_OUT_ENABLED | isl1208_OUT_1_HZ);
175:           
176:               while (1) {//
177:                   // di(); //
178:                   //Inicia Procesa los men
179:                   ////////////////////////////////////////
180:                   switch (menuactual) {
051A  1683     BSF STATUS, 0x5
051B  1303     BCF STATUS, 0x6
051C  083B     MOVF 0x3B, W
051D  0084     MOVWF FSR
051E  3012     MOVLW 0x12
051F  0204     SUBWF FSR, W
0520  1803     BTFSC STATUS, 0x0
0521  2D41     GOTO 0x541
0522  3007     MOVLW 0x7
0523  008A     MOVWF PCLATH
0524  1003     BCF STATUS, 0x0
0525  0D04     RLF FSR, W
0526  0704     ADDWF FSR, W
0527  3E90     ADDLW 0x90
0528  0082     MOVWF PCL
0790  120A     BCF PCLATH, 0x4
0791  118A     BCF PCLATH, 0x3
0792  2A20     GOTO 0x220
0793  120A     BCF PCLATH, 0x4
0794  118A     BCF PCLATH, 0x3
0795  2A62     GOTO 0x262
0796  120A     BCF PCLATH, 0x4
0797  118A     BCF PCLATH, 0x3
0798  2BE9     GOTO 0x3E9
0799  120A     BCF PCLATH, 0x4
079A  118A     BCF PCLATH, 0x3
079B  2A9A     GOTO 0x29A
079C  120A     BCF PCLATH, 0x4
079D  118A     BCF PCLATH, 0x3
079E  2AA2     GOTO 0x2A2
079F  120A     BCF PCLATH, 0x4
07A0  118A     BCF PCLATH, 0x3
07A1  2ACF     GOTO 0x2CF
07A2  120A     BCF PCLATH, 0x4
07A3  118A     BCF PCLATH, 0x3
07A4  2AE0     GOTO 0x2E0
07A5  120A     BCF PCLATH, 0x4
07A6  118A     BCF PCLATH, 0x3
07A7  2AE8     GOTO 0x2E8
07A8  120A     BCF PCLATH, 0x4
07A9  118A     BCF PCLATH, 0x3
07AA  2AF6     GOTO 0x2F6
07AB  120A     BCF PCLATH, 0x4
07AC  118A     BCF PCLATH, 0x3
07AD  2B07     GOTO 0x307
07AE  120A     BCF PCLATH, 0x4
07AF  118A     BCF PCLATH, 0x3
07B0  2B4B     GOTO 0x34B
07B1  120A     BCF PCLATH, 0x4
07B2  118A     BCF PCLATH, 0x3
07B3  2B53     GOTO 0x353
07B4  120A     BCF PCLATH, 0x4
07B5  118A     BCF PCLATH, 0x3
07B6  2B63     GOTO 0x363
07B7  120A     BCF PCLATH, 0x4
07B8  118A     BCF PCLATH, 0x3
07B9  2B86     GOTO 0x386
07BA  120A     BCF PCLATH, 0x4
07BB  118A     BCF PCLATH, 0x3
07BC  2B9A     GOTO 0x39A
07BD  120A     BCF PCLATH, 0x4
07BE  118A     BCF PCLATH, 0x3
07BF  2BAE     GOTO 0x3AE
07C0  120A     BCF PCLATH, 0x4
07C1  118A     BCF PCLATH, 0x3
07C2  2BAF     GOTO 0x3AF
07C3  120A     BCF PCLATH, 0x4
07C4  118A     BCF PCLATH, 0x3
07C5  2BC7     GOTO 0x3C7
181:                       case MENU_MUESTRAHORA:
182:                       {
183:                           horario = &horarioactual;
0220  306D     MOVLW 0x6D
0221  00FD     MOVWF horario
184:                           //Se actualiza lo que se muestra en el display, solamente cuando hay cambios en lo que mostrar
185:           
186:                           if (flanco) {
0222  087C     MOVF flanco, W
0223  1903     BTFSC STATUS, 0x2
0224  2A46     GOTO 0x246
187:                               lee_y_transmite_date_and_time();
0225  120A     BCF PCLATH, 0x4
0226  158A     BSF PCLATH, 0x3
0227  2092     CALL 0x92
0228  120A     BCF PCLATH, 0x4
0229  118A     BCF PCLATH, 0x3
188:                               sprintf(cadenaamostrar, "%02d:%02d    ", horarioactual.hrs, horarioactual.min);
022A  3058     MOVLW 0x58
022B  1283     BCF STATUS, 0x5
022C  00C7     MOVWF f
022D  3098     MOVLW 0x98
022E  00C8     MOVWF 0x48
022F  086F     MOVF 0x6F, W
0230  00C9     MOVWF 0x49
0231  01CA     CLRF cntr
0232  086E     MOVF 0x6E, W
0233  00CB     MOVWF sign
0234  30C0     MOVLW 0xC0
0235  01CC     CLRF f2
0236  160A     BSF PCLATH, 0x4
0237  118A     BCF PCLATH, 0x3
0238  25D3     CALL 0x5D3
0239  120A     BCF PCLATH, 0x4
023A  118A     BCF PCLATH, 0x3
189:                               sprintf(cadenaamostrar2, cadena_esp);
023B  3031     MOVLW 0x31
023C  00C7     MOVWF f
023D  3098     MOVLW 0x98
023E  00C8     MOVWF 0x48
023F  30C8     MOVLW 0xC8
0240  160A     BSF PCLATH, 0x4
0241  118A     BCF PCLATH, 0x3
0242  25D3     CALL 0x5D3
0243  120A     BCF PCLATH, 0x4
0244  118A     BCF PCLATH, 0x3
190:                           } else {
0245  2D41     GOTO 0x541
191:                               sprintf(cadenaamostrar, "%02d %02d    ", horarioactual.hrs, horarioactual.min);
0246  304A     MOVLW 0x4A
0247  1283     BCF STATUS, 0x5
0248  00C7     MOVWF f
0249  3098     MOVLW 0x98
024A  00C8     MOVWF 0x48
024B  086F     MOVF 0x6F, W
024C  00C9     MOVWF 0x49
024D  01CA     CLRF cntr
024E  086E     MOVF 0x6E, W
024F  00CB     MOVWF sign
0250  30C0     MOVLW 0xC0
0251  01CC     CLRF f2
0252  160A     BSF PCLATH, 0x4
0253  118A     BCF PCLATH, 0x3
0254  25D3     CALL 0x5D3
0255  120A     BCF PCLATH, 0x4
0256  118A     BCF PCLATH, 0x3
192:                               sprintf(cadenaamostrar2, cadena_esp);
0257  3031     MOVLW 0x31
0258  00C7     MOVWF f
0259  3098     MOVLW 0x98
025A  00C8     MOVWF 0x48
025B  30C8     MOVLW 0xC8
025C  160A     BSF PCLATH, 0x4
025D  118A     BCF PCLATH, 0x3
025E  25D3     CALL 0x5D3
025F  120A     BCF PCLATH, 0x4
0260  118A     BCF PCLATH, 0x3
0261  2D41     GOTO 0x541
193:                           }
194:                           break;
195:                       }
196:                       case MENU_MUESTRAFECHA:
197:                       {
198:           
199:                           if (flanco) {
0262  087C     MOVF flanco, W
0263  1903     BTFSC STATUS, 0x2
0264  2D41     GOTO 0x541
200:                               lee_y_transmite_date_and_time();
0265  120A     BCF PCLATH, 0x4
0266  158A     BSF PCLATH, 0x3
0267  2092     CALL 0x92
0268  120A     BCF PCLATH, 0x4
0269  118A     BCF PCLATH, 0x3
201:                               sprintf(cadenaamostrar, "%02d/%02d/%02d ", fecha.day, fecha.month, fecha.yr);
026A  303A     MOVLW 0x3A
026B  1283     BCF STATUS, 0x5
026C  00C7     MOVWF f
026D  3098     MOVLW 0x98
026E  00C8     MOVWF 0x48
026F  0869     MOVF fecha, W
0270  00C9     MOVWF 0x49
0271  01CA     CLRF cntr
0272  086A     MOVF 0x6A, W
0273  00CB     MOVWF sign
0274  01CC     CLRF f2
0275  086B     MOVF 0x6B, W
0276  00CD     MOVWF 0x4D
0277  30C0     MOVLW 0xC0
0278  01CE     CLRF 0x4E
0279  160A     BSF PCLATH, 0x4
027A  118A     BCF PCLATH, 0x3
027B  25D3     CALL 0x5D3
027C  120A     BCF PCLATH, 0x4
027D  118A     BCF PCLATH, 0x3
202:                               sprintf(cadenaamostrar2, days_of_week[dia_de_la_semana(&fecha.day, &fecha.month, &fecha.yr)]);
027E  306B     MOVLW 0x6B
027F  00B8     MOVWF anio
0280  306A     MOVLW 0x6A
0281  00B7     MOVWF mes
0282  3069     MOVLW 0x69
0283  120A     BCF PCLATH, 0x4
0284  158A     BSF PCLATH, 0x3
0285  20A4     CALL 0xA4
0286  120A     BCF PCLATH, 0x4
0287  118A     BCF PCLATH, 0x3
0288  1683     BSF STATUS, 0x5
0289  00E8     MOVWF maximodia
028A  3003     MOVLW 0x3
028B  1283     BCF STATUS, 0x5
028C  00A3     MOVWF x
028D  1683     BSF STATUS, 0x5
028E  0868     MOVF maximodia, W
028F  120A     BCF PCLATH, 0x4
0290  158A     BSF PCLATH, 0x3
0291  23C5     CALL 0x3C5
0292  120A     BCF PCLATH, 0x4
0293  118A     BCF PCLATH, 0x3
0294  3E1C     ADDLW 0x1C
0295  00C7     MOVWF f
0296  3098     MOVLW 0x98
0297  1803     BTFSC STATUS, 0x0
0298  3E01     ADDLW 0x1
0299  2BE7     GOTO 0x3E7
203:                           }
204:           
205:           
206:                           break;
207:                       }
208:                       case MENU_CONFIGURAHORARIO:
209:                       {
210:           
211:                           if (flanco) {
029A  087C     MOVF flanco, W
029B  1903     BTFSC STATUS, 0x2
029C  2D41     GOTO 0x541
212:                               sprintf(cadenaamostrar, "SET HORA ");
029D  30E7     MOVLW 0xE7
029E  1283     BCF STATUS, 0x5
029F  00C7     MOVWF f
02A0  3098     MOVLW 0x98
02A1  2BDD     GOTO 0x3DD
213:                               sprintf(cadenaamostrar2, cadena_esp);
214:                           }
215:           
216:                           break;
217:                       }
218:                       case SUBMENU_CONFIGURAHORA:
219:                       {
220:                           modificafecha = HORA;
02A2  306D     MOVLW 0x6D
02A3  01E9     CLRF fecha
221:                           horario = &horarioactual;
02A2  306D     MOVLW 0x6D
02A4  00FD     MOVWF horario
222:                           if (flanco || haycambio) {
02A5  08FC     MOVF flanco, F
02A6  1903     BTFSC STATUS, 0x2
02A7  0839     MOVF 0x39, W
02A8  1903     BTFSC STATUS, 0x2
02A9  2AC8     GOTO 0x2C8
223:                               sprintf(cadenaamostrar, "%02d:%02d    ", horarioactual.hrs, horarioactual.min);
02AA  3058     MOVLW 0x58
02AB  1283     BCF STATUS, 0x5
02AC  00C7     MOVWF f
02AD  3098     MOVLW 0x98
02AE  00C8     MOVWF 0x48
02AF  086F     MOVF 0x6F, W
02B0  00C9     MOVWF 0x49
02B1  01CA     CLRF cntr
02B2  086E     MOVF 0x6E, W
02B3  00CB     MOVWF sign
02B4  30C0     MOVLW 0xC0
02B5  01CC     CLRF f2
02B6  160A     BSF PCLATH, 0x4
02B7  118A     BCF PCLATH, 0x3
02B8  25D3     CALL 0x5D3
02B9  120A     BCF PCLATH, 0x4
02BA  118A     BCF PCLATH, 0x3
224:                               sprintf(cadenaamostrar2, cadena_esp);
02BB  3031     MOVLW 0x31
02BC  00C7     MOVWF f
02BD  3098     MOVLW 0x98
02BE  00C8     MOVWF 0x48
02BF  30C8     MOVLW 0xC8
02C0  160A     BSF PCLATH, 0x4
02C1  118A     BCF PCLATH, 0x3
02C2  25D3     CALL 0x5D3
02C3  120A     BCF PCLATH, 0x4
02C4  118A     BCF PCLATH, 0x3
225:                               haycambio = 0;
02C5  1683     BSF STATUS, 0x5
02C6  01B9     CLRF 0x39
226:                           } else {
02C7  2D41     GOTO 0x541
227:                               sprintf(cadenaamostrar, "  :%02d    ", horarioactual.min);
02C8  309C     MOVLW 0x9C
02C9  1283     BCF STATUS, 0x5
02CA  00C7     MOVWF f
02CB  3098     MOVLW 0x98
02CC  00C8     MOVWF 0x48
02CD  086E     MOVF 0x6E, W
02CE  2B82     GOTO 0x382
228:                               sprintf(cadenaamostrar2, cadena_esp);
229:                           }
230:                           break;
231:                       }
232:                       case SUBMENU_CONFIGURAMINUTOS:
02CF  306D     MOVLW 0x6D
233:                       {
234:                           modificafecha = MINUTOS;
02D0  01E9     CLRF fecha
02D1  0AE9     INCF fecha, F
235:                           horario = &horarioactual;
02CF  306D     MOVLW 0x6D
02D2  00FD     MOVWF horario
236:                           if (flanco || haycambio) {
02D3  08FC     MOVF flanco, F
02D4  1D03     BTFSS STATUS, 0x2
02D5  2AAA     GOTO 0x2AA
02D6  0839     MOVF 0x39, W
02D7  1D03     BTFSS STATUS, 0x2
237:                               sprintf(cadenaamostrar, "%02d:%02d    ", horarioactual.hrs, horarioactual.min);
02D8  2AAA     GOTO 0x2AA
238:                               sprintf(cadenaamostrar2, cadena_esp);
239:                               haycambio = 0;
240:                           } else {
241:                               sprintf(cadenaamostrar, "%02d:      ", horarioactual.hrs);
02D9  3090     MOVLW 0x90
02DA  1283     BCF STATUS, 0x5
02DB  00C7     MOVWF f
02DC  3098     MOVLW 0x98
02DD  00C8     MOVWF 0x48
02DE  086F     MOVF 0x6F, W
02DF  2B82     GOTO 0x382
242:                               sprintf(cadenaamostrar2, cadena_esp);
243:                           }
244:                           break;
245:                       }
246:                       case MENU_CONFIGURAFECHA:
247:                       {
248:           
249:                           if (flanco) {
02E0  087C     MOVF flanco, W
02E1  1903     BTFSC STATUS, 0x2
02E2  2D41     GOTO 0x541
250:                               sprintf(cadenaamostrar, "SET FECHA");
02E3  30FB     MOVLW 0xFB
02E4  1283     BCF STATUS, 0x5
02E5  00C7     MOVWF f
02E6  3098     MOVLW 0x98
02E7  2BDD     GOTO 0x3DD
251:                               sprintf(cadenaamostrar2, cadena_esp);
252:                           }
253:                           break;
254:                       }
255:                       case SUBMENU_CONFIGURADIA:
256:                       {
257:                           modificafecha = DIA;
02E8  3002     MOVLW 0x2
02E9  00E9     MOVWF fecha
258:           
259:                           if (flanco || haycambio) {
02EA  08FC     MOVF flanco, F
02EB  1903     BTFSC STATUS, 0x2
02EC  0839     MOVF 0x39, W
02ED  1D03     BTFSS STATUS, 0x2
02EE  2B0E     GOTO 0x30E
260:                               sprintf(cadenaamostrar, "%02d/%02d/%02d ", fecha.day, fecha.month, fecha.yr);
261:                               sprintf(cadenaamostrar2, days_of_week[dia_de_la_semana(&fecha.day, &fecha.month, &fecha.yr)]);
262:                               //sprintf(cadenaamostrar2, "             ");
263:                               haycambio = 0;
264:                           } else {
265:                               sprintf(cadenaamostrar, "  /%02d/%02d ", fecha.month, fecha.yr);
02EF  3082     MOVLW 0x82
02F0  1283     BCF STATUS, 0x5
02F1  00C7     MOVWF f
02F2  3098     MOVLW 0x98
02F3  00C8     MOVWF 0x48
02F4  086A     MOVF 0x6A, W
02F5  2B03     GOTO 0x303
266:                               sprintf(cadenaamostrar2, cadena_esp);
267:                           }
268:                           break;
269:                       }
270:                       case SUBMENU_CONFIGURAMES:
271:                       {
272:                           modificafecha = MES;
02F6  3003     MOVLW 0x3
02F7  00E9     MOVWF fecha
273:           
274:                           if (flanco || haycambio) {
02F8  08FC     MOVF flanco, F
02F9  1903     BTFSC STATUS, 0x2
02FA  0839     MOVF 0x39, W
02FB  1D03     BTFSS STATUS, 0x2
02FC  2B0E     GOTO 0x30E
275:                               sprintf(cadenaamostrar, "%02d/%02d/%02d ", fecha.day, fecha.month, fecha.yr);
276:                               sprintf(cadenaamostrar2, days_of_week[dia_de_la_semana(&fecha.day, &fecha.month, &fecha.yr)]);
277:                               haycambio = 0;
278:                           } else {
279:                               sprintf(cadenaamostrar, "%02d/  /%02d ", fecha.day, fecha.yr);
02FD  3074     MOVLW 0x74
02FE  1283     BCF STATUS, 0x5
02FF  00C7     MOVWF f
0300  3098     MOVLW 0x98
0301  00C8     MOVWF 0x48
0302  0869     MOVF fecha, W
0303  00C9     MOVWF 0x49
0304  01CA     CLRF cntr
0305  086B     MOVF 0x6B, W
0306  2B47     GOTO 0x347
280:                               sprintf(cadenaamostrar2, cadena_esp);
281:                           }
282:                           break;
283:                       }
284:                       case SUBMENU_CONFIGURAANIO:
285:                       {
286:                           modificafecha = ANIO;
0307  3004     MOVLW 0x4
0308  00E9     MOVWF fecha
287:           
288:                           if (flanco || haycambio) {
0309  08FC     MOVF flanco, F
030A  1903     BTFSC STATUS, 0x2
030B  0839     MOVF 0x39, W
030C  1903     BTFSC STATUS, 0x2
030D  2B3E     GOTO 0x33E
289:                               sprintf(cadenaamostrar, "%02d/%02d/%02d ", fecha.day, fecha.month, fecha.yr);
030E  303A     MOVLW 0x3A
030F  1283     BCF STATUS, 0x5
0310  00C7     MOVWF f
0311  3098     MOVLW 0x98
0312  00C8     MOVWF 0x48
0313  0869     MOVF fecha, W
0314  00C9     MOVWF 0x49
0315  01CA     CLRF cntr
0316  086A     MOVF 0x6A, W
0317  00CB     MOVWF sign
0318  01CC     CLRF f2
0319  086B     MOVF 0x6B, W
031A  00CD     MOVWF 0x4D
031B  30C0     MOVLW 0xC0
031C  01CE     CLRF 0x4E
031D  160A     BSF PCLATH, 0x4
031E  118A     BCF PCLATH, 0x3
031F  25D3     CALL 0x5D3
0320  120A     BCF PCLATH, 0x4
0321  118A     BCF PCLATH, 0x3
290:                               sprintf(cadenaamostrar2, days_of_week[dia_de_la_semana(&fecha.day, &fecha.month, &fecha.yr)]);
0322  306B     MOVLW 0x6B
0323  00B8     MOVWF anio
0324  306A     MOVLW 0x6A
0325  00B7     MOVWF mes
0326  3069     MOVLW 0x69
0327  120A     BCF PCLATH, 0x4
0328  158A     BSF PCLATH, 0x3
0329  20A4     CALL 0xA4
032A  120A     BCF PCLATH, 0x4
032B  118A     BCF PCLATH, 0x3
032C  1683     BSF STATUS, 0x5
032D  00E8     MOVWF maximodia
032E  3003     MOVLW 0x3
032F  1283     BCF STATUS, 0x5
0330  00A3     MOVWF x
0331  1683     BSF STATUS, 0x5
0332  0868     MOVF maximodia, W
0333  120A     BCF PCLATH, 0x4
0334  158A     BSF PCLATH, 0x3
0335  23C5     CALL 0x3C5
0336  120A     BCF PCLATH, 0x4
0337  118A     BCF PCLATH, 0x3
0338  3E1C     ADDLW 0x1C
0339  00C7     MOVWF f
033A  3098     MOVLW 0x98
033B  1803     BTFSC STATUS, 0x0
033C  3E01     ADDLW 0x1
033D  2ABE     GOTO 0x2BE
291:                               haycambio = 0;
292:                           } else {
293:                               sprintf(cadenaamostrar, "%02d/%02d/   ", fecha.day, fecha.month);
033E  3066     MOVLW 0x66
033F  1283     BCF STATUS, 0x5
0340  00C7     MOVWF f
0341  3098     MOVLW 0x98
0342  00C8     MOVWF 0x48
0343  0869     MOVF fecha, W
0344  00C9     MOVWF 0x49
0345  01CA     CLRF cntr
0346  086A     MOVF 0x6A, W
0347  00CB     MOVWF sign
0348  30C0     MOVLW 0xC0
0349  01CC     CLRF f2
034A  2BDF     GOTO 0x3DF
294:                               sprintf(cadenaamostrar2, cadena_esp);
295:                           }
296:                           break;
297:                       }
298:                       case MENU_CONFIGURAENCENDIDO:
299:                       {
300:           
301:                           if (flanco) {
034B  087C     MOVF flanco, W
034C  1903     BTFSC STATUS, 0x2
034D  2D41     GOTO 0x541
302:                               sprintf(cadenaamostrar, "SET ENC  ");
034E  30D3     MOVLW 0xD3
034F  1283     BCF STATUS, 0x5
0350  00C7     MOVWF f
0351  3098     MOVLW 0x98
0352  2BDD     GOTO 0x3DD
303:                               sprintf(cadenaamostrar2, cadena_esp);
304:                           }
305:           
306:                           break;
307:                       }
308:                       case SUBMENU_CONFIGURAHORAENCENDIDO:
309:                       {
310:                           modificafecha = HORA;
0353  30D4     MOVLW 0xD4
0354  01E9     CLRF fecha
311:                           horario = &horarioenc;
0353  30D4     MOVLW 0xD4
0355  00FD     MOVWF horario
312:                           if (flanco || haycambio) {
0356  08FC     MOVF flanco, F
0357  1903     BTFSC STATUS, 0x2
0358  0839     MOVF 0x39, W
0359  1D03     BTFSS STATUS, 0x2
035A  2B6C     GOTO 0x36C
313:                               sprintf(cadenaamostrar, "%02d:%02d    ", horarioenc.hrs, horarioenc.min);
314:                               sprintf(cadenaamostrar2, cadena_esp);
315:                               haycambio = 0;
316:                           } else {
317:                               sprintf(cadenaamostrar, "  :%02d    ", horarioenc.min);
035B  309C     MOVLW 0x9C
035C  1283     BCF STATUS, 0x5
035D  00C7     MOVWF f
035E  3098     MOVLW 0x98
035F  00C8     MOVWF 0x48
0360  1683     BSF STATUS, 0x5
0361  0855     MOVF width, W
0362  2B81     GOTO 0x381
318:                               sprintf(cadenaamostrar2, cadena_esp);
319:                           }
320:           
321:                           break;
322:                       }
323:                       case SUBMENU_CONFIGURAMINUTOSENCENDIDO:
0363  30D4     MOVLW 0xD4
324:                       {
325:                           modificafecha = MINUTOS;
0364  01E9     CLRF fecha
0365  0AE9     INCF fecha, F
326:                           horario = &horarioenc;
0363  30D4     MOVLW 0xD4
0366  00FD     MOVWF horario
327:                           if (flanco || haycambio) {
0367  08FC     MOVF flanco, F
0368  1903     BTFSC STATUS, 0x2
0369  0839     MOVF 0x39, W
036A  1903     BTFSC STATUS, 0x2
036B  2B7A     GOTO 0x37A
328:                               sprintf(cadenaamostrar, "%02d:%02d    ", horarioenc.hrs, horarioenc.min);
036C  3058     MOVLW 0x58
036D  1283     BCF STATUS, 0x5
036E  00C7     MOVWF f
036F  3098     MOVLW 0x98
0370  00C8     MOVWF 0x48
0371  1683     BSF STATUS, 0x5
0372  0856     MOVF f3, W
0373  1283     BCF STATUS, 0x5
0374  00C9     MOVWF 0x49
0375  01CA     CLRF cntr
0376  1683     BSF STATUS, 0x5
0377  0855     MOVF width, W
0378  1283     BCF STATUS, 0x5
0379  2AB3     GOTO 0x2B3
329:                               sprintf(cadenaamostrar2, cadena_esp);
330:                               haycambio = 0;
331:                           } else {
332:                               sprintf(cadenaamostrar, "%02d:      ", horarioenc.hrs);
037A  3090     MOVLW 0x90
037B  1283     BCF STATUS, 0x5
037C  00C7     MOVWF f
037D  3098     MOVLW 0x98
037E  00C8     MOVWF 0x48
037F  1683     BSF STATUS, 0x5
0380  0856     MOVF f3, W
0381  1283     BCF STATUS, 0x5
0382  00C9     MOVWF 0x49
0383  30C0     MOVLW 0xC0
0384  01CA     CLRF cntr
0385  2BDF     GOTO 0x3DF
333:                               sprintf(cadenaamostrar2, cadena_esp);
334:                           }
335:                           break;
336:                       }
337:           
338:           
339:                       case SUBMENU_CONFIGURAPERIODOENCENDIDO:
340:                       {
341:                           modificafecha = PERIODOENCENDIDO;
0386  3009     MOVLW 0x9
0387  00E9     MOVWF fecha
342:           
343:                           if (flanco || haycambio) {
0388  08FC     MOVF flanco, F
0389  1903     BTFSC STATUS, 0x2
038A  0839     MOVF 0x39, W
038B  1903     BTFSC STATUS, 0x2
038C  2B95     GOTO 0x395
344:                               sprintf(cadenaamostrar, "c/%u dias", periodoencendido);
038D  3005     MOVLW 0x5
038E  1283     BCF STATUS, 0x5
038F  00C7     MOVWF f
0390  3099     MOVLW 0x99
0391  00C8     MOVWF 0x48
0392  1683     BSF STATUS, 0x5
0393  086A     MOVF 0x6A, W
0394  2BBD     GOTO 0x3BD
345:                               sprintf(cadenaamostrar2, cadena_esp);
346:                               haycambio = 0;
347:                           } else {
348:                               sprintf(cadenaamostrar, "c/  dias");
0395  3045     MOVLW 0x45
0396  1283     BCF STATUS, 0x5
0397  00C7     MOVWF f
0398  3099     MOVLW 0x99
0399  2BDD     GOTO 0x3DD
349:                               sprintf(cadenaamostrar2, cadena_esp);
350:                           }
351:                           break;
352:                       }
353:           
354:                       case SUBMENU_CONFIGURATIEMPOENCENDIDO:
355:                       {
356:                           modificafecha = TIEMPOENCENDIDO;
039A  3007     MOVLW 0x7
039B  00E9     MOVWF fecha
357:           
358:                           if (flanco || haycambio) {
039C  08FC     MOVF flanco, F
039D  1903     BTFSC STATUS, 0x2
039E  0839     MOVF 0x39, W
039F  1903     BTFSC STATUS, 0x2
03A0  2BA9     GOTO 0x3A9
359:                               sprintf(cadenaamostrar, "ENCEN:%02d", tiempoencendido);
03A1  30BE     MOVLW 0xBE
03A2  1283     BCF STATUS, 0x5
03A3  00C7     MOVWF f
03A4  3098     MOVLW 0x98
03A5  00C8     MOVWF 0x48
03A6  1683     BSF STATUS, 0x5
03A7  083D     MOVF f1, W
03A8  2BBD     GOTO 0x3BD
360:                               sprintf(cadenaamostrar2, cadena_esp);
361:                               haycambio = 0;
362:                           } else {
363:                               sprintf(cadenaamostrar, "ENCEN:  ");
03A9  3021     MOVLW 0x21
03AA  1283     BCF STATUS, 0x5
03AB  00C7     MOVWF f
03AC  3099     MOVLW 0x99
03AD  2BDD     GOTO 0x3DD
364:                               sprintf(cadenaamostrar2, cadena_esp);
365:                           }
366:                           break;
367:                       }
368:                       case MENU_CONFIGURAFALLACORRIENTE:
369:                       {
370:                           modificafecha = SINO;
03AE  2BC7     GOTO 0x3C7
371:           
372:                           if (flanco)
373:                               if (banderasino) {
374:                                   sprintf(cadenaamostrar, "NORMAL A ");
375:                                   sprintf(cadenaamostrar2, cadena_esp);
376:                               } else {
377:                                   sprintf(cadenaamostrar, "NORMAL C ");
378:                                   sprintf(cadenaamostrar2, cadena_esp);
379:                               } else {
380:                               sprintf(cadenaamostrar, "NORMAL   ");
381:                               sprintf(cadenaamostrar2, cadena_esp);
382:                           }
383:                           break;
384:                       }
385:                       case MENU_CONFIGURATIEMPOFALLACORRIENTE:
386:                       {
387:                           modificafecha = TIEMPOFALLA;
03AF  3008     MOVLW 0x8
03B0  00E9     MOVWF fecha
388:           
389:                           if (flanco || haycambio) {
03B1  08FC     MOVF flanco, F
03B2  1903     BTFSC STATUS, 0x2
03B3  0839     MOVF 0x39, W
03B4  1903     BTFSC STATUS, 0x2
03B5  2BC2     GOTO 0x3C2
390:                               sprintf(cadenaamostrar, "FALLA:%02d", tiempofalla);
03B6  30B3     MOVLW 0xB3
03B7  1283     BCF STATUS, 0x5
03B8  00C7     MOVWF f
03B9  3098     MOVLW 0x98
03BA  00C8     MOVWF 0x48
03BB  1683     BSF STATUS, 0x5
03BC  083E     MOVF 0x3E, W
03BD  1283     BCF STATUS, 0x5
03BE  00C9     MOVWF 0x49
03BF  30C0     MOVLW 0xC0
03C0  01CA     CLRF cntr
03C1  2AB6     GOTO 0x2B6
391:                               sprintf(cadenaamostrar2, cadena_esp);
392:                               haycambio = 0;
393:                           } else {
394:                               sprintf(cadenaamostrar, "FALLA:  ");
03C2  3018     MOVLW 0x18
03C3  1283     BCF STATUS, 0x5
03C4  00C7     MOVWF f
03C5  3099     MOVLW 0x99
03C6  2BDD     GOTO 0x3DD
395:                               sprintf(cadenaamostrar2, cadena_esp);
396:                           }
397:                           break;
398:                       }
399:                       case MENU_CONFIGURAINDICACIONDENIVEL:
400:                       {
401:                           modificafecha = SINO;
03C7  3006     MOVLW 0x6
03C8  00E9     MOVWF fecha
402:           
403:           
404:                           if (flanco)
03C9  087C     MOVF flanco, W
03CA  1903     BTFSC STATUS, 0x2
03CB  2BD9     GOTO 0x3D9
405:                               if (banderasino) {
03CC  0834     MOVF sign, W
03CD  1903     BTFSC STATUS, 0x2
03CE  2BD4     GOTO 0x3D4
406:                                   sprintf(cadenaamostrar, "NORMAL A ");
03CF  30DD     MOVLW 0xDD
03D0  1283     BCF STATUS, 0x5
03D1  00C7     MOVWF f
03D2  3098     MOVLW 0x98
03D3  2BDD     GOTO 0x3DD
407:                                   sprintf(cadenaamostrar2, cadena_esp);
408:                               } else {
409:                                   sprintf(cadenaamostrar, "NORMAL C ");
03D4  30F1     MOVLW 0xF1
03D5  1283     BCF STATUS, 0x5
03D6  00C7     MOVWF f
03D7  3098     MOVLW 0x98
03D8  2BDD     GOTO 0x3DD
410:                                   sprintf(cadenaamostrar2, cadena_esp);
411:                               } else {
412:                               sprintf(cadenaamostrar, "NORMAL   ");
03D9  30C9     MOVLW 0xC9
03DA  1283     BCF STATUS, 0x5
03DB  00C7     MOVWF f
03DC  3098     MOVLW 0x98
03DD  00C8     MOVWF 0x48
03DE  30C0     MOVLW 0xC0
03DF  160A     BSF PCLATH, 0x4
03E0  118A     BCF PCLATH, 0x3
03E1  25D3     CALL 0x5D3
03E2  120A     BCF PCLATH, 0x4
03E3  118A     BCF PCLATH, 0x3
413:                               sprintf(cadenaamostrar2, cadena_esp);
03E4  3031     MOVLW 0x31
03E5  00C7     MOVWF f
03E6  3098     MOVLW 0x98
03E7  00C8     MOVWF 0x48
03E8  2D12     GOTO 0x512
414:                           }
415:           
416:                           break;
417:                       }
418:                       case MENU_MUESTRAMEDICIONES:
419:                       {
420:                           unsigned int adcenteroI;
421:                           unsigned int adcdecimalI;
422:                           unsigned int adcenteroV;
423:                           mediciondecorriente = (float) medidaI_adc * 50 / 1024;
03E9  1283     BCF STATUS, 0x5
03EA  3080     MOVLW 0x80
03EB  01CC     CLRF f2
03EC  00CD     MOVWF 0x4D
03ED  3044     MOVLW 0x44
03EE  00CE     MOVWF 0x4E
03EF  3048     MOVLW 0x48
03F0  01BD     CLRF f1
03F1  00BE     MOVWF 0x3E
03F2  3042     MOVLW 0x42
03F3  00BF     MOVWF 0x3F
03F4  1683     BSF STATUS, 0x5
03F5  082E     MOVF sign, W
03F6  1283     BCF STATUS, 0x5
03F7  00B1     MOVWF divisor
03F8  1683     BSF STATUS, 0x5
03F9  082D     MOVF day, W
03FA  1283     BCF STATUS, 0x5
03FB  00B0     MOVWF c
03FC  160A     BSF PCLATH, 0x4
03FD  118A     BCF PCLATH, 0x3
03FE  23CC     CALL 0x3CC
03FF  120A     BCF PCLATH, 0x4
0400  118A     BCF PCLATH, 0x3
0401  0830     MOVF c, W
0402  00C0     MOVWF f2
0403  0831     MOVF divisor, W
0404  00C1     MOVWF 0x41
0405  0832     MOVF 0x32, W
0406  00C2     MOVWF m
0407  160A     BSF PCLATH, 0x4
0408  118A     BCF PCLATH, 0x3
0409  245A     CALL 0x45A
040A  120A     BCF PCLATH, 0x4
040B  118A     BCF PCLATH, 0x3
040C  083D     MOVF f1, W
040D  00CF     MOVWF f1
040E  083E     MOVF 0x3E, W
040F  00D0     MOVWF 0x50
0410  083F     MOVF 0x3F, W
0411  00D1     MOVWF 0x51
0412  160A     BSF PCLATH, 0x4
0413  118A     BCF PCLATH, 0x3
0414  23F2     CALL 0x3F2
0415  120A     BCF PCLATH, 0x4
0416  118A     BCF PCLATH, 0x3
0417  084C     MOVF f2, W
0418  1683     BSF STATUS, 0x5
0419  00AA     MOVWF Data
041A  1283     BCF STATUS, 0x5
041B  084D     MOVF 0x4D, W
041C  1683     BSF STATUS, 0x5
041D  00AB     MOVWF sec
041E  1283     BCF STATUS, 0x5
041F  084E     MOVF 0x4E, W
0420  1683     BSF STATUS, 0x5
0421  00AC     MOVWF hr
424:                           //convierto el valor decimal a float
425:                           //para una entrada de 3.3V la lectura es 1023
426:                           //para 0 V la lectura es 0
427:                           //para una maxima lectura quiero que en el display se observe 50A
428:                           //Deseo que tambien me muestre 1 decimal, separo la parte entera y la decimal
429:                           //como la resolucion es 1024, cada bit corresponde a 50A/1024=0.048828125A
430:                           //cada 20 muestras tengo aproximdamente 1A
431:                           float mediciondevoltaje = (float) medidaV_adc * 440 / 1024;
0422  1283     BCF STATUS, 0x5
0423  3080     MOVLW 0x80
0424  01CC     CLRF f2
0425  00CD     MOVWF 0x4D
0426  3044     MOVLW 0x44
0427  00CE     MOVWF 0x4E
0428  30DC     MOVLW 0xDC
0429  01BD     CLRF f1
042A  00BE     MOVWF 0x3E
042B  3043     MOVLW 0x43
042C  00BF     MOVWF 0x3F
042D  1683     BSF STATUS, 0x5
042E  0830     MOVF c, W
042F  1283     BCF STATUS, 0x5
0430  00B1     MOVWF divisor
0431  1683     BSF STATUS, 0x5
0432  082F     MOVF quotient, W
0433  1283     BCF STATUS, 0x5
0434  00B0     MOVWF c
0435  160A     BSF PCLATH, 0x4
0436  118A     BCF PCLATH, 0x3
0437  23CC     CALL 0x3CC
0438  120A     BCF PCLATH, 0x4
0439  118A     BCF PCLATH, 0x3
043A  0830     MOVF c, W
043B  00C0     MOVWF f2
043C  0831     MOVF divisor, W
043D  00C1     MOVWF 0x41
043E  0832     MOVF 0x32, W
043F  00C2     MOVWF m
0440  160A     BSF PCLATH, 0x4
0441  118A     BCF PCLATH, 0x3
0442  245A     CALL 0x45A
0443  120A     BCF PCLATH, 0x4
0444  118A     BCF PCLATH, 0x3
0445  083D     MOVF f1, W
0446  00CF     MOVWF f1
0447  083E     MOVF 0x3E, W
0448  00D0     MOVWF 0x50
0449  083F     MOVF 0x3F, W
044A  00D1     MOVWF 0x51
044B  160A     BSF PCLATH, 0x4
044C  118A     BCF PCLATH, 0x3
044D  23F2     CALL 0x3F2
044E  120A     BCF PCLATH, 0x4
044F  118A     BCF PCLATH, 0x3
0450  084C     MOVF f2, W
0451  1683     BSF STATUS, 0x5
0452  00D7     MOVWF _val
0453  1283     BCF STATUS, 0x5
0454  084D     MOVF 0x4D, W
0455  1683     BSF STATUS, 0x5
0456  00D8     MOVWF 0x58
0457  1283     BCF STATUS, 0x5
0458  084E     MOVF 0x4E, W
0459  1683     BSF STATUS, 0x5
045A  00D9     MOVWF exp
432:                           adcenteroI = (unsigned int) mediciondecorriente;
045B  082A     MOVF Data, W
045C  1283     BCF STATUS, 0x5
045D  00A3     MOVWF x
045E  1683     BSF STATUS, 0x5
045F  082B     MOVF sec, W
0460  1283     BCF STATUS, 0x5
0461  00A4     MOVWF dato
0462  1683     BSF STATUS, 0x5
0463  082C     MOVF hr, W
0464  1283     BCF STATUS, 0x5
0465  00A5     MOVWF y
0466  120A     BCF PCLATH, 0x4
0467  118A     BCF PCLATH, 0x3
0468  26F2     CALL 0x6F2
0469  120A     BCF PCLATH, 0x4
046A  118A     BCF PCLATH, 0x3
046B  0824     MOVF dato, W
046C  1683     BSF STATUS, 0x5
046D  00E1     MOVWF cambio_de_canal
046E  1283     BCF STATUS, 0x5
046F  0823     MOVF x, W
0470  1683     BSF STATUS, 0x5
0471  00E0     MOVWF activapwmpor
433:                           adcdecimalI = (unsigned int) ((mediciondecorriente - (unsigned int) mediciondecorriente)*10);
0472  082A     MOVF Data, W
0473  1283     BCF STATUS, 0x5
0474  00BA     MOVWF f1
0475  1683     BSF STATUS, 0x5
0476  082B     MOVF sec, W
0477  1283     BCF STATUS, 0x5
0478  00BB     MOVWF 0x3B
0479  1683     BSF STATUS, 0x5
047A  082C     MOVF hr, W
047B  1283     BCF STATUS, 0x5
047C  00BC     MOVWF 0x3C
047D  1683     BSF STATUS, 0x5
047E  082A     MOVF Data, W
047F  1283     BCF STATUS, 0x5
0480  00A3     MOVWF x
0481  1683     BSF STATUS, 0x5
0482  082B     MOVF sec, W
0483  1283     BCF STATUS, 0x5
0484  00A4     MOVWF dato
0485  1683     BSF STATUS, 0x5
0486  082C     MOVF hr, W
0487  1283     BCF STATUS, 0x5
0488  00A5     MOVWF y
0489  120A     BCF PCLATH, 0x4
048A  118A     BCF PCLATH, 0x3
048B  26F2     CALL 0x6F2
048C  120A     BCF PCLATH, 0x4
048D  118A     BCF PCLATH, 0x3
048E  0824     MOVF dato, W
048F  00B1     MOVWF divisor
0490  0823     MOVF x, W
0491  00B0     MOVWF c
0492  160A     BSF PCLATH, 0x4
0493  118A     BCF PCLATH, 0x3
0494  23CC     CALL 0x3CC
0495  120A     BCF PCLATH, 0x4
0496  118A     BCF PCLATH, 0x3
0497  0830     MOVF c, W
0498  00B7     MOVWF mes
0499  0831     MOVF divisor, W
049A  00B8     MOVWF anio
049B  0832     MOVF 0x32, W
049C  00B9     MOVWF 0x39
049D  160A     BSF PCLATH, 0x4
049E  118A     BCF PCLATH, 0x3
049F  23DC     CALL 0x3DC
04A0  120A     BCF PCLATH, 0x4
04A1  118A     BCF PCLATH, 0x3
04A2  0837     MOVF mes, W
04A3  00C0     MOVWF f2
04A4  0838     MOVF anio, W
04A5  00C1     MOVWF 0x41
04A6  0839     MOVF 0x39, W
04A7  00C2     MOVWF m
04A8  3020     MOVLW 0x20
04A9  01BD     CLRF f1
04AA  00BE     MOVWF 0x3E
04AB  3041     MOVLW 0x41
04AC  00BF     MOVWF 0x3F
04AD  160A     BSF PCLATH, 0x4
04AE  118A     BCF PCLATH, 0x3
04AF  245A     CALL 0x45A
04B0  120A     BCF PCLATH, 0x4
04B1  118A     BCF PCLATH, 0x3
04B2  083D     MOVF f1, W
04B3  1683     BSF STATUS, 0x5
04B4  00DD     MOVWF 0x5D
04B5  1283     BCF STATUS, 0x5
04B6  083E     MOVF 0x3E, W
04B7  1683     BSF STATUS, 0x5
04B8  00DE     MOVWF 0x5E
04B9  1283     BCF STATUS, 0x5
04BA  083F     MOVF 0x3F, W
04BB  1683     BSF STATUS, 0x5
04BC  00DF     MOVWF NLinea
04BD  085D     MOVF 0x5D, W
04BE  1283     BCF STATUS, 0x5
04BF  00A3     MOVWF x
04C0  1683     BSF STATUS, 0x5
04C1  085E     MOVF 0x5E, W
04C2  1283     BCF STATUS, 0x5
04C3  00A4     MOVWF dato
04C4  1683     BSF STATUS, 0x5
04C5  085F     MOVF NLinea, W
04C6  1283     BCF STATUS, 0x5
04C7  00A5     MOVWF y
04C8  120A     BCF PCLATH, 0x4
04C9  118A     BCF PCLATH, 0x3
04CA  26F2     CALL 0x6F2
04CB  120A     BCF PCLATH, 0x4
04CC  118A     BCF PCLATH, 0x3
04CD  0824     MOVF dato, W
04CE  1683     BSF STATUS, 0x5
04CF  00E3     MOVWF cuenta500ms
04D0  1283     BCF STATUS, 0x5
04D1  0823     MOVF x, W
04D2  1683     BSF STATUS, 0x5
04D3  00E2     MOVWF cuenta40ms
434:                           adcenteroV = (unsigned int) mediciondevoltaje;
04D4  0857     MOVF _val, W
04D5  1283     BCF STATUS, 0x5
04D6  00A3     MOVWF x
04D7  1683     BSF STATUS, 0x5
04D8  0858     MOVF 0x58, W
04D9  1283     BCF STATUS, 0x5
04DA  00A4     MOVWF dato
04DB  1683     BSF STATUS, 0x5
04DC  0859     MOVF exp, W
04DD  1283     BCF STATUS, 0x5
04DE  00A5     MOVWF y
04DF  120A     BCF PCLATH, 0x4
04E0  118A     BCF PCLATH, 0x3
04E1  26F2     CALL 0x6F2
04E2  120A     BCF PCLATH, 0x4
04E3  118A     BCF PCLATH, 0x3
04E4  0824     MOVF dato, W
04E5  1683     BSF STATUS, 0x5
04E6  00E5     MOVWF cuentahoras
04E7  1283     BCF STATUS, 0x5
04E8  0823     MOVF x, W
04E9  1683     BSF STATUS, 0x5
04EA  00E4     MOVWF cuentadias
435:                           sprintf(cadenaamostrar, "%2u.%uA   ", (unsigned int) adcenteroI, (unsigned int) adcdecimalI);
04EB  30A8     MOVLW 0xA8
04EC  1283     BCF STATUS, 0x5
04ED  00C7     MOVWF f
04EE  3098     MOVLW 0x98
04EF  00C8     MOVWF 0x48
04F0  1683     BSF STATUS, 0x5
04F1  0861     MOVF cambio_de_canal, W
04F2  1283     BCF STATUS, 0x5
04F3  00CA     MOVWF cntr
04F4  1683     BSF STATUS, 0x5
04F5  0860     MOVF activapwmpor, W
04F6  1283     BCF STATUS, 0x5
04F7  00C9     MOVWF 0x49
04F8  1683     BSF STATUS, 0x5
04F9  0863     MOVF cuenta500ms, W
04FA  1283     BCF STATUS, 0x5
04FB  00CC     MOVWF f2
04FC  1683     BSF STATUS, 0x5
04FD  0862     MOVF cuenta40ms, W
04FE  1283     BCF STATUS, 0x5
04FF  00CB     MOVWF sign
0500  30C0     MOVLW 0xC0
0501  160A     BSF PCLATH, 0x4
0502  118A     BCF PCLATH, 0x3
0503  25D3     CALL 0x5D3
0504  120A     BCF PCLATH, 0x4
0505  118A     BCF PCLATH, 0x3
436:                           sprintf(cadenaamostrar2, "%3uV    ", (unsigned int) adcenteroV);
0506  300F     MOVLW 0xF
0507  00C7     MOVWF f
0508  3099     MOVLW 0x99
0509  00C8     MOVWF 0x48
050A  1683     BSF STATUS, 0x5
050B  0865     MOVF cuentahoras, W
050C  1283     BCF STATUS, 0x5
050D  00CA     MOVWF cntr
050E  1683     BSF STATUS, 0x5
050F  0864     MOVF cuentadias, W
0510  1283     BCF STATUS, 0x5
0511  00C9     MOVWF 0x49
0512  30C8     MOVLW 0xC8
0513  160A     BSF PCLATH, 0x4
0514  118A     BCF PCLATH, 0x3
0515  25D3     CALL 0x5D3
0516  120A     BCF PCLATH, 0x4
0517  118A     BCF PCLATH, 0x3
437:                           break;
0518  1683     BSF STATUS, 0x5
0519  2D41     GOTO 0x541
438:                       }
439:                       default:
440:                           break;
441:                   };
442:                   //////////////////////////////////////////////////////////
443:                   //Finaliza Procesa los men
444:           
445:                   //Verifica estados de falla
446:                   /////////////////////////////////////////////////////////
447:                   switch (estadobomba) {
0541  1683     BSF STATUS, 0x5
0542  0835     MOVF counter, W
0543  3A00     XORLW 0x0
0544  1903     BTFSC STATUS, 0x2
0545  2D29     GOTO 0x529
0546  3A01     XORLW 0x1
0547  1903     BTFSC STATUS, 0x2
0548  2D35     GOTO 0x535
0549  2D4A     GOTO 0x54A
448:                       case BOMBAAPAGADA:
449:                       {
450:                           sprintf(cadenaamostrar2, "     off");
0529  3033     MOVLW 0x33
052A  1283     BCF STATUS, 0x5
052B  00C7     MOVWF f
052C  3099     MOVLW 0x99
052D  00C8     MOVWF 0x48
052E  30C8     MOVLW 0xC8
052F  160A     BSF PCLATH, 0x4
0530  118A     BCF PCLATH, 0x3
0531  25D3     CALL 0x5D3
0532  120A     BCF PCLATH, 0x4
0533  118A     BCF PCLATH, 0x3
451:                           break;
0534  2D4A     GOTO 0x54A
452:                       }
453:                       case BOMBAENCENDIDA:
454:                       {
455:                           sprintf(cadenaamostrar2, "      on");
0535  303C     MOVLW 0x3C
0536  1283     BCF STATUS, 0x5
0537  00C7     MOVWF f
0538  3099     MOVLW 0x99
0539  00C8     MOVWF 0x48
053A  30C8     MOVLW 0xC8
053B  160A     BSF PCLATH, 0x4
053C  118A     BCF PCLATH, 0x3
053D  25D3     CALL 0x5D3
053E  120A     BCF PCLATH, 0x4
053F  118A     BCF PCLATH, 0x3
456:                           break;
0540  2D4A     GOTO 0x54A
457:                       }
458:                       default:
459:                           break;
460:                   }
461:           
462:                   if (/*(estadonivel == NIVELNORMAL)&&*/(estadofallacorriente == CORRIENTENORMAL) && (estadofallavoltaje == VOLTAJENORMAL)) {
054A  1683     BSF STATUS, 0x5
054B  08B6     MOVF sign, F
054C  1D03     BTFSS STATUS, 0x2
054D  2D57     GOTO 0x557
054E  08B7     MOVF mes, F
054F  1D03     BTFSS STATUS, 0x2
0550  2D57     GOTO 0x557
463:                       if (estadonivel == NIVELNORMAL)
0551  08B8     MOVF anio, F
0552  1D03     BTFSS STATUS, 0x2
0553  2D5B     GOTO 0x55B
464:                           activabomba = ENCIENDEBOMBA;
0554  01B1     CLRF divisor
0555  0AB1     INCF divisor, F
0556  2D5B     GOTO 0x55B
465:                       //TODO ac debo dar la orden para encender la bomba?
466:                   } else {
467:                       activabomba = APAGABOMBA;
0557  01B1     CLRF divisor
0558  2D5B     GOTO 0x55B
468:                   }
469:           
470:                   switch (estadonivel) {
055B  0838     MOVF anio, W
055C  3A00     XORLW 0x0
055D  1903     BTFSC STATUS, 0x2
055E  2D65     GOTO 0x565
055F  3A01     XORLW 0x1
0560  1903     BTFSC STATUS, 0x2
0561  2D59     GOTO 0x559
0562  2D65     GOTO 0x565
471:                       case NIVELNORMAL:
472:                       {
473:           
474:                           break;
475:                       }
476:                       case NIVELBAJO:
477:                       {
478:                           activabomba = 0;
0559  01B1     CLRF divisor
479:                           break;
055A  2D65     GOTO 0x565
480:                       }
481:                       default:
482:                           break;
483:                   }
484:           
485:                   switch (estadofallacorriente) {
0565  0836     MOVF sign, W
0566  3A00     XORLW 0x0
0567  1903     BTFSC STATUS, 0x2
0568  2D6F     GOTO 0x56F
0569  3A01     XORLW 0x1
056A  1903     BTFSC STATUS, 0x2
056B  2D63     GOTO 0x563
056C  2D6F     GOTO 0x56F
486:                       case CORRIENTENORMAL:
487:                       {
488:                           break;
489:                       }
490:                       case FALLACORRIENTE:
491:                       {
492:                           activabomba = 0;
0563  01B1     CLRF divisor
493:                           break;
0564  2D6F     GOTO 0x56F
494:                       }
495:                       default:
496:                           break;
497:                   }
498:                   switch (estadofallavoltaje) {
056F  0837     MOVF mes, W
0570  3A00     XORLW 0x0
0571  1903     BTFSC STATUS, 0x2
0572  2D77     GOTO 0x577
0573  3A01     XORLW 0x1
0574  1903     BTFSC STATUS, 0x2
0575  2D6D     GOTO 0x56D
0576  2D77     GOTO 0x577
499:                       case VOLTAJENORMAL:
500:                       {
501:                           break;
502:                       }
503:                       case FALLAVOLTAJE:
504:                       {
505:                           activabomba = 0;
056D  01B1     CLRF divisor
506:                           break;
056E  2D77     GOTO 0x577
507:                       }
508:                       default:
509:                           break;
510:                   }
511:                   //////////////////////////////////////////////////////
512:                   //Fin Verifica estados de falla
513:           
514:                   //Inicio de procesamiento de medicion de voltaje, corriente
515:                   /////////////////////////////////////////////////////////////
516:                   //  unsigned int adcenteroI;
517:                   //unsigned int adcdecimalI;
518:                   unsigned int adcenteroV;
519:           
520:                   //convierto el valor decimal a float
521:                   //para una entrada de 3.3V la lectura es 1023
522:                   //para 0 V la lectura es 0
523:                   //para una maxima lectura quiero que en el display se observe 50A
524:                   //Deseo que tambien me muestre 1 decimal, separo la parte entera y la decimal
525:                   //como la resolucion es 1024, cada bit corresponde a 50A/1024=0.048828125A
526:                   //cada 20 muestras tengo aproximdamente 1A
527:                   float mediciondevoltaje = (float) medidaV_adc * 440 / 1024;
0577  1283     BCF STATUS, 0x5
0578  3080     MOVLW 0x80
0579  01CC     CLRF f2
057A  00CD     MOVWF 0x4D
057B  3044     MOVLW 0x44
057C  00CE     MOVWF 0x4E
057D  30DC     MOVLW 0xDC
057E  01BD     CLRF f1
057F  00BE     MOVWF 0x3E
0580  3043     MOVLW 0x43
0581  00BF     MOVWF 0x3F
0582  1683     BSF STATUS, 0x5
0583  0830     MOVF c, W
0584  1283     BCF STATUS, 0x5
0585  00B1     MOVWF divisor
0586  1683     BSF STATUS, 0x5
0587  082F     MOVF quotient, W
0588  1283     BCF STATUS, 0x5
0589  00B0     MOVWF c
058A  160A     BSF PCLATH, 0x4
058B  118A     BCF PCLATH, 0x3
058C  23CC     CALL 0x3CC
058D  120A     BCF PCLATH, 0x4
058E  118A     BCF PCLATH, 0x3
058F  0830     MOVF c, W
0590  00C0     MOVWF f2
0591  0831     MOVF divisor, W
0592  00C1     MOVWF 0x41
0593  0832     MOVF 0x32, W
0594  00C2     MOVWF m
0595  160A     BSF PCLATH, 0x4
0596  118A     BCF PCLATH, 0x3
0597  245A     CALL 0x45A
0598  120A     BCF PCLATH, 0x4
0599  118A     BCF PCLATH, 0x3
059A  083D     MOVF f1, W
059B  00CF     MOVWF f1
059C  083E     MOVF 0x3E, W
059D  00D0     MOVWF 0x50
059E  083F     MOVF 0x3F, W
059F  00D1     MOVWF 0x51
05A0  160A     BSF PCLATH, 0x4
05A1  118A     BCF PCLATH, 0x3
05A2  23F2     CALL 0x3F2
05A3  120A     BCF PCLATH, 0x4
05A4  118A     BCF PCLATH, 0x3
05A5  084C     MOVF f2, W
05A6  1683     BSF STATUS, 0x5
05A7  00DA     MOVWF c
05A8  1283     BCF STATUS, 0x5
05A9  084D     MOVF 0x4D, W
05AA  1683     BSF STATUS, 0x5
05AB  00DB     MOVWF sp
05AC  1283     BCF STATUS, 0x5
05AD  084E     MOVF 0x4E, W
05AE  1683     BSF STATUS, 0x5
05AF  00DC     MOVWF 0x5C
528:                   adcenteroV = (unsigned int) mediciondevoltaje;
05B0  085A     MOVF c, W
05B1  1283     BCF STATUS, 0x5
05B2  00A3     MOVWF x
05B3  1683     BSF STATUS, 0x5
05B4  085B     MOVF sp, W
05B5  1283     BCF STATUS, 0x5
05B6  00A4     MOVWF dato
05B7  1683     BSF STATUS, 0x5
05B8  085C     MOVF 0x5C, W
05B9  1283     BCF STATUS, 0x5
05BA  00A5     MOVWF y
05BB  120A     BCF PCLATH, 0x4
05BC  118A     BCF PCLATH, 0x3
05BD  26F2     CALL 0x6F2
05BE  120A     BCF PCLATH, 0x4
05BF  118A     BCF PCLATH, 0x3
05C0  0824     MOVF dato, W
05C1  1683     BSF STATUS, 0x5
05C2  00E7     MOVWF cuentasegundos
05C3  1283     BCF STATUS, 0x5
05C4  0823     MOVF x, W
05C5  1683     BSF STATUS, 0x5
05C6  00E6     MOVWF cuentaminutos
529:                   //Se lee el voltaje de alimentacin constantemente
530:                   if (adcenteroV <= VOLTAJEMAXIMO && adcenteroV >= VOLTAJEMINIMO) {
05C7  3000     MOVLW 0x0
05C8  0267     SUBWF cuentasegundos, W
05C9  30F1     MOVLW 0xF1
05CA  1903     BTFSC STATUS, 0x2
05CB  0266     SUBWF cuentaminutos, W
05CC  1803     BTFSC STATUS, 0x0
05CD  2DD7     GOTO 0x5D7
05CE  3000     MOVLW 0x0
05CF  0267     SUBWF cuentasegundos, W
05D0  30BE     MOVLW 0xBE
05D1  1903     BTFSC STATUS, 0x2
05D2  0266     SUBWF cuentaminutos, W
05D4  1C03     BTFSS STATUS, 0x0
05D5  2DD8     GOTO 0x5D8
531:                       estadofallavoltaje = VOLTAJENORMAL;
05D3  01B7     CLRF mes
532:                   } else {
05D6  2E4D     GOTO 0x64D
533:                       estadofallavoltaje = FALLAVOLTAJE;
05D7  01B7     CLRF mes
05D8  0AB7     INCF mes, F
05D9  2E4D     GOTO 0x64D
534:                   }
535:           
536:                   //Se lee la corriente consumida solamente cuando la bomba est activada
537:                   switch (activabomba) {
064D  0831     MOVF divisor, W
064E  3A00     XORLW 0x0
064F  1903     BTFSC STATUS, 0x2
0650  2E60     GOTO 0x660
0651  3A01     XORLW 0x1
0652  1903     BTFSC STATUS, 0x2
0653  2DDA     GOTO 0x5DA
0654  2E60     GOTO 0x660
538:                       case APAGABOMBA:
539:                       {
540:                           break;
541:                       }
542:                       case ENCIENDEBOMBA:
543:                       {
544:                           mediciondecorriente = (float) medidaI_adc * 50 / 1024;
05DA  1283     BCF STATUS, 0x5
05DB  3080     MOVLW 0x80
05DC  01CC     CLRF f2
05DD  00CD     MOVWF 0x4D
05DE  3044     MOVLW 0x44
05DF  00CE     MOVWF 0x4E
05E0  3048     MOVLW 0x48
05E1  01BD     CLRF f1
05E2  00BE     MOVWF 0x3E
05E3  3042     MOVLW 0x42
05E4  00BF     MOVWF 0x3F
05E5  1683     BSF STATUS, 0x5
05E6  082E     MOVF sign, W
05E7  1283     BCF STATUS, 0x5
05E8  00B1     MOVWF divisor
05E9  1683     BSF STATUS, 0x5
05EA  082D     MOVF day, W
05EB  1283     BCF STATUS, 0x5
05EC  00B0     MOVWF c
05ED  160A     BSF PCLATH, 0x4
05EE  118A     BCF PCLATH, 0x3
05EF  23CC     CALL 0x3CC
05F0  120A     BCF PCLATH, 0x4
05F1  118A     BCF PCLATH, 0x3
05F2  0830     MOVF c, W
05F3  00C0     MOVWF f2
05F4  0831     MOVF divisor, W
05F5  00C1     MOVWF 0x41
05F6  0832     MOVF 0x32, W
05F7  00C2     MOVWF m
05F8  160A     BSF PCLATH, 0x4
05F9  118A     BCF PCLATH, 0x3
05FA  245A     CALL 0x45A
05FB  120A     BCF PCLATH, 0x4
05FC  118A     BCF PCLATH, 0x3
05FD  083D     MOVF f1, W
05FE  00CF     MOVWF f1
05FF  083E     MOVF 0x3E, W
0600  00D0     MOVWF 0x50
0601  083F     MOVF 0x3F, W
0602  00D1     MOVWF 0x51
0603  160A     BSF PCLATH, 0x4
0604  118A     BCF PCLATH, 0x3
0605  23F2     CALL 0x3F2
0606  120A     BCF PCLATH, 0x4
0607  118A     BCF PCLATH, 0x3
0608  084C     MOVF f2, W
0609  1683     BSF STATUS, 0x5
060A  00AA     MOVWF Data
060B  1283     BCF STATUS, 0x5
060C  084D     MOVF 0x4D, W
060D  1683     BSF STATUS, 0x5
060E  00AB     MOVWF sec
060F  1283     BCF STATUS, 0x5
0610  084E     MOVF 0x4E, W
0611  1683     BSF STATUS, 0x5
0612  00AC     MOVWF hr
545:                           //adcenteroI = (unsigned int) mediciondecorriente;
546:                           //adcdecimalI = (unsigned int) ((mediciondecorriente - (unsigned int) mediciondecorriente)*10);
547:                           if (mediciondecorriente <= CORRIENTEMAXIMA && mediciondecorriente >= CORRIENTEMINIMA) {
0613  1283     BCF STATUS, 0x5
0614  3048     MOVLW 0x48
0615  01A3     CLRF x
0616  00A4     MOVWF dato
0617  3042     MOVLW 0x42
0618  00A5     MOVWF y
0619  1683     BSF STATUS, 0x5
061A  082A     MOVF Data, W
061B  1283     BCF STATUS, 0x5
061C  00A6     MOVWF x
061D  1683     BSF STATUS, 0x5
061E  082B     MOVF sec, W
061F  1283     BCF STATUS, 0x5
0620  00A7     MOVWF i
0621  1683     BSF STATUS, 0x5
0622  082C     MOVF hr, W
0623  1283     BCF STATUS, 0x5
0624  00A8     MOVWF mth
0625  120A     BCF PCLATH, 0x4
0626  118A     BCF PCLATH, 0x3
0627  27C6     CALL 0x7C6
0628  120A     BCF PCLATH, 0x4
0629  118A     BCF PCLATH, 0x3
062A  1C03     BTFSS STATUS, 0x0
062B  2E47     GOTO 0x647
062C  1683     BSF STATUS, 0x5
062D  082A     MOVF Data, W
062E  1283     BCF STATUS, 0x5
062F  00A3     MOVWF x
0630  1683     BSF STATUS, 0x5
0631  082B     MOVF sec, W
0632  1283     BCF STATUS, 0x5
0633  00A4     MOVWF dato
0634  1683     BSF STATUS, 0x5
0635  082C     MOVF hr, W
0636  1283     BCF STATUS, 0x5
0637  00A5     MOVWF y
0638  3040     MOVLW 0x40
0639  01A6     CLRF x
063A  01A7     CLRF i
063B  00A8     MOVWF mth
063C  120A     BCF PCLATH, 0x4
063D  118A     BCF PCLATH, 0x3
063E  27C6     CALL 0x7C6
063F  120A     BCF PCLATH, 0x4
0640  118A     BCF PCLATH, 0x3
0641  1C03     BTFSS STATUS, 0x0
0642  2E47     GOTO 0x647
548:                               estadofallacorriente = CORRIENTENORMAL;
0643  1683     BSF STATUS, 0x5
0644  01B6     CLRF sign
549:                               estadonivel = NIVELNORMAL;
0645  01B8     CLRF anio
550:           
551:                           } else {
0646  2E60     GOTO 0x660
552:                               estadofallacorriente = FALLACORRIENTE;
0647  1683     BSF STATUS, 0x5
0648  01B6     CLRF sign
0649  0AB6     INCF sign, F
553:                               estadonivel = NIVELBAJO;
064A  01B8     CLRF anio
064B  0AB8     INCF anio, F
064C  2E60     GOTO 0x660
554:           
555:                           }
556:                           break;
557:                       }
558:                       default:
559:                           break;
560:                   }
561:           
562:                   // sprintf(cadenaamostrar, "%2u.%uA   ", (unsigned int) adcenteroI, (unsigned int) adcdecimalI);
563:                   // sprintf(cadenaamostrar2, "%3uV    ", (unsigned int) adcenteroV);
564:                   /////////////////////////////////////////////////////////////
565:                   //Fin de procesamiento de medicion de voltaje, corriente
566:           
567:           
568:                   //Activa o desactiva la Bomba
569:                   ///////////////////////////////////////////////////////
570:                   switch (activabomba) {
0660  0831     MOVF divisor, W
0661  3A00     XORLW 0x0
0662  1903     BTFSC STATUS, 0x2
0663  2E5B     GOTO 0x65B
0664  3A01     XORLW 0x1
0665  1903     BTFSC STATUS, 0x2
0666  2E55     GOTO 0x655
0667  2E68     GOTO 0x668
571:                       case ENCIENDEBOMBA:
572:                       {
573:                           salidabomba = 1;
0655  1283     BCF STATUS, 0x5
0656  1407     BSF PORTC, 0x0
574:                           estadobomba = 1;
0657  1683     BSF STATUS, 0x5
0658  01B5     CLRF counter
0659  0AB5     INCF counter, F
575:                           break;
065A  2E68     GOTO 0x668
576:                       }
577:                       case APAGABOMBA:
578:                       {
579:                           salidabomba = 0;
065B  1283     BCF STATUS, 0x5
065C  1007     BCF PORTC, 0x0
580:                           estadobomba = 0;
065D  1683     BSF STATUS, 0x5
065E  01B5     CLRF counter
581:                           break;
065F  2E68     GOTO 0x668
582:                       }
583:                       default:
584:                           break;
585:                   }
586:                   //////////////////////////////////////////////////////
587:                   //Fin Activa o desactiva la Bomba
588:           
589:                   //Actualiza Display
590:                   /////////////////////////////////////////////
591:                   if (refrescadisplay) {
0668  083C     MOVF 0x3C, W
0669  1903     BTFSC STATUS, 0x2
066A  2EA8     GOTO 0x6A8
592:                       vGotoxyLCD(1, 1);
066B  1283     BCF STATUS, 0x5
066C  3001     MOVLW 0x1
066D  01A5     CLRF y
066E  0AA5     INCF y, F
066F  160A     BSF PCLATH, 0x4
0670  118A     BCF PCLATH, 0x3
0671  2272     CALL 0x272
0672  120A     BCF PCLATH, 0x4
0673  118A     BCF PCLATH, 0x3
593:                       cadena = cadenaamostrar;
0674  30C0     MOVLW 0xC0
0675  1683     BSF STATUS, 0x5
0676  00BF     MOVWF 0x3F
594:                       while (*cadena != '\0')
0677  083F     MOVF 0x3F, W
0678  0084     MOVWF FSR
0679  1383     BCF STATUS, 0x7
067A  0880     MOVF INDF, F
067B  1903     BTFSC STATUS, 0x2
067C  2E89     GOTO 0x689
0688  2E77     GOTO 0x677
595:                           vLCD_Putc(*cadena++);
067D  083F     MOVF 0x3F, W
067E  0084     MOVWF FSR
067F  0800     MOVF INDF, W
0680  160A     BSF PCLATH, 0x4
0681  118A     BCF PCLATH, 0x3
0682  2292     CALL 0x292
0683  120A     BCF PCLATH, 0x4
0684  118A     BCF PCLATH, 0x3
0685  1683     BSF STATUS, 0x5
0686  1303     BCF STATUS, 0x6
0687  0ABF     INCF 0x3F, F
596:                       vGotoxyLCD(1, 2);
0689  3002     MOVLW 0x2
068A  1283     BCF STATUS, 0x5
068B  00A5     MOVWF y
068C  3001     MOVLW 0x1
068D  160A     BSF PCLATH, 0x4
068E  118A     BCF PCLATH, 0x3
068F  2272     CALL 0x272
0690  120A     BCF PCLATH, 0x4
0691  118A     BCF PCLATH, 0x3
597:                       cadena = cadenaamostrar2;
0692  30C8     MOVLW 0xC8
0693  1683     BSF STATUS, 0x5
0694  00BF     MOVWF 0x3F
598:                       while (*cadena != '\0')
0695  083F     MOVF 0x3F, W
0696  0084     MOVWF FSR
0697  1383     BCF STATUS, 0x7
0698  0880     MOVF INDF, F
0699  1903     BTFSC STATUS, 0x2
069A  2EA7     GOTO 0x6A7
06A6  2E95     GOTO 0x695
599:                           vLCD_Putc(*cadena++);
069B  083F     MOVF 0x3F, W
069C  0084     MOVWF FSR
069D  0800     MOVF INDF, W
069E  160A     BSF PCLATH, 0x4
069F  118A     BCF PCLATH, 0x3
06A0  2292     CALL 0x292
06A1  120A     BCF PCLATH, 0x4
06A2  118A     BCF PCLATH, 0x3
06A3  1683     BSF STATUS, 0x5
06A4  1303     BCF STATUS, 0x6
06A5  0ABF     INCF 0x3F, F
600:           
601:                       refrescadisplay = 0;
06A7  01BC     CLRF 0x3C
602:                   }
603:                   ////////////////////////////////////////////////
604:                   //Fin Actualiza Display
605:           
606:                   //Graba Nuevos datos en el RC
607:                   /////////////////////////////////////////////////
608:                   if (bandera_startglobal) {
06A8  0833     MOVF dividend, W
06A9  1903     BTFSC STATUS, 0x2
06AA  2EAD     GOTO 0x6AD
609:                       bandera_grabafechay_hora = 1;
06AB  01B2     CLRF 0x32
06AC  0AB2     INCF 0x32, F
610:           
611:                   }
612:                   if (!bandera_startglobal && bandera_grabafechay_hora) {
06AD  08B3     MOVF dividend, F
06AE  1D03     BTFSS STATUS, 0x2
06AF  2EEF     GOTO 0x6EF
06B0  0832     MOVF 0x32, W
06B1  1903     BTFSC STATUS, 0x2
06B2  2EEF     GOTO 0x6EF
613:                       if (horario == &horarioactual) {
06B3  087D     MOVF horario, W
06B4  3A6D     XORLW 0x6D
06B5  1D03     BTFSS STATUS, 0x2
06B6  2ED4     GOTO 0x6D4
614:                           isl1208_set_time((*horario).hrs, (*horario).min, 00);
06B7  0A7D     INCF horario, W
06B8  0084     MOVWF FSR
06B9  1383     BCF STATUS, 0x7
06BA  0800     MOVF INDF, W
06BB  1283     BCF STATUS, 0x5
06BC  00AA     MOVWF Data
06BD  01AB     CLRF sec
06BE  087D     MOVF horario, W
06BF  3E02     ADDLW 0x2
06C0  0084     MOVWF FSR
06C1  0800     MOVF INDF, W
06C2  120A     BCF PCLATH, 0x4
06C3  158A     BSF PCLATH, 0x3
06C4  22AD     CALL 0x2AD
06C5  120A     BCF PCLATH, 0x4
06C6  118A     BCF PCLATH, 0x3
615:                           isl1208_set_date(&fecha.day, &fecha.month, &fecha.yr, &fecha.dow);
06C7  306A     MOVLW 0x6A
06C8  1283     BCF STATUS, 0x5
06C9  00AA     MOVWF Data
06CA  306B     MOVLW 0x6B
06CB  00AB     MOVWF sec
06CC  306C     MOVLW 0x6C
06CD  00AC     MOVWF hr
06CE  3069     MOVLW 0x69
06CF  120A     BCF PCLATH, 0x4
06D0  158A     BSF PCLATH, 0x3
06D1  22E9     CALL 0x2E9
06D2  120A     BCF PCLATH, 0x4
06D3  118A     BCF PCLATH, 0x3
616:                       }
617:                       if (horario == &horarioenc) {
06D4  087D     MOVF horario, W
06D5  3AD4     XORLW 0xD4
06D6  1D03     BTFSS STATUS, 0x2
06D7  2EEE     GOTO 0x6EE
618:                           isl1208_set_time_enc((*horario).hrs, (*horario).min, 00);
06D8  0A7D     INCF horario, W
06D9  0084     MOVWF FSR
06DA  1383     BCF STATUS, 0x7
06DB  0800     MOVF INDF, W
06DC  1283     BCF STATUS, 0x5
06DD  00AA     MOVWF Data
06DE  01AB     CLRF sec
06DF  087D     MOVF horario, W
06E0  3E02     ADDLW 0x2
06E1  0084     MOVWF FSR
06E2  0800     MOVF INDF, W
06E3  120A     BCF PCLATH, 0x4
06E4  158A     BSF PCLATH, 0x3
06E5  2284     CALL 0x284
06E6  120A     BCF PCLATH, 0x4
06E7  118A     BCF PCLATH, 0x3
619:                           //isl1208_set_date(&fecha.day, &fecha.month, &fecha.yr, &fecha.dow);
620:                           isl1208_set_dow_enc(&fechaenc.dow);
06E8  30D3     MOVLW 0xD3
06E9  120A     BCF PCLATH, 0x4
06EA  158A     BSF PCLATH, 0x3
06EB  2266     CALL 0x266
06EC  120A     BCF PCLATH, 0x4
06ED  118A     BCF PCLATH, 0x3
621:                       }
622:                       bandera_grabafechay_hora = 0;
06EE  01B2     CLRF 0x32
623:                   }
624:                   //////////////////////////////////////////////////////////////////
625:                   //Finaliza Graba Nuevos datos en el RTC
626:                   NOP();
06EF  0000     NOP
627:                   NOP();
06F0  0000     NOP
628:           
629:               }
630:           }
631:           
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/interrupts.c  -------------------------
1:             
2:             /******************************************************************************/
3:             /*Files to Include                                                            */
4:             /******************************************************************************/
5:             
6:             #if defined(__XC)
7:             #include <xc.h>         /* XC8 General Include File */
8:             #elif defined(HI_TECH_C)
9:             #include <htc.h>        /* HiTech General Include File */
10:            #endif
11:            #include <stdbool.h>        /* For true/false definition */
12:            #include <stdint.h>
13:            #include "user.h"
14:            #include "system.h"
15:            
16:            #include "Pulsadores.h"
17:            #include "pwm.h"
18:            #include "adcPic16.h"
19:            #include "_isl1208.h"
20:            /* Interrupt Routines                                                         */
21:            /******************************************************************************/
22:            
23:            /* Baseline devices don't have interrupts. Note that some PIC16's 
24:             * are baseline devices.  Unfortunately the baseline detection macro is 
25:             * _PIC12 */
26:            #ifndef _PIC18
27:            #ifndef _PIC12
28:            
29:            void interrupt isr(void) {
0004  00FE     MOVWF 0x7E
0005  0E03     SWAPF STATUS, W
0006  1283     BCF STATUS, 0x5
0007  1303     BCF STATUS, 0x6
0008  00A0     MOVWF 0x20
0009  0804     MOVF FSR, W
000A  00A1     MOVWF 0x21
000B  080A     MOVF PCLATH, W
000C  00A2     MOVWF 0x22
000D  120A     BCF PCLATH, 0x4
000E  158A     BSF PCLATH, 0x3
000F  2C2D     GOTO 0x42D
0010  120A     BCF PCLATH, 0x4
0011  118A     BCF PCLATH, 0x3
0012  2813     GOTO 0x13
30:                if (ADIF && ADIE) {
0C2D  1F0C     BTFSS PIR1, 0x6
0C2E  2C50     GOTO 0x450
0C2F  1683     BSF STATUS, 0x5
0C30  1F0C     BTFSS PIR1, 0x6
0C31  2C50     GOTO 0x450
31:                    if (getADCChannel() == MIDECORRIENTE) {
0C32  27DE     CALL 0x7DE
0C33  120A     BCF PCLATH, 0x4
0C34  158A     BSF PCLATH, 0x3
0C35  3800     IORLW 0x0
0C36  1D03     BTFSS STATUS, 0x2
0C37  2C41     GOTO 0x441
32:                        medidaI_adc = adcRead();
0C38  279A     CALL 0x79A
0C39  120A     BCF PCLATH, 0x4
0C3A  158A     BSF PCLATH, 0x3
0C3B  0871     MOVF canal, W
0C3C  00AE     MOVWF sign
0C3D  0870     MOVF divisor, W
0C3E  00AD     MOVWF day
33:                        setADCChannel(MIDETENSION);
0C3F  3001     MOVLW 0x1
0C40  2C49     GOTO 0x449
34:                    } else {
35:                        medidaV_adc = adcRead();
0C41  279A     CALL 0x79A
0C42  120A     BCF PCLATH, 0x4
0C43  158A     BSF PCLATH, 0x3
0C44  0871     MOVF canal, W
0C45  00B0     MOVWF c
0C46  0870     MOVF divisor, W
0C47  00AF     MOVWF quotient
36:                        /*TODO debo realizar un promedio en las mediciones para filtrar las
37:                        variaciones rpidas de tensin*/
38:                        setADCChannel(MIDECORRIENTE);
0C48  3000     MOVLW 0x0
0C49  27F4     CALL 0x7F4
0C4A  120A     BCF PCLATH, 0x4
0C4B  158A     BSF PCLATH, 0x3
39:                    }
40:                    ADIF = 0;
0C4C  130C     BCF PIR1, 0x6
41:                    cambio_de_canal = 1;
0C4D  01E1     CLRF cambio_de_canal
0C4E  0AE1     INCF cambio_de_canal, F
42:                } else if (INTF && INTE) { // INTERRUPCION por EXT2 Clock Out --------------------------------------------
0C4F  2EC9     GOTO 0x6C9
0C50  188B     BTFSC INTCON, 0x1
0C51  1E0B     BTFSS INTCON, 0x4
0C52  2C60     GOTO 0x460
43:                    if (INTEDG == 1) {
0C53  1683     BSF STATUS, 0x5
0C54  1F01     BTFSS TMR0, 0x6
0C55  2C59     GOTO 0x459
44:                        //      ext_int_edge(2,H_TO_L);
45:                        INTEDG = 0;
0C56  1301     BCF TMR0, 0x6
46:                        flanco = 0;
0C57  01FC     CLRF flanco
47:                        //PORTEbits.RE0 = 1; //output_high(PIN_E0);
48:                    } else {
0C58  2C5C     GOTO 0x45C
49:                        //   ext_int_edge(2,L_TO_H);
50:                        INTEDG = 1;
0C59  1701     BSF TMR0, 0x6
51:                        flanco = 1;
0C5A  01FC     CLRF flanco
0C5B  0AFC     INCF flanco, F
52:                        // PORTEbits.RE0 = 0; //output_low(PIN_E0);
53:                        //      flanco=1;
54:            
55:                    }
56:                    refrescadisplay = 1;
0C5C  01BC     CLRF 0x3C
0C5D  0ABC     INCF 0x3C, F
57:                    INTF = 0;
0C5E  108B     BCF INTCON, 0x1
58:                } else if (T0IF && T0IE) {
0C5F  2EC9     GOTO 0x6C9
0C60  190B     BTFSC INTCON, 0x2
0C61  1E8B     BTFSS INTCON, 0x5
0C62  2EC9     GOTO 0x6C9
59:            
60:                    //Interrupcion por desborde del timer0. Tal como esta configurado, se el timer desborda cada
61:                    //0.003264seg o sea 3.264 ms, por lo tanto para que pase alrededor de 0.5segundo, se debe entrar 150 veces
62:                    //como con un unsigned int no funciona uso unsigned char y solo hasta 150
63:                    //cada 3ms realizamos una conversion analogica para obtener la medida de corriente
64:                    if (cambio_de_canal)
0C63  1283     BCF STATUS, 0x5
0C64  0861     MOVF cambio_de_canal, W
0C65  1903     BTFSC STATUS, 0x2
0C66  2C69     GOTO 0x469
65:                        cambio_de_canal = 0;
0C67  01E1     CLRF cambio_de_canal
0C68  2C6C     GOTO 0x46C
66:                    else
67:                        startADC();
0C69  27E5     CALL 0x7E5
0C6A  120A     BCF PCLATH, 0x4
0C6B  158A     BSF PCLATH, 0x3
68:                    if (cuenta40ms < 12) {
0C6C  300C     MOVLW 0xC
0C6D  0262     SUBWF cuenta40ms, W
0C6E  1803     BTFSC STATUS, 0x0
0C6F  2C72     GOTO 0x472
69:                        cuenta40ms++;
0C70  0AE2     INCF cuenta40ms, F
70:                    } else {
0C71  2CAD     GOTO 0x4AD
71:                        cuenta40ms = 0;
0C72  01E2     CLRF cuenta40ms
72:                        if (activapwmpor > 0) {
0C73  0860     MOVF activapwmpor, W
0C74  1903     BTFSC STATUS, 0x2
0C75  2C78     GOTO 0x478
73:                            activapwmpor--;
0C76  03E0     DECF activapwmpor, F
74:                        } else {
0C77  2C7C     GOTO 0x47C
75:                            buzzer_off();
0C78  27E7     CALL 0x7E7
0C79  120A     BCF PCLATH, 0x4
0C7A  158A     BSF PCLATH, 0x3
76:                            activapwmpor = 0;
0C7B  01E0     CLRF activapwmpor
77:                        }
78:                        if (cuenta500ms < 11) {
0C7C  300B     MOVLW 0xB
0C7D  0263     SUBWF cuenta500ms, W
0C7E  1803     BTFSC STATUS, 0x0
0C7F  2C82     GOTO 0x482
79:                            cuenta500ms++;
0C80  0AE3     INCF cuenta500ms, F
80:            
81:            
82:                        } else {
0C81  2CAD     GOTO 0x4AD
83:            
84:                            cuenta500ms = 0;
0C82  3000     MOVLW 0x0
0C83  01E3     CLRF cuenta500ms
85:                            flanco = !flanco;
0C82  3000     MOVLW 0x0
0C84  08FC     MOVF flanco, F
0C85  1903     BTFSC STATUS, 0x2
0C86  3001     MOVLW 0x1
0C87  00FC     MOVWF flanco
86:                            refrescadisplay = 1;
0C88  1683     BSF STATUS, 0x5
0C8A  01BC     CLRF 0x3C
0C8B  0ABC     INCF 0x3C, F
87:                            if (cuentasegundos < 60) {
0C89  303C     MOVLW 0x3C
0C8C  1283     BCF STATUS, 0x5
0C8D  0267     SUBWF cuentasegundos, W
0C8E  1803     BTFSC STATUS, 0x0
0C8F  2C92     GOTO 0x492
88:            
89:                                cuentasegundos++;
0C90  0AE7     INCF cuentasegundos, F
90:                            } else {
0C91  2CAD     GOTO 0x4AD
91:                                //TODO quitar esto en la version final
92:                                TRISDbits.TRISD3 = 0;
0C92  1683     BSF STATUS, 0x5
0C93  1188     BCF PORTD, 0x3
93:                                RD3 = !RD3; // PORTDbits.RD3 = !PORTDbits.RD3;
0C94  3008     MOVLW 0x8
0C95  1283     BCF STATUS, 0x5
0C96  0688     XORWF PORTD, F
94:                                cuentasegundos = 0;
0C98  01E7     CLRF cuentasegundos
95:                                if (cuentaminutos < 60) {
0C97  303C     MOVLW 0x3C
0C99  0266     SUBWF cuentaminutos, W
0C9A  1803     BTFSC STATUS, 0x0
0C9B  2C9E     GOTO 0x49E
96:                                    cuentaminutos++;
0C9C  0AE6     INCF cuentaminutos, F
97:                                } else {
0C9D  2CAD     GOTO 0x4AD
98:                                    cuentaminutos = 0;
0C9E  3018     MOVLW 0x18
0C9F  01E6     CLRF cuentaminutos
99:                                    if (cuentahoras < 24) {
0C9E  3018     MOVLW 0x18
0CA0  0265     SUBWF cuentahoras, W
0CA1  1803     BTFSC STATUS, 0x0
0CA2  2CA5     GOTO 0x4A5
100:                                       cuentahoras++;
0CA3  0AE5     INCF cuentahoras, F
101:                                   } else
0CA4  2CA6     GOTO 0x4A6
102:                                       cuentahoras = 0;
0CA5  01E5     CLRF cuentahoras
103:                                   if (cuentadias < 30) {
0CA6  301E     MOVLW 0x1E
0CA7  0264     SUBWF cuentadias, W
0CA8  1803     BTFSC STATUS, 0x0
0CA9  2CAC     GOTO 0x4AC
104:                                       cuentadias++;
0CAA  0AE4     INCF cuentadias, F
105:                                   } else {
0CAB  2CAD     GOTO 0x4AD
106:                                       cuentadias = 0;
0CAC  01E4     CLRF cuentadias
107:                                   }
108:                               }
109:           
110:                           }
111:                       }
112:                   }
113:                   static char maximodia;
114:                   if (Pulsacion(0, BOTON_Subir, CON_REPETICION, LOGICA_INVERSA)) {
0CAD  3000     MOVLW 0x0
0CAE  1906     BTFSC PORTB, 0x2
0CAF  3001     MOVLW 0x1
0CB0  00F5     MOVWF Pin
0CB1  3000     MOVLW 0x0
0CB2  01F6     CLRF TipoPin
0CB3  0AF6     INCF TipoPin, F
0CB4  01F7     CLRF Logica
0CB5  0AF7     INCF Logica, F
0CB6  26D4     CALL 0x6D4
0CB7  120A     BCF PCLATH, 0x4
0CB8  158A     BSF PCLATH, 0x3
0CB9  3A00     XORLW 0x0
0CBA  1903     BTFSC STATUS, 0x2
0CBB  2DA1     GOTO 0x5A1
115:           
116:                       refrescadisplay = 1;
0CBC  1683     BSF STATUS, 0x5
0CBD  1303     BCF STATUS, 0x6
0CBE  01BC     CLRF 0x3C
0CBF  0ABC     INCF 0x3C, F
117:                       switch (modificafecha) {
0800  120A     BCF PCLATH, 0x4
0801  158A     BSF PCLATH, 0x3
0802  2CD2     GOTO 0x4D2
0803  120A     BCF PCLATH, 0x4
0804  158A     BSF PCLATH, 0x3
0805  2CC1     GOTO 0x4C1
0806  120A     BCF PCLATH, 0x4
0807  158A     BSF PCLATH, 0x3
0808  2CEC     GOTO 0x4EC
0809  120A     BCF PCLATH, 0x4
080A  158A     BSF PCLATH, 0x3
080B  2CFA     GOTO 0x4FA
080C  120A     BCF PCLATH, 0x4
080D  158A     BSF PCLATH, 0x3
080E  2D08     GOTO 0x508
080F  120A     BCF PCLATH, 0x4
0810  158A     BSF PCLATH, 0x3
0811  2D53     GOTO 0x553
0812  120A     BCF PCLATH, 0x4
0813  158A     BSF PCLATH, 0x3
0814  2D17     GOTO 0x517
0815  120A     BCF PCLATH, 0x4
0816  158A     BSF PCLATH, 0x3
0817  2D1D     GOTO 0x51D
0818  120A     BCF PCLATH, 0x4
0819  158A     BSF PCLATH, 0x3
081A  2D2B     GOTO 0x52B
081B  120A     BCF PCLATH, 0x4
081C  158A     BSF PCLATH, 0x3
081D  2D39     GOTO 0x539
0CC0  2D46     GOTO 0x546
0D46  0869     MOVF fecha, W
0D47  0084     MOVWF FSR
0D48  300A     MOVLW 0xA
0D49  0204     SUBWF FSR, W
0D4A  1803     BTFSC STATUS, 0x0
0D4B  2D53     GOTO 0x553
0D4C  3008     MOVLW 0x8
0D4D  008A     MOVWF PCLATH
0D4E  1003     BCF STATUS, 0x0
0D4F  0D04     RLF FSR, W
0D50  0704     ADDWF FSR, W
0D51  3E00     ADDLW 0x0
0D52  0082     MOVWF PCL
118:                           case MINUTOS:
119:                               haycambio = 1;
0CC1  01B9     CLRF 0x39
0CC2  0AB9     INCF 0x39, F
120:                               if ((*horario).min < 59) (*horario).min++;
0CC3  0A7D     INCF horario, W
0CC4  0084     MOVWF FSR
0CC5  303B     MOVLW 0x3B
0CC6  1383     BCF STATUS, 0x7
0CC7  0200     SUBWF INDF, W
0CC8  0A7D     INCF horario, W
0CCA  1C03     BTFSS STATUS, 0x0
0CCB  2CDF     GOTO 0x4DF
121:                               else
122:                                   if ((*horario).min == 59) (*horario).min = 0;
0CC9  0084     MOVWF FSR
0CCC  0800     MOVF INDF, W
0CCD  3A3B     XORLW 0x3B
0CCE  1D03     BTFSS STATUS, 0x2
0CCF  2D53     GOTO 0x553
0CD0  0A7D     INCF horario, W
0CD1  2CE9     GOTO 0x4E9
123:                               break;
124:                           case HORA:
125:                               haycambio = 1;
0CD2  01B9     CLRF 0x39
0CD3  0AB9     INCF 0x39, F
126:                               if ((*horario).hrs < 23) (*horario).hrs++;
0CD4  087D     MOVF horario, W
0CD5  3E02     ADDLW 0x2
0CD6  0084     MOVWF FSR
0CD7  3017     MOVLW 0x17
0CD8  1383     BCF STATUS, 0x7
0CD9  0200     SUBWF INDF, W
0CDA  087D     MOVF horario, W
0CDB  1803     BTFSC STATUS, 0x0
0CDC  2CE1     GOTO 0x4E1
0CDD  3E02     ADDLW 0x2
0CDE  0084     MOVWF FSR
0CDF  0A80     INCF INDF, F
0CE0  2D53     GOTO 0x553
127:                               else
128:                                   if ((*horario).hrs == 23) (*horario).hrs = 0;
0CE1  3E02     ADDLW 0x2
0CE2  0084     MOVWF FSR
0CE3  0800     MOVF INDF, W
0CE4  3A17     XORLW 0x17
0CE5  1D03     BTFSS STATUS, 0x2
0CE6  2D53     GOTO 0x553
0CE7  087D     MOVF horario, W
0CE8  3E02     ADDLW 0x2
0CE9  0084     MOVWF FSR
0CEA  0180     CLRF INDF
0CEB  2D53     GOTO 0x553
129:                               break;
130:                           case DIA:
131:                               haycambio = 1;
0CEC  01B9     CLRF 0x39
0CED  0AB9     INCF 0x39, F
132:                               if (fecha.day < maximodia) fecha.day++;
0CEE  1283     BCF STATUS, 0x5
0CEF  0868     MOVF maximodia, W
0CF0  0269     SUBWF fecha, W
0CF1  1C03     BTFSS STATUS, 0x0
0CF2  2CF8     GOTO 0x4F8
133:                               else
134:                                   if (fecha.day == maximodia) fecha.day = 1;
0CF3  0869     MOVF fecha, W
0CF4  0668     XORWF maximodia, W
0CF5  1D03     BTFSS STATUS, 0x2
0CF6  2D53     GOTO 0x553
0CF7  01E9     CLRF fecha
0CF8  0AE9     INCF fecha, F
0CF9  2D53     GOTO 0x553
135:                               break;
136:                           case MES:
0CFA  300C     MOVLW 0xC
137:                               haycambio = 1;
0CFB  01B9     CLRF 0x39
0CFC  0AB9     INCF 0x39, F
138:                               if (fecha.month < 12) fecha.month++;
0CFA  300C     MOVLW 0xC
0CFD  1283     BCF STATUS, 0x5
0CFE  026A     SUBWF 0x6A, W
0CFF  1C03     BTFSS STATUS, 0x0
0D00  2D06     GOTO 0x506
139:                               else
140:                                   if (fecha.month == 12) fecha.month = 1;
0D01  086A     MOVF 0x6A, W
0D02  3A0C     XORLW 0xC
0D03  1D03     BTFSS STATUS, 0x2
0D04  2D53     GOTO 0x553
0D05  01EA     CLRF 0x6A
0D06  0AEA     INCF 0x6A, F
0D07  2D53     GOTO 0x553
141:                               break;
142:                           case ANIO:
0D08  3063     MOVLW 0x63
143:                               haycambio = 1;
0D09  01B9     CLRF 0x39
0D0A  0AB9     INCF 0x39, F
144:                               if (fecha.yr < 99) fecha.yr++; //solamente vamos hasta el ao 00
0D08  3063     MOVLW 0x63
0D0B  1283     BCF STATUS, 0x5
0D0C  026B     SUBWF 0x6B, W
0D0D  1803     BTFSC STATUS, 0x0
0D0E  2D11     GOTO 0x511
0D0F  0AEB     INCF 0x6B, F
0D10  2D53     GOTO 0x553
145:                               else
146:                                   if (fecha.yr == 99) fecha.yr = 0; //solamente contamos desde el ao 99
0D11  086B     MOVF 0x6B, W
0D12  3A63     XORLW 0x63
0D13  1D03     BTFSS STATUS, 0x2
0D14  2D53     GOTO 0x553
0D15  01EB     CLRF 0x6B
0D16  2D53     GOTO 0x553
147:                               break;
148:                           case SINO:
149:                               banderasino = !banderasino;
0D17  3000     MOVLW 0x0
0D18  08B4     MOVF sign, F
0D19  1903     BTFSC STATUS, 0x2
0D1A  3001     MOVLW 0x1
0D1B  00B4     MOVWF sign
150:                               break;
0D1C  2D53     GOTO 0x553
151:                           case TIEMPOENCENDIDO:
0D1D  303C     MOVLW 0x3C
152:                               haycambio = 1;
0D1E  01B9     CLRF 0x39
0D1F  0AB9     INCF 0x39, F
153:                               if (tiempoencendido < TIEMPOMAXIMOENCENDIDO) tiempoencendido++; //
0D1D  303C     MOVLW 0x3C
0D20  023D     SUBWF f1, W
0D21  1803     BTFSC STATUS, 0x0
0D22  2D25     GOTO 0x525
0D23  0ABD     INCF f1, F
0D24  2D53     GOTO 0x553
154:                               else
155:                                   if (tiempoencendido == TIEMPOMAXIMOENCENDIDO) tiempoencendido = 0;
0D25  083D     MOVF f1, W
0D26  3A3C     XORLW 0x3C
0D27  1D03     BTFSS STATUS, 0x2
0D28  2D53     GOTO 0x553
0D29  01BD     CLRF f1
0D2A  2D53     GOTO 0x553
156:                               break;
157:                           case TIEMPOFALLA:
0D2B  301E     MOVLW 0x1E
158:                               haycambio = 1;
0D2C  01B9     CLRF 0x39
0D2D  0AB9     INCF 0x39, F
159:                               if (tiempofalla < TIEMPOMAXIMOFALLA) tiempofalla++; //
0D2B  301E     MOVLW 0x1E
0D2E  023E     SUBWF 0x3E, W
0D2F  1803     BTFSC STATUS, 0x0
0D30  2D33     GOTO 0x533
0D31  0ABE     INCF 0x3E, F
0D32  2D53     GOTO 0x553
160:                               else
161:                                   if (tiempofalla == TIEMPOMAXIMOFALLA) tiempofalla = 0;
0D33  083E     MOVF 0x3E, W
0D34  3A1E     XORLW 0x1E
0D35  1D03     BTFSS STATUS, 0x2
0D36  2D53     GOTO 0x553
0D37  01BE     CLRF 0x3E
0D38  2D53     GOTO 0x553
162:                               break;
163:                           case PERIODOENCENDIDO:
0D39  3007     MOVLW 0x7
164:                               haycambio = 1;
0D3A  01B9     CLRF 0x39
0D3B  0AB9     INCF 0x39, F
165:                               if (periodoencendido < TIEMPOMAXIMOPERIODO) periodoencendido++; //
0D39  3007     MOVLW 0x7
0D3C  026A     SUBWF 0x6A, W
0D3D  1C03     BTFSS STATUS, 0x0
0D3E  2D44     GOTO 0x544
166:                               else
167:                                   if (periodoencendido == TIEMPOMAXIMOPERIODO) periodoencendido = 1;
0D3F  086A     MOVF 0x6A, W
0D40  3A07     XORLW 0x7
0D41  1D03     BTFSS STATUS, 0x2
0D42  2D53     GOTO 0x553
0D43  01EA     CLRF 0x6A
0D44  0AEA     INCF 0x6A, F
0D45  2D53     GOTO 0x553
168:                               break;
169:                           default:
170:                               break;
171:                       }
172:                       if (aniobisiesto(fecha.yr) && fecha.month == 2) {
0D53  1283     BCF STATUS, 0x5
0D54  086B     MOVF 0x6B, W
0D55  27A1     CALL 0x7A1
0D56  120A     BCF PCLATH, 0x4
0D57  158A     BSF PCLATH, 0x3
0D58  0877     MOVF Logica, W
0D59  0476     IORWF TipoPin, W
0D5A  1903     BTFSC STATUS, 0x2
0D5B  2D64     GOTO 0x564
0D5C  1283     BCF STATUS, 0x5
0D5D  1303     BCF STATUS, 0x6
0D5E  086A     MOVF 0x6A, W
0D5F  3A02     XORLW 0x2
0D60  1D03     BTFSS STATUS, 0x2
0D61  2D64     GOTO 0x564
173:                           maximodia = 29;
0D62  301D     MOVLW 0x1D
0D63  2D6B     GOTO 0x56B
174:                       } else if (fecha.month == 2)
0D64  1283     BCF STATUS, 0x5
0D65  1303     BCF STATUS, 0x6
0D66  086A     MOVF 0x6A, W
0D67  3A02     XORLW 0x2
0D68  1D03     BTFSS STATUS, 0x2
0D69  2D6C     GOTO 0x56C
175:                           maximodia = 28;
0D6A  301C     MOVLW 0x1C
0D6B  00E8     MOVWF maximodia
176:                       if (fecha.month == 4 || fecha.month == 6 || fecha.month == 9 || fecha.month == 11) {
0D6C  086A     MOVF 0x6A, W
0D6D  3A04     XORLW 0x4
0D6E  1903     BTFSC STATUS, 0x2
0D6F  2D7C     GOTO 0x57C
0D70  086A     MOVF 0x6A, W
0D71  3A06     XORLW 0x6
0D72  1903     BTFSC STATUS, 0x2
0D73  2D7C     GOTO 0x57C
0D74  086A     MOVF 0x6A, W
0D75  3A09     XORLW 0x9
0D76  1903     BTFSC STATUS, 0x2
0D77  2D7C     GOTO 0x57C
0D78  086A     MOVF 0x6A, W
0D79  3A0B     XORLW 0xB
0D7A  1D03     BTFSS STATUS, 0x2
0D7B  2D7E     GOTO 0x57E
177:                           maximodia = 30;
0D7C  301E     MOVLW 0x1E
0D7D  00E8     MOVWF maximodia
178:                       }
179:                       if (fecha.month == 1 || fecha.month == 3 || fecha.month == 5 || fecha.month == 7 || fecha.month == 8 || fecha.month == 10 || fecha.month == 12) {
0D7E  036A     DECF 0x6A, W
0D7F  1903     BTFSC STATUS, 0x2
0D80  2D99     GOTO 0x599
0D81  086A     MOVF 0x6A, W
0D82  3A03     XORLW 0x3
0D83  1903     BTFSC STATUS, 0x2
0D84  2D99     GOTO 0x599
0D85  086A     MOVF 0x6A, W
0D86  3A05     XORLW 0x5
0D87  1903     BTFSC STATUS, 0x2
0D88  2D99     GOTO 0x599
0D89  086A     MOVF 0x6A, W
0D8A  3A07     XORLW 0x7
0D8B  1903     BTFSC STATUS, 0x2
0D8C  2D99     GOTO 0x599
0D8D  086A     MOVF 0x6A, W
0D8E  3A08     XORLW 0x8
0D8F  1903     BTFSC STATUS, 0x2
0D90  2D99     GOTO 0x599
0D91  086A     MOVF 0x6A, W
0D92  3A0A     XORLW 0xA
0D93  1903     BTFSC STATUS, 0x2
0D94  2D99     GOTO 0x599
0D95  086A     MOVF 0x6A, W
0D96  3A0C     XORLW 0xC
0D97  1D03     BTFSS STATUS, 0x2
0D98  2D9B     GOTO 0x59B
180:                           maximodia = 31;
0D99  301F     MOVLW 0x1F
0D9A  00E8     MOVWF maximodia
181:                       }
182:                       if (fecha.day > maximodia)
0D9B  0869     MOVF fecha, W
0D9C  0268     SUBWF maximodia, W
0D9D  1803     BTFSC STATUS, 0x0
0D9E  2DA1     GOTO 0x5A1
183:                           fecha.day = maximodia;
0D9F  0868     MOVF maximodia, W
0DA0  00E9     MOVWF fecha
184:                   }
185:                   if (Pulsacion(1, BOTON_Bajar, CON_REPETICION, LOGICA_INVERSA)) {
0DA1  3000     MOVLW 0x0
0DA2  1283     BCF STATUS, 0x5
0DA3  1303     BCF STATUS, 0x6
0DA4  1886     BTFSC PORTB, 0x1
0DA5  3001     MOVLW 0x1
0DA6  00F5     MOVWF Pin
0DA7  3001     MOVLW 0x1
0DA8  01F6     CLRF TipoPin
0DA9  0AF6     INCF TipoPin, F
0DAA  01F7     CLRF Logica
0DAB  0AF7     INCF Logica, F
0DAC  26D4     CALL 0x6D4
0DAD  120A     BCF PCLATH, 0x4
0DAE  158A     BSF PCLATH, 0x3
0DAF  3A00     XORLW 0x0
0DB0  1903     BTFSC STATUS, 0x2
0DB1  2E96     GOTO 0x696
186:           
187:                       refrescadisplay = 1;
0DB2  1683     BSF STATUS, 0x5
0DB3  1303     BCF STATUS, 0x6
0DB4  01BC     CLRF 0x3C
0DB5  0ABC     INCF 0x3C, F
188:                       switch (modificafecha) {
081E  120A     BCF PCLATH, 0x4
081F  158A     BSF PCLATH, 0x3
0820  2DCA     GOTO 0x5CA
0821  120A     BCF PCLATH, 0x4
0822  158A     BSF PCLATH, 0x3
0823  2DB7     GOTO 0x5B7
0824  120A     BCF PCLATH, 0x4
0825  158A     BSF PCLATH, 0x3
0826  2DE4     GOTO 0x5E4
0827  120A     BCF PCLATH, 0x4
0828  158A     BSF PCLATH, 0x3
0829  2DF2     GOTO 0x5F2
082A  120A     BCF PCLATH, 0x4
082B  158A     BSF PCLATH, 0x3
082C  2E00     GOTO 0x600
082D  120A     BCF PCLATH, 0x4
082E  158A     BSF PCLATH, 0x3
082F  2E48     GOTO 0x648
0830  120A     BCF PCLATH, 0x4
0831  158A     BSF PCLATH, 0x3
0832  2E0E     GOTO 0x60E
0833  120A     BCF PCLATH, 0x4
0834  158A     BSF PCLATH, 0x3
0835  2E14     GOTO 0x614
0836  120A     BCF PCLATH, 0x4
0837  158A     BSF PCLATH, 0x3
0838  2E21     GOTO 0x621
0839  120A     BCF PCLATH, 0x4
083A  158A     BSF PCLATH, 0x3
083B  2E2E     GOTO 0x62E
0DB6  2E3B     GOTO 0x63B
0E3B  0869     MOVF fecha, W
0E3C  0084     MOVWF FSR
0E3D  300A     MOVLW 0xA
0E3E  0204     SUBWF FSR, W
0E3F  1803     BTFSC STATUS, 0x0
0E40  2E48     GOTO 0x648
0E41  3008     MOVLW 0x8
0E42  008A     MOVWF PCLATH
0E43  1003     BCF STATUS, 0x0
0E44  0D04     RLF FSR, W
0E45  0704     ADDWF FSR, W
0E46  3E1E     ADDLW 0x1E
0E47  0082     MOVWF PCL
189:                           case MINUTOS:
190:                               haycambio = 1;
0DB7  01B9     CLRF 0x39
0DB8  0AB9     INCF 0x39, F
191:                               if ((*horario).min > 0) (*horario).min--;
0DB9  0A7D     INCF horario, W
0DBA  0084     MOVWF FSR
0DBB  1383     BCF STATUS, 0x7
0DBC  0880     MOVF INDF, F
0DBD  1903     BTFSC STATUS, 0x2
0DBE  2DC1     GOTO 0x5C1
0DBF  0A7D     INCF horario, W
0DC0  2DD5     GOTO 0x5D5
192:                               else
193:                                   if ((*horario).min == 0) (*horario).min = 59;
0DC1  0A7D     INCF horario, W
0DC2  0084     MOVWF FSR
0DC3  0880     MOVF INDF, F
0DC4  1D03     BTFSS STATUS, 0x2
0DC5  2E48     GOTO 0x648
0DC6  0A7D     INCF horario, W
0DC7  0084     MOVWF FSR
0DC8  303B     MOVLW 0x3B
0DC9  2DE2     GOTO 0x5E2
194:                               break;
195:                           case HORA:
196:                               haycambio = 1;
0DCA  01B9     CLRF 0x39
0DCB  0AB9     INCF 0x39, F
197:                               if ((*horario).hrs > 0) (*horario).hrs--;
0DCC  087D     MOVF horario, W
0DCD  3E02     ADDLW 0x2
0DCE  0084     MOVWF FSR
0DCF  1383     BCF STATUS, 0x7
0DD0  0880     MOVF INDF, F
0DD1  1903     BTFSC STATUS, 0x2
0DD2  2DD8     GOTO 0x5D8
0DD3  087D     MOVF horario, W
0DD4  3E02     ADDLW 0x2
0DD5  0084     MOVWF FSR
0DD6  0380     DECF INDF, F
0DD7  2E48     GOTO 0x648
198:                               else
199:                                   if ((*horario).hrs == 0) (*horario).hrs = 23;
0DD8  087D     MOVF horario, W
0DD9  3E02     ADDLW 0x2
0DDA  0084     MOVWF FSR
0DDB  0880     MOVF INDF, F
0DDC  1D03     BTFSS STATUS, 0x2
0DDD  2E48     GOTO 0x648
0DDE  087D     MOVF horario, W
0DDF  3E02     ADDLW 0x2
0DE0  0084     MOVWF FSR
0DE1  3017     MOVLW 0x17
0DE2  0080     MOVWF INDF
0DE3  2E48     GOTO 0x648
200:                               break;
201:                           case DIA:
0DE4  3002     MOVLW 0x2
202:                               haycambio = 1;
0DE5  01B9     CLRF 0x39
0DE6  0AB9     INCF 0x39, F
203:                               if (fecha.day > 1) fecha.day--;
0DE4  3002     MOVLW 0x2
0DE7  1283     BCF STATUS, 0x5
0DE8  0269     SUBWF fecha, W
0DE9  1C03     BTFSS STATUS, 0x0
0DEA  2DED     GOTO 0x5ED
0DEB  03E9     DECF fecha, F
0DEC  2E48     GOTO 0x648
204:                               else
205:                                   if (fecha.day == 1) fecha.day = maximodia;
0DED  0B69     DECFSZ fecha, W
0DEE  2E48     GOTO 0x648
0DEF  0868     MOVF maximodia, W
0DF0  00E9     MOVWF fecha
0DF1  2E48     GOTO 0x648
206:                               break;
207:                           case MES:
0DF2  3002     MOVLW 0x2
208:                               haycambio = 1;
0DF3  01B9     CLRF 0x39
0DF4  0AB9     INCF 0x39, F
209:                               if (fecha.month > 1) fecha.month--;
0DF2  3002     MOVLW 0x2
0DF5  1283     BCF STATUS, 0x5
0DF6  026A     SUBWF 0x6A, W
0DF7  1C03     BTFSS STATUS, 0x0
0DF8  2DFB     GOTO 0x5FB
0DF9  03EA     DECF 0x6A, F
0DFA  2E48     GOTO 0x648
210:                               else
211:                                   if (fecha.month == 1) fecha.month = 12;
0DFB  0B6A     DECFSZ 0x6A, W
0DFC  2E48     GOTO 0x648
0DFD  300C     MOVLW 0xC
0DFE  00EA     MOVWF 0x6A
0DFF  2E48     GOTO 0x648
212:                               break;
213:                           case ANIO:
214:                               haycambio = 1;
0E00  01B9     CLRF 0x39
0E01  0AB9     INCF 0x39, F
215:                               if (fecha.yr > 0) fecha.yr--; //solamente vamos hasta el ao 00
0E02  1283     BCF STATUS, 0x5
0E03  086B     MOVF 0x6B, W
0E04  1903     BTFSC STATUS, 0x2
0E05  2E08     GOTO 0x608
0E06  03EB     DECF 0x6B, F
0E07  2E48     GOTO 0x648
216:                               else
217:                                   if (fecha.yr == 0) fecha.yr = 99; //solamente contamos desde el ao 99
0E08  08EB     MOVF 0x6B, F
0E09  1D03     BTFSS STATUS, 0x2
0E0A  2E48     GOTO 0x648
0E0B  3063     MOVLW 0x63
0E0C  00EB     MOVWF 0x6B
0E0D  2E48     GOTO 0x648
218:                               break;
219:                           case SINO:
220:                               banderasino = !banderasino;
0E0E  3000     MOVLW 0x0
0E0F  08B4     MOVF sign, F
0E10  1903     BTFSC STATUS, 0x2
0E11  3001     MOVLW 0x1
0E12  00B4     MOVWF sign
221:                               break;
0E13  2E48     GOTO 0x648
222:                           case TIEMPOENCENDIDO:
223:                               haycambio = 1;
0E14  01B9     CLRF 0x39
0E15  0AB9     INCF 0x39, F
224:                               if (tiempoencendido > 0) tiempoencendido--; //
0E16  083D     MOVF f1, W
0E17  1903     BTFSC STATUS, 0x2
0E18  2E1B     GOTO 0x61B
0E19  03BD     DECF f1, F
0E1A  2E48     GOTO 0x648
225:                               else
226:                                   if (tiempoencendido == 0) tiempoencendido = TIEMPOMAXIMOENCENDIDO;
0E1B  08BD     MOVF f1, F
0E1C  1D03     BTFSS STATUS, 0x2
0E1D  2E48     GOTO 0x648
0E1E  303C     MOVLW 0x3C
0E1F  00BD     MOVWF f1
0E20  2E48     GOTO 0x648
227:                               break;
228:                           case TIEMPOFALLA:
229:                               haycambio = 1;
0E21  01B9     CLRF 0x39
0E22  0AB9     INCF 0x39, F
230:                               if (tiempofalla > 0) tiempofalla--; //
0E23  083E     MOVF 0x3E, W
0E24  1903     BTFSC STATUS, 0x2
0E25  2E28     GOTO 0x628
0E26  03BE     DECF 0x3E, F
0E27  2E48     GOTO 0x648
231:                               else
232:                                   if (tiempofalla == 0) tiempofalla = TIEMPOMAXIMOFALLA;
0E28  08BE     MOVF 0x3E, F
0E29  1D03     BTFSS STATUS, 0x2
0E2A  2E48     GOTO 0x648
0E2B  301E     MOVLW 0x1E
0E2C  00BE     MOVWF 0x3E
0E2D  2E48     GOTO 0x648
233:                               break;
234:                           case PERIODOENCENDIDO:
0E2E  3002     MOVLW 0x2
235:                               haycambio = 1;
0E2F  01B9     CLRF 0x39
0E30  0AB9     INCF 0x39, F
236:                               if (periodoencendido > 1) periodoencendido--; //
0E2E  3002     MOVLW 0x2
0E31  026A     SUBWF 0x6A, W
0E32  1C03     BTFSS STATUS, 0x0
0E33  2E36     GOTO 0x636
0E34  03EA     DECF 0x6A, F
0E35  2E48     GOTO 0x648
237:                               else
238:                                   if (periodoencendido == 1) periodoencendido = TIEMPOMAXIMOPERIODO;
0E36  0B6A     DECFSZ 0x6A, W
0E37  2E48     GOTO 0x648
0E38  3007     MOVLW 0x7
0E39  00EA     MOVWF 0x6A
0E3A  2E48     GOTO 0x648
239:                               break;
240:                           default:
241:                               break;
242:                       }
243:                       if (aniobisiesto(fecha.yr) && fecha.month == 2) {
0E48  1283     BCF STATUS, 0x5
0E49  086B     MOVF 0x6B, W
0E4A  27A1     CALL 0x7A1
0E4B  120A     BCF PCLATH, 0x4
0E4C  158A     BSF PCLATH, 0x3
0E4D  0877     MOVF Logica, W
0E4E  0476     IORWF TipoPin, W
0E4F  1903     BTFSC STATUS, 0x2
0E50  2E59     GOTO 0x659
0E51  1283     BCF STATUS, 0x5
0E52  1303     BCF STATUS, 0x6
0E53  086A     MOVF 0x6A, W
0E54  3A02     XORLW 0x2
0E55  1D03     BTFSS STATUS, 0x2
0E56  2E59     GOTO 0x659
244:                           maximodia = 29;
0E57  301D     MOVLW 0x1D
0E58  2E60     GOTO 0x660
245:                       } else if (fecha.month == 2)
0E59  1283     BCF STATUS, 0x5
0E5A  1303     BCF STATUS, 0x6
0E5B  086A     MOVF 0x6A, W
0E5C  3A02     XORLW 0x2
0E5D  1D03     BTFSS STATUS, 0x2
0E5E  2E61     GOTO 0x661
246:                           maximodia = 28;
0E5F  301C     MOVLW 0x1C
0E60  00E8     MOVWF maximodia
247:                       if (fecha.month == 4 || fecha.month == 6 || fecha.month == 9 || fecha.month == 11) {
0E61  086A     MOVF 0x6A, W
0E62  3A04     XORLW 0x4
0E63  1903     BTFSC STATUS, 0x2
0E64  2E71     GOTO 0x671
0E65  086A     MOVF 0x6A, W
0E66  3A06     XORLW 0x6
0E67  1903     BTFSC STATUS, 0x2
0E68  2E71     GOTO 0x671
0E69  086A     MOVF 0x6A, W
0E6A  3A09     XORLW 0x9
0E6B  1903     BTFSC STATUS, 0x2
0E6C  2E71     GOTO 0x671
0E6D  086A     MOVF 0x6A, W
0E6E  3A0B     XORLW 0xB
0E6F  1D03     BTFSS STATUS, 0x2
0E70  2E73     GOTO 0x673
248:                           maximodia = 30;
0E71  301E     MOVLW 0x1E
0E72  00E8     MOVWF maximodia
249:                       }
250:                       if (fecha.month == 1 || fecha.month == 3 || fecha.month == 5 || fecha.month == 7 || fecha.month == 8 || fecha.month == 10 || fecha.month == 12) {
0E73  036A     DECF 0x6A, W
0E74  1903     BTFSC STATUS, 0x2
0E75  2E8E     GOTO 0x68E
0E76  086A     MOVF 0x6A, W
0E77  3A03     XORLW 0x3
0E78  1903     BTFSC STATUS, 0x2
0E79  2E8E     GOTO 0x68E
0E7A  086A     MOVF 0x6A, W
0E7B  3A05     XORLW 0x5
0E7C  1903     BTFSC STATUS, 0x2
0E7D  2E8E     GOTO 0x68E
0E7E  086A     MOVF 0x6A, W
0E7F  3A07     XORLW 0x7
0E80  1903     BTFSC STATUS, 0x2
0E81  2E8E     GOTO 0x68E
0E82  086A     MOVF 0x6A, W
0E83  3A08     XORLW 0x8
0E84  1903     BTFSC STATUS, 0x2
0E85  2E8E     GOTO 0x68E
0E86  086A     MOVF 0x6A, W
0E87  3A0A     XORLW 0xA
0E88  1903     BTFSC STATUS, 0x2
0E89  2E8E     GOTO 0x68E
0E8A  086A     MOVF 0x6A, W
0E8B  3A0C     XORLW 0xC
0E8C  1D03     BTFSS STATUS, 0x2
0E8D  2E90     GOTO 0x690
251:                           maximodia = 31;
0E8E  301F     MOVLW 0x1F
0E8F  00E8     MOVWF maximodia
252:                       }
253:                       if (fecha.day > maximodia)
0E90  0869     MOVF fecha, W
0E91  0268     SUBWF maximodia, W
0E92  1803     BTFSC STATUS, 0x0
0E93  2E96     GOTO 0x696
254:                           fecha.day = maximodia;
0E94  0868     MOVF maximodia, W
0E95  00E9     MOVWF fecha
255:                   }
256:           
257:           
258:                   bandera_startglobal = 0;
0E96  1683     BSF STATUS, 0x5
0E97  1303     BCF STATUS, 0x6
0E99  01B3     CLRF dividend
259:                   if (Pulsacion(3, BOTON_ONOFF, INMEDIATO, LOGICA_INVERSA)) {
0E98  3000     MOVLW 0x0
0E9A  1283     BCF STATUS, 0x5
0E9B  1A86     BTFSC PORTB, 0x5
0E9C  3001     MOVLW 0x1
0E9D  00F5     MOVWF Pin
0E9E  3002     MOVLW 0x2
0E9F  00F6     MOVWF TipoPin
0EA0  3003     MOVLW 0x3
0EA1  01F7     CLRF Logica
0EA2  0AF7     INCF Logica, F
0EA3  26D4     CALL 0x6D4
0EA4  120A     BCF PCLATH, 0x4
0EA5  158A     BSF PCLATH, 0x3
0EA6  3A00     XORLW 0x0
0EA7  1903     BTFSC STATUS, 0x2
0EA8  2EAD     GOTO 0x6AD
260:           
261:                       bandera_startglobal = 1;
0EA9  1683     BSF STATUS, 0x5
0EAA  1303     BCF STATUS, 0x6
0EAB  01B3     CLRF dividend
0EAC  0AB3     INCF dividend, F
262:                   }
263:           
264:                   if (Pulsacion(4, BOTON_MENU, SIN_REPETICION, LOGICA_INVERSA)) {
0EAD  3000     MOVLW 0x0
0EAE  1283     BCF STATUS, 0x5
0EAF  1303     BCF STATUS, 0x6
0EB0  1986     BTFSC PORTB, 0x3
0EB1  3001     MOVLW 0x1
0EB2  00F5     MOVWF Pin
0EB3  3004     MOVLW 0x4
0EB4  01F6     CLRF TipoPin
0EB5  01F7     CLRF Logica
0EB6  0AF7     INCF Logica, F
0EB7  26D4     CALL 0x6D4
0EB8  120A     BCF PCLATH, 0x4
0EB9  158A     BSF PCLATH, 0x3
0EBA  3A00     XORLW 0x0
0EBB  1903     BTFSC STATUS, 0x2
0EBC  2EC8     GOTO 0x6C8
265:           
266:                       buzzer_on();
0EBD  27EB     CALL 0x7EB
0EBE  120A     BCF PCLATH, 0x4
0EBF  158A     BSF PCLATH, 0x3
267:                       if (menuactual < ULTIMOMENU)
0EC0  3011     MOVLW 0x11
0EC1  1683     BSF STATUS, 0x5
0EC2  023B     SUBWF 0x3B, W
0EC3  1803     BTFSC STATUS, 0x0
0EC4  2EC7     GOTO 0x6C7
268:                           menuactual++;
0EC5  0ABB     INCF 0x3B, F
0EC6  2EC8     GOTO 0x6C8
269:                       else
270:                           menuactual = 0;
0EC7  01BB     CLRF 0x3B
271:                   }
272:                   T0IF = 0;
0EC8  110B     BCF INTCON, 0x2
273:               } else {
274:                   ///interrupciones no contempladas
275:               }
276:           
277:               /* This code stub shows general interrupt handling.  Note that these
278:               conditional statements are not handled within 3 seperate if blocks.
279:               Do not use a seperate if block for each interrupt flag to avoid run
280:               time errors. */
281:           
282:           #if 0
283:           
284:               /* Add interrupt routine code here. */
285:           
286:               /* Determine which flag generated the interrupt */
287:               if (<Interrupt Flag 1 >) {
288:                   <Interrupt Flag 1 = 0 >; /* Clear Interrupt Flag 1 */
289:               } else if (<Interrupt Flag 2 >) {
290:                   <Interrupt Flag 2 = 0 >; /* Clear Interrupt Flag 2 */
291:               } else {
292:                   /* Unhandled interrupts */
293:               }
294:           
295:           #endif
296:           
297:           }
0EC9  1283     BCF STATUS, 0x5
298:           #endif
299:           
300:           
301:           #endif
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/adcPic16.c  ---------------------------
1:             #include <xc.h>
2:             #include <stdint.h>
3:             #include <stdbool.h>
4:             #include "system.h"
5:             #include "user.h"
6:             #include "adcPic16.h"
7:             
8:             void setADCChannel(char canal) {
07F2  1283     BCF STATUS, 0x5
07F3  00A4     MOVWF dato
0FF4  00F1     MOVWF canal
9:                 ADCON0bits.CHS = canal; //Selecciono el canal AD0
07F4  00A3     MOVWF x
07F5  0DA3     RLF x, F
07F6  0DA3     RLF x, F
07F7  0DA3     RLF x, F
07F8  081F     MOVF ADCON0, W
07F9  0623     XORWF x, W
07FA  39C7     ANDLW 0xC7
07FB  0623     XORWF x, W
07FC  009F     MOVWF ADCON0
0FF5  00F0     MOVWF divisor
0FF6  0DF0     RLF divisor, F
0FF7  0DF0     RLF divisor, F
0FF8  0DF0     RLF divisor, F
0FF9  1283     BCF STATUS, 0x5
0FFA  081F     MOVF ADCON0, W
0FFB  0670     XORWF divisor, W
0FFC  39C7     ANDLW 0xC7
0FFD  0670     XORWF divisor, W
0FFE  009F     MOVWF ADCON0
10:            };
07FD  0008     RETURN
07FE  3FFF     ADDLW 0xFF
07FF  3FFF     ADDLW 0xFF
0FFF  0008     RETURN
11:            
12:            char getADCChannel(void) {
13:                return ADCON0bits.CHS; //Selecciono el canal AD0
0FDE  1283     BCF STATUS, 0x5
0FDF  0C1F     RRF ADCON0, W
0FE0  00F0     MOVWF divisor
0FE1  0CF0     RRF divisor, F
0FE2  0C70     RRF divisor, W
0FE3  3907     ANDLW 0x7
14:            };
0FE4  0008     RETURN
15:            
16:            void openADC(void) {
17:            
18:                TRISA0 = 1; //configuro como entrada para el ADC0
0855  1683     BSF STATUS, 0x5
0856  1303     BCF STATUS, 0x6
0857  1405     BSF PORTA, 0x0
19:                TRISA1 = 1; //configuro como entrada para el ADC1
0858  1485     BSF PORTA, 0x1
20:                TRISA3 = 1; //Configuro como entrada para Vref+
0859  1585     BSF PORTA, 0x3
21:                TRISA2 = 0; //No usado
085A  1105     BCF PORTA, 0x2
22:                TRISA4 = 0;//No usado
085B  1205     BCF PORTA, 0x4
23:                TRISA5 = 0;//No usado
085C  1285     BCF PORTA, 0x5
24:                ADCON1bits.PCFG = 0b101; //An3 como VREF+ , AN0 y AN1 como entrada analogica, AN0 Corriente, AN1 Tension de red
085D  081F     MOVF ADCON0, W
085E  39F0     ANDLW 0xF0
085F  3805     IORLW 0x5
0860  009F     MOVWF ADCON0
25:                ADCON1bits.ADFM = 1; //justificado a la derecha
0861  179F     BSF ADCON0, 0x7
26:                ADCON1bits.ADCS2 = 1;
0862  171F     BSF ADCON0, 0x6
27:                ADCON0bits.ADCS = 0b10; //Tosc/64
0863  1283     BCF STATUS, 0x5
0864  081F     MOVF ADCON0, W
0865  393F     ANDLW 0x3F
0866  3880     IORLW 0x80
0867  009F     MOVWF ADCON0
28:                ADCON0bits.ADON = 1; //Activo el ADC
0868  141F     BSF ADCON0, 0x0
29:            
30:            }
0869  0008     RETURN
31:            
32:            unsigned int adcRead(void) {
33:            
34:                return ((unsigned int) ADRESH << 8) | ADRESL;
0F9A  081E     MOVF ADRESH, W
0F9B  00F1     MOVWF canal
0F9C  01F0     CLRF divisor
0F9D  1683     BSF STATUS, 0x5
0F9E  081E     MOVF ADRESH, W
0F9F  04F0     IORWF divisor, F
35:            }
0FA0  0008     RETURN
36:            
37:            void startADC(void) {
38:                ADCON0bits.GO_DONE = 1;
0FE5  151F     BSF ADCON0, 0x2
39:            }
0FE6  0008     RETURN
40:            
41:            void interruptADC_on(void) {
42:                ADIE = 1;
125F  1683     BSF STATUS, 0x5
1260  1303     BCF STATUS, 0x6
1261  170C     BSF PIR1, 0x6
43:            }
1262  0008     RETURN
44:            
45:            void interruptADC_off(void) {
46:                ADIE = 0;
47:            }
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/_isl1208.c  ---------------------------
1:             ////////////////////////////////////////////////////////////////////////////////////////
2:             ///                               isl1208.C                                          ///
3:             ///                     Driver for Real Time Clock                                   ///
4:             ///                     modified by Pablo Fernando Manieri - Enero 2015              ///
5:             ///                                                                                  ///
6:             /// bool ISL1208_ready(void) - Testea si el RTC est presente                        ///
7:             /// void isl1208_init(val)                                                           ///
8:             ///                  - Enable oscillator without clearing the seconds register       ///
9:             ///                    used when PIC loses power and isl1208 run from 3V BAT         ///
10:            ///                  - Config Control Register with next parameters:                 ///
11:            ///                     isl1208_ALL_DISABLED          All disabled                   ///
12:            ///                     isl1208_OUT_ON_DISABLED_HIHG  Out to Hight on Disable Out    ///
13:            ///                     isl1208_OUT_ENABLED           Out Enabled                    ///
14:            ///                     isl1208_OUT_1_HZ              Freq. Out to 1 Hz              ///
15:            ///                     isl1208_OUT_4_KHZ             Freq. Out to 4.096 Khz         ///
16:            ///                     isl1208_OUT_8_KHZ             Freq. Out to 8.192 Khz         ///
17:            ///                     isl1208_OUT_32_KHZ            Freq. Out to 32.768 Khz        ///
18:            ///                                                                                  ///
19:            ///                     Example init:                                                ///
20:            ///                     isl1208_init(isl1208_ALL_DISABLED);                          ///
21:            ///                     isl1208_init(isl1208_OUT_ENABLED | isl1208_OUT_1_HZ);        ///
22:            ///                                                                                  ///
23:            /// void isl1208_set_date_time(day,mth,year,dow,hour,min,sec) - Set the date/time    ///
24:            ///                                                                                  ///
25:            /// void isl1208_get_date(day,mth,year,dow) - Get the date                           ///
26:            ///                                                                                  ///
27:            /// void isl1208_get_time(hr,min,sec) - Get the time                                 ///
28:            ///                                                                                  ///
29:            /// char isl1208_read_nvram_unsigned char(char addr) - Read unsigned char in address ///
30:            ///                                                                                  ///
31:            /// void isl1208_write_nvram_unsigned char(char addr, char value) - Write unsigned   ///
32:            ///                                                                  char in address ///
33:            ///                                                                                  ///
34:            /// void isl1208_get_day_of_week(char* ptr) - Get string Day Of Week                 ///
35:            ///                                                                                  ///
36:            ///                                                                                  ///
37:            ////////////////////////////////////////////////////////////////////////////////////////
38:            
39:            #include <xc.h>
40:            #include <stdio.h>
41:            #include <stdbool.h>       /* For true/false definition */
42:            #include "system.h"        /* System funct/params, like osc/peripheral config */
43:            #include "HardI2C.h"
44:            #include "_isl1208.h"
45:            #include "user.h"
46:            
47:            bool ISL1208_ready(void) {
48:                bool ack;
49:            
50:                start_i2c(); // If the write command is acknowledged,
0963  235E     CALL 0x35E
0964  120A     BCF PCLATH, 0x4
0965  158A     BSF PCLATH, 0x3
51:                ack = write_i2c(isl1208_Write); // then the device is ready.
0966  30DE     MOVLW 0xDE
0967  2334     CALL 0x334
0968  120A     BCF PCLATH, 0x4
0969  158A     BSF PCLATH, 0x3
096A  1283     BCF STATUS, 0x5
096B  00A4     MOVWF dato
52:                stop_i2c();
096C  2366     CALL 0x366
53:                return !ack; // Invert ACK returned so TRUE = ACK OK
096D  1283     BCF STATUS, 0x5
096E  3000     MOVLW 0x0
096F  08A4     MOVF dato, F
0970  1903     BTFSC STATUS, 0x2
0971  3001     MOVLW 0x1
54:            }
0972  0008     RETURN
55:            
56:            unsigned char ISL1208_Read_status(void) {
57:                char SR;
58:                start_i2c(); // If the write command is acknowledged,
0973  235E     CALL 0x35E
0974  120A     BCF PCLATH, 0x4
0975  158A     BSF PCLATH, 0x3
59:                write_i2c(isl1208_Write); // then the device is ready.
0976  30DE     MOVLW 0xDE
0977  2334     CALL 0x334
0978  120A     BCF PCLATH, 0x4
0979  158A     BSF PCLATH, 0x3
60:                write_i2c(0x07);
097A  3007     MOVLW 0x7
097B  2334     CALL 0x334
097C  120A     BCF PCLATH, 0x4
097D  158A     BSF PCLATH, 0x3
61:                rstart_i2c(); 
097E  23A2     CALL 0x3A2
097F  120A     BCF PCLATH, 0x4
0980  158A     BSF PCLATH, 0x3
62:                write_i2c(isl1208_Read);
0981  30DF     MOVLW 0xDF
0982  2334     CALL 0x334
0983  120A     BCF PCLATH, 0x4
0984  158A     BSF PCLATH, 0x3
63:                SR = read_i2c(NOACK);
0985  3001     MOVLW 0x1
0986  236E     CALL 0x36E
0987  120A     BCF PCLATH, 0x4
0988  158A     BSF PCLATH, 0x3
0989  00A5     MOVWF y
64:                stop_i2c();
098A  2366     CALL 0x366
65:                return SR;
098B  1283     BCF STATUS, 0x5
098C  0825     MOVF y, W
66:            }
098D  0008     RETURN
67:            
68:            void isl1208_init(unsigned char val) {
69:            
70:                unsigned char seconds = 0;
71:            
72:            #ifndef USE_INTERRUPTS
73:                //di();
74:            #endif
75:                //TODO Verificar secuencia correcta para pode escribir en el ISL1208
76:                
77:            #ifndef USE_INTERRUPTS
78:                //ei();
79:            #endif
80:            
81:            }
82:            
83:            void isl1208_set_time(unsigned char hr, unsigned char min, unsigned char sec) {
0AAD  00AC     MOVWF hr
84:            
85:            #ifndef USE_INTERRUPTS
86:                //di();
87:            #endif
88:            
89:                sec &= 0x7F;
0AAF  13AB     BCF sec, 0x7
90:                min &= 0x7F;
0AB0  13AA     BCF Data, 0x7
91:                hr &= 0x3F;
0AAE  303F     MOVLW 0x3F
0AB1  05AC     ANDWF hr, F
92:                start_i2c();
0AB2  235E     CALL 0x35E
0AB3  120A     BCF PCLATH, 0x4
0AB4  158A     BSF PCLATH, 0x3
93:                write_i2c(isl1208_Write);
0AB5  30DE     MOVLW 0xDE
0AB6  2334     CALL 0x334
0AB7  120A     BCF PCLATH, 0x4
0AB8  158A     BSF PCLATH, 0x3
94:                write_i2c(0x07);
0AB9  3007     MOVLW 0x7
0ABA  2334     CALL 0x334
0ABB  120A     BCF PCLATH, 0x4
0ABC  158A     BSF PCLATH, 0x3
95:                write_i2c(0b00010000);
0ABD  3010     MOVLW 0x10
0ABE  2334     CALL 0x334
0ABF  120A     BCF PCLATH, 0x4
0AC0  158A     BSF PCLATH, 0x3
96:                stop_i2c();
0AC1  2366     CALL 0x366
0AC2  120A     BCF PCLATH, 0x4
0AC3  158A     BSF PCLATH, 0x3
97:                start_i2c();
0AC4  235E     CALL 0x35E
0AC5  120A     BCF PCLATH, 0x4
0AC6  158A     BSF PCLATH, 0x3
98:                write_i2c(isl1208_Write);
0AC7  30DE     MOVLW 0xDE
0AC8  2334     CALL 0x334
0AC9  120A     BCF PCLATH, 0x4
0ACA  158A     BSF PCLATH, 0x3
99:                write_i2c(0x00);
0ACB  3000     MOVLW 0x0
0ACC  2334     CALL 0x334
0ACD  120A     BCF PCLATH, 0x4
0ACE  158A     BSF PCLATH, 0x3
100:               write_i2c(isl1208_bin2bcd(sec));
0ACF  1283     BCF STATUS, 0x5
0AD0  082B     MOVF sec, W
0AD1  234C     CALL 0x34C
0AD2  120A     BCF PCLATH, 0x4
0AD3  158A     BSF PCLATH, 0x3
0AD4  2334     CALL 0x334
0AD5  120A     BCF PCLATH, 0x4
0AD6  158A     BSF PCLATH, 0x3
101:               write_i2c(isl1208_bin2bcd(min));
0AD7  1283     BCF STATUS, 0x5
0AD8  082A     MOVF Data, W
0AD9  234C     CALL 0x34C
0ADA  120A     BCF PCLATH, 0x4
0ADB  158A     BSF PCLATH, 0x3
0ADC  2334     CALL 0x334
0ADD  120A     BCF PCLATH, 0x4
0ADE  158A     BSF PCLATH, 0x3
102:               write_i2c(isl1208_bin2bcd(hr) | 0b10000000);
0ADF  1283     BCF STATUS, 0x5
0AE0  082C     MOVF hr, W
0AE1  234C     CALL 0x34C
0AE2  120A     BCF PCLATH, 0x4
0AE3  158A     BSF PCLATH, 0x3
0AE4  3880     IORLW 0x80
0AE5  2334     CALL 0x334
0AE6  120A     BCF PCLATH, 0x4
0AE7  158A     BSF PCLATH, 0x3
103:               stop_i2c();
0AE8  2B66     GOTO 0x366
104:           
105:           #ifndef USE_INTERRUPTS
106:               //  ei();
107:           #endif
108:           
109:           }
110:           
111:           void isl1208_set_date(unsigned char* day, unsigned char* mth, unsigned char* year, unsigned char* dow) {
0AE9  00AD     MOVWF day
112:           
113:           #ifndef USE_INTERRUPTS
114:               //di();
115:           #endif
116:           
117:               start_i2c();
0AEA  235E     CALL 0x35E
0AEB  120A     BCF PCLATH, 0x4
0AEC  158A     BSF PCLATH, 0x3
118:               write_i2c(isl1208_Write);
0AED  30DE     MOVLW 0xDE
0AEE  2334     CALL 0x334
0AEF  120A     BCF PCLATH, 0x4
0AF0  158A     BSF PCLATH, 0x3
119:               write_i2c(0x07);
0AF1  3007     MOVLW 0x7
0AF2  2334     CALL 0x334
0AF3  120A     BCF PCLATH, 0x4
0AF4  158A     BSF PCLATH, 0x3
120:               write_i2c(0b00010000);
0AF5  3010     MOVLW 0x10
0AF6  2334     CALL 0x334
0AF7  120A     BCF PCLATH, 0x4
0AF8  158A     BSF PCLATH, 0x3
121:               stop_i2c();
0AF9  2366     CALL 0x366
0AFA  120A     BCF PCLATH, 0x4
0AFB  158A     BSF PCLATH, 0x3
122:               start_i2c();
0AFC  235E     CALL 0x35E
0AFD  120A     BCF PCLATH, 0x4
0AFE  158A     BSF PCLATH, 0x3
123:               write_i2c(isl1208_Write);
0AFF  30DE     MOVLW 0xDE
0B00  2334     CALL 0x334
0B01  120A     BCF PCLATH, 0x4
0B02  158A     BSF PCLATH, 0x3
124:               write_i2c(0x03);
0B03  3003     MOVLW 0x3
0B04  2334     CALL 0x334
0B05  120A     BCF PCLATH, 0x4
0B06  158A     BSF PCLATH, 0x3
125:               write_i2c(isl1208_bin2bcd(*day));
0B07  1283     BCF STATUS, 0x5
0B08  082D     MOVF day, W
0B09  0084     MOVWF FSR
0B0A  1383     BCF STATUS, 0x7
0B0B  0800     MOVF INDF, W
0B0C  234C     CALL 0x34C
0B0D  120A     BCF PCLATH, 0x4
0B0E  158A     BSF PCLATH, 0x3
0B0F  2334     CALL 0x334
0B10  120A     BCF PCLATH, 0x4
0B11  158A     BSF PCLATH, 0x3
126:               write_i2c(isl1208_bin2bcd(*mth));
0B12  1283     BCF STATUS, 0x5
0B13  082A     MOVF Data, W
0B14  0084     MOVWF FSR
0B15  1383     BCF STATUS, 0x7
0B16  0800     MOVF INDF, W
0B17  234C     CALL 0x34C
0B18  120A     BCF PCLATH, 0x4
0B19  158A     BSF PCLATH, 0x3
0B1A  2334     CALL 0x334
0B1B  120A     BCF PCLATH, 0x4
0B1C  158A     BSF PCLATH, 0x3
127:               write_i2c(isl1208_bin2bcd(*year));
0B1D  1283     BCF STATUS, 0x5
0B1E  082B     MOVF sec, W
0B1F  0084     MOVWF FSR
0B20  1383     BCF STATUS, 0x7
0B21  0800     MOVF INDF, W
0B22  234C     CALL 0x34C
0B23  120A     BCF PCLATH, 0x4
0B24  158A     BSF PCLATH, 0x3
0B25  2334     CALL 0x334
0B26  120A     BCF PCLATH, 0x4
0B27  158A     BSF PCLATH, 0x3
128:               write_i2c(isl1208_bin2bcd(*dow));
0B28  1283     BCF STATUS, 0x5
0B29  082C     MOVF hr, W
0B2A  0084     MOVWF FSR
0B2B  1383     BCF STATUS, 0x7
0B2C  0800     MOVF INDF, W
0B2D  234C     CALL 0x34C
0B2E  120A     BCF PCLATH, 0x4
0B2F  158A     BSF PCLATH, 0x3
0B30  2334     CALL 0x334
0B31  120A     BCF PCLATH, 0x4
0B32  158A     BSF PCLATH, 0x3
129:               stop_i2c();
0B33  2B66     GOTO 0x366
130:           
131:           #ifndef USE_INTERRUPTS
132:               //  ei();
133:           #endif
134:           
135:           }
136:           
137:           void isl1208_get_date(unsigned char* day, unsigned char* mth, unsigned char* year, unsigned char *dow) {
0A22  00AB     MOVWF sec
138:           
139:           #ifndef USE_INTERRUPTS
140:               // di();
141:           #endif
142:           
143:               start_i2c();
0A23  235E     CALL 0x35E
0A24  120A     BCF PCLATH, 0x4
0A25  158A     BSF PCLATH, 0x3
144:               write_i2c(isl1208_Write);
0A26  30DE     MOVLW 0xDE
0A27  2334     CALL 0x334
0A28  120A     BCF PCLATH, 0x4
0A29  158A     BSF PCLATH, 0x3
145:               write_i2c(0x03);
0A2A  3003     MOVLW 0x3
0A2B  2334     CALL 0x334
0A2C  120A     BCF PCLATH, 0x4
0A2D  158A     BSF PCLATH, 0x3
146:               rstart_i2c();
0A2E  23A2     CALL 0x3A2
0A2F  120A     BCF PCLATH, 0x4
0A30  158A     BSF PCLATH, 0x3
147:               write_i2c(isl1208_Read);
0A31  30DF     MOVLW 0xDF
0A32  2334     CALL 0x334
0A33  120A     BCF PCLATH, 0x4
0A34  158A     BSF PCLATH, 0x3
148:               *day = isl1208_bcd2bin(read_i2c(ACK) & 0x3f);
0A35  1283     BCF STATUS, 0x5
0A36  082B     MOVF sec, W
0A37  0084     MOVWF FSR
0A38  3000     MOVLW 0x0
0A39  236E     CALL 0x36E
0A3A  120A     BCF PCLATH, 0x4
0A3B  158A     BSF PCLATH, 0x3
0A3C  393F     ANDLW 0x3F
0A3D  2398     CALL 0x398
0A3E  120A     BCF PCLATH, 0x4
0A3F  158A     BSF PCLATH, 0x3
0A40  1383     BCF STATUS, 0x7
0A41  0080     MOVWF INDF
149:               *mth = isl1208_bcd2bin(read_i2c(ACK) & 0x1f);
0A42  0828     MOVF mth, W
0A43  0084     MOVWF FSR
0A44  3000     MOVLW 0x0
0A45  236E     CALL 0x36E
0A46  120A     BCF PCLATH, 0x4
0A47  158A     BSF PCLATH, 0x3
0A48  391F     ANDLW 0x1F
0A49  2398     CALL 0x398
0A4A  120A     BCF PCLATH, 0x4
0A4B  158A     BSF PCLATH, 0x3
0A4C  1383     BCF STATUS, 0x7
0A4D  0080     MOVWF INDF
150:               *year = isl1208_bcd2bin(read_i2c(ACK));
0A4E  0829     MOVF year, W
0A4F  0084     MOVWF FSR
0A50  3000     MOVLW 0x0
0A51  236E     CALL 0x36E
0A52  120A     BCF PCLATH, 0x4
0A53  158A     BSF PCLATH, 0x3
0A54  2398     CALL 0x398
0A55  120A     BCF PCLATH, 0x4
0A56  158A     BSF PCLATH, 0x3
0A57  1383     BCF STATUS, 0x7
0A58  0080     MOVWF INDF
151:               *dow = isl1208_bcd2bin(read_i2c(NOACK) & 0x07);
0A59  082A     MOVF Data, W
0A5A  0084     MOVWF FSR
0A5B  3001     MOVLW 0x1
0A5C  236E     CALL 0x36E
0A5D  120A     BCF PCLATH, 0x4
0A5E  158A     BSF PCLATH, 0x3
0A5F  3907     ANDLW 0x7
0A60  2398     CALL 0x398
0A61  120A     BCF PCLATH, 0x4
0A62  158A     BSF PCLATH, 0x3
0A63  1383     BCF STATUS, 0x7
0A64  0080     MOVWF INDF
152:               stop_i2c();
0A65  2B66     GOTO 0x366
153:           #ifndef USE_INTERRUPTS
154:               // ei();
155:           #endif
156:           
157:           }
158:           
159:           void isl1208_get_time(unsigned char *hr, unsigned char* min, unsigned char *sec) {
09B0  00AA     MOVWF Data
160:           
161:           #ifndef USE_INTERRUPTS
162:               // di();
163:           #endif
164:           
165:               start_i2c();
09B1  235E     CALL 0x35E
09B2  120A     BCF PCLATH, 0x4
09B3  158A     BSF PCLATH, 0x3
166:               write_i2c(isl1208_Write);
09B4  30DE     MOVLW 0xDE
09B5  2334     CALL 0x334
09B6  120A     BCF PCLATH, 0x4
09B7  158A     BSF PCLATH, 0x3
167:               write_i2c(0x00);
09B8  3000     MOVLW 0x0
09B9  2334     CALL 0x334
09BA  120A     BCF PCLATH, 0x4
09BB  158A     BSF PCLATH, 0x3
168:           
169:               rstart_i2c();
09BC  23A2     CALL 0x3A2
09BD  120A     BCF PCLATH, 0x4
09BE  158A     BSF PCLATH, 0x3
170:               write_i2c(isl1208_Read);
09BF  30DF     MOVLW 0xDF
09C0  2334     CALL 0x334
09C1  120A     BCF PCLATH, 0x4
09C2  158A     BSF PCLATH, 0x3
171:               *sec = isl1208_bcd2bin(read_i2c(ACK) & 0x7f);
09C3  1283     BCF STATUS, 0x5
09C4  0829     MOVF year, W
09C5  0084     MOVWF FSR
09C6  3000     MOVLW 0x0
09C7  236E     CALL 0x36E
09C8  120A     BCF PCLATH, 0x4
09C9  158A     BSF PCLATH, 0x3
09CA  397F     ANDLW 0x7F
09CB  2398     CALL 0x398
09CC  120A     BCF PCLATH, 0x4
09CD  158A     BSF PCLATH, 0x3
09CE  1383     BCF STATUS, 0x7
09CF  0080     MOVWF INDF
172:               * min = isl1208_bcd2bin(read_i2c(ACK) & 0x7f);
09D0  0828     MOVF mth, W
09D1  0084     MOVWF FSR
09D2  3000     MOVLW 0x0
09D3  236E     CALL 0x36E
09D4  120A     BCF PCLATH, 0x4
09D5  158A     BSF PCLATH, 0x3
09D6  397F     ANDLW 0x7F
09D7  2398     CALL 0x398
09D8  120A     BCF PCLATH, 0x4
09D9  158A     BSF PCLATH, 0x3
09DA  1383     BCF STATUS, 0x7
09DB  0080     MOVWF INDF
173:               * hr = isl1208_bcd2bin(read_i2c(NOACK) & 0x3f);
09DC  082A     MOVF Data, W
09DD  0084     MOVWF FSR
09DE  3001     MOVLW 0x1
09DF  236E     CALL 0x36E
09E0  120A     BCF PCLATH, 0x4
09E1  158A     BSF PCLATH, 0x3
09E2  393F     ANDLW 0x3F
09E3  2398     CALL 0x398
09E4  120A     BCF PCLATH, 0x4
09E5  158A     BSF PCLATH, 0x3
09E6  1383     BCF STATUS, 0x7
09E7  0080     MOVWF INDF
174:               stop_i2c();
09E8  2B66     GOTO 0x366
175:           
176:           #ifndef USE_INTERRUPTS
177:               // ei();
178:           #endif
179:           
180:           }
181:           
182:           void isl1208_set_time_enc(unsigned char hr, unsigned char min, unsigned char sec) {
0A84  00AC     MOVWF hr
183:           #ifndef USE_INTERRUPTS
184:               //di();
185:           #endif
186:               min &=0x7F;
0A86  13AA     BCF Data, 0x7
187:               hr &= 0x3F;
0A85  303F     MOVLW 0x3F
0A87  05AC     ANDWF hr, F
188:               
189:               start_i2c();
0A88  235E     CALL 0x35E
0A89  120A     BCF PCLATH, 0x4
0A8A  158A     BSF PCLATH, 0x3
190:               write_i2c(isl1208_Write);
0A8B  30DE     MOVLW 0xDE
0A8C  2334     CALL 0x334
0A8D  120A     BCF PCLATH, 0x4
0A8E  158A     BSF PCLATH, 0x3
191:               write_i2c(0x0C);
0A8F  300C     MOVLW 0xC
0A90  2334     CALL 0x334
0A91  120A     BCF PCLATH, 0x4
0A92  158A     BSF PCLATH, 0x3
192:               write_i2c(isl1208_bin2bcd(0));
0A93  3000     MOVLW 0x0
0A94  234C     CALL 0x34C
0A95  120A     BCF PCLATH, 0x4
0A96  158A     BSF PCLATH, 0x3
0A97  2334     CALL 0x334
0A98  120A     BCF PCLATH, 0x4
0A99  158A     BSF PCLATH, 0x3
193:               write_i2c(isl1208_bin2bcd(min)| 0b10000000); //habilita la alarma de minutos
0A9A  1283     BCF STATUS, 0x5
0A9B  082A     MOVF Data, W
0A9C  234C     CALL 0x34C
0A9D  120A     BCF PCLATH, 0x4
0A9E  158A     BSF PCLATH, 0x3
0A9F  3880     IORLW 0x80
0AA0  2334     CALL 0x334
0AA1  120A     BCF PCLATH, 0x4
0AA2  158A     BSF PCLATH, 0x3
194:               write_i2c(isl1208_bin2bcd(hr) | 0b10000000); //habilita la alarma de horas
0AA3  1283     BCF STATUS, 0x5
0AA4  082C     MOVF hr, W
0AA5  234C     CALL 0x34C
0AA6  120A     BCF PCLATH, 0x4
0AA7  158A     BSF PCLATH, 0x3
0AA8  3880     IORLW 0x80
0AA9  2334     CALL 0x334
0AAA  120A     BCF PCLATH, 0x4
0AAB  158A     BSF PCLATH, 0x3
195:               stop_i2c();
0AAC  2B66     GOTO 0x366
196:           
197:           #ifndef USE_INTERRUPTS
198:               //  ei();
199:           #endif
200:           
201:           }
202:           void isl1208_set_dow_enc(unsigned char *dow) {
0A66  1283     BCF STATUS, 0x5
0A67  00AA     MOVWF Data
203:           //TODO terminar de implementar la funcion de escritura de dow.
204:           #ifndef USE_INTERRUPTS
205:               //di();
206:           #endif
207:               *dow &=0x07;
0A68  0084     MOVWF FSR
0A69  3007     MOVLW 0x7
0A6A  1383     BCF STATUS, 0x7
0A6B  0580     ANDWF INDF, F
208:               start_i2c();
0A6C  235E     CALL 0x35E
0A6D  120A     BCF PCLATH, 0x4
0A6E  158A     BSF PCLATH, 0x3
209:               write_i2c(isl1208_Write);
0A6F  30DE     MOVLW 0xDE
0A70  2334     CALL 0x334
0A71  120A     BCF PCLATH, 0x4
0A72  158A     BSF PCLATH, 0x3
210:               write_i2c(0x11);
0A73  3011     MOVLW 0x11
0A74  2334     CALL 0x334
0A75  120A     BCF PCLATH, 0x4
0A76  158A     BSF PCLATH, 0x3
211:               write_i2c(isl1208_bin2bcd(*dow)| 0b10000000); //habilita la alarma de dow
0A77  1283     BCF STATUS, 0x5
0A78  082A     MOVF Data, W
0A79  0084     MOVWF FSR
0A7A  1383     BCF STATUS, 0x7
0A7B  0800     MOVF INDF, W
0A7C  234C     CALL 0x34C
0A7D  120A     BCF PCLATH, 0x4
0A7E  158A     BSF PCLATH, 0x3
0A7F  3880     IORLW 0x80
0A80  2334     CALL 0x334
0A81  120A     BCF PCLATH, 0x4
0A82  158A     BSF PCLATH, 0x3
212:               stop_i2c();
0A83  2B66     GOTO 0x366
213:           
214:           #ifndef USE_INTERRUPTS
215:               //  ei();
216:           #endif
217:           
218:           }
219:           
220:           void isl1208_get_dow_enc(unsigned char *dow) {
098E  1283     BCF STATUS, 0x5
098F  00A8     MOVWF mth
221:           //TODO terminar de implementar la funcion de escritura de dow.
222:           #ifndef USE_INTERRUPTS
223:               //di();
224:           #endif
225:           
226:               start_i2c();
0990  235E     CALL 0x35E
0991  120A     BCF PCLATH, 0x4
0992  158A     BSF PCLATH, 0x3
227:               write_i2c(isl1208_Write);
0993  30DE     MOVLW 0xDE
0994  2334     CALL 0x334
0995  120A     BCF PCLATH, 0x4
0996  158A     BSF PCLATH, 0x3
228:               write_i2c(0x11);
0997  3011     MOVLW 0x11
0998  2334     CALL 0x334
0999  120A     BCF PCLATH, 0x4
099A  158A     BSF PCLATH, 0x3
229:               rstart_i2c();
099B  23A2     CALL 0x3A2
099C  120A     BCF PCLATH, 0x4
099D  158A     BSF PCLATH, 0x3
230:               write_i2c(isl1208_Read);
099E  30DF     MOVLW 0xDF
099F  2334     CALL 0x334
09A0  120A     BCF PCLATH, 0x4
09A1  158A     BSF PCLATH, 0x3
231:               *dow = isl1208_bcd2bin(read_i2c(NOACK) & 0x07);
09A2  1283     BCF STATUS, 0x5
09A3  0828     MOVF mth, W
09A4  0084     MOVWF FSR
09A5  3001     MOVLW 0x1
09A6  236E     CALL 0x36E
09A7  120A     BCF PCLATH, 0x4
09A8  158A     BSF PCLATH, 0x3
09A9  3907     ANDLW 0x7
09AA  2398     CALL 0x398
09AB  120A     BCF PCLATH, 0x4
09AC  158A     BSF PCLATH, 0x3
09AD  1383     BCF STATUS, 0x7
09AE  0080     MOVWF INDF
232:               stop_i2c();
09AF  2B66     GOTO 0x366
233:           
234:           #ifndef USE_INTERRUPTS
235:               //  ei();
236:           #endif
237:           
238:           }
239:           void isl1208_get_time_enc(unsigned char *hr, unsigned char* min, unsigned char *sec) {
09E9  00AA     MOVWF Data
240:           
241:           #ifndef USE_INTERRUPTS
242:               // di();
243:           #endif
244:           
245:               start_i2c();
09EA  235E     CALL 0x35E
09EB  120A     BCF PCLATH, 0x4
09EC  158A     BSF PCLATH, 0x3
246:               write_i2c(isl1208_Write);
09ED  30DE     MOVLW 0xDE
09EE  2334     CALL 0x334
09EF  120A     BCF PCLATH, 0x4
09F0  158A     BSF PCLATH, 0x3
247:               write_i2c(0x0C);
09F1  300C     MOVLW 0xC
09F2  2334     CALL 0x334
09F3  120A     BCF PCLATH, 0x4
09F4  158A     BSF PCLATH, 0x3
248:           
249:               rstart_i2c();
09F5  23A2     CALL 0x3A2
09F6  120A     BCF PCLATH, 0x4
09F7  158A     BSF PCLATH, 0x3
250:               write_i2c(isl1208_Read);
09F8  30DF     MOVLW 0xDF
09F9  2334     CALL 0x334
09FA  120A     BCF PCLATH, 0x4
09FB  158A     BSF PCLATH, 0x3
251:               *sec = isl1208_bcd2bin(read_i2c(ACK) & 0x7f);
09FC  1283     BCF STATUS, 0x5
09FD  0829     MOVF year, W
09FE  0084     MOVWF FSR
09FF  3000     MOVLW 0x0
0A00  236E     CALL 0x36E
0A01  120A     BCF PCLATH, 0x4
0A02  158A     BSF PCLATH, 0x3
0A03  397F     ANDLW 0x7F
0A04  2398     CALL 0x398
0A05  120A     BCF PCLATH, 0x4
0A06  158A     BSF PCLATH, 0x3
0A07  1383     BCF STATUS, 0x7
0A08  0080     MOVWF INDF
252:               * min = isl1208_bcd2bin(read_i2c(ACK) & 0x7f);
0A09  0828     MOVF mth, W
0A0A  0084     MOVWF FSR
0A0B  3000     MOVLW 0x0
0A0C  236E     CALL 0x36E
0A0D  120A     BCF PCLATH, 0x4
0A0E  158A     BSF PCLATH, 0x3
0A0F  397F     ANDLW 0x7F
0A10  2398     CALL 0x398
0A11  120A     BCF PCLATH, 0x4
0A12  158A     BSF PCLATH, 0x3
0A13  1383     BCF STATUS, 0x7
0A14  0080     MOVWF INDF
253:               * hr = isl1208_bcd2bin(read_i2c(NOACK) & 0x3f);
0A15  082A     MOVF Data, W
0A16  0084     MOVWF FSR
0A17  3001     MOVLW 0x1
0A18  236E     CALL 0x36E
0A19  120A     BCF PCLATH, 0x4
0A1A  158A     BSF PCLATH, 0x3
0A1B  393F     ANDLW 0x3F
0A1C  2398     CALL 0x398
0A1D  120A     BCF PCLATH, 0x4
0A1E  158A     BSF PCLATH, 0x3
0A1F  1383     BCF STATUS, 0x7
0A20  0080     MOVWF INDF
254:               stop_i2c();
0A21  2B66     GOTO 0x366
255:           
256:           #ifndef USE_INTERRUPTS
257:               // ei();
258:           #endif
259:           
260:           }
261:           
262:           char isl1208_read_nvram_byte(char addr) {
263:           
264:               char retval;
265:           
266:           #ifndef USE_INTERRUPTS
267:               // di();
268:           #endif
269:           
270:               start_i2c();
271:               write_i2c(isl1208_Write);
272:               write_i2c(addr);
273:           
274:               start_i2c();
275:               write_i2c(isl1208_Read);
276:               retval = read_i2c(NOACK);
277:               stop_i2c();
278:           
279:           
280:           
281:           #ifndef USE_INTERRUPTS
282:               // ei();
283:           #endif
284:               return (retval);
285:           }
286:           
287:           void isl1208_write_nvram_byte(char addr, char value) {
288:           
289:           #ifndef USE_INTERRUPTS
290:               //di();
291:           #endif
292:           
293:               start_i2c();
294:               write_i2c(isl1208_Write);
295:               write_i2c(addr);
296:               write_i2c(value);
297:               stop_i2c();
298:           
299:           #ifndef USE_INTERRUPTS
300:               // ei();
301:           #endif
302:           
303:           }
304:           int aniobisiesto(unsigned char year)
0FA1  00FA     MOVWF j
305:           {
306:               return ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0);
0FA2  01F9     CLRF Indice
0FA3  0AF9     INCF Indice, F
0FA4  3903     ANDLW 0x3
0FA5  1D03     BTFSS STATUS, 0x2
0FA6  2FB0     GOTO 0x7B0
0FA7  3064     MOVLW 0x64
0FA8  00F0     MOVWF divisor
0FA9  087A     MOVF j, W
0FAA  27C2     CALL 0x7C2
0FAB  120A     BCF PCLATH, 0x4
0FAC  158A     BSF PCLATH, 0x3
0FAD  3800     IORLW 0x0
0FAE  1D03     BTFSS STATUS, 0x2
0FAF  2FBE     GOTO 0x7BE
0FB0  3090     MOVLW 0x90
0FB1  00F0     MOVWF divisor
0FB2  3001     MOVLW 0x1
0FB3  00F1     MOVWF canal
0FB4  087A     MOVF j, W
0FB5  00F2     MOVWF dividend
0FB6  01F3     CLRF counter
0FB7  120A     BCF PCLATH, 0x4
0FB8  118A     BCF PCLATH, 0x3
0FB9  2753     CALL 0x753
0FBA  0871     MOVF canal, W
0FBB  0470     IORWF divisor, W
0FBC  1D03     BTFSS STATUS, 0x2
0FBD  01F9     CLRF Indice
0FBE  0879     MOVF Indice, W
0FBF  00F6     MOVWF TipoPin
0FC0  01F7     CLRF Logica
307:           }
0FC1  0008     RETURN
308:           unsigned char dia_de_la_semana(unsigned char *dia, unsigned char *mes, unsigned char *anio){
08A4  00C5     MOVWF dia
309:           //se usa el algoritmo de Zeller
310:              unsigned char a,y,m,dow;
311:           
312:              a = (14 -*mes) / 12;
08A5  300E     MOVLW 0xE
08A6  00AB     MOVWF sec
08A7  01AC     CLRF hr
08A8  0837     MOVF mes, W
08A9  0084     MOVWF FSR
08AA  0800     MOVF INDF, W
08AB  02AB     SUBWF sec, F
08AC  1C03     BTFSS STATUS, 0x0
08AD  03AC     DECF hr, F
08AE  300C     MOVLW 0xC
08AF  00A9     MOVWF year
08B0  01AA     CLRF Data
08B1  211E     CALL 0x11E
08B2  120A     BCF PCLATH, 0x4
08B3  158A     BSF PCLATH, 0x3
08B4  0829     MOVF year, W
08B5  00C4     MOVWF a
313:           y = *anio - a;
08B6  0838     MOVF anio, W
08B7  0084     MOVWF FSR
08B8  0844     MOVF a, W
08B9  1383     BCF STATUS, 0x7
08BA  0200     SUBWF INDF, W
08BB  00C6     MOVWF y
314:           m = *mes + 12 * a - 2;
08BC  0837     MOVF mes, W
08BD  0084     MOVWF FSR
08BE  300C     MOVLW 0xC
08BF  00A3     MOVWF x
08C0  0844     MOVF a, W
08C1  23C5     CALL 0x3C5
08C2  120A     BCF PCLATH, 0x4
08C3  158A     BSF PCLATH, 0x3
08C4  1383     BCF STATUS, 0x7
08C5  0700     ADDWF INDF, W
08C6  3EFE     ADDLW 0xFE
08C7  00C2     MOVWF m
315:           
316:           //Para el calendario Juliano:
317:           //d = (5 + dia + y + y/4 + (31*m)/12) mod 7
318:           
319:           //Para el calendario Gregoriano:
320:            dow = (*dia + y + y/4 - y/100 + y/400 + (31*m)/12) % 7;
08C8  3007     MOVLW 0x7
08C9  00B1     MOVWF divisor
08CA  3090     MOVLW 0x90
08CB  01B2     CLRF 0x32
08CC  00A9     MOVWF year
08CD  3001     MOVLW 0x1
08CE  00AA     MOVWF Data
08CF  0846     MOVF y, W
08D0  00AB     MOVWF sec
08D1  01AC     CLRF hr
08D2  211E     CALL 0x11E
08D3  0846     MOVF y, W
08D4  00B9     MOVWF 0x39
08D5  1003     BCF STATUS, 0x0
08D6  0CB9     RRF 0x39, F
08D7  1003     BCF STATUS, 0x0
08D8  0CB9     RRF 0x39, F
08D9  0845     MOVF dia, W
08DA  0084     MOVWF FSR
08DB  1383     BCF STATUS, 0x7
08DC  0800     MOVF INDF, W
08DD  0746     ADDWF y, W
08DE  00BA     MOVWF f1
08DF  01BB     CLRF 0x3B
08E0  0DBB     RLF 0x3B, F
08E1  0839     MOVF 0x39, W
08E2  073A     ADDWF f1, W
08E3  00BC     MOVWF 0x3C
08E4  3000     MOVLW 0x0
08E5  1803     BTFSC STATUS, 0x0
08E6  3001     MOVLW 0x1
08E7  073B     ADDWF 0x3B, W
08E8  00BD     MOVWF f1
08E9  0829     MOVF year, W
08EA  073C     ADDWF 0x3C, W
08EB  00BE     MOVWF 0x3E
08EC  082A     MOVF Data, W
08ED  1803     BTFSC STATUS, 0x0
08EE  0A2A     INCF Data, W
08EF  073D     ADDWF f1, W
08F0  00BF     MOVWF 0x3F
08F1  300C     MOVLW 0xC
08F2  00A9     MOVWF year
08F3  01AA     CLRF Data
08F4  0842     MOVF m, W
08F5  00A3     MOVWF x
08F6  301F     MOVLW 0x1F
08F7  01A4     CLRF dato
08F8  00A5     MOVWF y
08F9  01A6     CLRF x
08FA  160A     BSF PCLATH, 0x4
08FB  118A     BCF PCLATH, 0x3
08FC  2799     CALL 0x799
08FD  120A     BCF PCLATH, 0x4
08FE  158A     BSF PCLATH, 0x3
08FF  0824     MOVF dato, W
0900  00AC     MOVWF hr
0901  0823     MOVF x, W
0902  00AB     MOVWF sec
0903  211E     CALL 0x11E
0904  120A     BCF PCLATH, 0x4
0905  158A     BSF PCLATH, 0x3
0906  0829     MOVF year, W
0907  073E     ADDWF 0x3E, W
0908  00C0     MOVWF f2
0909  082A     MOVF Data, W
090A  1803     BTFSC STATUS, 0x0
090B  0A2A     INCF Data, W
090C  073F     ADDWF 0x3F, W
090D  00C1     MOVWF 0x41
090E  3064     MOVLW 0x64
090F  00A3     MOVWF x
0910  0846     MOVF y, W
0911  23AA     CALL 0x3AA
0912  120A     BCF PCLATH, 0x4
0913  158A     BSF PCLATH, 0x3
0914  0240     SUBWF f2, W
0915  00B3     MOVWF dividend
0916  0841     MOVF 0x41, W
0917  1C03     BTFSS STATUS, 0x0
0918  0341     DECF 0x41, W
0919  00B4     MOVWF sign
091A  23D4     CALL 0x3D4
091B  0831     MOVF divisor, W
091C  00C3     MOVWF dow
321:           
322:           //El resultado es un cero (0) para el domingo, 1 para el lunes? 6 para el sbado
323:           
324:            return (dow);
325:           }
091D  0008     RETURN
326:           ///////////////////////////////////////////////////////////////////////////////
327:           
328:           unsigned char isl1208_bin2bcd(unsigned char binary_value) {
0B4C  1283     BCF STATUS, 0x5
0B4D  00A9     MOVWF year
329:               return ((binary_value / 10) << 4) +binary_value % 10;
0B4E  300A     MOVLW 0xA
0B4F  00A3     MOVWF x
0B50  0829     MOVF year, W
0B51  23AA     CALL 0x3AA
0B52  120A     BCF PCLATH, 0x4
0B53  158A     BSF PCLATH, 0x3
0B54  00A8     MOVWF mth
0B55  0E28     SWAPF mth, W
0B56  39F0     ANDLW 0xF0
0B57  00A8     MOVWF mth
0B58  300A     MOVLW 0xA
0B59  00A3     MOVWF x
0B5A  0829     MOVF year, W
0B5B  2411     CALL 0x411
0B5C  0728     ADDWF mth, W
330:           
331:           }
0B5D  0008     RETURN
332:           
333:           unsigned char isl1208_bcd2bin(unsigned char bcd_value) {
0B98  00A7     MOVWF i
334:               return (bcd_value & 0x0F) + (bcd_value >> 4) * 10;
0B99  390F     ANDLW 0xF
0B9A  00A6     MOVWF x
0B9B  300A     MOVLW 0xA
0B9C  00A3     MOVWF x
0B9D  0E27     SWAPF i, W
0B9E  390F     ANDLW 0xF
0B9F  23C5     CALL 0x3C5
0BA0  0726     ADDWF x, W
335:           }
0BA1  0008     RETURN
336:           
337:           
338:           /*unsigned int ISL1208::bcd2bin(unsigned char val)
339:           {
340:               return (val & 0x0F) + (val >> 4) * 10;
341:           }
342:           
343:           char ISL1208::bin2bcd(unsigned int val)
344:           {
345:               return ((val / 10) << 4) + val % 10;
346:           }*/
347:           ///////////////////////////////////////////////////////////////////////////////
348:           
349:           
350:           
351:           
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/Pulsadores.c  -------------------------
1:             //Programa de gestin de pulsadores por Nocturno adaptado a xc8 por Pablo F. Manieri
2:             
3:             #include <xc.h>
4:             #include <stdint.h>
5:             #include <stdbool.h>
6:             #include "system.h"
7:             #include "user.h"
8:             #include "Pulsadores.h"
9:             
10:            /****** HARDWARE ********
11:            BOTON_Subir       	RB1
12:            BOTON_Bajar       	RB2
13:            BOTON_MENU       	RB3
14:            BOTON_MANAUT     	RB4
15:            BOTON_ONOFF		RB5
16:            **************************/
17:            
18:            bool Pulsacion(unsigned char Indice, unsigned char Pin, unsigned char TipoPin, bool Logica) {
0ED4  00F9     MOVWF Indice
19:               /*
20:                  Esta funcin gestiona las entradas de pulsador, mediante el control de un retardo
21:                  antirrebotes y con la opcin de autorrepeticin de hasta 4 velocidades
22:                  
23:                  Para que funcione, hay que dimensionar la variable Entradas con el n de pulsadores
24:                  que queramos controlar.
25:                  
26:                  ENTRADAS
27:                     Indice: hace referencia al n de pulsador a chequear
28:                     Pin: indica el estado del pin del pulsador (lgica inversa)
29:                     TipoPIN:
30:                        TipoPin=0   -> No tiene autorrepeticin
31:                        TipoPin=1   -> Pin con autorrepeticin
32:                     
33:                  SALIDA
34:                     La funcin devuelve un 1 si el pulsador est en condiciones de ser procesado
35:                     y un 0 en caso contrario.
36:                  
37:               */
38:               static unsigned int Entradas[5]={0,0,0,0,0};  // Dimensionar en funcin del n de pulsadores
39:               unsigned int j;
40:              bool resultado=0;
0ED5  01F8     CLRF resultado
41:               
42:               j=Entradas[Indice];  // Como leemos muchas veces el array, lo pasamos a variable local para 
0ED6  1003     BCF STATUS, 0x0
0ED7  0D79     RLF Indice, W
0ED8  3EA0     ADDLW 0xA0
0ED9  0084     MOVWF FSR
0EDA  1383     BCF STATUS, 0x7
0EDB  0800     MOVF INDF, W
0EDC  00FA     MOVWF j
0EDD  0A84     INCF FSR, F
0EDE  0800     MOVF INDF, W
0EDF  00FB     MOVWF 0x7B
43:                                    // incrementar la velocidad de ejecucin
44:                                    
45:               // Si se detecta pulsacin y antes no haba, devolvemos un 1 en resultado
46:               if ((((!Pin && Logica==LOGICA_INVERSA) || (Pin && Logica==LOGICA_DIRECTA)) && (j==0))) {
0EE0  08F5     MOVF Pin, F
0EE1  1903     BTFSC STATUS, 0x2
0EE2  0377     DECF Logica, W
0EE3  1903     BTFSC STATUS, 0x2
0EE4  2EEB     GOTO 0x6EB
0EE5  0875     MOVF Pin, W
0EE6  1903     BTFSC STATUS, 0x2
0EE7  2EF4     GOTO 0x6F4
0EE8  08F7     MOVF Logica, F
0EE9  1D03     BTFSS STATUS, 0x2
0EEA  2EF4     GOTO 0x6F4
0EEB  087B     MOVF 0x7B, W
0EEC  047A     IORWF j, W
0EED  1D03     BTFSS STATUS, 0x2
0EEE  2EF4     GOTO 0x6F4
47:                     resultado=1;
0EEF  01F8     CLRF resultado
0EF0  0AF8     INCF resultado, F
48:                     j=1;
0EF1  01FA     CLRF j
0EF2  0AFA     INCF j, F
0EF3  01FB     CLRF 0x7B
49:               };
50:               
51:               // Cada vez que se entra a la funcin se incrementa una unidad el array
52:               if (j>0) 
0EF4  087B     MOVF 0x7B, W
0EF5  047A     IORWF j, W
0EF6  1903     BTFSC STATUS, 0x2
0EF7  2F01     GOTO 0x701
53:                     Entradas[Indice]++;
0EF8  1003     BCF STATUS, 0x0
0EF9  0D79     RLF Indice, W
0EFA  3EA0     ADDLW 0xA0
0EFB  0084     MOVWF FSR
0EFC  3001     MOVLW 0x1
0EFD  0780     ADDWF INDF, F
0EFE  0A84     INCF FSR, F
0EFF  1803     BTFSC STATUS, 0x0
0F00  0A80     INCF INDF, F
54:               
55:               // Si se detecta que ya no se est pulsando, inicializamos a 0 el array
56:               if (((Pin && Logica==LOGICA_INVERSA) || (!Pin && Logica==LOGICA_DIRECTA)) && j>ANTIRREBOTES)
0F01  0875     MOVF Pin, W
0F02  1903     BTFSC STATUS, 0x2
0F03  2F07     GOTO 0x707
0F04  0377     DECF Logica, W
0F05  1903     BTFSC STATUS, 0x2
0F06  2F0D     GOTO 0x70D
0F07  08F5     MOVF Pin, F
0F08  1D03     BTFSS STATUS, 0x2
0F09  2F1B     GOTO 0x71B
0F0A  08F7     MOVF Logica, F
0F0B  1D03     BTFSS STATUS, 0x2
0F0C  2F1B     GOTO 0x71B
0F0D  3000     MOVLW 0x0
0F0E  027B     SUBWF 0x7B, W
0F0F  3033     MOVLW 0x33
0F10  1903     BTFSC STATUS, 0x2
0F11  027A     SUBWF j, W
0F12  1C03     BTFSS STATUS, 0x0
0F13  2F1B     GOTO 0x71B
57:                  Entradas[Indice]=0;
0F14  1003     BCF STATUS, 0x0
0F15  0D79     RLF Indice, W
0F16  3EA0     ADDLW 0xA0
0F17  0084     MOVWF FSR
0F18  0180     CLRF INDF
0F19  0A84     INCF FSR, F
0F1A  0180     CLRF INDF
58:                  
59:               if (TipoPin) { // Si el pulsador tiene autorrepeticin
0F1B  0876     MOVF TipoPin, W
0F1C  1903     BTFSC STATUS, 0x2
0F1D  2F6A     GOTO 0x76A
60:                 // Cuando se supera el n de ciclos 4, devolveremos un 1 con la frecuencia VELOCIDAD4
61:                   if ((j>=CAMBIO4) && !(j%VELOCIDAD4)){
0F1E  300F     MOVLW 0xF
0F1F  027B     SUBWF 0x7B, W
0F20  30A0     MOVLW 0xA0
0F21  1903     BTFSC STATUS, 0x2
0F22  027A     SUBWF j, W
0F23  1803     BTFSC STATUS, 0x0
0F24  187A     BTFSC j, 0x0
0F25  2F2B     GOTO 0x72B
62:                       resultado=1;
0F26  01F8     CLRF resultado
0F27  0AF8     INCF resultado, F
63:                  }else
0F28  1283     BCF STATUS, 0x5
0F29  1303     BCF STATUS, 0x6
0F2A  2F6A     GOTO 0x76A
64:                   // Cuando se supera el n de ciclos 3, devolveremos un 1 con la frecuencia VELOCIDAD3
65:                  if ((j>=CAMBIO3) && !(j%VELOCIDAD3)){           
0F2B  3007     MOVLW 0x7
0F2C  027B     SUBWF 0x7B, W
0F2D  30D0     MOVLW 0xD0
0F2E  1903     BTFSC STATUS, 0x2
0F2F  027A     SUBWF j, W
0F30  1C03     BTFSS STATUS, 0x0
0F31  2F40     GOTO 0x740
0F32  300A     MOVLW 0xA
0F33  00F0     MOVWF divisor
0F34  01F1     CLRF canal
0F35  087B     MOVF 0x7B, W
0F36  00F3     MOVWF counter
0F37  087A     MOVF j, W
0F38  00F2     MOVWF dividend
0F39  2776     CALL 0x776
0F3A  120A     BCF PCLATH, 0x4
0F3B  158A     BSF PCLATH, 0x3
0F3C  0871     MOVF canal, W
0F3D  0470     IORWF divisor, W
0F3E  1903     BTFSC STATUS, 0x2
0F3F  2F26     GOTO 0x726
66:                     resultado=1;
67:                  } else 
68:                     // Cuando se supera el n de ciclos 2, devolveremos un 1 con la frecuencia VELOCIDAD2
69:                     if ((j>=CAMBIO2) && !(j%VELOCIDAD2)){
0F40  3001     MOVLW 0x1
0F41  027B     SUBWF 0x7B, W
0F42  30F4     MOVLW 0xF4
0F43  1903     BTFSC STATUS, 0x2
0F44  027A     SUBWF j, W
0F45  1C03     BTFSS STATUS, 0x0
0F46  2F55     GOTO 0x755
0F47  3032     MOVLW 0x32
0F48  00F0     MOVWF divisor
0F49  01F1     CLRF canal
0F4A  087B     MOVF 0x7B, W
0F4B  00F3     MOVWF counter
0F4C  087A     MOVF j, W
0F4D  00F2     MOVWF dividend
0F4E  2776     CALL 0x776
0F4F  120A     BCF PCLATH, 0x4
0F50  158A     BSF PCLATH, 0x3
0F51  0871     MOVF canal, W
0F52  0470     IORWF divisor, W
0F53  1903     BTFSC STATUS, 0x2
0F54  2F26     GOTO 0x726
70:                        resultado=1;
71:                  } else
72:                     // Cuando se supera el n de ciclos 1, devolveremos un 1 con la frecuencia VELOCIDAD1
73:                     if ((j>CAMBIO1) && !(j%VELOCIDAD1)){
0F55  3000     MOVLW 0x0
0F56  027B     SUBWF 0x7B, W
0F57  3065     MOVLW 0x65
0F58  1903     BTFSC STATUS, 0x2
0F59  027A     SUBWF j, W
0F5A  1C03     BTFSS STATUS, 0x0
0F5B  2F6A     GOTO 0x76A
0F5C  3064     MOVLW 0x64
0F5D  00F0     MOVWF divisor
0F5E  01F1     CLRF canal
0F5F  087B     MOVF 0x7B, W
0F60  00F3     MOVWF counter
0F61  087A     MOVF j, W
0F62  00F2     MOVWF dividend
0F63  2776     CALL 0x776
0F64  120A     BCF PCLATH, 0x4
0F65  158A     BSF PCLATH, 0x3
0F66  0871     MOVF canal, W
0F67  0470     IORWF divisor, W
0F68  1903     BTFSC STATUS, 0x2
0F69  2F26     GOTO 0x726
74:                        resultado=1;
75:                  };
76:               }
77:               if ((TipoPin==INMEDIATO)&&(j>=1))
0F6A  0876     MOVF TipoPin, W
0F6B  3A02     XORLW 0x2
0F6C  1D03     BTFSS STATUS, 0x2
0F6D  2F74     GOTO 0x774
0F6E  087B     MOVF 0x7B, W
0F6F  047A     IORWF j, W
0F70  1903     BTFSC STATUS, 0x2
0F71  2F74     GOTO 0x774
78:                   resultado=1;
0F72  01F8     CLRF resultado
0F73  0AF8     INCF resultado, F
79:               return (resultado);
0F74  0878     MOVF resultado, W
80:            }
0F75  0008     RETURN
81:            
82:            
83:               
84:            
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/LCDGeneric.c  -------------------------
1:             /**
2:                \version: 1.0
3:             
4:                
5:                \author Suky (Casanova Alejandro) 
6:                \web www.infopic.comlu.com
7:                \date 16/08/10
8:             
9:             
10:            ///////////////////////////////////////////////////////////////////////////
11:            ////                                                                   ////
12:            ////                                                                   ////
13:            ////        (C) Copyright 2010 www.infopic.comlu.com                   ////
14:            //// Este cdigo puede ser usado, modificado y distribuido libremente  ////
15:            //// sin eliminar esta cabecera y  sin garanta de ningn tipo.        ////
16:            ////                                                                   ////
17:            ////                                                                   ////
18:            /////////////////////////////////////////////////////////////////////////// 
19:               
20:             *- Version Log --------------------------------------------------------------*
21:             *   Fecha       Autor                Comentarios                             *
22:             *----------------------------------------------------------------------------*
23:             * 16/08/10      Suky               Original (Rev 1.0)                        *
24:             * 20/08/10      Suky               Se incluye CodeVisionAVR                  *
25:             *----------------------------------------------------------------------------* */
26:            #include "xc.h"
27:            #include "system.h"
28:            #include "LCDGeneric.h"
29:            
30:            UINT8 NLinea;
31:            
32:            UINT8 ui8BusyLCD(void){
33:            
34:            #ifdef LCD_USE_RW
35:            	 LCD_DATA_PIN_7 = 0;
139A  1388     BCF PORTD, 0x7
36:            	 LCD_DATA_PIN_6 = 0;
139B  1308     BCF PORTD, 0x6
37:            	 LCD_DATA_PIN_5 = 0;
139C  1288     BCF PORTD, 0x5
38:            	 LCD_DATA_PIN_4 = 0;
139D  1208     BCF PORTD, 0x4
39:            
40:                 LCD_TRIS_DATA_PIN_7 = CONFIG_INPUT;
139E  1683     BSF STATUS, 0x5
139F  1788     BSF PORTD, 0x7
41:                 LCD_TRIS_DATA_PIN_6 = CONFIG_INPUT;
13A0  1708     BSF PORTD, 0x6
42:                 LCD_TRIS_DATA_PIN_5 = CONFIG_INPUT;
13A1  1688     BSF PORTD, 0x5
43:                 LCD_TRIS_DATA_PIN_4 = CONFIG_INPUT;
13A2  1608     BSF PORTD, 0x4
44:            
45:                 LCD_RW_PIN = 1;    
13A3  1283     BCF STATUS, 0x5
13A4  1488     BSF PORTD, 0x1
46:                 LCD_RS_PIN = 0; 
13A5  1008     BCF PORTD, 0x0
47:            	 LCD_E_PIN=1;         
13A6  1508     BSF PORTD, 0x2
48:                 __delay_1us();
13A7  2BA8     GOTO 0x3A8
13A8  2BA9     GOTO 0x3A9
13A9  0000     NOP
49:            
50:                 if(LCD_READ_PIN_7==1){
13AA  1283     BCF STATUS, 0x5
13AB  1303     BCF STATUS, 0x6
13AC  1F88     BTFSS PORTD, 0x7
13AD  2BBD     GOTO 0x3BD
51:                      LCD_E_PIN = 0; 
13AE  1108     BCF PORTD, 0x2
52:            		  __delay_1us();
13AF  2BB0     GOTO 0x3B0
13B0  2BB1     GOTO 0x3B1
13B1  0000     NOP
53:            		  LCD_E_PIN = 1;
13B2  1283     BCF STATUS, 0x5
13B3  1303     BCF STATUS, 0x6
13B4  1508     BSF PORTD, 0x2
54:            		  __delay_1us();
13B5  2BB6     GOTO 0x3B6
13B6  2BB7     GOTO 0x3B7
13B7  0000     NOP
55:            		  LCD_E_PIN = 0;
13B8  1283     BCF STATUS, 0x5
13B9  1303     BCF STATUS, 0x6
13BA  1108     BCF PORTD, 0x2
56:                  	  LCD_RW_PIN = 0; 
13BB  1088     BCF PORTD, 0x1
57:                      return 1;
13BC  3401     RETLW 0x1
58:                 }else{
59:                      LCD_E_PIN = 0;
13BD  1108     BCF PORTD, 0x2
60:            		  __delay_1us();
13BE  2BBF     GOTO 0x3BF
13BF  2BC0     GOTO 0x3C0
13C0  0000     NOP
61:            		  LCD_E_PIN = 1;
13C1  1283     BCF STATUS, 0x5
13C2  1303     BCF STATUS, 0x6
13C3  1508     BSF PORTD, 0x2
62:            		  __delay_1us();
13C4  2BC5     GOTO 0x3C5
13C5  2BC6     GOTO 0x3C6
13C6  0000     NOP
63:            		  LCD_E_PIN = 0;
13C7  1283     BCF STATUS, 0x5
13C8  1303     BCF STATUS, 0x6
13C9  1108     BCF PORTD, 0x2
64:            		  LCD_RW_PIN = 0;       
13CA  1088     BCF PORTD, 0x1
65:                      return 0;
13CB  3400     RETLW 0x0
66:                 }
67:            #else
68:            	 __delay_100us();
69:            	 return 0;
70:            #endif
71:            }
72:            
73:            void vWriteLCD(UINT8 Data,UINT8 Type){
1329  00A4     MOVWF dato
74:            
75:            #ifdef LCD_USE_3PINES
76:            	UINT8 i, data_temp;
77:            #endif
78:            
79:            	while(ui8BusyLCD());
132A  239A     CALL 0x39A
132B  160A     BSF PCLATH, 0x4
132C  118A     BCF PCLATH, 0x3
132D  3800     IORLW 0x0
132E  1D03     BTFSS STATUS, 0x2
132F  2B2A     GOTO 0x32A
80:            
81:            	#ifndef LCD_USE_3PINES
82:            		#ifdef LCD_USE_RW
83:            			LCD_RW_PIN = 0;
1330  1088     BCF PORTD, 0x1
84:            		#endif   
85:            		if(Type){
1331  0823     MOVF x, W
1332  1903     BTFSC STATUS, 0x2
1333  2B36     GOTO 0x336
86:            			LCD_RS_PIN=1;
1334  1408     BSF PORTD, 0x0
87:            		}else{
1335  2B37     GOTO 0x337
88:            			LCD_RS_PIN = 0;
1336  1008     BCF PORTD, 0x0
89:            		}	  
90:            		LCD_TRIS_DATA_PIN_7 = CONFIG_OUTPUT;
1337  1683     BSF STATUS, 0x5
1338  1388     BCF PORTD, 0x7
91:            		LCD_TRIS_DATA_PIN_6 = CONFIG_OUTPUT;
1339  1308     BCF PORTD, 0x6
92:            		LCD_TRIS_DATA_PIN_5 = CONFIG_OUTPUT;
133A  1288     BCF PORTD, 0x5
93:            		LCD_TRIS_DATA_PIN_4 = CONFIG_OUTPUT;
133B  1208     BCF PORTD, 0x4
94:            		
95:            		LCD_DATA_PIN_7 = !!(Data & 0x80);
133C  1283     BCF STATUS, 0x5
133D  1FA4     BTFSS dato, 0x7
133E  2B43     GOTO 0x343
133F  1283     BCF STATUS, 0x5
1340  1303     BCF STATUS, 0x6
1341  1788     BSF PORTD, 0x7
1342  2B46     GOTO 0x346
1343  1283     BCF STATUS, 0x5
1344  1303     BCF STATUS, 0x6
1345  1388     BCF PORTD, 0x7
96:            		LCD_DATA_PIN_6 = !!(Data & 0x40);
1346  1F24     BTFSS dato, 0x6
1347  2B4C     GOTO 0x34C
1348  1283     BCF STATUS, 0x5
1349  1303     BCF STATUS, 0x6
134A  1708     BSF PORTD, 0x6
134B  2B4F     GOTO 0x34F
134C  1283     BCF STATUS, 0x5
134D  1303     BCF STATUS, 0x6
134E  1308     BCF PORTD, 0x6
97:            		LCD_DATA_PIN_5 = !!(Data & 0x20);
134F  1EA4     BTFSS dato, 0x5
1350  2B55     GOTO 0x355
1351  1283     BCF STATUS, 0x5
1352  1303     BCF STATUS, 0x6
1353  1688     BSF PORTD, 0x5
1354  2B58     GOTO 0x358
1355  1283     BCF STATUS, 0x5
1356  1303     BCF STATUS, 0x6
1357  1288     BCF PORTD, 0x5
98:            		LCD_DATA_PIN_4 = !!(Data & 0x10);
1358  1E24     BTFSS dato, 0x4
1359  2B5E     GOTO 0x35E
135A  1283     BCF STATUS, 0x5
135B  1303     BCF STATUS, 0x6
135C  1608     BSF PORTD, 0x4
135D  2B61     GOTO 0x361
135E  1283     BCF STATUS, 0x5
135F  1303     BCF STATUS, 0x6
1360  1208     BCF PORTD, 0x4
99:            	#else
100:           		data_temp=(Data>>4);  // Rs es bit 4
101:           		if(Type){
102:           			data_temp|=0x10;
103:           		}
104:           		for(i=0;i<8;i++){
105:           			LCD_DATA_PIN=!!(data_temp & 0x80);
106:           			data_temp<<=1;
107:           			LCD_CLOCK_PIN=1;
108:           			__delay_1us();
109:           			LCD_CLOCK_PIN=0;
110:           		}
111:           	#endif
112:           	__delay_1Cycle();
1361  0000     NOP
113:           	LCD_E_PIN = 1;
1362  1283     BCF STATUS, 0x5
1363  1303     BCF STATUS, 0x6
1364  1508     BSF PORTD, 0x2
114:           	__delay_1us();
1365  2B66     GOTO 0x366
1366  2B67     GOTO 0x367
1367  0000     NOP
115:           	LCD_E_PIN = 0;
1368  1283     BCF STATUS, 0x5
1369  1303     BCF STATUS, 0x6
136A  1108     BCF PORTD, 0x2
116:           	#ifndef LCD_USE_3PINES	
117:           		LCD_DATA_PIN_7 = !!(Data & 0x08);
136B  1DA4     BTFSS dato, 0x3
136C  2B71     GOTO 0x371
136D  1283     BCF STATUS, 0x5
136E  1303     BCF STATUS, 0x6
136F  1788     BSF PORTD, 0x7
1370  2B74     GOTO 0x374
1371  1283     BCF STATUS, 0x5
1372  1303     BCF STATUS, 0x6
1373  1388     BCF PORTD, 0x7
118:           		LCD_DATA_PIN_6 = !!(Data & 0x04);
1374  1D24     BTFSS dato, 0x2
1375  2B7A     GOTO 0x37A
1376  1283     BCF STATUS, 0x5
1377  1303     BCF STATUS, 0x6
1378  1708     BSF PORTD, 0x6
1379  2B7D     GOTO 0x37D
137A  1283     BCF STATUS, 0x5
137B  1303     BCF STATUS, 0x6
137C  1308     BCF PORTD, 0x6
119:           		LCD_DATA_PIN_5 = !!(Data & 0x02);
137D  1CA4     BTFSS dato, 0x1
137E  2B83     GOTO 0x383
137F  1283     BCF STATUS, 0x5
1380  1303     BCF STATUS, 0x6
1381  1688     BSF PORTD, 0x5
1382  2B86     GOTO 0x386
1383  1283     BCF STATUS, 0x5
1384  1303     BCF STATUS, 0x6
1385  1288     BCF PORTD, 0x5
120:           		LCD_DATA_PIN_4 = !!(Data & 0x01);
1386  1C24     BTFSS dato, 0x0
1387  2B8C     GOTO 0x38C
1388  1283     BCF STATUS, 0x5
1389  1303     BCF STATUS, 0x6
138A  1608     BSF PORTD, 0x4
138B  2B8F     GOTO 0x38F
138C  1283     BCF STATUS, 0x5
138D  1303     BCF STATUS, 0x6
138E  1208     BCF PORTD, 0x4
121:           	#else
122:           		data_temp=(Data&0x0F);  // Rs es bit 4
123:           		if(Type){
124:           			data_temp|=0x10;
125:           		}
126:           		for(i=0;i<8;i++){
127:           			LCD_DATA_PIN=!!(data_temp & 0x80);
128:           			data_temp<<=1;
129:           			LCD_CLOCK_PIN=1;
130:           			__delay_1us();
131:           			LCD_CLOCK_PIN=0;
132:           		}
133:           	#endif
134:           	__delay_1Cycle();	
138F  0000     NOP
135:           	LCD_E_PIN = 1;
1390  1283     BCF STATUS, 0x5
1391  1303     BCF STATUS, 0x6
1392  1508     BSF PORTD, 0x2
136:           	__delay_1us();
1393  2B94     GOTO 0x394
1394  2B95     GOTO 0x395
1395  0000     NOP
137:           	LCD_E_PIN = 0;
1396  1283     BCF STATUS, 0x5
1397  1303     BCF STATUS, 0x6
1398  1108     BCF PORTD, 0x2
138:           	
139:           } 
1399  0008     RETURN
140:           
141:           void vInitLCD(){
142:           UINT8 i;
143:           #ifdef LCD_USE_3PINES
144:           	UINT8 temp;
145:           #endif
146:           
147:           	for(i=0;i<8;i++){__delay_2ms();}
12B6  01A7     CLRF i
12B7  300D     MOVLW 0xD
12B8  00A6     MOVWF x
12B9  30FB     MOVLW 0xFB
12BA  00A5     MOVWF y
12BB  0BA5     DECFSZ y, F
12BC  2ABB     GOTO 0x2BB
12BD  0BA6     DECFSZ x, F
12BE  2ABB     GOTO 0x2BB
12BF  2AC0     GOTO 0x2C0
12C0  1283     BCF STATUS, 0x5
12C1  1303     BCF STATUS, 0x6
12C2  3008     MOVLW 0x8
12C3  0AA7     INCF i, F
12C4  0227     SUBWF i, W
12C5  1C03     BTFSS STATUS, 0x0
12C6  2AB7     GOTO 0x2B7
148:           	NLinea=1;
12C7  01DF     CLRF NLinea
12C8  0ADF     INCF NLinea, F
149:           	
150:           #ifndef LCD_USE_3PINES
151:           /* ** Configuracin de pines ** */	
152:           	LCD_DATA_PIN_7 = 0;
12C9  1388     BCF PORTD, 0x7
153:           	LCD_DATA_PIN_6 = 0;
12CA  1308     BCF PORTD, 0x6
154:           	LCD_DATA_PIN_5 = 0;
12CB  1288     BCF PORTD, 0x5
155:           	LCD_DATA_PIN_4 = 0;
12CC  1208     BCF PORTD, 0x4
156:           	#ifdef LCD_USE_RW
157:           		LCD_RW_PIN = 0;
12CD  1088     BCF PORTD, 0x1
158:           	#endif
159:           	LCD_RS_PIN = 0;
12CE  1008     BCF PORTD, 0x0
160:           	LCD_E_PIN = 0;
12CF  1108     BCF PORTD, 0x2
161:           	
162:           	LCD_TRIS_DATA_PIN_7 = CONFIG_OUTPUT;
12D0  1683     BSF STATUS, 0x5
12D1  1388     BCF PORTD, 0x7
163:           	LCD_TRIS_DATA_PIN_6 = CONFIG_OUTPUT;
12D2  1308     BCF PORTD, 0x6
164:           	LCD_TRIS_DATA_PIN_5 = CONFIG_OUTPUT;
12D3  1288     BCF PORTD, 0x5
165:           	LCD_TRIS_DATA_PIN_4 = CONFIG_OUTPUT;
12D4  1208     BCF PORTD, 0x4
166:           	#ifdef LCD_USE_RW	
167:           		LCD_TRIS_RW = CONFIG_OUTPUT;
12D5  1088     BCF PORTD, 0x1
168:           	#endif
169:           	LCD_TRIS_RS = CONFIG_OUTPUT;
12D6  1008     BCF PORTD, 0x0
170:           	LCD_TRIS_E = CONFIG_OUTPUT;
12D7  1108     BCF PORTD, 0x2
171:           #else
172:           	LCD_DATA_PIN = 0;
173:           	LCD_CLOCK_PIN = 0;
174:           	LCD_E_PIN = 0;
175:           
176:           	LCD_TRIS_DATA = CONFIG_OUTPUT;
177:           	LCD_TRIS_CLOCK = CONFIG_OUTPUT;
178:           	LCD_TRIS_E = CONFIG_OUTPUT;
179:           	
180:           	for(i=0;i<8;i++){
181:           		LCD_DATA_PIN=0;
182:           		LCD_CLOCK_PIN=1;
183:           		__delay_1us();
184:           		LCD_CLOCK_PIN=0;
185:           	}
186:           #endif
187:           /* ** INICIALIZACION ** */     
188:           #ifndef LCD_USE_3PINES
189:           	LCD_DATA_PIN_5 = 1;
12D8  1283     BCF STATUS, 0x5
12D9  1688     BSF PORTD, 0x5
190:           	LCD_DATA_PIN_4 = 1;
12DA  1608     BSF PORTD, 0x4
191:           #else
192:           	temp=0x03;
193:           	for(i=0;i<8;i++){
194:           		LCD_DATA_PIN=!!(temp & 0x80);
195:           		temp<<=1;
196:           		LCD_CLOCK_PIN=1;
197:           		__delay_1us();
198:           		LCD_CLOCK_PIN=0;
199:           	}
200:           #endif
201:           	for(i=0;i<3;i++){
12DB  01A7     CLRF i
12F2  1283     BCF STATUS, 0x5
12F3  1303     BCF STATUS, 0x6
12F4  3003     MOVLW 0x3
12F5  0AA7     INCF i, F
12F6  0227     SUBWF i, W
12F7  1C03     BTFSS STATUS, 0x0
12F8  2ADC     GOTO 0x2DC
202:           		LCD_E_PIN = 1;
12DC  1508     BSF PORTD, 0x2
203:           		__delay_2ms();
12DD  300D     MOVLW 0xD
12DE  00A6     MOVWF x
12DF  30FB     MOVLW 0xFB
12E0  00A5     MOVWF y
12E1  0BA5     DECFSZ y, F
12E2  2AE1     GOTO 0x2E1
12E3  0BA6     DECFSZ x, F
12E4  2AE1     GOTO 0x2E1
12E5  2AE6     GOTO 0x2E6
204:           		LCD_E_PIN = 0;
12E6  1283     BCF STATUS, 0x5
12E7  1303     BCF STATUS, 0x6
12E8  1108     BCF PORTD, 0x2
205:           	 	__delay_2ms();
12E9  300D     MOVLW 0xD
12EA  00A6     MOVWF x
12EB  30FB     MOVLW 0xFB
12EC  00A5     MOVWF y
12ED  0BA5     DECFSZ y, F
12EE  2AED     GOTO 0x2ED
12EF  0BA6     DECFSZ x, F
12F0  2AED     GOTO 0x2ED
12F1  2AF2     GOTO 0x2F2
206:           	}
207:           #ifndef LCD_USE_3PINES
208:           	LCD_DATA_PIN_4 = 0;
12F9  1208     BCF PORTD, 0x4
209:           #else
210:           	temp=0x02;
211:           	for(i=0;i<8;i++){
212:           		LCD_DATA_PIN=!!(temp & 0x80);
213:           		temp<<=1;
214:           		LCD_CLOCK_PIN=1;
215:           		__delay_1us();
216:           		LCD_CLOCK_PIN=0;
217:           	}
218:           #endif
219:           	LCD_E_PIN = 1;
12FA  1508     BSF PORTD, 0x2
220:           	__delay_1us();
12FB  2AFC     GOTO 0x2FC
12FC  2AFD     GOTO 0x2FD
12FD  0000     NOP
221:           	LCD_E_PIN = 0;
12FE  1283     BCF STATUS, 0x5
12FF  1303     BCF STATUS, 0x6
1300  1108     BCF PORTD, 0x2
222:           
223:           	vWriteLCD(0x20 | (LcdType<<2),LCD_COMMAND);  // Tipo display.-  
1301  3028     MOVLW 0x28
1302  01A3     CLRF x
1303  2329     CALL 0x329
1304  160A     BSF PCLATH, 0x4
1305  118A     BCF PCLATH, 0x3
224:           	__delay_2ms();     
1306  300D     MOVLW 0xD
1307  00A6     MOVWF x
1308  30FB     MOVLW 0xFB
1309  00A5     MOVWF y
130A  0BA5     DECFSZ y, F
130B  2B0A     GOTO 0x30A
130C  0BA6     DECFSZ x, F
130D  2B0A     GOTO 0x30A
130E  2B0F     GOTO 0x30F
225:           	vWriteLCD(0x01,LCD_COMMAND);	// Borramos display.-   
130F  1283     BCF STATUS, 0x5
1310  1303     BCF STATUS, 0x6
1311  3001     MOVLW 0x1
1312  01A3     CLRF x
1313  2329     CALL 0x329
1314  160A     BSF PCLATH, 0x4
1315  118A     BCF PCLATH, 0x3
226:           	__delay_2ms();           
1316  300D     MOVLW 0xD
1317  00A6     MOVWF x
1318  30FB     MOVLW 0xFB
1319  00A5     MOVWF y
131A  0BA5     DECFSZ y, F
131B  2B1A     GOTO 0x31A
131C  0BA6     DECFSZ x, F
131D  2B1A     GOTO 0x31A
131E  2B1F     GOTO 0x31F
227:           	vWriteLCD(0x06,LCD_COMMAND);	// Incrementa cursor.-
131F  1283     BCF STATUS, 0x5
1320  1303     BCF STATUS, 0x6
1321  3006     MOVLW 0x6
1322  01A3     CLRF x
1323  2329     CALL 0x329
1324  160A     BSF PCLATH, 0x4
1325  118A     BCF PCLATH, 0x3
228:           	vWriteLCD(0x0C,LCD_COMMAND);	// Encendemos display.-
1326  300C     MOVLW 0xC
229:           }
230:           
231:           
232:           void vLCD_Putc(UINT8 Data){
1292  1283     BCF STATUS, 0x5
1293  00AA     MOVWF Data
233:           	
234:           	switch(Data){
1294  3A0A     XORLW 0xA
1295  1903     BTFSC STATUS, 0x2
1296  2AAD     GOTO 0x2AD
1297  3A06     XORLW 0x6
1298  1903     BTFSC STATUS, 0x2
1299  2A9C     GOTO 0x29C
129A  2AB2     GOTO 0x2B2
235:           		case '\f':
236:           			vWriteLCD(0x01,LCD_COMMAND);
129C  3001     MOVLW 0x1
129D  01A3     CLRF x
129E  2329     CALL 0x329
129F  160A     BSF PCLATH, 0x4
12A0  118A     BCF PCLATH, 0x3
237:           			NLinea=1;
12A2  01DF     CLRF NLinea
12A3  0ADF     INCF NLinea, F
238:           			__delay_2ms();
12A1  300D     MOVLW 0xD
12A4  00A9     MOVWF year
12A5  30FB     MOVLW 0xFB
12A6  00A8     MOVWF mth
12A7  0BA8     DECFSZ mth, F
12A8  2AA7     GOTO 0x2A7
12A9  0BA9     DECFSZ year, F
12AA  2AA7     GOTO 0x2A7
12AB  2AAC     GOTO 0x2AC
239:           		break;
12AC  0008     RETURN
240:           		case '\n':
241:           			vGotoxyLCD(1,++NLinea);			
12AD  0ADF     INCF NLinea, F
12AE  085F     MOVF NLinea, W
12AF  00A5     MOVWF y
12B0  3001     MOVLW 0x1
12B1  2A72     GOTO 0x272
242:           		break;
243:           		default:
244:           			vWriteLCD(Data,LCD_DATA);
12B2  01A3     CLRF x
12B3  0AA3     INCF x, F
12B4  082A     MOVF Data, W
12B5  2B29     GOTO 0x329
245:           	}
246:           } 
129B  0008     RETURN
247:           
248:           void vGotoxyLCD(UINT8 x,UINT8 y){
1272  00A6     MOVWF x
249:           UINT8 Direccion;
250:           
251:           	switch(y){
1273  2A7D     GOTO 0x27D
127D  0825     MOVF y, W
127E  3A01     XORLW 0x1
127F  1903     BTFSC STATUS, 0x2
1280  2A74     GOTO 0x274
1281  3A03     XORLW 0x3
1282  1903     BTFSC STATUS, 0x2
1283  2A78     GOTO 0x278
1284  2A74     GOTO 0x274
252:           		case 1:Direccion = LCD_LINE_1_ADDRESS;NLinea=1;break;
1274  01A7     CLRF i
1275  01DF     CLRF NLinea
1276  0ADF     INCF NLinea, F
1277  2A85     GOTO 0x285
253:           		case 2:Direccion = LCD_LINE_2_ADDRESS;NLinea=2;break;
1278  3040     MOVLW 0x40
1279  00A7     MOVWF i
127A  3002     MOVLW 0x2
127B  00DF     MOVWF NLinea
127C  2A85     GOTO 0x285
254:           		#ifdef LCD_4LINES
255:           		case 3:Direccion = LCD_LINE_3_ADDRESS;NLinea=3;break;
256:           		case 4:Direccion = LCD_LINE_4_ADDRESS;NLinea=4;break;
257:           		#endif
258:           		default:Direccion = LCD_LINE_1_ADDRESS;NLinea=1;break;
259:           	}
260:           
261:           	Direccion+=x-1;
1285  0826     MOVF x, W
1286  3EFF     ADDLW 0xFF
1287  07A7     ADDWF i, F
262:           	while(ui8BusyLCD());
1288  239A     CALL 0x39A
1289  160A     BSF PCLATH, 0x4
128A  118A     BCF PCLATH, 0x3
128B  3800     IORLW 0x0
128C  1D03     BTFSS STATUS, 0x2
128D  2A88     GOTO 0x288
263:           	vWriteLCD(0x80|Direccion,LCD_COMMAND);
128E  01A3     CLRF x
264:           }
265:           
266:           void vPuts_LCD(UINT8 *buffer){
267:           
268:           
269:               while(*buffer != '\0')    {
270:                  // vLCD_Putc(*buffer++);;
271:                   vWriteLCD(*buffer++,LCD_DATA);
272:               }
273:           }
274:           
275:           void vBlinkingLCD(void){
276:           	vWriteLCD(0b1101,LCD_COMMAND);
277:           }
278:           void vnoBlinkingLCD(void){
279:           	vWriteLCD(0b1100,LCD_COMMAND);
280:           }
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/HardI2C.c  ----------------------------
1:             /**************************************************************************
2:             *      Libreria para protocolo I2C Master por HardWare para HiTech        *
3:             ***************************************************************************
4:             
5:             ***************************************************************************
6:             *                                                                         *
7:             * Antes de incluir este archivo en nuestro programa hay que definir       *
8:             * algunos parametros. Estos son                                           *
9:             *                                                                         *
10:            * PIC_CLK        (se usa para calcular el valor de SSPADD)                *     
11:            * I2C_BAUD       (velocidad de transferencia)                             *
12:            *                                                                         *
13:            ***************************************************************************
14:            
15:            ***************************************************************************
16:            *                                                                         *
17:            * En esta libreria se encuentran las siguientes funciones                 *
18:            *                                                                         *
19:            * setup_i2c(char)               (inicializa el puerto I2C)                *
20:            * start_i2c()                   (envia start, inicia transmision)         *
21:            * rstar_i2c()                   (envia restart, reinicia transmision)     *
22:            * stop_i2c()                    (envia stop, termina transmision)         *
23:            * write_i2c(char)               (envia un byte)                           *
24:            * read_i2c(char)                (recibe un byte y envia ack o noack)      *
25:            *                                                                         *
26:            *  La funcion write_i2c() devuelve 0 si el dispositivo responde o 1 si el *
27:            * dispositivo no responde.                                                *
28:            *                                                                         *
29:            *  A la funcion read_i2c() hay que pasarle 0 si se quiere responder al    *
30:            * disipositivo o 1 si no se quiere responder                              *
31:            *                                                                         *
32:            *  En esta libreria estan definidos los parametros I2C_MASTER, I2C_SLAVE, *
33:            * I2C_10BIT_ADDRESS. Eston son utilizados en la funcion setup_i2c(char)   *
34:            *                                                                         *
35:            *  Tambien estan definidos ACK y NOACK que son los utilizados para        *
36:            * responder o no al dispositivo                                           *
37:            *                                                                         *
38:            ***************************************************************************
39:            
40:            * Ejemplo de configuracion y utilizacion
41:            
42:             #define PIC_CLK   10000000   // cristal 10MHz
43:             #define I2C_BAUD  100000     // velocidad 100 KHz
44:             #include "HardI2c.c"
45:            
46:             void main (void);
47:             {
48:               unsigned char respuesta;
49:               unsigned char dato;  
50:             
51:               ......
52:               ......
53:               ......
54:               setup_i2c (I2C_MASTER);
55:               start_i2c();
56:               respuesta = write_i2c (0b10101110);    // comunicacion para escribir en una 24C02C
57:               if (respuesta == ACK)
58:               {
59:                 write_i2c (0x00);                    // indico la direccion a escribir
60:                 write_i2c (0xF5);                    // escribo el dato F5
61:                 write_i2c (0x06);                    // escribo el dato 06
62:               }
63:               stop_i2c();
64:            
65:               // colocar un delay necesario para que termine de grabar la memoria
66:            
67:               start_i2c();
68:               respuesta = write_i2c (0b10101110);    // comunicacion para escribir en una 24C02C
69:               if (respuesta == ACK)
70:               {
71:                 write_i2c (0x00);                    // indico la direccion de memoria
72:                 rstart_i2c();                       // reinicio la transmisin
73:                 respuesta = write_i2c (0b10101111);  // comunicacion para leer en una 24C02C
74:                 if (respuesta == ACK)
75:                 {
76:                   dato = read_i2c (ACK);             // leo el dato y respondo
77:                   dato = read_i2c (NOACK);           // leo el dato y no respondo
78:                 }
79:               }
80:               stop_i2c();
81:             }
82:            
83:            */
84:            #include <xc.h>
85:            #include <stdbool.h>       /* For true/false definition */
86:            #include "system.h"        /* System funct/params, like osc/peripheral config */
87:            #include "HardI2C.h"
88:            
89:            
90:            #if defined (PIC_CLK) && defined (I2C_BAUD)
91:            
92:            void setup_i2c (char x)
0844  00A3     MOVWF x
93:             {
94:                TRISC3 = 1;
0845  1683     BSF STATUS, 0x5
0846  1587     BSF PORTC, 0x3
95:            
96:                TRISC4 = 1;
0847  1607     BSF PORTC, 0x4
97:            
98:                SSPSTAT = 0;
0848  0194     CLRF SSPCON
99:                SSPCON = x;
0849  1283     BCF STATUS, 0x5
084A  0823     MOVF x, W
084B  0094     MOVWF SSPCON
100:               
101:               SSPCON2 = 0;
084C  1683     BSF STATUS, 0x5
084D  0191     CLRF TMR2
102:               // SSPCON2bits.RCEN=1;
103:               if (SSPM3 == 1) SSPADD = (unsigned char)((PIC_CLK/(4*I2C_BAUD)) - 1);
084E  1283     BCF STATUS, 0x5
084F  1D94     BTFSS SSPCON, 0x3
0850  0008     RETURN
0851  300B     MOVLW 0xB
0852  1683     BSF STATUS, 0x5
0853  0093     MOVWF SSPBUF
104:           
105:           }
0854  0008     RETURN
106:           
107:             char start_i2c (void)
108:             { 
109:               while (( SSPCON2 & 0x1F ) || R_nW );
0B5E  1683     BSF STATUS, 0x5
0B5F  0811     MOVF TMR2, W
0B60  391F     ANDLW 0x1F
0B61  1903     BTFSC STATUS, 0x2
0B62  1914     BTFSC SSPCON, 0x2
0B63  2B5E     GOTO 0x35E
110:               SEN = 1;
0B64  1411     BSF TMR2, 0x0
111:               return !BCLIF;
112:             }
0B65  0008     RETURN
113:           
114:             void rstart_i2c (void)
115:             {
116:               while (( SSPCON2 & 0x1F ) || R_nW );
0BA2  1683     BSF STATUS, 0x5
0BA3  0811     MOVF TMR2, W
0BA4  391F     ANDLW 0x1F
0BA5  1903     BTFSC STATUS, 0x2
0BA6  1914     BTFSC SSPCON, 0x2
0BA7  2BA2     GOTO 0x3A2
117:               RSEN = 1;
0BA8  1491     BSF TMR2, 0x1
118:             }
0BA9  0008     RETURN
119:           
120:             void stop_i2c (void)
121:             {
122:               while (( SSPCON2 & 0x1F ) || R_nW );
0B66  1683     BSF STATUS, 0x5
0B67  0811     MOVF TMR2, W
0B68  391F     ANDLW 0x1F
0B69  1903     BTFSC STATUS, 0x2
0B6A  1914     BTFSC SSPCON, 0x2
0B6B  2B66     GOTO 0x366
123:               PEN = 1;
0B6C  1511     BSF TMR2, 0x2
124:             }
0B6D  0008     RETURN
125:           
126:             char write_i2c (unsigned char data)
0B34  1283     BCF STATUS, 0x5
0B35  00A3     MOVWF x
127:             {
128:               if (SSPM3 == 1)
0B36  1D94     BTFSS SSPCON, 0x3
0B37  2B48     GOTO 0x348
129:               {
130:                 while (( SSPCON2 & 0x1F ) || R_nW );
0B38  1683     BSF STATUS, 0x5
0B39  0811     MOVF TMR2, W
0B3A  391F     ANDLW 0x1F
0B3B  1903     BTFSC STATUS, 0x2
0B3C  1914     BTFSC SSPCON, 0x2
0B3D  2B38     GOTO 0x338
131:                 SSPBUF = data;
0B3E  1283     BCF STATUS, 0x5
0B3F  0823     MOVF x, W
0B40  0093     MOVWF SSPBUF
132:                 while (R_nW == 1);
0B41  1683     BSF STATUS, 0x5
0B42  1914     BTFSC SSPCON, 0x2
0B43  2B41     GOTO 0x341
133:                 //while(ACKSTAT==1);
134:                 return ACKSTAT;
0B44  3000     MOVLW 0x0
0B45  1B11     BTFSC TMR2, 0x6
0B46  3001     MOVLW 0x1
0B47  0008     RETURN
135:               }
136:               else
137:               {
138:                 SSPBUF = data;
0B48  0823     MOVF x, W
0B49  0093     MOVWF SSPBUF
139:                 CKP = 1;
0B4A  1614     BSF SSPCON, 0x4
140:                 return 0;
0B4B  3400     RETLW 0x0
141:               }
142:             }
143:           
144:             unsigned char read_i2c (unsigned char respuesta)
0B6E  1283     BCF STATUS, 0x5
0B6F  00A3     MOVWF x
145:             {
146:               unsigned char dato;
147:           
148:               if (SSPM3 == 1)
0B70  1D94     BTFSS SSPCON, 0x3
0B71  2B95     GOTO 0x395
149:               {
150:                 while (( SSPCON2 & 0x1F ) || R_nW );
0B72  1683     BSF STATUS, 0x5
0B73  0811     MOVF TMR2, W
0B74  391F     ANDLW 0x1F
0B75  1903     BTFSC STATUS, 0x2
0B76  1914     BTFSC SSPCON, 0x2
0B77  2B72     GOTO 0x372
151:                 RCEN = 1;
0B78  1591     BSF TMR2, 0x3
152:                 while (( SSPCON2 & 0x1F ) || R_nW );
0B79  0811     MOVF TMR2, W
0B7A  391F     ANDLW 0x1F
0B7B  1903     BTFSC STATUS, 0x2
0B7C  1914     BTFSC SSPCON, 0x2
0B7D  2B79     GOTO 0x379
153:                 dato = SSPBUF;
0B7E  1283     BCF STATUS, 0x5
0B7F  0813     MOVF SSPBUF, W
0B80  00A4     MOVWF dato
154:                 while (( SSPCON2 & 0x1F ) || R_nW );
0B81  1683     BSF STATUS, 0x5
0B82  0811     MOVF TMR2, W
0B83  391F     ANDLW 0x1F
0B84  1903     BTFSC STATUS, 0x2
0B85  1914     BTFSC SSPCON, 0x2
0B86  2B81     GOTO 0x381
155:                 ACKDT = respuesta;
0B87  1283     BCF STATUS, 0x5
0B88  1C23     BTFSS x, 0x0
0B89  2B8E     GOTO 0x38E
0B8A  1683     BSF STATUS, 0x5
0B8B  1303     BCF STATUS, 0x6
0B8C  1691     BSF TMR2, 0x5
0B8D  2B91     GOTO 0x391
0B8E  1683     BSF STATUS, 0x5
0B8F  1303     BCF STATUS, 0x6
0B90  1291     BCF TMR2, 0x5
156:                 ACKEN = 1;
0B91  1611     BSF TMR2, 0x4
157:                 return dato;
0B92  1283     BCF STATUS, 0x5
0B93  0824     MOVF dato, W
0B94  0008     RETURN
158:               }
159:               else
160:               {
161:                 dato = SSPBUF;
0B95  0813     MOVF SSPBUF, W
0B96  00A4     MOVWF dato
162:                 return dato;
163:               }
164:             }
0B97  0008     RETURN
165:           #else
166:             #error Faltan definir parametros
167:           #endif
