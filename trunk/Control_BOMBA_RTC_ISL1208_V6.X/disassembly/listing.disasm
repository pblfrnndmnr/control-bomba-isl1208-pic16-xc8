Disassembly Listing for Control_BOMBA_RTC_ISL1208_V6
Generated From:
/home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/dist/ISL1208_XC8_16f877a/production/Control_BOMBA_RTC_ISL1208_V6.X.production.cof
08/02/2015 14:43:45

---  /opt/microchip/xc8/v1.31/sources/pic/fldiv.c  ------------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (C) 2006 HI-TECH Software
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"flarith.h"
9:             
10:            #define	f1_as_dividend	(*(unsigned long *)&f1)
11:            #define	f2_as_divisor	(*(unsigned long *)&f2)
12:            #define	f3_as_quot	(*(unsigned long *)&f3)
13:            
14:            // floating addition
15:            #ifdef _OLDLIB
16:            #define	cntr		sign2
17:            double
18:            __fldiv(double f2, double f1)
19:            {
20:            	unsigned char	exp1, exp2, sign1, sign2;
21:            	double	f3;
22:            	
23:            	f3_as_quot = 0;
24:            	sign1 = __flunpack(&f1_as_dividend, &exp1);
25:            	if(exp1 == 0)
26:            		return f3;
27:            	sign2 = __flunpack(&f2_as_divisor, &exp2);
28:            	if(exp2 == 0)
29:            		return f3;
30:            	exp1 -= exp2-127+8;	// compute new exponent
31:            	sign1 ^= sign2;
32:            	cntr = 24+8;
33:            	do {
34:            		f3_as_quot <<= 1;
35:            		if(f1_as_dividend >= f2_as_divisor) {
36:            			f1_as_dividend -= f2_as_divisor;
37:            			f3_as_quot |= 1;
38:            		}
39:            		f1_as_dividend <<= 1;
40:            	} while(--cntr != 0);
41:            	__flpack(&f3_as_quot, exp1);
42:            	if(sign1)
43:            		f3_as_quot |= 0x80000000;
44:            	return f3;
45:            }
46:            #else
47:            #define	exp2	sign
48:            double
49:            __fldiv(double f2, double f1)
50:            {
51:            	unsigned char	exp, sign, cntr;
52:            	double	f3;
53:            	
54:            	// unpack the operands
55:            	if((exp = f1_as_dividend >> 23) == 0)
15C9  085C     MOVF f1, W
15CA  00E0     MOVWF 0x60
15CB  085D     MOVF 0x5D, W
15CC  00E1     MOVWF 0x61
15CD  085E     MOVF 0x5E, W
15CE  00E2     MOVWF 0x62
15CF  085F     MOVF 0x5F, W
15D0  00E3     MOVWF 0x63
15D1  1003     BCF STATUS, 0x0
15D2  0D62     RLF 0x62, W
15D3  0D63     RLF 0x63, W
15D4  00E9     MOVWF exp
15D5  08E9     MOVF exp, F
15D6  1D03     BTFSS STATUS, 0x2
15D7  2DDD     GOTO 0x5DD
56:            		return 0.0;
15D8  01D8     CLRF f2
15D9  01D9     CLRF 0x59
15DA  01DA     CLRF 0x5A
15DB  01DB     CLRF 0x5B
15DC  0008     RETURN
57:            	if((exp2 = f2_as_divisor >> 23) == 0)
15DD  0858     MOVF f2, W
15DE  00E0     MOVWF 0x60
15DF  0859     MOVF 0x59, W
15E0  00E1     MOVWF 0x61
15E1  085A     MOVF 0x5A, W
15E2  00E2     MOVWF 0x62
15E3  085B     MOVF 0x5B, W
15E4  00E3     MOVWF 0x63
15E5  1003     BCF STATUS, 0x0
15E6  0D62     RLF 0x62, W
15E7  0D63     RLF 0x63, W
15E8  00EA     MOVWF sign
15E9  08EA     MOVF sign, F
15EA  1D03     BTFSS STATUS, 0x2
15EB  2DF1     GOTO 0x5F1
58:            		return 0.0;
15EC  01D8     CLRF f2
15ED  01D9     CLRF 0x59
15EE  01DA     CLRF 0x5A
15EF  01DB     CLRF 0x5B
15F0  0008     RETURN
59:            	exp -= exp2-127+8;	// compute new exponent
15F1  3089     MOVLW 0x89
15F2  076A     ADDWF sign, W
15F3  00E0     MOVWF 0x60
15F4  02E9     SUBWF exp, F
60:            	sign = f1_as_dividend >> 24;
15F5  085F     MOVF 0x5F, W
15F6  00EA     MOVWF sign
61:            	sign ^= (unsigned char)(f2_as_divisor >> 24);
15F7  085B     MOVF 0x5B, W
15F8  06EA     XORWF sign, F
62:            	sign &= 0x80;
15F9  3080     MOVLW 0x80
15FA  05EA     ANDWF sign, F
63:            	f1_as_dividend |= 0x800000UL;
15FC  17DE     BSF 0x5E, 0x7
64:            	f1_as_dividend &= 0xFFFFFFUL;
15FD  01DF     CLRF 0x5F
65:            	f2_as_divisor |= 0x800000UL;
15FE  17DA     BSF 0x5A, 0x7
66:            	f2_as_divisor &= 0xFFFFFFUL;
15FF  01DB     CLRF 0x5B
67:            	cntr = 24+8;
15FB  3020     MOVLW 0x20
1600  00E8     MOVWF cntr
68:            	do {
69:            		f3_as_quot <<= 1;
1601  1003     BCF STATUS, 0x0
1602  0DE4     RLF f3, F
1603  0DE5     RLF 0x65, F
1604  0DE6     RLF 0x66, F
1605  0DE7     RLF 0x67, F
70:            		if(f1_as_dividend >= f2_as_divisor) {
1606  085B     MOVF 0x5B, W
1607  025F     SUBWF 0x5F, W
1608  1D03     BTFSS STATUS, 0x2
1609  2E14     GOTO 0x614
160A  085A     MOVF 0x5A, W
160B  025E     SUBWF 0x5E, W
160C  1D03     BTFSS STATUS, 0x2
160D  2E14     GOTO 0x614
160E  0859     MOVF 0x59, W
160F  025D     SUBWF 0x5D, W
1610  1D03     BTFSS STATUS, 0x2
1611  2E14     GOTO 0x614
1612  0858     MOVF f2, W
1613  025C     SUBWF f1, W
1614  1C03     BTFSS STATUS, 0x0
1615  2E26     GOTO 0x626
71:            			f1_as_dividend -= f2_as_divisor;
1616  0858     MOVF f2, W
1617  02DC     SUBWF f1, F
1618  0859     MOVF 0x59, W
1619  1C03     BTFSS STATUS, 0x0
161A  0F59     INCFSZ 0x59, W
161B  02DD     SUBWF 0x5D, F
161C  085A     MOVF 0x5A, W
161D  1C03     BTFSS STATUS, 0x0
161E  0F5A     INCFSZ 0x5A, W
161F  02DE     SUBWF 0x5E, F
1620  085B     MOVF 0x5B, W
1621  1C03     BTFSS STATUS, 0x0
1622  0F5B     INCFSZ 0x5B, W
1623  02DF     SUBWF 0x5F, F
72:            			f3_as_quot |= 1;
1624  1464     BSF f3, 0x0
73:            		}
74:            		f1_as_dividend <<= 1;
1625  1003     BCF STATUS, 0x0
1626  0DDC     RLF f1, F
1627  0DDD     RLF 0x5D, F
1628  0DDE     RLF 0x5E, F
1629  0DDF     RLF 0x5F, F
75:            	} while(--cntr != 0);
162A  0BE8     DECFSZ cntr, F
162B  2E01     GOTO 0x601
76:            	return __flpack(f3_as_quot, exp, sign);
162C  0867     MOVF 0x67, W
162D  00A7     MOVWF x
162E  0866     MOVF 0x66, W
162F  00A6     MOVWF y
1630  0865     MOVF 0x65, W
1631  00A5     MOVWF dato
1632  0864     MOVF f3, W
1633  00A4     MOVWF x
1634  0869     MOVF exp, W
1635  00A8     MOVWF i
1636  086A     MOVF sign, W
1637  00A9     MOVWF mth
1638  27B5     CALL 0x7B5
1639  0827     MOVF x, W
163A  00DB     MOVWF 0x5B
163B  0826     MOVF y, W
163C  00DA     MOVWF 0x5A
163D  0825     MOVF dato, W
163E  00D9     MOVWF 0x59
163F  0824     MOVF x, W
1640  00D8     MOVWF f2
77:            }
1641  0008     RETURN
78:            #endif
---  /opt/microchip/xc8/v1.31/sources/pic/eewrite.c  ----------------------------------------------------
1:             #include	<htc.h>
2:             
3:             #if	EEPROM_SIZE > 0
4:             
5:             void
6:             eeprom_write(unsigned char addr, unsigned char value)
1071  00A5     MOVWF dato
7:             {
8:             	EEPROM_WRITE(addr, value);
1072  1683     BSF STATUS, 0x5
1073  1703     BSF STATUS, 0x6
1074  188C     BTFSC PIR1, 0x1
1075  2872     GOTO 0x72
1076  1283     BCF STATUS, 0x5
1077  1303     BCF STATUS, 0x6
1078  0825     MOVF dato, W
1079  1703     BSF STATUS, 0x6
107A  008D     MOVWF PIR2
107B  1303     BCF STATUS, 0x6
107C  0824     MOVF x, W
107D  1703     BSF STATUS, 0x6
107E  008C     MOVWF PIR1
107F  303F     MOVLW 0x3F
1080  1683     BSF STATUS, 0x5
1081  058C     ANDWF PIR1, F
1082  1003     BCF STATUS, 0x0
1083  1B8B     BTFSC INTCON, 0x7
1084  1403     BSF STATUS, 0x0
1085  138B     BCF INTCON, 0x7
1086  150C     BSF PIR1, 0x2
1087  3055     MOVLW 0x55
1088  008D     MOVWF PIR2
1089  30AA     MOVLW 0xAA
108A  008D     MOVWF PIR2
108B  148C     BSF PIR1, 0x1
108C  110C     BCF PIR1, 0x2
108D  1803     BTFSC STATUS, 0x0
108E  178B     BSF INTCON, 0x7
9:             }
108F  0008     RETURN
10:            #endif
11:            
---  /opt/microchip/xc8/v1.31/sources/pic/eeread.c  -----------------------------------------------------
1:             #include	<htc.h>
2:             
3:             #if	EEPROM_SIZE > 0
4:             
5:             unsigned char
6:             eeprom_read(unsigned char addr)
1056  1283     BCF STATUS, 0x5
1057  00A4     MOVWF x
7:             {
8:             	do
9:             		CLRWDT();
105B  0064     CLRWDT
10:            	while(WR);
1058  285B     GOTO 0x5B
1059  1283     BCF STATUS, 0x5
105A  1303     BCF STATUS, 0x6
105C  1683     BSF STATUS, 0x5
105D  1703     BSF STATUS, 0x6
105E  188C     BTFSC PIR1, 0x1
105F  2859     GOTO 0x59
11:            	return EEPROM_READ(addr);
1060  1283     BCF STATUS, 0x5
1061  1303     BCF STATUS, 0x6
1062  0824     MOVF x, W
1063  1703     BSF STATUS, 0x6
1064  008D     MOVWF PIR2
1065  303F     MOVLW 0x3F
1066  1683     BSF STATUS, 0x5
1067  058C     ANDWF PIR1, F
1068  140C     BSF PIR1, 0x0
1069  1003     BCF STATUS, 0x0
106A  180C     BTFSC PIR1, 0x0
106B  1403     BSF STATUS, 0x0
106C  1803     BTFSC STATUS, 0x0
106D  3001     MOVLW 0x1
106E  1283     BCF STATUS, 0x5
106F  080C     MOVF PIR1, W
12:            }
1070  0008     RETURN
13:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/wmul.c  ----------------------------------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             unsigned int
3:             __wmul(unsigned int multiplier, unsigned int multiplicand)
4:             {
5:                     unsigned int product;
6:             
7:             #ifdef _PIC18
8:             
9:             #define LOWBYTE(x)  (*(unsigned char *)(&x))
10:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
11:            
12:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
13:            /*
14:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
15:                   a  b
16:            *      c  d
17:            -----------
18:                 |   bd
19:                 |ad  0
20:                 |bc  0
21:            +  ac| 0  0 (we ignore this intermediate product
22:                         because it does not affect the low 16 bits of the result)
23:            ===========
24:             */
25:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
26:                    product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
27:                    product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
28:            
29:            #else
30:            
31:            	product = 0;
1581  01A8     CLRF i
1582  01A9     CLRF mth
32:            	do {
33:            		if(multiplier & 1)
1583  1C24     BTFSS x, 0x0
1584  2D8B     GOTO 0x58B
34:            			product += multiplicand;
1585  0826     MOVF y, W
1586  07A8     ADDWF i, F
1587  1803     BTFSC STATUS, 0x0
1588  0AA9     INCF mth, F
1589  0827     MOVF x, W
158A  07A9     ADDWF mth, F
35:            		multiplicand <<= 1;
158B  1003     BCF STATUS, 0x0
158C  0DA6     RLF y, F
158D  0DA7     RLF x, F
36:            		multiplier >>= 1;
158E  1003     BCF STATUS, 0x0
158F  0CA5     RRF dato, F
1590  0CA4     RRF x, F
37:            	} while(multiplier != 0);
1591  0825     MOVF dato, W
1592  0424     IORWF x, W
1593  1D03     BTFSS STATUS, 0x2
1594  2D83     GOTO 0x583
38:            
39:            #endif
40:                    return product;
1595  0829     MOVF mth, W
1596  00A5     MOVWF dato
1597  0828     MOVF i, W
1598  00A4     MOVWF x
41:            }
1599  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/strncpy.c  -------------------------------------------------
1:             #include	<string.h>
2:             
3:             #ifdef _PIC16
4:             far char *
5:             strncpy(register far char * to, register const char * from, register size_t size)
6:             #else /* _PIC16 */
7:             char *
8:             strncpy(register char * to, register const char * from, register size_t size)
0814  00AB     MOVWF Data
9:             #endif /* _PIC16 */
10:            {
11:            
12:            #ifdef _PIC16
13:            	register far char *	cp;
14:            #else /* _PIC16 */
15:            	register char *	cp;
16:            #endif /* _PIC16 */
17:            
18:            	cp = to;
0815  00AC     MOVWF sec
19:            	while(size) {
0816  0827     MOVF x, W
0817  0426     IORWF y, W
0819  1903     BTFSC STATUS, 0x2
081A  2841     GOTO 0x41
083A  2816     GOTO 0x16
20:            		size--;
0818  3001     MOVLW 0x1
081B  02A6     SUBWF y, F
081C  3000     MOVLW 0x0
081D  1C03     BTFSS STATUS, 0x0
081E  03A7     DECF x, F
081F  02A7     SUBWF x, F
21:            		if(!(*cp++ = *from++))
0820  0825     MOVF dato, W
0821  00A9     MOVWF mth
0822  0824     MOVF x, W
0823  00A8     MOVWF i
0824  0AA4     INCF x, F
0825  1903     BTFSC STATUS, 0x2
0826  0AA5     INCF dato, F
0827  0829     MOVF mth, W
0828  00FF     MOVWF 0x7F
0829  0828     MOVF i, W
082A  0084     MOVWF FSR
082B  160A     BSF PCLATH, 0x4
082C  158A     BSF PCLATH, 0x3
082D  2000     CALL 0x0
082E  120A     BCF PCLATH, 0x4
082F  158A     BSF PCLATH, 0x3
0830  00AA     MOVWF year
0831  082C     MOVF sec, W
0832  0AAC     INCF sec, F
0833  0084     MOVWF FSR
0834  082A     MOVF year, W
0835  1783     BSF STATUS, 0x7
0836  0080     MOVWF INDF
0837  0880     MOVF INDF, F
0838  1903     BTFSC STATUS, 0x2
0839  2840     GOTO 0x40
22:            			break;
23:            	}
24:            	while(size--)
0840  3001     MOVLW 0x1
0841  02A6     SUBWF y, F
0842  3000     MOVLW 0x0
0843  1C03     BTFSS STATUS, 0x0
0844  03A7     DECF x, F
0845  02A7     SUBWF x, F
0846  0A26     INCF y, W
0847  1903     BTFSC STATUS, 0x2
0848  0A27     INCF x, W
0849  1903     BTFSC STATUS, 0x2
084A  0008     RETURN
084B  283B     GOTO 0x3B
25:            		*cp++ = 0;
083B  082C     MOVF sec, W
26:            	return to;
27:            }
---  /opt/microchip/xc8/v1.31/sources/common/lwtofl.c  --------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"flarith.h"
9:             
10:            
11:            // Convert unsigned int to float
12:            
13:            #ifdef _OLDLIB
14:            #define	f1_as_mant1	(*(unsigned long *)&f1)
15:            double
16:            __lwtofl(unsigned int c)
17:            {
18:            	double	f1;
19:            	
20:            	if(c == 0)
21:            		return 0.0;
22:            	f1_as_mant1 = c;
23:            	__flpack(&f1_as_mant1, 127+23);
24:            	return f1;
25:            }
26:            #else
27:            double
28:            __lwtofl(unsigned int c)
29:            {
30:            	return __flpack(c, 127+23, 0);
159A  082E     MOVF day, W
159B  00A4     MOVWF x
159C  082F     MOVF counter, W
159D  00A5     MOVWF dato
159E  3096     MOVLW 0x96
159F  01A6     CLRF y
15A0  01A7     CLRF x
15A1  00A8     MOVWF i
15A2  01A9     CLRF mth
15A3  27B5     CALL 0x7B5
15A4  0827     MOVF x, W
15A5  00B1     MOVWF 0x31
15A6  0826     MOVF y, W
15A7  00B0     MOVWF f
15A8  0825     MOVF dato, W
15A9  00AF     MOVWF counter
15AA  0824     MOVF x, W
15AB  00AE     MOVWF day
31:            }
15AC  0008     RETURN
32:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/lwmod.c  ---------------------------------------------------
1:             // word unsigned modulus
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwmod(unsigned int divisor, unsigned int dividend)
0FB6  0871     MOVF canal, W
155D  082C     MOVF sec, W
7:             #else
8:             __lwmod(unsigned int dividend, unsigned int divisor)
9:             #endif
10:            {
11:            	unsigned char	counter;
12:            
13:            	if(divisor != 0) {
0FB6  0871     MOVF canal, W
0FB7  0470     IORWF tiempo, W
0FB8  1903     BTFSC STATUS, 0x2
0FB9  2FD5     GOTO 0x7D5
155D  082C     MOVF sec, W
155E  042B     IORWF Data, W
155F  1903     BTFSC STATUS, 0x2
1560  2D7C     GOTO 0x57C
14:            		counter = 1;
0FBA  01F4     CLRF counter
1561  01AF     CLRF counter
15:            		while((divisor & 0x8000) == 0) {
0FBC  1BF1     BTFSC canal, 0x7
0FBD  2FC2     GOTO 0x7C2
0FC1  2FBB     GOTO 0x7BB
1563  1BAC     BTFSC sec, 0x7
1564  2D69     GOTO 0x569
1568  2D62     GOTO 0x562
16:            			divisor <<= 1;
0FBB  0AF4     INCF counter, F
0FBE  1003     BCF STATUS, 0x0
0FBF  0DF0     RLF tiempo, F
0FC0  0DF1     RLF canal, F
1562  0AAF     INCF counter, F
1565  1003     BCF STATUS, 0x0
1566  0DAB     RLF Data, F
1567  0DAC     RLF sec, F
17:            			counter++;
0FBB  0AF4     INCF counter, F
1562  0AAF     INCF counter, F
18:            		}
19:            		do {
20:            			if(divisor <= dividend)
0FC2  0871     MOVF canal, W
0FC3  0273     SUBWF counter, W
0FC4  1D03     BTFSS STATUS, 0x2
0FC5  2FC8     GOTO 0x7C8
0FC6  0870     MOVF tiempo, W
0FC7  0272     SUBWF dividend, W
0FC8  1C03     BTFSS STATUS, 0x0
0FC9  2FD1     GOTO 0x7D1
1569  082C     MOVF sec, W
156A  022E     SUBWF day, W
156B  1D03     BTFSS STATUS, 0x2
156C  2D6F     GOTO 0x56F
156D  082B     MOVF Data, W
156E  022D     SUBWF hr, W
156F  1C03     BTFSS STATUS, 0x0
1570  2D78     GOTO 0x578
21:            				dividend -= divisor;
0FCA  0870     MOVF tiempo, W
0FCB  02F2     SUBWF dividend, F
0FCC  0871     MOVF canal, W
0FCD  1C03     BTFSS STATUS, 0x0
0FCE  03F3     DECF counter, F
0FCF  02F3     SUBWF counter, F
1571  082B     MOVF Data, W
1572  02AD     SUBWF hr, F
1573  082C     MOVF sec, W
1574  1C03     BTFSS STATUS, 0x0
1575  03AE     DECF day, F
1576  02AE     SUBWF day, F
22:            			divisor >>= 1;
0FD0  1003     BCF STATUS, 0x0
0FD1  0CF1     RRF canal, F
0FD2  0CF0     RRF tiempo, F
1577  1003     BCF STATUS, 0x0
1578  0CAC     RRF sec, F
1579  0CAB     RRF Data, F
23:            		} while(--counter != 0);
0FD3  0BF4     DECFSZ counter, F
0FD4  2FC2     GOTO 0x7C2
157A  0BAF     DECFSZ counter, F
157B  2D69     GOTO 0x569
24:            	}
25:            	return dividend;
0FD5  0873     MOVF counter, W
0FD6  00F1     MOVWF canal
0FD7  0872     MOVF dividend, W
0FD8  00F0     MOVWF tiempo
157C  082E     MOVF day, W
157D  00AC     MOVWF sec
157E  082D     MOVF hr, W
157F  00AB     MOVWF Data
26:            }
0FD9  0008     RETURN
1580  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/lwdiv.c  ---------------------------------------------------
1:             // word unsigned division
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwdiv(unsigned int divisor, unsigned int dividend)
7:             #else
8:             __lwdiv(unsigned int dividend, unsigned int divisor)
9:             #endif
10:            {
11:            	unsigned int	quotient;
12:            	unsigned char	counter;
13:            
14:            	quotient = 0;
1533  01A9     CLRF mth
1534  01AA     CLRF year
15:            	if(divisor != 0) {
1535  0825     MOVF dato, W
1536  0424     IORWF x, W
1537  1903     BTFSC STATUS, 0x2
1538  2D58     GOTO 0x558
16:            		counter = 1;
1539  01A8     CLRF i
17:            		while((divisor & 0x8000) == 0) {
153B  1BA5     BTFSC dato, 0x7
153C  2D41     GOTO 0x541
1540  2D3A     GOTO 0x53A
18:            			divisor <<= 1;
153A  0AA8     INCF i, F
153D  1003     BCF STATUS, 0x0
153E  0DA4     RLF x, F
153F  0DA5     RLF dato, F
19:            			counter++;
153A  0AA8     INCF i, F
20:            		}
21:            		do {
22:            			quotient <<= 1;
1541  1003     BCF STATUS, 0x0
1542  0DA9     RLF mth, F
1543  0DAA     RLF year, F
23:            			if(divisor <= dividend) {
1544  0825     MOVF dato, W
1545  0227     SUBWF x, W
1546  1D03     BTFSS STATUS, 0x2
1547  2D4A     GOTO 0x54A
1548  0824     MOVF x, W
1549  0226     SUBWF y, W
154A  1C03     BTFSS STATUS, 0x0
154B  2D54     GOTO 0x554
24:            				dividend -= divisor;
154C  0824     MOVF x, W
154D  02A6     SUBWF y, F
154E  0825     MOVF dato, W
154F  1C03     BTFSS STATUS, 0x0
1550  03A7     DECF x, F
1551  02A7     SUBWF x, F
25:            				quotient |= 1;
1552  1429     BSF mth, 0x0
26:            			}
27:            			divisor >>= 1;
1553  1003     BCF STATUS, 0x0
1554  0CA5     RRF dato, F
1555  0CA4     RRF x, F
28:            		} while(--counter != 0);
1556  0BA8     DECFSZ i, F
1557  2D41     GOTO 0x541
29:            	}
30:            	return quotient;
1558  082A     MOVF year, W
1559  00A5     MOVWF dato
155A  0829     MOVF mth, W
155B  00A4     MOVWF x
31:            }
155C  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/lbmod.c  ---------------------------------------------------
1:             // byte unsigned modulus
2:             
3:             unsigned char
4:             __lbmod(unsigned char dividend, unsigned char divisor)
0770  00F2     MOVWF dividend
0BE9  00A6     MOVWF y
5:             {
6:             	unsigned char	rem;
7:             	unsigned char	counter;
8:             
9:             	counter = 8;
0771  3008     MOVLW 0x8
0772  00F3     MOVWF counter
0BEA  3008     MOVLW 0x8
0BEB  00A7     MOVWF x
10:            	rem = 0;
0773  01F4     CLRF counter
0BEC  01A8     CLRF i
11:            	do {
12:            		rem = (rem << 1) | (dividend >> 7);
0774  0872     MOVF dividend, W
0775  00F1     MOVWF canal
0776  3007     MOVLW 0x7
0777  1003     BCF STATUS, 0x0
0778  0CF1     RRF canal, F
0779  3EFF     ADDLW 0xFF
077A  1003     BCF STATUS, 0x0
077B  1D03     BTFSS STATUS, 0x2
077C  2F78     GOTO 0x778
077D  0D74     RLF counter, W
077E  0471     IORWF canal, W
077F  00F4     MOVWF counter
0BED  0826     MOVF y, W
0BEE  00A5     MOVWF dato
0BEF  3007     MOVLW 0x7
0BF0  1003     BCF STATUS, 0x0
0BF1  0CA5     RRF dato, F
0BF2  3EFF     ADDLW 0xFF
0BF3  1003     BCF STATUS, 0x0
0BF4  1D03     BTFSS STATUS, 0x2
0BF5  2BF1     GOTO 0x3F1
0BF6  0D28     RLF i, W
0BF7  0425     IORWF dato, W
0BF8  00A8     MOVWF i
13:            		dividend <<= 1;
0780  1003     BCF STATUS, 0x0
0781  0DF2     RLF dividend, F
0BF9  1003     BCF STATUS, 0x0
0BFA  0DA6     RLF y, F
14:            		if(divisor <= rem)
0782  0870     MOVF tiempo, W
0783  0274     SUBWF counter, W
0784  1C03     BTFSS STATUS, 0x0
0785  2F88     GOTO 0x788
0BFB  0824     MOVF x, W
0BFC  0228     SUBWF i, W
0BFD  1C03     BTFSS STATUS, 0x0
0BFE  2C01     GOTO 0x401
15:            			rem -= divisor;
0786  0870     MOVF tiempo, W
0787  02F4     SUBWF counter, F
0BFF  0824     MOVF x, W
0C00  02A8     SUBWF i, F
16:            	} while(--counter != 0);
0788  0BF3     DECFSZ counter, F
0789  2F74     GOTO 0x774
0C01  0BA7     DECFSZ x, F
0C02  2BED     GOTO 0x3ED
17:            	return rem;
078A  0874     MOVF counter, W
0C03  0828     MOVF i, W
18:            }
078B  0008     RETURN
0C04  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/lbdiv.c  ---------------------------------------------------
1:             // byte unsigned division
2:             
3:             unsigned char
4:             __lbdiv(unsigned char dividend, unsigned char divisor)
0BC0  00A5     MOVWF dato
5:             {
6:             	unsigned char	quotient;
7:             	unsigned char	counter;
8:             
9:             	quotient = 0;
0BC1  01A7     CLRF x
10:            	if(divisor != 0) {
0BC2  0824     MOVF x, W
0BC3  1903     BTFSC STATUS, 0x2
0BC4  2BD9     GOTO 0x3D9
11:            		counter = 1;
0BC5  01A6     CLRF y
12:            		while((divisor & 0x80) == 0) {
0BC7  1BA4     BTFSC x, 0x7
0BC8  2BCC     GOTO 0x3CC
0BCB  2BC6     GOTO 0x3C6
13:            			divisor <<= 1;
0BC9  1003     BCF STATUS, 0x0
0BCA  0DA4     RLF x, F
14:            			counter++;
0BC6  0AA6     INCF y, F
15:            		}
16:            		do {
17:            			quotient <<= 1;
0BCC  1003     BCF STATUS, 0x0
0BCD  0DA7     RLF x, F
18:            			if(divisor <= dividend) {
0BCE  0824     MOVF x, W
0BCF  0225     SUBWF dato, W
0BD0  1C03     BTFSS STATUS, 0x0
0BD1  2BD6     GOTO 0x3D6
19:            				dividend -= divisor;
0BD2  0824     MOVF x, W
0BD3  02A5     SUBWF dato, F
20:            				quotient |= 1;
0BD4  1427     BSF x, 0x0
21:            			}
22:            			divisor >>= 1;
0BD5  1003     BCF STATUS, 0x0
0BD6  0CA4     RRF x, F
23:            		} while(--counter != 0);
0BD7  0BA6     DECFSZ y, F
0BD8  2BCC     GOTO 0x3CC
24:            	}
25:            	return quotient;
0BD9  0827     MOVF x, W
26:            }
0BDA  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/isdigit.c  -------------------------------------------------
1:             #include	<ctype.h>
2:             
3:             #ifndef isdigit
4:             
5:             #ifdef _CTYPE_BIT_FUNCS_
6:             
7:             bit
8:             isdigit(char c)
1525  00A5     MOVWF dato
9:             #else
10:            int
11:            isdigit(int c)
12:            #endif
13:            {
14:            	return c <= '9' && c >= '0';
1526  303A     MOVLW 0x3A
1527  01A4     CLRF x
1528  0225     SUBWF dato, W
1529  1803     BTFSC STATUS, 0x0
152A  2D31     GOTO 0x531
152B  3030     MOVLW 0x30
152C  0225     SUBWF dato, W
152D  1C03     BTFSS STATUS, 0x0
152E  2D31     GOTO 0x531
152F  01A4     CLRF x
1530  0AA4     INCF x, F
1531  0C24     RRF x, W
15:            }
1532  0008     RETURN
16:            
17:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/fltol.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"flarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned long *)&f1)
11:            
12:            // Convert float to long
13:            #ifdef _OLDLIB
14:            long
15:            __fltol(double f1)
16:            {
17:            	unsigned char	sign1, exp1;
18:            	unsigned long	lval;
19:            
20:            	sign1 = __flunpack(&f1_as_mant1, &exp1);
21:            	lval = f1_as_mant1;
22:            	exp1 -= 127+23;
23:            	if((signed char)exp1 < 0) {
24:            		if((signed char)exp1 < -23)
25:            			return 0;
26:            		do
27:            			lval >>= 1;
28:            		while(++exp1 != 0);
29:            	} else {
30:            		if(exp1 >= 32)
31:            			return 00;
32:            		while(exp1 != 0) {
33:            			lval <<= 1;
34:            			exp1--;
35:            		}
36:            	}
37:            	if(sign1)
38:            		lval = -lval;
39:            	return lval;
40:            }
41:            #else
42:            long
43:            __fltol(double f1)
44:            {
45:            	unsigned char	sign1, exp1;
46:            
47:            	if((exp1 = f1_as_mant1 >> 23) == 0)
08D5  0824     MOVF x, W
08D6  00A8     MOVWF i
08D7  0825     MOVF dato, W
08D8  00A9     MOVWF mth
08D9  0826     MOVF y, W
08DA  00AA     MOVWF year
08DB  0827     MOVF x, W
08DC  00AB     MOVWF Data
08DD  1003     BCF STATUS, 0x0
08DE  0D2A     RLF year, W
08DF  0D2B     RLF Data, W
08E0  00AD     MOVWF hr
08E1  08AD     MOVF hr, F
08E2  1D03     BTFSS STATUS, 0x2
08E3  28E9     GOTO 0xE9
48:            		return 0;
08E4  01A4     CLRF x
08E5  01A5     CLRF dato
08E6  01A6     CLRF y
08E7  01A7     CLRF x
08E8  0008     RETURN
49:            	sign1 = f1_as_mant1 >> 31;
08E9  0824     MOVF x, W
08EA  00A8     MOVWF i
08EB  0825     MOVF dato, W
08EC  00A9     MOVWF mth
08ED  0826     MOVF y, W
08EE  00AA     MOVWF year
08EF  0827     MOVF x, W
08F0  00AB     MOVWF Data
08F1  301F     MOVLW 0x1F
08F2  1003     BCF STATUS, 0x0
08F3  0CAB     RRF Data, F
08F4  0CAA     RRF year, F
08F5  0CA9     RRF mth, F
08F6  0CA8     RRF i, F
08F7  3EFF     ADDLW 0xFF
08F8  1D03     BTFSS STATUS, 0x2
08F9  28F2     GOTO 0xF2
08FA  0828     MOVF i, W
08FB  00AC     MOVWF sec
50:            	f1_as_mant1 |= 0x800000UL;
08FD  17A6     BSF y, 0x7
51:            	f1_as_mant1 &= 0xFFFFFFUL;
08FE  01A7     CLRF x
52:            	exp1 -= 127+23;
08FC  3096     MOVLW 0x96
08FF  02AD     SUBWF hr, F
53:            	if((signed char)exp1 < 0) {
0900  1FAD     BTFSS hr, 0x7
0901  290F     GOTO 0x10F
54:            		if((signed char)exp1 < -23)
0902  082D     MOVF hr, W
0903  3A80     XORLW 0x80
0904  3E97     ADDLW 0x97
0905  1C03     BTFSS STATUS, 0x0
0906  28E4     GOTO 0xE4
55:            			return 0;
56:            		do
57:            			f1_as_mant1 >>= 1;
0907  1003     BCF STATUS, 0x0
0908  0CA7     RRF x, F
0909  0CA6     RRF y, F
090A  0CA5     RRF dato, F
090B  0CA4     RRF x, F
58:            		while(++exp1 != 0);
090C  0FAD     INCFSZ hr, F
090D  2907     GOTO 0x107
090E  291D     GOTO 0x11D
59:            	} else {
60:            		if(exp1 >= 32)
090F  3020     MOVLW 0x20
0910  022D     SUBWF hr, W
0911  1803     BTFSC STATUS, 0x0
0912  28E4     GOTO 0xE4
61:            			return 00;
62:            		while(exp1 != 0) {
0913  08AD     MOVF hr, F
091C  2913     GOTO 0x113
63:            			f1_as_mant1 <<= 1;
0916  1003     BCF STATUS, 0x0
0917  0DA4     RLF x, F
0918  0DA5     RLF dato, F
0919  0DA6     RLF y, F
091A  0DA7     RLF x, F
64:            			exp1--;
091B  03AD     DECF hr, F
65:            		}
0913  08AD     MOVF hr, F
0914  1903     BTFSC STATUS, 0x2
0915  291D     GOTO 0x11D
66:            	}
67:            	if(sign1)
091D  082C     MOVF sec, W
091E  1903     BTFSC STATUS, 0x2
091F  0008     RETURN
68:            		f1_as_mant1 = -f1_as_mant1;
0920  09A4     COMF x, F
0921  09A5     COMF dato, F
0922  09A6     COMF y, F
0923  09A7     COMF x, F
0924  0AA4     INCF x, F
0925  1903     BTFSC STATUS, 0x2
0926  0AA5     INCF dato, F
0927  1903     BTFSC STATUS, 0x2
0928  0AA6     INCF y, F
0929  1903     BTFSC STATUS, 0x2
092A  0AA7     INCF x, F
69:            	return f1_as_mant1;
70:            }
092B  0008     RETURN
71:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/flsub.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"flarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned long *)&f1)
11:            #define	f2_as_mant2	(*(unsigned long *)&f2)
12:            
13:            // floating addition
14:            
15:            double
16:            #ifdef __PICC__
17:            #warning TODO: update cgpic and this file to use the other prototype
18:            __flsub(double f2, double f1)
19:            #else
20:            __flsub(double f1, double f2)
21:            #endif
22:            {
23:            	f2_as_mant2 ^= 0x80000000;
15AD  3080     MOVLW 0x80
15AE  06C0     XORWF c, F
24:            #ifdef __PICC__
25:            #warning TODO: update this file to use the other prototype
26:            	return __fladd(f2, f1);
15AF  0840     MOVF c, W
15B0  00B1     MOVWF 0x31
15B1  083F     MOVF 0x3F, W
15B2  00B0     MOVWF f
15B3  083E     MOVF width, W
15B4  00AF     MOVWF counter
15B5  083D     MOVF flag, W
15B6  00AE     MOVWF day
15B7  0844     MOVF sp, W
15B8  00B5     MOVWF 0x35
15B9  0843     MOVF 0x43, W
15BA  00B4     MOVWF 0x34
15BB  0842     MOVF 0x42, W
15BC  00B3     MOVWF 0x33
15BD  0841     MOVF _val, W
15BE  00B2     MOVWF f2
15BF  26D8     CALL 0x6D8
15C0  0831     MOVF 0x31, W
15C1  00C0     MOVWF c
15C2  0830     MOVF f, W
15C3  00BF     MOVWF 0x3F
15C4  082F     MOVF counter, W
15C5  00BE     MOVWF width
15C6  082E     MOVF day, W
15C7  00BD     MOVWF flag
27:            #else
28:            	return __fladd(f1, f2);
29:            #endif
30:            }
15C8  0008     RETURN
---  /opt/microchip/xc8/v1.31/sources/common/flmul.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"flarith.h"
9:             
10:            #define	f1_as_plier	(*(unsigned long *)&f1)
11:            #define	f2_as_plicand	(*(unsigned long *)&f2)
12:            
13:            // floating addition
14:            #ifdef _OLDLIB
15:            #define	f3_as_product		(*(unsigned long *)&f3)
16:            double
17:            __flmul(double f1, double f2)
18:            {
19:            	unsigned char	exp1, sign1, cntr;
20:            	double	f3;
21:            	
22:            	f3_as_product = 0;
23:            	sign1 = __flunpack(&f1_as_plier, &exp1);
24:            	sign1 ^= __flunpack(&f2_as_plicand, &cntr);
25:            	if(cntr == 0 || exp1 == 0)
26:            		return f3;
27:            	exp1 += cntr-127-6;	// compute new exponent
28:            	cntr = 7;
29:            	do {
30:            		if(f1_as_plier & 1)
31:            			f3_as_product += f2_as_plicand;
32:            		f1_as_plier >>= 1;
33:            		f2_as_plicand <<= 1;
34:            	} while(--cntr != 0);
35:            	cntr = 17;
36:            	do {
37:            		if(f1_as_plier & 1)
38:            			f3_as_product += f2_as_plicand;
39:            		f1_as_plier >>= 1;
40:            		f3_as_product >>= 1;
41:            	} while(--cntr != 0);
42:            	__flpack(&f3_as_product, exp1);
43:            	if(sign1)
44:            		f3_as_product |= 0x80000000;
45:            	return f3;
46:            }
47:            #else
48:            #define	exp2	sign
49:            double
50:            __flmul(double f1, double f2)
51:            {
52:            	unsigned char	exp, sign, cntr;
53:            	unsigned long	f3_as_product;
54:            	
55:            	if((exp = f1_as_plier >> 23) == 0)
1642  0845     MOVF f1, W
1643  00CD     MOVWF 0x4D
1644  0846     MOVF 0x46, W
1645  00CE     MOVWF 0x4E
1646  0847     MOVF 0x47, W
1647  00CF     MOVWF 0x4F
1648  0848     MOVF 0x48, W
1649  00D0     MOVWF 0x50
164A  1003     BCF STATUS, 0x0
164B  0D4F     RLF 0x4F, W
164C  0D50     RLF 0x50, W
164D  00D1     MOVWF exp
164E  08D1     MOVF exp, F
164F  1D03     BTFSS STATUS, 0x2
1650  2E56     GOTO 0x656
56:            		return 0.0;
1651  01C5     CLRF f1
1652  01C6     CLRF 0x46
1653  01C7     CLRF 0x47
1654  01C8     CLRF 0x48
1655  0008     RETURN
57:            	if((exp2 = f2_as_plicand >> 23) == 0)
1656  0849     MOVF f2, W
1657  00CD     MOVWF 0x4D
1658  084A     MOVF 0x4A, W
1659  00CE     MOVWF 0x4E
165A  084B     MOVF 0x4B, W
165B  00CF     MOVWF 0x4F
165C  084C     MOVF 0x4C, W
165D  00D0     MOVWF 0x50
165E  1003     BCF STATUS, 0x0
165F  0D4F     RLF 0x4F, W
1660  0D50     RLF 0x50, W
1661  00D7     MOVWF sign
1662  08D7     MOVF sign, F
1663  1D03     BTFSS STATUS, 0x2
1664  2E6A     GOTO 0x66A
58:            		return 0.0;
1665  01C5     CLRF f1
1666  01C6     CLRF 0x46
1667  01C7     CLRF 0x47
1668  01C8     CLRF 0x48
1669  0008     RETURN
59:            	exp += exp2-127-6;	// compute new exponent
166A  0857     MOVF sign, W
166B  3E7B     ADDLW 0x7B
166C  07D1     ADDWF exp, F
60:            	sign = f1_as_plier >> 24;
166D  0848     MOVF 0x48, W
166E  00D7     MOVWF sign
61:            	sign ^= (unsigned char)(f2_as_plicand >> 24);
166F  084C     MOVF 0x4C, W
1670  06D7     XORWF sign, F
62:            	sign &= 0x80;
1671  3080     MOVLW 0x80
1672  05D7     ANDWF sign, F
63:            	f1_as_plier |= 0x800000UL;
1674  17C7     BSF 0x47, 0x7
64:            	//f1_as_plier &= 0xFFFFFFUL;		// not required
65:            	f2_as_plicand |= 0x800000UL;
1675  17CB     BSF 0x4B, 0x7
66:            	f2_as_plicand &= 0xFFFFFFUL;
1676  01CC     CLRF 0x4C
67:            	f3_as_product = 0;
1677  01D2     CLRF f3_as_product
1678  01D3     CLRF 0x53
1679  01D4     CLRF 0x54
167A  01D5     CLRF 0x55
68:            	cntr = 7;
1673  3007     MOVLW 0x7
167B  00D6     MOVWF cntr
69:            	do {
70:            		if(f1_as_plier & 1)
167C  1C45     BTFSS f1, 0x0
167D  2E92     GOTO 0x692
71:            			f3_as_product += f2_as_plicand;
167E  0849     MOVF f2, W
167F  07D2     ADDWF f3_as_product, F
1680  084A     MOVF 0x4A, W
1681  1103     BCF STATUS, 0x2
1682  1803     BTFSC STATUS, 0x0
1683  3E01     ADDLW 0x1
1684  1D03     BTFSS STATUS, 0x2
1685  07D3     ADDWF 0x53, F
1686  084B     MOVF 0x4B, W
1687  1103     BCF STATUS, 0x2
1688  1803     BTFSC STATUS, 0x0
1689  3E01     ADDLW 0x1
168A  1D03     BTFSS STATUS, 0x2
168B  07D4     ADDWF 0x54, F
168C  084C     MOVF 0x4C, W
168D  1103     BCF STATUS, 0x2
168E  1803     BTFSC STATUS, 0x0
168F  3E01     ADDLW 0x1
1690  1D03     BTFSS STATUS, 0x2
1691  07D5     ADDWF 0x55, F
72:            		f1_as_plier >>= 1;
1692  1003     BCF STATUS, 0x0
1693  0CC8     RRF 0x48, F
1694  0CC7     RRF 0x47, F
1695  0CC6     RRF 0x46, F
1696  0CC5     RRF f1, F
73:            		f2_as_plicand <<= 1;
1697  1003     BCF STATUS, 0x0
1698  0DC9     RLF f2, F
1699  0DCA     RLF 0x4A, F
169A  0DCB     RLF 0x4B, F
169B  0DCC     RLF 0x4C, F
74:            	} while(--cntr != 0);
169C  0BD6     DECFSZ cntr, F
169D  2E7C     GOTO 0x67C
75:            	cntr = 17;
169E  3011     MOVLW 0x11
169F  00D6     MOVWF cntr
76:            	do {
77:            		if(f1_as_plier & 1)
16A0  1C45     BTFSS f1, 0x0
16A1  2EB6     GOTO 0x6B6
78:            			f3_as_product += f2_as_plicand;
16A2  0849     MOVF f2, W
16A3  07D2     ADDWF f3_as_product, F
16A4  084A     MOVF 0x4A, W
16A5  1103     BCF STATUS, 0x2
16A6  1803     BTFSC STATUS, 0x0
16A7  3E01     ADDLW 0x1
16A8  1D03     BTFSS STATUS, 0x2
16A9  07D3     ADDWF 0x53, F
16AA  084B     MOVF 0x4B, W
16AB  1103     BCF STATUS, 0x2
16AC  1803     BTFSC STATUS, 0x0
16AD  3E01     ADDLW 0x1
16AE  1D03     BTFSS STATUS, 0x2
16AF  07D4     ADDWF 0x54, F
16B0  084C     MOVF 0x4C, W
16B1  1103     BCF STATUS, 0x2
16B2  1803     BTFSC STATUS, 0x0
16B3  3E01     ADDLW 0x1
16B4  1D03     BTFSS STATUS, 0x2
16B5  07D5     ADDWF 0x55, F
79:            		f1_as_plier >>= 1;
16B6  1003     BCF STATUS, 0x0
16B7  0CC8     RRF 0x48, F
16B8  0CC7     RRF 0x47, F
16B9  0CC6     RRF 0x46, F
16BA  0CC5     RRF f1, F
80:            		f3_as_product >>= 1;
16BB  1003     BCF STATUS, 0x0
16BC  0CD5     RRF 0x55, F
16BD  0CD4     RRF 0x54, F
16BE  0CD3     RRF 0x53, F
16BF  0CD2     RRF f3_as_product, F
81:            	} while(--cntr != 0);
16C0  0BD6     DECFSZ cntr, F
16C1  2EA0     GOTO 0x6A0
82:            	return __flpack(f3_as_product, exp, sign);
16C2  0855     MOVF 0x55, W
16C3  00A7     MOVWF x
16C4  0854     MOVF 0x54, W
16C5  00A6     MOVWF y
16C6  0853     MOVF 0x53, W
16C7  00A5     MOVWF dato
16C8  0852     MOVF f3_as_product, W
16C9  00A4     MOVWF x
16CA  0851     MOVF exp, W
16CB  00A8     MOVWF i
16CC  0857     MOVF sign, W
16CD  00A9     MOVWF mth
16CE  27B5     CALL 0x7B5
16CF  0827     MOVF x, W
16D0  00C8     MOVWF 0x48
16D1  0826     MOVF y, W
16D2  00C7     MOVWF 0x47
16D3  0825     MOVF dato, W
16D4  00C6     MOVWF 0x46
16D5  0824     MOVF x, W
16D6  00C5     MOVWF f1
83:            }
16D7  0008     RETURN
84:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/flge.c  ----------------------------------------------------
1:             #define	f1	(*(unsigned long *)&ff1)
2:             #define	f2	(*(unsigned long *)&ff2)
3:             bit
4:             __flge(double ff1, double ff2)
5:             {
6:             	if(f1 &  0x80000000UL)
0889  1FA7     BTFSS x, 0x7
088A  28A6     GOTO 0xA6
7:             		f1 = 0x80000000UL - f1;
088B  3080     MOVLW 0x80
088C  01AC     CLRF sec
088D  01AD     CLRF hr
088E  01AE     CLRF day
088F  00AF     MOVWF counter
0890  0824     MOVF x, W
0891  02AC     SUBWF sec, F
0892  0825     MOVF dato, W
0893  1C03     BTFSS STATUS, 0x0
0894  0F25     INCFSZ dato, W
0895  02AD     SUBWF hr, F
0896  0826     MOVF y, W
0897  1C03     BTFSS STATUS, 0x0
0898  0F26     INCFSZ y, W
0899  02AE     SUBWF day, F
089A  0827     MOVF x, W
089B  1C03     BTFSS STATUS, 0x0
089C  0F27     INCFSZ x, W
089D  02AF     SUBWF counter, F
089E  082F     MOVF counter, W
089F  00A7     MOVWF x
08A0  082E     MOVF day, W
08A1  00A6     MOVWF y
08A2  082D     MOVF hr, W
08A3  00A5     MOVWF dato
08A4  082C     MOVF sec, W
08A5  00A4     MOVWF x
8:             	if(f2 &  0x80000000UL)
08A6  1FAB     BTFSS Data, 0x7
08A7  28C3     GOTO 0xC3
9:             		f2 = 0x80000000UL - f2;
08A8  3080     MOVLW 0x80
08A9  01AC     CLRF sec
08AA  01AD     CLRF hr
08AB  01AE     CLRF day
08AC  00AF     MOVWF counter
08AD  0828     MOVF i, W
08AE  02AC     SUBWF sec, F
08AF  0829     MOVF mth, W
08B0  1C03     BTFSS STATUS, 0x0
08B1  0F29     INCFSZ mth, W
08B2  02AD     SUBWF hr, F
08B3  082A     MOVF year, W
08B4  1C03     BTFSS STATUS, 0x0
08B5  0F2A     INCFSZ year, W
08B6  02AE     SUBWF day, F
08B7  082B     MOVF Data, W
08B8  1C03     BTFSS STATUS, 0x0
08B9  0F2B     INCFSZ Data, W
08BA  02AF     SUBWF counter, F
08BB  082F     MOVF counter, W
08BC  00AB     MOVWF Data
08BD  082E     MOVF day, W
08BE  00AA     MOVWF year
08BF  082D     MOVF hr, W
08C0  00A9     MOVWF mth
08C1  082C     MOVF sec, W
08C2  00A8     MOVWF i
10:            	f1 ^= 0x80000000UL;
08C3  3080     MOVLW 0x80
08C4  06A7     XORWF x, F
11:            	f2 ^= 0x80000000UL;
08C5  06AB     XORWF Data, F
12:            	return f1 >= f2;
08C6  082B     MOVF Data, W
13:            }
---  /opt/microchip/xc8/v1.31/sources/common/fladd.c  ---------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"flarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned long *)&f1)
11:            #define	f2_as_mant2	(*(unsigned long *)&f2)
12:            
13:            // floating addition
14:            #ifdef _OLDLIB
15:            double
16:            __fladd(double f1, double f2)
17:            {
18:            	unsigned char	exp1, exp2, sign1, sign2, cntr;
19:            
20:            	if(sizeof(f1_as_mant1) != 4)
21:            		return 0;
22:            	sign1 = __flunpack(&f1_as_mant1, &exp1);
23:            	if(exp1 == 0)
24:            		return f2;
25:            	sign2 = __flunpack(&f2_as_mant2, &exp2);
26:            	if(exp2 != 0) {
27:            		cntr = 6;
28:            		// determine the smaller number. 
29:            		if(exp1 < exp2) {
30:            			if((unsigned char)(exp2-exp1) > sizeof(f1)*8) {
31:            				// return f2
32:            				f1_as_mant1 = 0;
33:            				exp1 = exp2;
34:            				sign1 = sign2;
35:            			} else {
36:            				// f1 has the smaller exponent - we can shift f2_as_mant2 up to 6 bits
37:            				// left, decrementing exp2.
38:            				do {
39:            					f2_as_mant2 <<= 1;
40:            					exp2--;
41:            				} while(exp2 != exp1 && --cntr != 0);
42:            				while(exp1 != exp2) {
43:            					f1_as_mant1 >>= 1;
44:            					exp1++;
45:            				}
46:            			}
47:            		} else if(exp1 != exp2) {
48:            			if((unsigned char)(exp1-exp2) > sizeof(f1)*8)	// too small to worry about
49:            				f2_as_mant2 = 0;
50:            			else {
51:            				// f2 has the smaller exponent - we can shift f1_as_mant1 up to 6 bits
52:            				// left, decrementing exp2.
53:            				do {
54:            					f1_as_mant1 <<= 1;
55:            					exp1--;
56:            				} while(exp2 != exp1 && --cntr != 0);
57:            				while(exp1 != exp2) {
58:            					f2_as_mant2 >>= 1;
59:            					exp2++;
60:            				}
61:            			}
62:            		}
63:            		if(sign1 != 0) { 
64:            			// complement and add 1
65:            			f1_as_mant1 ^= 0xFFFFFFFFUL;
66:            			f1_as_mant1++;
67:            		}
68:            		if(sign2 != 0) {
69:            			// complement and add 1
70:            			f2_as_mant2 ^= 0xFFFFFFFFUL;
71:            			f2_as_mant2++;
72:            		}
73:            		sign1 = 0;
74:            		f1_as_mant1 += f2_as_mant2;
75:            		if(f1_as_mant1 & 0x80000000UL) {
76:            			f1_as_mant1 ^= 0xFFFFFFFFUL;
77:            			f1_as_mant1++;
78:            			sign1 = 1;
79:            		}
80:            	}
81:            	__flpack(&f1_as_mant1, exp1);
82:            	if(sign1)
83:            		f1_as_mant1 ^= 0x80000000UL;
84:            	return f1;
85:            }
86:            #else
87:            double
88:            __fladd(double f1, double f2)
89:            {
90:            	unsigned char	exp1, exp2, sign;
91:            
92:            	exp1 = f1_as_mant1 >> 23;
16D8  082E     MOVF day, W
16D9  00B6     MOVWF 0x36
16DA  082F     MOVF counter, W
16DB  00B7     MOVWF 0x37
16DC  0830     MOVF f, W
16DD  00B8     MOVWF 0x38
16DE  0831     MOVF 0x31, W
16DF  00B9     MOVWF 0x39
16E0  1003     BCF STATUS, 0x0
16E1  0D38     RLF 0x38, W
16E2  0D39     RLF 0x39, W
16E3  00BC     MOVWF ap
93:            	exp2 = f2_as_mant2 >> 23;
16E4  0832     MOVF f2, W
16E5  00B6     MOVWF 0x36
16E6  0833     MOVF 0x33, W
16E7  00B7     MOVWF 0x37
16E8  0834     MOVF 0x34, W
16E9  00B8     MOVWF 0x38
16EA  0835     MOVF 0x35, W
16EB  00B9     MOVWF 0x39
16EC  1003     BCF STATUS, 0x0
16ED  0D38     RLF 0x38, W
16EE  0D39     RLF 0x39, W
16EF  00BB     MOVWF prec
94:            	if(exp1 == 0 || exp1 < exp2  && (unsigned char)(exp2-exp1) > sizeof(f1)*8)
16F0  083C     MOVF ap, W
16F1  1903     BTFSC STATUS, 0x2
16F2  2EFF     GOTO 0x6FF
16F3  083B     MOVF prec, W
16F4  023C     SUBWF ap, W
16F5  083B     MOVF prec, W
16F6  1803     BTFSC STATUS, 0x0
16F7  2F09     GOTO 0x709
16F8  00B6     MOVWF 0x36
16F9  083C     MOVF ap, W
16FA  02B6     SUBWF 0x36, F
16FB  3021     MOVLW 0x21
16FC  0236     SUBWF 0x36, W
16FD  1C03     BTFSS STATUS, 0x0
16FE  2F08     GOTO 0x708
95:            		return f2;
16FF  0835     MOVF 0x35, W
1700  00B1     MOVWF 0x31
1701  0834     MOVF 0x34, W
1702  00B0     MOVWF f
1703  0833     MOVF 0x33, W
1704  00AF     MOVWF counter
1705  0832     MOVF f2, W
1706  00AE     MOVWF day
1707  0008     RETURN
96:            	if(exp2 == 0 || exp1 > exp2  && (unsigned char)(exp1-exp2) > sizeof(f1)*8)
1708  083B     MOVF prec, W
1709  1903     BTFSC STATUS, 0x2
170A  0008     RETURN
170B  083C     MOVF ap, W
170C  023B     SUBWF prec, W
170D  1803     BTFSC STATUS, 0x0
170E  2F17     GOTO 0x717
170F  083C     MOVF ap, W
1710  00B6     MOVWF 0x36
1711  083B     MOVF prec, W
1712  02B6     SUBWF 0x36, F
1713  3021     MOVLW 0x21
1714  0236     SUBWF 0x36, W
1715  1803     BTFSC STATUS, 0x0
1716  0008     RETURN
97:            		return f1;
98:            	sign = 6;
1717  3006     MOVLW 0x6
1718  00BA     MOVWF sign
99:            	if(f1_as_mant1 & 0x80000000L)
1719  1BB1     BTFSC 0x31, 0x7
100:           		sign |= 0x80;
171A  17BA     BSF sign, 0x7
101:           	if(f2_as_mant2 & 0x80000000L)
171B  1BB5     BTFSC 0x35, 0x7
102:           		sign |= 0x40;
171C  173A     BSF sign, 0x6
103:           	f1_as_mant1 |= 0x800000UL;
171D  17B0     BSF f, 0x7
104:           	f1_as_mant1 &= 0xFFFFFFUL;
171E  01B1     CLRF 0x31
105:           	f2_as_mant2 |= 0x800000UL;
171F  17B4     BSF 0x34, 0x7
106:           	f2_as_mant2 &= 0xFFFFFFUL;
1720  01B5     CLRF 0x35
107:           	// determine the smaller number. 
108:           	if(exp1 < exp2) {
1721  083B     MOVF prec, W
1722  023C     SUBWF ap, W
1723  1803     BTFSC STATUS, 0x0
1724  2F40     GOTO 0x740
109:           		// f1 has the smaller exponent - we can shift f2_as_mant2 up to 6 bits
110:           		// left, decrementing exp2.
111:           		do {
112:           			f2_as_mant2 <<= 1;
1725  1003     BCF STATUS, 0x0
1726  0DB2     RLF f2, F
1727  0DB3     RLF 0x33, F
1728  0DB4     RLF 0x34, F
1729  0DB5     RLF 0x35, F
113:           			exp2--;
172A  03BB     DECF prec, F
114:           		} while(exp2 != exp1 && --sign & 7);
172B  083B     MOVF prec, W
172C  063C     XORWF ap, W
172D  1903     BTFSC STATUS, 0x2
172E  2F3B     GOTO 0x73B
172F  03BA     DECF sign, F
1730  083A     MOVF sign, W
1731  3907     ANDLW 0x7
1732  1903     BTFSC STATUS, 0x2
1733  2F3B     GOTO 0x73B
1734  2F25     GOTO 0x725
115:           		while(exp1 != exp2) {
173B  083C     MOVF ap, W
173C  063B     XORWF prec, W
173D  1903     BTFSC STATUS, 0x2
173E  2F5E     GOTO 0x75E
173F  2F35     GOTO 0x735
116:           			f1_as_mant1 >>= 1;
1735  1003     BCF STATUS, 0x0
1736  0CB1     RRF 0x31, F
1737  0CB0     RRF f, F
1738  0CAF     RRF counter, F
1739  0CAE     RRF day, F
117:           			exp1++;
173A  0ABC     INCF ap, F
118:           		}
119:           	} else if(exp1 > exp2) {
1740  083C     MOVF ap, W
1741  023B     SUBWF prec, W
1742  1803     BTFSC STATUS, 0x0
1743  2F5E     GOTO 0x75E
120:           		// f2 has the smaller exponent - we can shift f1_as_mant1 up to 6 bits
121:           		// left, decrementing exp2.
122:           		do {
123:           			f1_as_mant1 <<= 1;
1744  1003     BCF STATUS, 0x0
1745  0DAE     RLF day, F
1746  0DAF     RLF counter, F
1747  0DB0     RLF f, F
1748  0DB1     RLF 0x31, F
124:           			exp1--;
1749  03BC     DECF ap, F
125:           		} while(exp2 != exp1 && --sign & 7);
174A  083B     MOVF prec, W
174B  063C     XORWF ap, W
174C  1903     BTFSC STATUS, 0x2
174D  2F5A     GOTO 0x75A
174E  03BA     DECF sign, F
174F  083A     MOVF sign, W
1750  3907     ANDLW 0x7
1751  1903     BTFSC STATUS, 0x2
1752  2F5A     GOTO 0x75A
1753  2F44     GOTO 0x744
126:           		while(exp1 != exp2) {
175A  083C     MOVF ap, W
175B  063B     XORWF prec, W
175C  1D03     BTFSS STATUS, 0x2
175D  2F54     GOTO 0x754
127:           			f2_as_mant2 >>= 1;
1754  1003     BCF STATUS, 0x0
1755  0CB5     RRF 0x35, F
1756  0CB4     RRF 0x34, F
1757  0CB3     RRF 0x33, F
1758  0CB2     RRF f2, F
128:           			exp2++;
1759  0ABB     INCF prec, F
129:           		}
130:           	}
131:           	if(sign & 0x80) { 
175E  1FBA     BTFSS sign, 0x7
175F  2F6C     GOTO 0x76C
132:           		// complement and add 1
133:           		f1_as_mant1 ^= 0xFFFFFFFFUL;
1760  30FF     MOVLW 0xFF
1761  06AE     XORWF day, F
1762  06AF     XORWF counter, F
1763  06B0     XORWF f, F
1764  06B1     XORWF 0x31, F
134:           		f1_as_mant1++;
1765  0AAE     INCF day, F
1766  1903     BTFSC STATUS, 0x2
1767  0AAF     INCF counter, F
1768  1903     BTFSC STATUS, 0x2
1769  0AB0     INCF f, F
176A  1903     BTFSC STATUS, 0x2
176B  0AB1     INCF 0x31, F
135:           	}
136:           	if(sign & 0x40) {
176C  1F3A     BTFSS sign, 0x6
176D  2F7A     GOTO 0x77A
137:           		// complement and add 1
138:           		f2_as_mant2 ^= 0xFFFFFFFFUL;
176E  30FF     MOVLW 0xFF
176F  06B2     XORWF f2, F
1770  06B3     XORWF 0x33, F
1771  06B4     XORWF 0x34, F
1772  06B5     XORWF 0x35, F
139:           		f2_as_mant2++;
1773  0AB2     INCF f2, F
1774  1903     BTFSC STATUS, 0x2
1775  0AB3     INCF 0x33, F
1776  1903     BTFSC STATUS, 0x2
1777  0AB4     INCF 0x34, F
1778  1903     BTFSC STATUS, 0x2
1779  0AB5     INCF 0x35, F
140:           	}
141:           	sign = 0;
177A  01BA     CLRF sign
142:           	f2_as_mant2 += f1_as_mant1;
177B  082E     MOVF day, W
177C  07B2     ADDWF f2, F
177D  082F     MOVF counter, W
177E  1103     BCF STATUS, 0x2
177F  1803     BTFSC STATUS, 0x0
1780  3E01     ADDLW 0x1
1781  1D03     BTFSS STATUS, 0x2
1782  07B3     ADDWF 0x33, F
1783  0830     MOVF f, W
1784  1103     BCF STATUS, 0x2
1785  1803     BTFSC STATUS, 0x0
1786  3E01     ADDLW 0x1
1787  1D03     BTFSS STATUS, 0x2
1788  07B4     ADDWF 0x34, F
1789  0831     MOVF 0x31, W
178A  1103     BCF STATUS, 0x2
178B  1803     BTFSC STATUS, 0x0
178C  3E01     ADDLW 0x1
178D  1D03     BTFSS STATUS, 0x2
178E  07B5     ADDWF 0x35, F
143:           	if(f2_as_mant2 & 0x80000000UL) {
178F  1FB5     BTFSS 0x35, 0x7
1790  2F9F     GOTO 0x79F
144:           		f2_as_mant2 ^= 0xFFFFFFFFUL;
1791  30FF     MOVLW 0xFF
1792  06B2     XORWF f2, F
1793  06B3     XORWF 0x33, F
1794  06B4     XORWF 0x34, F
1795  06B5     XORWF 0x35, F
145:           		f2_as_mant2++;
1796  0AB2     INCF f2, F
1797  1903     BTFSC STATUS, 0x2
1798  0AB3     INCF 0x33, F
1799  1903     BTFSC STATUS, 0x2
179A  0AB4     INCF 0x34, F
179B  1903     BTFSC STATUS, 0x2
179C  0AB5     INCF 0x35, F
146:           		sign = 1;
179D  01BA     CLRF sign
179E  0ABA     INCF sign, F
147:           	}
148:           	return __flpack(f2_as_mant2, exp1, sign);
179F  0835     MOVF 0x35, W
17A0  00A7     MOVWF x
17A1  0834     MOVF 0x34, W
17A2  00A6     MOVWF y
17A3  0833     MOVF 0x33, W
17A4  00A5     MOVWF dato
17A5  0832     MOVF f2, W
17A6  00A4     MOVWF x
17A7  083C     MOVF ap, W
17A8  00A8     MOVWF i
17A9  083A     MOVF sign, W
17AA  00A9     MOVWF mth
17AB  27B5     CALL 0x7B5
17AC  0827     MOVF x, W
17AD  00B1     MOVWF 0x31
17AE  0826     MOVF y, W
17AF  00B0     MOVWF f
17B0  0825     MOVF dato, W
17B1  00AF     MOVWF counter
17B2  0824     MOVF x, W
17B3  00AE     MOVWF day
149:           }
17B4  0008     RETURN
150:           #endif
---  /opt/microchip/xc8/v1.31/sources/common/double.c  --------------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             #include	"flarith.h"
7:             
8:             
9:             //	unpack the operand pointed to. Store the exponent into the location pointed to by exp,
10:            //	and return the sign (zero is positive)
11:            
12:            #ifdef _OLDLIB
13:            
14:            unsigned char
15:            __flunpack(unsigned long * arg, unsigned char * exp)
16:            {
17:            	unsigned char	sign;
18:            
19:            	*exp = sign = *arg >> 23;
20:            	if(sign == 0) {
21:            		*arg = 0;
22:            		return 0;
23:            	}
24:            	sign = 0;
25:            	*arg |= 0x800000UL;
26:            	if(*arg & 0x80000000UL)
27:            		sign++;
28:            	*arg &= 0xFFFFFFUL;
29:            	return sign;
30:            }
31:            #endif
32:            
33:            // normalize and pack the supplied argument into floating point format
34:            
35:            #ifdef _OLDLIB 
36:            void
37:            __flpack(unsigned long * arg, unsigned char exp)
38:            {
39:            	if(exp == 0 || *arg == 0) {
40:            		*arg = 0;
41:            		return;
42:            	}
43:            	while(*arg & ~0x1FFFFFFUL) {
44:            		exp++;
45:            		*arg >>= 1;
46:            	}
47:            	while(*arg & ~0xFFFFFFUL) {
48:            		exp++;
49:            		(*arg)++;
50:            		*arg >>= 1;
51:            	}
52:            	while(!(*arg & 0x800000UL)) {
53:            		exp--;
54:            		*arg <<= 1;
55:            	}
56:            	if(!(exp & 1))
57:            		*arg &= ~0x800000UL;
58:            	exp >>= 1;
59:            	*arg |= (unsigned long)exp << 24;
60:            }
61:            #else
62:            double
63:            __flpack(unsigned long arg, unsigned char exp, unsigned char sign)
64:            {
65:            	if(exp == 0 || arg == 0)
17B5  0828     MOVF i, W
17B6  1903     BTFSC STATUS, 0x2
17B7  2FBE     GOTO 0x7BE
17B8  0827     MOVF x, W
17B9  0426     IORWF y, W
17BA  0425     IORWF dato, W
17BB  0424     IORWF x, W
17BC  1D03     BTFSS STATUS, 0x2
17BD  2FC9     GOTO 0x7C9
66:            		return 0.0;
17BE  01A4     CLRF x
17BF  01A5     CLRF dato
17C0  01A6     CLRF y
17C1  01A7     CLRF x
17C2  0008     RETURN
67:            	while(arg & ~0x1FFFFFFUL) {
17C9  30FE     MOVLW 0xFE
17CA  0527     ANDWF x, W
17CB  1903     BTFSC STATUS, 0x2
17CC  2FDB     GOTO 0x7DB
17CD  2FC3     GOTO 0x7C3
68:            		exp++;
17C3  0AA8     INCF i, F
69:            		arg >>= 1;
17C4  1003     BCF STATUS, 0x0
17C5  0CA7     RRF x, F
17C6  0CA6     RRF y, F
17C7  0CA5     RRF dato, F
17C8  0CA4     RRF x, F
70:            	}
71:            	while(arg & ~0xFFFFFFUL) {
17DB  30FF     MOVLW 0xFF
17DC  0527     ANDWF x, W
17DD  1903     BTFSC STATUS, 0x2
17DE  2FE6     GOTO 0x7E6
17DF  2FCE     GOTO 0x7CE
72:            		exp++;
17CE  0AA8     INCF i, F
73:            		(arg)++;
17CF  0AA4     INCF x, F
17D0  1903     BTFSC STATUS, 0x2
17D1  0AA5     INCF dato, F
17D2  1903     BTFSC STATUS, 0x2
17D3  0AA6     INCF y, F
17D4  1903     BTFSC STATUS, 0x2
17D5  0AA7     INCF x, F
74:            		arg >>= 1;
17D6  1003     BCF STATUS, 0x0
17D7  0CA7     RRF x, F
17D8  0CA6     RRF y, F
17D9  0CA5     RRF dato, F
17DA  0CA4     RRF x, F
75:            	}
76:            	while(!(arg & 0x800000UL)) {
17E6  1FA6     BTFSS y, 0x7
17E7  2FE0     GOTO 0x7E0
77:            		exp--;
17E0  03A8     DECF i, F
78:            		arg <<= 1;
17E1  1003     BCF STATUS, 0x0
17E2  0DA4     RLF x, F
17E3  0DA5     RLF dato, F
17E4  0DA6     RLF y, F
17E5  0DA7     RLF x, F
79:            	}
80:            	if(!(exp & 1))
17E8  1828     BTFSC i, 0x0
17E9  2FED     GOTO 0x7ED
81:            		arg &= ~0x800000UL;
17EA  307F     MOVLW 0x7F
17EB  05A6     ANDWF y, F
17EC  30FF     MOVLW 0xFF
82:            	exp >>= 1;
17ED  1003     BCF STATUS, 0x0
17EE  0CA8     RRF i, F
83:            	arg |= (unsigned long)exp << 24;
17EF  0828     MOVF i, W
17F0  00AD     MOVWF hr
17F1  01AC     CLRF sec
17F2  01AB     CLRF Data
17F3  01AA     CLRF year
17F4  082A     MOVF year, W
17F5  04A4     IORWF x, F
17F6  082B     MOVF Data, W
17F7  04A5     IORWF dato, F
17F8  082C     MOVF sec, W
17F9  04A6     IORWF y, F
17FA  082D     MOVF hr, W
17FB  04A7     IORWF x, F
84:            	if(sign)
17FC  0829     MOVF mth, W
17FD  1D03     BTFSS STATUS, 0x2
85:            		arg |= 0x80000000UL;
17FE  17A7     BSF x, 0x7
86:            	return *(double *)&arg;
87:            }
17FF  0008     RETURN
88:            #endif
---  /opt/microchip/xc8/v1.31/sources/common/doprnt.c  --------------------------------------------------
1:             #include	<stdio.h>
2:             #include	<ctype.h>
3:             #include	<stdlib.h>
4:             #include	<string.h>
5:             #include	<stdarg.h>
6:             #include	<conio.h>
7:             #include	<sys.h>
8:             #include	<math.h>
9:             #include	<float.h>
10:            
11:            // disable unused variable warnings
12:            // the compiler will optimize them away, so no harm is done
13:            #pragma warning disable 350
14:            
15:            /*
16:             *	doprnt - versions depends on conditional compilation.
17:             *	Can be customized with defines.
18:             *
19:             *	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
20:             *
21:             *	$Header$
22:             *
23:             */
24:            
25:            #ifndef	CUSTOM_PRINTF
26:            
27:             // define all flags, thus enabling all features
28:            
29:            #define	BASEM	0xC0
30:            #define	OPTSIGN	0x00
31:            #define	SPCSIGN	0x01
32:            #define	MANSIGN	0x02
33:            #define	NEGSIGN	0x03
34:            #define	FILL	0x04
35:            #define	LEFT	0x08
36:            #define	LONG	0x10
37:            #define	UPCASE	0x20
38:            #define	TEN		0x00
39:            #define	EIGHT	0x40
40:            #define	SIXTEEN	0x80
41:            #define	UNSIGN	0xC0
42:            #ifdef	__FLOAT
43:            #define	EFMT	0x100
44:            #define	GFMT	0x200
45:            #define	FFMT	0x400
46:            #endif	// __FLOAT
47:            #define	ALTERN	0x800
48:            #define POINTER	0x2000
49:            #define HEXUPCASE
50:            #define HEXLOWCASE
51:            
52:             // defines for ifdef only, not used as flags
53:            #define	WIDTH	1		// width used
54:            #define	STAR	1		// width or precision as an arg
55:            #define	STRING	1		// %s used
56:            #define	CHAR	1		// %c used
57:            #define	PERCPERC	1	// %% used
58:            #define	SPRINTF	1		// sprintf is used
59:            #define	PRINTF	1		// printf is used
60:            #define	MULTRAD	1		// handle multiple radices
61:            #define	RETVALUE	1	// return value is needed
62:            
63:            #else	// CUSTOM_PRINTF
64:            
65:            #if	defined(HEXUPCASE) || defined(HEXLOWCASE)
66:            #define	SIXTEEN
67:            #endif
68:            
69:            #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
70:            #ifndef UPCASE
71:            #define	UPCASE
72:            #endif
73:            #endif
74:            
75:             // make sure we have the right values for each define
76:            #ifdef	OPTSIGN
77:            #undef	OPTSIGN
78:            #define	OPTSIGN	0x00
79:            #endif
80:            #ifdef	SPCSIGN
81:            #undef	SPCSIGN
82:            #define	SPCSIGN	0x01
83:            #endif
84:            #ifdef	MANSIGN
85:            #undef	MANSIGN
86:            #define	MANSIGN	0x02
87:            #define	SPCSIGN	0x01
88:            #endif
89:            #ifdef	NEGSIGN
90:            #undef	NEGSIGN
91:            #define	NEGSIGN	0x03
92:            #endif
93:            #ifdef	FILL
94:            #define	WIDTH	1
95:            #undef	FILL
96:            #define	FILL	0x04
97:            #endif
98:            #ifdef	LEFT
99:            #undef	LEFT
100:            // LEFT without WIDTH is meaningless
101:           #ifdef	WIDTH
102:           #define	LEFT	0x08
103:           #endif
104:           #endif
105:           #ifdef	LONG
106:           #undef	LONG
107:           #define	LONG	0x10
108:           #define	__LONG	1
109:           #endif
110:           #ifdef	UPCASE
111:           #undef	UPCASE
112:           #define	UPCASE	0x20
113:           #endif
114:           #ifdef	TEN	
115:           #undef	TEN	
116:           #define	TEN		0x00
117:           #endif
118:           #ifdef	EIGHT
119:           #undef	EIGHT
120:           #define	EIGHT	0x40
121:           #endif
122:           #ifdef	SIXTEEN
123:           #undef	SIXTEEN
124:           #define	SIXTEEN	0x80
125:           #endif
126:           #ifdef	UNSIGN
127:           #undef	UNSIGN
128:           #define	UNSIGN	0xC0
129:           #endif
130:           #ifdef	EFMT
131:           #undef	EFMT
132:           #define	EFMT	0x100
133:           #endif
134:           #ifdef	GFMT
135:           #undef	GFMT
136:           #define	GFMT	0x200
137:           #endif
138:           #ifdef	FFMT
139:           #undef	FFMT
140:           #define	FFMT	0x400
141:           #endif
142:           #ifdef	ALTERN
143:           #undef	ALTERN
144:           #define	ALTERN	0x800
145:           #endif
146:           #ifdef	POINTER
147:           #undef	POINTER
148:           #define POINTER	0x2000
149:           #ifndef	SIXTEEN
150:           #define	SIXTEEN	0x80
151:           #endif
152:           #endif
153:           #ifdef	PRECISION
154:           #undef	PRECISION
155:           #define PRECISION	0x4000
156:           #endif
157:           
158:           #if	defined(TEN) && !defined(EIGHT) && !defined(SIXTEEN) && defined(UNSIGN)
159:           #undef	UNSIGN
160:           #define	UNSIGN	0x40
161:           #define	BASEM	UNSIGN
162:           #endif
163:           #if	defined(UNSIGN) && (defined(EIGHT) || defined(SIXTEEN))
164:           #define	MULTRAD	1
165:           #define	BASEM	(UNSIGN)
166:           #endif
167:           #if	defined(TEN) && !defined(SIXTEEN) && defined(EIGHT) && !defined(UNSIGN)
168:           #define	BASEM	EIGHT
169:           #define	MULTRAD	1
170:           #endif
171:           #if	defined(TEN) && defined(SIXTEEN) && !defined(EIGHT) && !defined(UNSIGN)
172:           #define	BASEM	SIXTEEN
173:           #define	MULTRAD	1
174:           #endif
175:           #if	defined(SIXTEEN) && defined(EIGHT) && !defined(BASEM)
176:           #define	BASEM	(SIXTEEN|EIGHT)
177:           #define	MULTRAD	1
178:           #endif
179:           
180:           #endif
181:           
182:            // float code needs these flags
183:           #if	defined(EFMT) || defined(GFMT) || defined(FFMT)
184:           #ifndef	__FLOAT
185:           #define	__FLOAT	1
186:           #endif
187:           #define	FLOATFORMAT	0x700
188:           #ifdef	PRECISION
189:           #define	DEFPREC	0x1000
190:           #endif
191:           #endif
192:           
193:           #ifdef	__FLOAT
194:           //#ifndef	MANSIGN
195:           //#define	MANSIGN	0x02
196:           //#endif
197:           //#ifndef	SPCSIGN
198:           //#define	SPCSIGN	0x01
199:           //#endif
200:           #ifndef	NEGSIGN
201:           #define	NEGSIGN	0x03
202:           #endif
203:           //#ifndef	WIDTH
204:           //#define	WIDTH	1
205:           //#endif
206:           #endif
207:           
208:           #ifdef	SPCSIGN
209:           #define	putsign()	pputc(flag & SPCSIGN ? '-' : '+')
210:           #else
211:           #define	putsign()	pputc('-')
212:           #endif	// SPCSIGN
213:           
214:           // were there ANY % formats defined?
215:           #if	defined(FLOATFORMAT) || defined(TEN) || defined(EIGHT) || defined(SIXTEEN) || \
216:           	defined(CHAR) || defined(POINTER) || defined(STRING) || defined(UNSIGN) || defined(PERCPERC)
217:           #define	ANYFORMAT
218:           #else
219:           #undef	ANYFORMAT
220:           #endif
221:           
222:           #ifdef	CHAR
223:           #ifndef	PERCPERC
224:           #define	PERCPERC
225:           #endif
226:           #endif
227:           
228:           #if	!defined(PRINTF) && !defined(VPRINTF) && !defined(SPRINTF) && !defined(VSPRINTF)
229:           #error	Must define at least one of PRINTF SPRINTF or VSPRINTF
230:           #endif
231:           
232:           #if	i8086 && SMALL_DATA
233:           #define	CONST	far
234:           #else
235:           #define	CONST	const
236:           #endif
237:           
238:            /* we don't need plus signs, use minus signs only if we have floats or signed ints */
239:           
240:           #if	!defined(NEGSIGN) && defined(TEN)
241:           #define	NEGSIGN	0x03
242:           #endif
243:           
244:           #ifndef	RETVALUE
245:           #define	INCR_CNT	/*nix */
246:           #else
247:           #define	INCR_CNT	,(++ccnt)
248:           #endif
249:           
250:           #if	defined(EFMT) || defined(GFMT) || defined(FFMT) || defined(ALTERN) || defined(DEFPREC) || defined(POINTER)
251:           #define	FLAG_SIZE	unsigned short
252:           #else
253:           #define	FLAG_SIZE	unsigned char
254:           #endif
255:           
256:           
257:           #if	(sizeof(long) == sizeof(int) || defined(__FLOAT)) && !defined(__LONG)
258:           #define	__LONG	1
259:           #endif
260:           
261:           #if	sizeof(double) == sizeof(long) && DBL_MAX_EXP == 128
262:           #undef	frexp
263:           #define	frexp(val, ptr) (void)(*(ptr) = (unsigned char)((*(unsigned long *)&val >> 23) & 255) - 126)
264:           #elif	defined(_PSOC_)
265:           #undef	frexp
266:           #define	frexp(val, ptr) (void)(*(ptr) = ((unsigned char)(*(unsigned short long *)&val >> 15)) - 126)
267:           #elif	sizeof(double) == 3 && DBL_MAX_EXP == 128
268:           #undef	frexp
269:           #define	frexp(val, ptr) (void)(*(ptr) = ((*(unsigned long *)&val >> 15) & 255) - 126)
270:           #endif
271:           
272:           #if	defined(__FLOAT) && sizeof(double) == 8
273:           #define	DOUBLE	1
274:           
275:           extern double	_dto64i(double);
276:           extern double	_64itod(double);
277:           extern double	_div64(double, double);
278:           extern double	_divto64i(double, double);
279:           extern unsigned	_div64ir(double, double);
280:           extern unsigned	_mod64i10(double);
281:           
282:           #else
283:           #define	DOUBLE	0
284:           #endif
285:           
286:           #ifdef	__LONG
287:           #define	value	long
288:           #define	NDIG	12		/* max number of digits to be printed */
289:           #else
290:           #define	value	int
291:           #define	NDIG	6		/* max number of digits to be printed */
292:           #endif
293:           
294:           #if	DOUBLE
295:           union {
296:           	unsigned long	ul[40];
297:           	double		db[20];
298:           }	_fdp =
299:           {
300:           #if	!defined(BIG_ENDIAN) && !defined(LITTLE_ENDIAN)
301:           #error Neither BIG_ENDIAN or LITTLE_ENDIAN has been set
302:           #endif
303:           #if	BIG_ENDIAN
304:           	0x00000000,0x00000001,
305:           	0x00000000,0x0000000A,
306:           	0x00000000,0x00000064,
307:           	0x00000000,0x000003E8,
308:           	0x00000000,0x00002710,
309:           	0x00000000,0x000186A0,
310:           	0x00000000,0x000F4240,
311:           	0x00000000,0x00989680,
312:           	0x00000000,0x05F5E100,
313:           	0x00000000,0x3B9ACA00,
314:           	0x00000002,0x540BE400,
315:           	0x00000017,0x4876E800,
316:           	0x000000E8,0xD4A51000,
317:           	0x00000918,0x4E72A000,
318:           	0x00005AF3,0x107A4000,
319:           	0x00038D7E,0xA4C68000,
320:           	0x002386F2,0x6FC10000,
321:           	0x01634578,0x5D8A0000,
322:           	0x0DE0B6B3,0xA7640000,
323:           	0x8AC72304,0x89E80000,
324:           #else
325:           	0x00000001,0x00000000,
326:           	0x0000000A,0x00000000,
327:           	0x00000064,0x00000000,
328:           	0x000003E8,0x00000000,
329:           	0x00002710,0x00000000,
330:           	0x000186A0,0x00000000,
331:           	0x000F4240,0x00000000,
332:           	0x00989680,0x00000000,
333:           	0x05F5E100,0x00000000,
334:           	0x3B9ACA00,0x00000000,
335:           	0x540BE400,0x00000002,
336:           	0x4876E800,0x00000017,
337:           	0xD4A51000,0x000000E8,
338:           	0x4E72A000,0x00000918,
339:           	0x107A4000,0x00005AF3,
340:           	0xA4C68000,0x00038D7E,
341:           	0x6FC10000,0x002386F2,
342:           	0x5D8A0000,0x01634578,
343:           	0xA7640000,0x0DE0B6B3,
344:           	0x89E80000,0x8AC72304,
345:           #endif
346:           };
347:           
348:           #define	fdpowers	_fdp.db
349:           
350:           #else
351:           #define	fdpowers	dpowers
352:           #endif
353:           #if defined(TEN) || defined(__FLOAT) || defined (UNSIGN)
354:           const static unsigned value	dpowers[] =	{1, 10, 100, 1000, 10000,
355:           #ifdef	__LONG
356:           						 100000, 1000000, 10000000, 100000000,
357:           						 1000000000
358:           #endif
359:           							 };
360:           #endif
361:           #ifdef	SIXTEEN
362:           const static unsigned value	hexpowers[] =	{1, 0x10, 0x100, 0x1000,
363:           #if	__LONG
364:           						 0x10000, 0x100000, 0x1000000, 0x10000000
365:           #endif
366:           							};
367:           #endif
368:           #ifdef	EIGHT
369:           const static unsigned value	octpowers[] =	{1, 010, 0100, 01000, 010000, 0100000,
370:           #ifdef	__LONG
371:           						01000000,
372:           						 010000000, 0100000000, 01000000000, 010000000000,
373:           						 0100000000000
374:           #endif
375:           							};
376:           #endif
377:           
378:           #ifdef	__FLOAT
379:           
380:           #define	NDDIG	(sizeof fdpowers/sizeof fdpowers[0])
381:           
382:           #if	DBL_MAX_10_EXP > 120
383:           #define	expon	int
384:           #else
385:           #define	expon	signed char
386:           #endif
387:           
388:           extern const double	_powers_[], _npowers_[];
389:           #ifdef	z80
390:           #define	_div_to_l_(a, b)	((unsigned long)((a)/(b)))
391:           #else
392:           extern unsigned long	_div_to_l_(double, double);
393:           #ifdef	_OMNI_CODE_
394:           extern unsigned long	_tdiv_to_l_(float, float);
395:           #ifdef	_HTKC_
396:           #pragma callname _div_to_l_ double
397:           #pragma callname _tdiv_to_l_ float
398:           #endif
399:           #define	div_to_l_(a,b)	((sizeof(double)== 3) ? _tdiv_to_l_(a,b) : _div_to_l_(a,b))
400:           #else
401:           #define	div_to_l_	_div_to_l_
402:           #endif
403:           #endif
404:           
405:           /* this routine returns a value to round to the number of decimal
406:           	places specified */
407:           #if __FLOAT
408:           static double
409:           fround(unsigned char prec)
410:           {
411:           	/* prec is guaranteed to be less than NDIG */
412:           
413:           	if(prec>=110)
414:           		return 0.5 * _npowers_[prec/100+18] * _npowers_[(prec%100)/10+9] * _npowers_[prec%10];
415:           	else if(prec > 10)
416:           		return 0.5 * _npowers_[prec/10+9] * _npowers_[prec%10];
417:           	return 0.5 * _npowers_[prec];
418:           }
419:           #endif
420:           
421:           /* this routine returns a scaling factor equal to 1 to the decimal
422:              power supplied */
423:           
424:           static double
425:           scale(expon scl)
426:           {
427:           
428:           	if(scl < 0) {
429:           		scl = -scl;
430:           		if(scl>=110)
431:           			return _npowers_[scl/100+18] * _npowers_[(scl%100)/10+9] * _npowers_[scl%10];
432:           		else if(scl > 10)
433:           			return _npowers_[scl/10+9] * _npowers_[scl%10];
434:           		return _npowers_[scl];
435:           	}
436:           	if(scl>=110)
437:           		return _powers_[scl/100+18] * _powers_[(scl%100)/10+9] * _powers_[scl%10];
438:           	else if(scl > 10)
439:           		return _powers_[scl/10+9] * _powers_[scl%10];
440:           	return _powers_[scl];
441:           }
442:           
443:           
444:           #endif	/* __FLOAT */
445:           
446:           
447:           
448:           #ifdef	_HOSTED
449:           #define	pputc(c)	(putc(c, fp) != EOF && ++ccnt)
450:           int
451:           vfprintf(FILE * fp, register const  char * f, register va_list ap)
452:           {
453:           	char		cbuf[2];
454:           #else	/* _HOSTED */
455:           int
456:           #if	defined(VPRINTF) || (defined(PRINTF) && (defined(SPRINTF) || defined(VSPRINTF)))
457:           #define	pputc(c)	if(pb->func) (pb->func(c))INCR_CNT; else ((*pb->ptr++ = c)INCR_CNT)
458:           _doprnt(struct __prbuf * pb, register const  char * f, register va_list ap)
459:           {
460:           #endif
461:           
462:           #if	defined(PRINTF) && !(defined(SPRINTF) || defined(VSPRINTF))
463:           #define	pputc(c)	(putch(c) INCR_CNT)
464:           printf(const char * f, ...)
465:           {
466:           	va_list	ap;
467:           #define	NEED_START
468:           #endif
469:           
470:           #if	!defined(PRINTF) && defined(VSPRINTF)
471:           
472:           #ifdef	SPRINTF
473:           sprintf(char * sp, const char * f, ...)
474:           {
475:           	va_list	ap;
476:           
477:           	va_start(ap, f);
478:           	vsprintf(sp, f, ap);
479:           	va_end(ap);
480:           }
481:           int
482:           #endif	// SPRINTF
483:           
484:           #define	pputc(c)	((*sp++ = (c))INCR_CNT)
485:           vsprintf(char * sp, register const  char * f, register va_list ap)
486:           {
487:           #define NEED_START
488:           #endif	// VSPRINTF
489:           
490:           #if	!defined(PRINTF) && defined(SPRINTF) && !defined(VSPRINTF)
491:           #define	pputc(c)	((*sp++ = (c))INCR_CNT)
492:           sprintf(char * sp, const  char * f, ...)
136C  00C4     MOVWF sp
493:           {
494:           	va_list	ap;
495:           #define	NEED_START
496:           #endif
497:           #endif	// HOSTED
498:           
499:           	signed char		c;
500:           #if	defined(WIDTH) || defined(__FLOAT)
501:           	int		width;
502:           #endif
503:           #ifdef	__LONG
504:           	int		prec;
505:           #else
506:           	signed char	prec;
507:           #endif
508:           	FLAG_SIZE	flag;
509:           #ifdef	RETVALUE
510:           	int		ccnt = 0;
511:           #else
512:           #define	ccnt	0
513:           #endif
514:           #ifdef	__FLOAT
515:           	char	d;
516:           	double	fval, integ;
517:           	int		exp;
518:           	double		ival;
519:           	union {
520:           		unsigned value	_val;
521:           		struct {
522:           		    CONST char *	_cp;
523:           		    unsigned	_len;
524:           		}		_str;
525:           	}		_val;
526:           #else	// __FLOAT
527:           	union {
528:           		unsigned value	_val;
529:           		struct {
530:           		    CONST char *	_cp;
531:           		    unsigned	_len;
532:           		}		_str;
533:           	}		_val;
534:           #endif	// __FLOAT
535:           
536:           #define	val	_val._val
537:           #define	cp	_val._str._cp
538:           #define	len	_val._str._len
539:           
540:           	
541:           #ifdef	NEED_START
542:           	va_start(ap, f);
136D  3032     MOVLW 0x32
136E  00BC     MOVWF ap
543:           #endif
544:           
545:           	while(c = *f++) {
136F  0831     MOVF 0x31, W
1370  00B9     MOVWF 0x39
1371  0830     MOVF f, W
1372  00B8     MOVWF 0x38
1373  0AB0     INCF f, F
1374  1903     BTFSC STATUS, 0x2
1375  0AB1     INCF 0x31, F
1376  0839     MOVF 0x39, W
1377  00FF     MOVWF 0x7F
1378  0838     MOVF 0x38, W
1379  0084     MOVWF FSR
137A  160A     BSF PCLATH, 0x4
137B  158A     BSF PCLATH, 0x3
137C  2000     CALL 0x0
137D  160A     BSF PCLATH, 0x4
137E  118A     BCF PCLATH, 0x3
137F  00C0     MOVWF c
1380  08C0     MOVF c, F
1381  1903     BTFSC STATUS, 0x2
1382  2D20     GOTO 0x520
151F  2B6F     GOTO 0x36F
546:           #ifdef	ANYFORMAT
547:           		if(c != '%')
1383  0840     MOVF c, W
1384  3A25     XORLW 0x25
1385  1903     BTFSC STATUS, 0x2
1386  2B8E     GOTO 0x38E
548:           #endif	//ANYFORMAT
549:           		{
550:           			pputc(c);
1387  0844     MOVF sp, W
1388  0084     MOVWF FSR
1389  0840     MOVF c, W
138A  1783     BSF STATUS, 0x7
138B  0080     MOVWF INDF
138C  0AC4     INCF sp, F
551:           			continue;
138D  2B6F     GOTO 0x36F
552:           		}
553:           #ifdef	ANYFORMAT
554:           #ifdef	WIDTH
555:           		width = 0;
138E  01BE     CLRF width
138F  01BF     CLRF 0x3F
556:           #endif
557:           		flag = 0;
1390  01BD     CLRF flag
1391  2B96     GOTO 0x396
558:           #if	defined(LEFT) || defined(SPCSIGN) || defined(MANSIGN) || defined(ALTERN) || defined(FILL)
559:           		for(;;) {
560:           			switch(*f) {
1396  0831     MOVF 0x31, W
1397  00FF     MOVWF 0x7F
1398  0830     MOVF f, W
1399  0084     MOVWF FSR
139A  160A     BSF PCLATH, 0x4
139B  158A     BSF PCLATH, 0x3
139C  2000     CALL 0x0
139D  160A     BSF PCLATH, 0x4
139E  118A     BCF PCLATH, 0x3
139F  3A30     XORLW 0x30
13A0  1903     BTFSC STATUS, 0x2
13A1  2B92     GOTO 0x392
13A2  2BA3     GOTO 0x3A3
561:           #ifdef	LEFT
562:           			case '-':
563:           				flag |= LEFT;
564:           				f++;
565:           				continue;
566:           #endif
567:           
568:           #ifdef	SPCSIGN
569:           			case ' ':
570:           				flag |= SPCSIGN;
571:           				f++;
572:           				continue;
573:           #endif
574:           
575:           #ifdef	MANSIGN
576:           			case '+':
577:           				flag |= MANSIGN;
578:           				f++;
579:           				continue;
580:           #endif
581:           #ifdef	ALTERN
582:           			case '#':
583:           				flag |= ALTERN;
584:           				f++;
585:           				continue;
586:           #endif
587:           #ifdef	FILL
588:           			case '0':
589:           				flag |= FILL;
1392  153D     BSF flag, 0x2
590:           				f++;
1393  0AB0     INCF f, F
1394  1903     BTFSC STATUS, 0x2
1395  0AB1     INCF 0x31, F
591:           				continue;
592:           #endif
593:           			}
594:           			break;
595:           		}
596:           #endif
597:           #if	defined(MANSIGN) && defined(SPCSIGN)
598:           		if(flag & MANSIGN)
599:           			flag &= ~SPCSIGN;
600:           #endif
601:           #if	defined(LEFT) && defined(FILL)
602:           		if(flag & LEFT)
603:           			flag &= ~FILL;
604:           #endif
605:           #ifdef	WIDTH
606:           		if(isdigit((unsigned)*f)) {
13A3  0831     MOVF 0x31, W
13A4  00FF     MOVWF 0x7F
13A5  0830     MOVF f, W
13A6  0084     MOVWF FSR
13A7  160A     BSF PCLATH, 0x4
13A8  158A     BSF PCLATH, 0x3
13A9  2000     CALL 0x0
13AA  160A     BSF PCLATH, 0x4
13AB  118A     BCF PCLATH, 0x3
13AC  2525     CALL 0x525
13AD  160A     BSF PCLATH, 0x4
13AE  118A     BCF PCLATH, 0x3
13AF  1C03     BTFSS STATUS, 0x0
13B0  2C27     GOTO 0x427
607:           			width = 0;
13B1  01BE     CLRF width
13B2  01BF     CLRF 0x3F
608:           			do {
609:           				width *= 10;
13B3  300A     MOVLW 0xA
13B4  00A4     MOVWF x
13B5  01A5     CLRF dato
13B6  083F     MOVF 0x3F, W
13B7  00A7     MOVWF x
13B8  083E     MOVF width, W
13B9  00A6     MOVWF y
13BA  2581     CALL 0x581
13BB  0825     MOVF dato, W
13BC  00BF     MOVWF 0x3F
13BD  0824     MOVF x, W
13BE  00BE     MOVWF width
610:           			   	width += *f++ - '0';
13BF  0831     MOVF 0x31, W
13C0  00FF     MOVWF 0x7F
13C1  0830     MOVF f, W
13C2  0084     MOVWF FSR
13C3  160A     BSF PCLATH, 0x4
13C4  158A     BSF PCLATH, 0x3
13C5  2000     CALL 0x0
13C6  160A     BSF PCLATH, 0x4
13C7  118A     BCF PCLATH, 0x3
13C8  3ED0     ADDLW 0xD0
13C9  00B8     MOVWF 0x38
13CA  30FF     MOVLW 0xFF
13CB  1803     BTFSC STATUS, 0x0
13CC  3000     MOVLW 0x0
13CD  00B9     MOVWF 0x39
13CE  0838     MOVF 0x38, W
13CF  07BE     ADDWF width, F
13D0  1803     BTFSC STATUS, 0x0
13D1  0ABF     INCF 0x3F, F
13D2  0839     MOVF 0x39, W
13D3  07BF     ADDWF 0x3F, F
13D4  0AB0     INCF f, F
13D5  1903     BTFSC STATUS, 0x2
13D6  0AB1     INCF 0x31, F
611:           			} while(isdigit((unsigned)*f));
13D7  0831     MOVF 0x31, W
13D8  00FF     MOVWF 0x7F
13D9  0830     MOVF f, W
13DA  0084     MOVWF FSR
13DB  160A     BSF PCLATH, 0x4
13DC  158A     BSF PCLATH, 0x3
13DD  2000     CALL 0x0
13DE  160A     BSF PCLATH, 0x4
13DF  118A     BCF PCLATH, 0x3
13E0  2525     CALL 0x525
13E1  160A     BSF PCLATH, 0x4
13E2  118A     BCF PCLATH, 0x3
13E3  1C03     BTFSS STATUS, 0x0
13E4  2C27     GOTO 0x427
13E5  2BB3     GOTO 0x3B3
612:           #ifdef	STAR
613:           		} else if(*f == '*') {
614:           			width = va_arg(ap, int);
615:           			f++;
616:           #endif
617:           		}
618:           #endif
619:           #ifdef	PRECISION
620:           		if(*f == '.') {
621:           			flag |= PRECISION;
622:           			f++;
623:           #ifdef	STAR
624:           			if(*f == '*') {
625:           				prec = va_arg(ap, int);
626:           				f++;
627:           			} else
628:           #endif
629:           			{
630:           				prec = 0;
631:           				while(isdigit((unsigned)*f))
632:           					prec = prec*10 + *f++ - '0';
633:           			}
634:           		} else {
635:           			prec = 0;
636:           #ifdef	DEFPREC
637:           			flag |= DEFPREC;
638:           #endif	// DEFPREC
639:           		}
640:           #endif	// PRECISION
641:           #if	defined(__LONG) && defined(LONG)
642:           loop:
643:           #endif
644:           		switch(c = *f++) {
1427  0831     MOVF 0x31, W
1428  00B9     MOVWF 0x39
1429  0830     MOVF f, W
142A  00B8     MOVWF 0x38
142B  0AB0     INCF f, F
142C  1903     BTFSC STATUS, 0x2
142D  0AB1     INCF 0x31, F
142E  0839     MOVF 0x39, W
142F  00FF     MOVWF 0x7F
1430  0838     MOVF 0x38, W
1431  0084     MOVWF FSR
1432  160A     BSF PCLATH, 0x4
1433  158A     BSF PCLATH, 0x3
1434  2000     CALL 0x0
1435  160A     BSF PCLATH, 0x4
1436  118A     BCF PCLATH, 0x3
1437  00C0     MOVWF c
1438  3A00     XORLW 0x0
1439  1903     BTFSC STATUS, 0x2
143A  2D20     GOTO 0x520
143B  3A64     XORLW 0x64
143C  1903     BTFSC STATUS, 0x2
143D  2C45     GOTO 0x445
143E  3A0D     XORLW 0xD
143F  1903     BTFSC STATUS, 0x2
1440  2C45     GOTO 0x445
1441  3A1C     XORLW 0x1C
1442  1903     BTFSC STATUS, 0x2
1443  2C25     GOTO 0x425
1444  2C1F     GOTO 0x41F
645:           
646:           		case 0:
647:           			goto alldone;
648:           
649:           #ifdef	LONG
650:           		case 'l':
651:           #ifdef	__LONG
652:           			flag |= LONG;
653:           			goto loop;
654:           #else
655:           			cp = "(non-long printf)";
656:           			goto strings;
657:           #endif
658:           #endif
659:           
660:           #ifdef	FLOATFORMAT
661:           #ifndef	__FLOAT
662:           		case 'E':
663:           		case 'f':
664:           		case 'e':
665:           		case 'G':
666:           		case 'g':
667:           			cp = "(non-float printf)";
668:           			goto strings;
669:           #else
670:           #ifdef	FFMT
671:           		case 'f':
672:           			flag |= FFMT;
673:           			break;
674:           #endif
675:           
676:           #ifdef	EFMT
677:           #ifdef	UPCASE
678:           		case 'E':
679:           			flag |= UPCASE;
680:           #endif
681:           		case 'e':
682:           			flag |= EFMT;
683:           			break;
684:           #endif
685:           
686:           #ifdef	GFMT
687:           #ifdef	UPCASE
688:           		case 'G':
689:           			flag |= UPCASE;
690:           #endif
691:           		case 'g':
692:           			flag |= GFMT;
693:           			break;
694:           #endif	// GFMT
695:           #endif
696:           #endif	// FLOATFORMAT
697:           #ifdef	EIGHT
698:           		case 'o':
699:           #ifdef	MULTRAD
700:           			flag |= EIGHT;
701:           #endif
702:           			break;
703:           #endif
704:           
705:           #ifdef	TEN
706:           		case 'd':
707:           		case 'i':
708:           			break;
709:           #endif
710:           
711:           #ifdef	POINTER
712:           		case 'p':
713:           #if	i8086 && LARGE_DATA
714:           			flag |= LONG;
715:           #elif	_PIC18 && LARGE_DATA
716:           			flag |= POINTER;
717:           #endif
718:           #endif	// POINTER
719:           #ifdef	SIXTEEN
720:           #ifdef	HEXUPCASE
721:           		case 'X':
722:           #ifdef	UPCASE
723:           			flag |= UPCASE;
724:           #endif
725:           #endif
726:           #if	defined(HEXLOWCASE) || !defined(UPCASE)
727:           		case 'x':
728:           #endif
729:           #ifdef	MULTRAD
730:           			flag |= SIXTEEN;
731:           #endif
732:           			break;
733:           #endif	// SIXTEEN
734:           
735:           #if	defined(STRING) || defined(PERCPERC)
736:           #ifdef	STRING
737:           		case 's':
738:           #if	i8086 && SMALL_DATA
739:           			if(flag & LONG)
740:           				cp = va_arg(ap, far char *);
741:           			else
742:           #endif
743:           				cp = va_arg(ap, const char *);
744:           #endif	// STRING
745:           #if	!defined(__FLOAT) && !defined(CUSTOM_PRINTF)
746:           strings:
747:           #endif
748:           #ifdef	STRING
749:           			if(!cp)
750:           				cp = "(null)";
751:           #endif
752:           #if	defined(WIDTH) || defined(PRECISION)
753:           #if	defined(STRING)
754:           			len = 0;
755:           			while(cp[len])
756:           				len++;
757:           #endif
758:           #ifdef	PERCPERC
759:           dostring:
760:           #endif
761:           #ifdef	PRECISION
762:           			if(prec && prec < len)
763:           				len = prec;
764:           #endif	// PRECISION
765:           #ifdef	WIDTH
766:           			if(width > len)
13E6  083F     MOVF 0x3F, W
13E7  0243     SUBWF 0x43, W
13E8  1D03     BTFSS STATUS, 0x2
13E9  2BEC     GOTO 0x3EC
13EA  083E     MOVF width, W
13EB  0242     SUBWF 0x42, W
13EC  1803     BTFSC STATUS, 0x0
13ED  2BF5     GOTO 0x3F5
767:           				width -= len;
13EE  0842     MOVF 0x42, W
13EF  02BE     SUBWF width, F
13F0  0843     MOVF 0x43, W
13F1  1C03     BTFSS STATUS, 0x0
13F2  03BF     DECF 0x3F, F
13F3  02BF     SUBWF 0x3F, F
13F4  2BF7     GOTO 0x3F7
768:           			else
769:           				width = 0;
13F5  01BE     CLRF width
13F6  01BF     CLRF 0x3F
770:           #ifdef	LEFT
771:           			if(!(flag & LEFT))
772:           #endif	// LEFT
773:           				while(width--)
13F7  30FF     MOVLW 0xFF
13F8  07BE     ADDWF width, F
13F9  1C03     BTFSS STATUS, 0x0
13FA  03BF     DECF 0x3F, F
13FB  0A3E     INCF width, W
13FC  1903     BTFSC STATUS, 0x2
13FD  0A3F     INCF 0x3F, W
13FE  1903     BTFSC STATUS, 0x2
13FF  2C13     GOTO 0x413
1406  2BF7     GOTO 0x3F7
774:           					pputc(' ');
1400  0844     MOVF sp, W
1401  0084     MOVWF FSR
1402  3020     MOVLW 0x20
1403  1783     BSF STATUS, 0x7
1404  0080     MOVWF INDF
1405  0AC4     INCF sp, F
775:           #endif	// WIDTH
776:           			while(len--)
1413  3001     MOVLW 0x1
1414  02C2     SUBWF 0x42, F
1415  3000     MOVLW 0x0
1416  1C03     BTFSS STATUS, 0x0
1417  03C3     DECF 0x43, F
1418  02C3     SUBWF 0x43, F
1419  0A42     INCF 0x42, W
141A  1903     BTFSC STATUS, 0x2
141B  0A43     INCF 0x43, W
141C  1903     BTFSC STATUS, 0x2
141D  2B6F     GOTO 0x36F
141E  2C07     GOTO 0x407
777:           				pputc(*cp++);
1407  0841     MOVF _val, W
1408  0084     MOVWF FSR
1409  1383     BCF STATUS, 0x7
140A  0800     MOVF INDF, W
140B  00B8     MOVWF 0x38
140C  0844     MOVF sp, W
140D  0084     MOVWF FSR
140E  0838     MOVF 0x38, W
140F  1783     BSF STATUS, 0x7
1410  0080     MOVWF INDF
1411  0AC1     INCF _val, F
1412  0AC4     INCF sp, F
778:           #ifdef	LEFT
779:           			if(flag & LEFT)
780:           				while(width--)
781:           					pputc(' ');
782:           #endif	// LEFT
783:           			continue;
784:           #else	// WIDTH || PRECISION
785:           #if	defined(STRING)
786:           			while(*cp)
787:           				pputc(*cp++);
788:           			continue;
789:           #endif
790:           #endif	// WIDTH || PRECISION
791:           #endif	// defined(STRING) || defined(PERCPERC)
792:           #ifdef	CHAR
793:           		case 'c':
794:           #if	_HOSTED
795:           			val = va_arg(ap, int);
796:           			c = val >> 8;
797:           			if(flag & LONG && c && (unsigned char)c != 0xFF) {
798:           				cbuf[0] = c;
799:           				cbuf[1] = val;
800:           				len = 2;
801:           			} else {
802:           				cbuf[0] = val;
803:           				len = 1;
804:           			}
805:           			cp = cbuf;
806:           			goto dostring;
807:           #else
808:           			c = va_arg(ap, int);
809:           #endif	// _HOSTED
810:           #endif	// CHAR
811:           		default:
812:           #ifdef	PERCPERC
813:           #if	defined(WIDTH) || defined(PRECISION)
814:           			cp = (char *)&c;
141F  3040     MOVLW 0x40
1420  00C1     MOVWF _val
815:           			len = 1;
1421  01C2     CLRF 0x42
1422  0AC2     INCF 0x42, F
1423  01C3     CLRF 0x43
816:           			goto dostring;
1424  2BE6     GOTO 0x3E6
817:           #else
818:           			pputc(c);
819:           			continue;
820:           #endif
821:           #else	// PERCPERC
822:           			continue;
823:           #endif
824:           
825:           #ifdef	UNSIGN
826:           		case 'u':
827:           			flag |= UNSIGN;
1425  173D     BSF flag, 0x6
828:           			break;
1426  2C45     GOTO 0x445
829:           #endif
830:           
831:           		}
832:           #endif	// ANYFORMAT
833:           #ifdef	__FLOAT
834:           		if(flag & (FLOATFORMAT)) {
835:           #ifdef	DEFPREC
836:           			if(flag & DEFPREC)
837:           #endif
838:           				prec = 6;
839:           			fval = va_arg(ap, double);	// source the floating point value
840:           			if(fval < 0.0) {
841:           				fval = -fval;		// get the absolute value
842:           				flag |= NEGSIGN;
843:           			}
844:           			exp = 0;		/* If the number is zero, the exponent is zero. */
845:           			if( fval!=0) {		/* If the number is non-zero, find the exponent. */
846:           				frexp(fval, &exp);		/* get binary exponent */
847:           				exp--;				/* adjust 0.5 -> 1.0 */
848:           				exp *= 3;
849:           				exp /= 10;			/* estimate decimal exponent */
850:           				if(exp < 0)
851:           					exp--;
852:           				// the following line can cause "recursive call" errors because scale calls
853:           				// ftmul, and is used when evaluating an argument to ftmul
854:           				//integ = fval * scale(-exp);
855:           				integ = scale(-exp);		// replaced with this
856:           				integ *= fval;
857:           				if(integ < 1.0)
858:           					exp--;
859:           				else if(integ >= 10.0)
860:           					exp++;
861:           			}
862:           #if	defined(EFMT) || defined(GFMT)
863:           			if(exp <= 0)	// value is 0.??? (neg expnt) whole characters = 1 (allow zero)
864:           				c = 1;
865:           			else
866:           				c = exp;
867:           			if(
868:           #ifdef	EFMT
869:           					flag & EFMT
870:           #ifdef	GFMT
871:           					||
872:           #endif
873:           #endif
874:           #ifdef	GFMT
875:           					flag & GFMT && (exp < -4 || exp >= (int)prec)
876:           #endif
877:           				) {	/* use e format */
878:           #ifdef	GFMT
879:           				if(prec && flag & GFMT)
880:           					prec--;		/* g format precision includes integer digit */
881:           #endif
882:           				if((unsigned)prec > NDDIG - 2)
883:           					c = NDDIG - 2;
884:           				else
885:           					c = prec;
886:           				if( fval!=0) {	/* Normalise only if the number is non-zero. */
887:           					fval /= scale(exp-c);
888:           #if	DOUBLE
889:           					ival = _dto64i(fval);
890:           					if(fval - _64itod(ival) >= 0.5) {
891:           						fval += 0.5;
892:           						ival = _dto64i(fval);
893:           					}
894:           					if(ival >= fdpowers[c+1]) {
895:           						fval *= 1e-1;
896:           						exp++;
897:           					} else if(ival < fdpowers[c]) {
898:           						fval *= 10.0;
899:           						exp--;
900:           					}
901:           #else	
902:           					if(fval - (double)(unsigned long)fval >= 0.5)
903:           						fval += 0.5;
904:           					if((unsigned long)fval >= fdpowers[c+1]) {
905:           						fval *= 1e-1;
906:           						exp++;
907:           					} else if((unsigned long)fval < fdpowers[c]) {
908:           						fval *= 10.0;
909:           						exp--;
910:           					}
911:           #endif
912:           				}
913:           #if defined(GFMT) && defined(ALTERN)
914:           				if(flag & GFMT && !(flag & ALTERN)) {		/* g format, precision means something different */
915:           					if(prec > (int)(NDDIG))
916:           						prec = NDDIG;
917:           #if	DOUBLE
918:           					ival = _dto64i(fval);
919:           					while(ival != 0.0 && _mod64i10(ival) == 0) {
920:           						prec--;
921:           						ival = _div64(ival, fdpowers[1]);
922:           					}
923:           #else
924:           					val = (unsigned long)fval;
925:           					while(val && val % 10 == 0) {
926:           						prec--;
927:           						val /= 10;
928:           					}
929:           #endif
930:           					if(prec < c) {
931:           						fval /= scale(c-prec);
932:           						c = prec;
933:           					}
934:           
935:           				}
936:           #endif
937:           #ifdef	WIDTH
938:           				width -=  prec + 5;
939:           #ifdef	ALTERN
940:           				if(prec || flag & ALTERN)
941:           					width--;
942:           #endif
943:           				if(flag & NEGSIGN)
944:           					width--;
945:           #if	DBL_MAX_10_EXP >= 100
946:           #if	DBL_MAX_10_EXP >= 1000
947:           				if(exp >= 1000 || exp <= -1000)	/* 4 digit exponent */
948:           					width--;
949:           #endif
950:           				if(exp >= 100 || exp <= -100)	/* 3 digit exponent */
951:           					width--;
952:           #endif
953:           #endif	// WIDTH
954:           #ifdef	FILL
955:           				if(flag & FILL) {
956:           #if defined(MANSIGN) && defined(SPCSIGN)
957:           					if(flag & MANSIGN)
958:           						pputc(flag & SPCSIGN ? '-' : '+');
959:           					else if(flag & SPCSIGN)
960:           						pputc(' ');
961:           #endif
962:           					while(width > 0) {
963:           						pputc('0');
964:           						width--;
965:           					}
966:           				} else
967:           #endif	// FILL
968:           				{
969:           #ifdef	WIDTH
970:           #ifdef	LEFT
971:           					if(!(flag & LEFT))
972:           #endif
973:           						while(width > 0) {
974:           							pputc(' ');
975:           							width--;
976:           						}
977:           #endif	// WIDTH
978:           #ifdef	MANSIGN
979:           					if(flag & MANSIGN)
980:           						putsign();
981:           #else
982:           					if(flag & NEGSIGN)
983:           						pputc('-');
984:           #endif	// MANSIGN
985:           #ifdef	SPCSIGN
986:           					else if(flag & SPCSIGN)
987:           						pputc(' ');
988:           #endif	// SPCSIGN
989:           				}
990:           #if	DOUBLE
991:           				ival = _dto64i(fval);
992:           				pputc(_div64ir(ival, fdpowers[c]) + '0');
993:           #else
994:           				val = (unsigned long)fval;
995:           				pputc(val/dpowers[c] + '0');
996:           				val %= dpowers[c];
997:           #endif
998:           #ifdef	ALTERN
999:           				if(prec || flag & ALTERN)
1000:          #else
1001:          				if(prec)
1002:          #endif
1003:          				{
1004:          					pputc('.');
1005:          					prec -= c;
1006:          					while(c--) {
1007:          #if	DOUBLE
1008:          						pputc('0' + _mod64i10(_div64(ival, fdpowers[c])));
1009:          #else
1010:          #ifdef	GFMT
1011:          						if(flag & GFMT && val == 0) {
1012:          							prec = c = 0;
1013:          							break;
1014:          						}
1015:          #endif
1016:          						pputc('0' + (val/dpowers[c]));
1017:          						val %= dpowers[c];
1018:          #endif
1019:          					}
1020:          					while(prec) {
1021:          						pputc('0');
1022:          						prec--;
1023:          					}
1024:          				}
1025:          #ifdef	UPCASE
1026:          				if(flag & UPCASE)
1027:          					pputc('E');
1028:          				else
1029:          #endif
1030:          					pputc('e');
1031:          				if(exp < 0) {
1032:          					exp = -exp;
1033:          					pputc('-');
1034:          				} else
1035:          					pputc('+');
1036:          #if	DBL_MAX_10_EXP >= 100
1037:          #if	DBL_MAX_10_EXP >= 1000
1038:          				if(exp >= 1000) {
1039:          					pputc(exp / 1000 + '0');
1040:          					exp %= 1000;
1041:          				}
1042:          #endif
1043:          				if(exp >= 100) {
1044:          					pputc(exp / 100 + '0');
1045:          					exp %= 100;
1046:          				}
1047:          #endif
1048:          				pputc(exp / 10 + '0');
1049:          				pputc(exp % 10 + '0');
1050:          #ifdef	LEFT
1051:          				if((flag & LEFT) && width > 0)
1052:          					do
1053:          						pputc(' ');
1054:          					while(--width);
1055:          #endif	// LEFT
1056:          					continue;
1057:          				}
1058:          #endif	// EFMT || GFMT
1059:          				/* here for f format */
1060:          #if	DOUBLE
1061:          #ifdef	GFMT
1062:          				if(flag & GFMT) {
1063:          					if(exp < 0)	// fractional part only
1064:          						prec -= exp-1;
1065:          					ival = _dto64i(fval);
1066:          					for(c = 1 ; c != NDDIG ; c++)
1067:          						if(ival < fdpowers[c])
1068:          							break;
1069:          					if(prec > NDDIG)
1070:          						prec = NDDIG;
1071:          					prec -= c;
1072:          					ival = _dto64i((fval - _64itod(ival)) * scale(prec)+0.5);
1073:          					// see how many zeros are at the end of the fractional part
1074:          					while(prec && _mod64i10(ival) == 0) {
1075:          						prec--;
1076:          						ival = _div64(ival, fdpowers[1]);
1077:          					}
1078:          				}
1079:          #endif	// GFMT
1080:          				if(prec <= (int)NDDIG)
1081:          					fval += fround(prec);
1082:          				if(exp > (int)(NDDIG)-2) {
1083:          					exp -= NDDIG-2;
1084:          					ival = _divto64i(fval, scale(exp));
1085:          					fval = 0.0;
1086:          				} else {
1087:          					ival = _dto64i(fval);
1088:          					fval -= _64itod(ival);
1089:          					exp = 0;
1090:          				}
1091:          				for(c = 1 ; c != NDDIG ; c++)
1092:          					if(ival < fdpowers[c])
1093:          						break;
1094:          #else	// DOUBLE
1095:          #ifdef	GFMT
1096:          				if(flag & GFMT) {
1097:          					if(exp < 0)	// fractional part only
1098:          						prec -= (exp+1);
1099:          					// count number of digits in the integral part (this is for %g)
1100:          					val = (unsigned long)fval;
1101:          					for(c = 0 ; c != NDDIG ; c++)
1102:          						if(val < fdpowers[c])
1103:          							break;
1104:          					prec -= c;		// reduce precision by this
1105:          					if(prec <= NDIG)
1106:          						fval += fround(prec);
1107:          					// get fractional part and count trailing zeros - reduce
1108:          					// prec as required
1109:          					{
1110:          						double	temp;
1111:          						temp = scale(prec);
1112:          						temp *= fval - (double)val;
1113:          						val = (unsigned long)temp;
1114:          					}
1115:          					while(prec && val % 10 == 0) {
1116:          						val /= 10;
1117:          						prec--;
1118:          					}
1119:          				} else
1120:          #endif	//GFMT
1121:          					if(prec <= NDIG)
1122:          						fval += fround(prec);
1123:          
1124:          				/* ~4.2e9 is the largest float that will fit into a 32-bit long */
1125:          				if((exp > 9)||(fval != 0 && (unsigned long)fval == 0 && exp > 1)) {
1126:          					// fval is > 4.2e9
1127:          					// new exp must be such that div_to_l() is < 4.2e9
1128:          					// OLD CODE:	if(fval / scale(exp) < 4.294967296){
1129:          					if(integ < 4.294967296){
1130:          						exp -= NDDIG-1;
1131:          					}else{
1132:          						exp -= NDDIG-2;
1133:          					}
1134:          					integ = scale(exp);
1135:          					val = div_to_l_(fval, integ);
1136:           					//val = _div_to_l_(integ, fval);
1137:          					//val = (long)(integ * fval);	// fit as much signifigant data into the long as it can hold
1138:          					fval = 0.0;	// There will be no fractional component
1139:          				} else {
1140:          					val = (unsigned long)fval;
1141:          					fval -= (double)val;
1142:          					exp = 0;
1143:          				}
1144:          				// count digits in integral part
1145:          				for(c = 1 ; c != NDDIG ; c++)
1146:          					if(val < fdpowers[c])
1147:          						break;
1148:          #endif	// DOUBLE
1149:          #ifdef	WIDTH
1150:          				// at this point, c contains the number of whole-number digits to print
1151:          				width -= prec + c + exp;
1152:          				if(
1153:          #ifdef	ALTERN
1154:          						flag & ALTERN ||
1155:          #endif
1156:          						prec)
1157:          					width--;		// allow for decimal point
1158:          				if(flag & NEGSIGN)
1159:          					width--;
1160:          #endif	// WIDTH
1161:          #ifdef	FILL
1162:          				if(flag & FILL) {
1163:          #ifdef	MANSIGN
1164:          					if(flag & MANSIGN)
1165:          #else
1166:          					if(flag & NEGSIGN)
1167:          #endif	// MANSIGN
1168:          						putsign();
1169:          #if defined(MANSIGN) && defined(SPCSIGN)
1170:          					else
1171:          #endif
1172:          #ifdef	SPCSIGN
1173:          					if(flag & SPCSIGN)
1174:          						pputc(' ');
1175:          #endif	// SPCSIGN
1176:          #ifdef	WIDTH
1177:          					while(width > 0) {
1178:          						pputc('0');
1179:          						width--;
1180:          					}
1181:          #endif	// WIDTH
1182:          				} else
1183:          #endif	// FILL
1184:          				{
1185:          #ifdef	LEFT
1186:          					if(!(flag & LEFT))
1187:          #endif
1188:          #ifdef	WIDTH
1189:          					while(width > 0) {
1190:          						pputc(' ');
1191:          						width--;
1192:          					}
1193:          #endif	// WIDTH
1194:          #ifdef	MANSIGN
1195:          				if(flag & MANSIGN)
1196:          #else
1197:          				if(flag & NEGSIGN)
1198:          #endif	// MANSIGN
1199:          					putsign();
1200:          #ifdef	SPCSIGN
1201:          				else if(flag & SPCSIGN)
1202:          					pputc(' ');
1203:          #endif	// SPCSIGN
1204:          			}
1205:          			while(c--) {
1206:          #if	DOUBLE
1207:          				pputc('0' + _mod64i10(_div64(ival, fdpowers[c])));
1208:          #else
1209:          				{
1210:          					unsigned long vd = val/dpowers[c];
1211:          					vd %= 10;
1212:          					pputc('0' + vd);
1213:          				}
1214:          #endif	// DOUBLE
1215:          			}
1216:          			while(exp > 0) {
1217:          				pputc('0');
1218:          				exp--;
1219:          			}
1220:          			if(prec > (int)(NDDIG-2))
1221:          				c = NDDIG-2;
1222:          			else
1223:          				c = prec;
1224:          			prec -= c;
1225:          #ifdef	ALTERN
1226:          			if(c || flag & ALTERN)
1227:          #else
1228:          			if(c)
1229:          #endif
1230:          				pputc('.');
1231:          #if	DOUBLE
1232:          			ival = _dto64i(fval * scale(c));
1233:          			while(c)
1234:          				pputc('0' + _mod64i10(_div64(ival, fdpowers[--c])));
1235:          #else	// DOUBLE
1236:          			val = (long)(fval * scale(c));
1237:          			while(c--) {
1238:          				unsigned long vd = val/dpowers[c];
1239:          				vd %= 10;
1240:          				pputc('0' + vd);
1241:          				val %= dpowers[c];
1242:          			}
1243:          #endif	// DOUBLE
1244:          			while(prec) {
1245:          				pputc('0');
1246:          				prec--;
1247:          			}
1248:          #ifdef	LEFT
1249:          			if((flag & LEFT) && width > 0)
1250:          				do
1251:          					pputc(' ');
1252:          				while(--width);
1253:          #endif
1254:          			continue;
1255:          		}
1256:          #endif	/* __FLOAT */
1257:          
1258:          #if	defined(TEN)
1259:          #ifdef	BASEM
1260:          		if((flag & BASEM) == TEN)
1445  1B3D     BTFSC flag, 0x6
1446  2C5B     GOTO 0x45B
1261:          #endif	//BASEM
1262:          		{
1263:          #ifdef	LONG
1264:          			if(flag & LONG)
1265:          				val = va_arg(ap, long);
1266:          			else
1267:          #endif	// LONG
1268:          				val = (value)va_arg(ap, int);
1447  083C     MOVF ap, W
1448  0084     MOVWF FSR
1449  1383     BCF STATUS, 0x7
144A  0800     MOVF INDF, W
144B  00C1     MOVWF _val
144C  0A84     INCF FSR, F
144D  0800     MOVF INDF, W
144E  00C2     MOVWF 0x42
144F  0ABC     INCF ap, F
1450  0ABC     INCF ap, F
1269:          #ifdef	NEGSIGN
1270:          			if((value)val < 0) {
1451  1FC2     BTFSS 0x42, 0x7
1452  2C65     GOTO 0x465
1271:          				flag |= NEGSIGN;
1453  3003     MOVLW 0x3
1454  04BD     IORWF flag, F
1272:          				val = -val;
1455  09C1     COMF _val, F
1456  09C2     COMF 0x42, F
1457  0AC1     INCF _val, F
1458  1903     BTFSC STATUS, 0x2
1459  0AC2     INCF 0x42, F
145A  2C65     GOTO 0x465
1273:          			}
1274:          #endif
1275:          		}
1276:          #ifdef	BASEM
1277:          		else
1278:          #endif
1279:          #endif	// TEN
1280:          
1281:          #if	defined(EIGHT) || defined(SIXTEEN) || defined(UNSIGN)
1282:          		{
1283:          #ifdef	__LONG
1284:          #if	defined(_PIC18) && defined(LARGE_DATA) && defined(POINTER)
1285:          			if(flag & POINTER)
1286:          				val = (unsigned long)va_arg(ap, far char *);
1287:          			else
1288:          #endif
1289:          #ifdef	LONG
1290:          				if(flag & LONG)
1291:          				val = va_arg(ap, unsigned long);
1292:          			else
1293:          #endif	// LONG
1294:          #endif	// __LONG
1295:          				val = va_arg(ap, unsigned);
145B  083C     MOVF ap, W
145C  0084     MOVWF FSR
145D  1383     BCF STATUS, 0x7
145E  0800     MOVF INDF, W
145F  00C1     MOVWF _val
1460  0A84     INCF FSR, F
1461  0800     MOVF INDF, W
1462  00C2     MOVWF 0x42
1463  0ABC     INCF ap, F
1464  0ABC     INCF ap, F
1296:          		}
1297:          #endif	// EIGHT or SIXTEEN or UNSIGN
1298:          #ifdef	PRECISION
1299:          		if(prec == 0 && val == 0)
1300:          			prec++;
1301:          #endif
1302:          #ifdef	MULTRAD
1303:          		switch((unsigned char)(flag & BASEM)) {
1304:          #endif
1305:          #if	defined(TEN) || defined(UNSIGN)
1306:          #ifdef	MULTRAD
1307:          #ifdef	TEN
1308:          		case TEN:
1309:          #endif
1310:          #ifdef	UNSIGN
1311:          		case UNSIGN:
1312:          #endif
1313:          #endif	// MULTRAD
1314:          			for(c = 1 ; c != sizeof dpowers/sizeof dpowers[0] ; c++)
1465  01C0     CLRF c
1466  0AC0     INCF c, F
1467  0840     MOVF c, W
1468  3A05     XORLW 0x5
1469  1903     BTFSC STATUS, 0x2
146A  2C86     GOTO 0x486
1315:          				if(val < dpowers[c])
146B  1003     BCF STATUS, 0x0
146C  0D40     RLF c, W
146D  3E12     ADDLW 0x12
146E  0084     MOVWF FSR
146F  3098     MOVLW 0x98
1470  1803     BTFSC STATUS, 0x0
1471  3E01     ADDLW 0x1
1472  00FF     MOVWF 0x7F
1473  160A     BSF PCLATH, 0x4
1474  158A     BSF PCLATH, 0x3
1475  2000     CALL 0x0
1476  160A     BSF PCLATH, 0x4
1477  118A     BCF PCLATH, 0x3
1478  00B8     MOVWF 0x38
1479  160A     BSF PCLATH, 0x4
147A  158A     BSF PCLATH, 0x3
147B  2000     CALL 0x0
147C  160A     BSF PCLATH, 0x4
147D  118A     BCF PCLATH, 0x3
147E  00B9     MOVWF 0x39
147F  0242     SUBWF 0x42, W
1480  1D03     BTFSS STATUS, 0x2
1481  2C84     GOTO 0x484
1482  0838     MOVF 0x38, W
1483  0241     SUBWF _val, W
1484  1803     BTFSC STATUS, 0x0
1485  2C66     GOTO 0x466
1316:          					break;
1317:          #ifdef	MULTRAD
1318:          			break;
1319:          #endif
1320:          #endif	// TEN || UNSIGN
1321:          #ifdef	SIXTEEN
1322:          #ifdef	MULTRAD
1323:          		case SIXTEEN:
1324:          #endif	// MULTRAD
1325:          			for(c = 1 ; c != sizeof hexpowers/sizeof hexpowers[0] ; c++)
1326:          				if(val < hexpowers[c])
1327:          					break;
1328:          #ifdef	MULTRAD
1329:          			break;
1330:          #endif
1331:          #endif
1332:          
1333:          #ifdef	EIGHT
1334:          #ifdef	MULTRAD
1335:          		case EIGHT:
1336:          #endif	// MULTRAD
1337:          			for(c = 1 ; c != sizeof octpowers/sizeof octpowers[0] ; c++)
1338:          				if(val < octpowers[c])
1339:          					break;
1340:          #ifdef	MULTRAD
1341:          			break;
1342:          #endif
1343:          #endif
1344:          #ifdef	MULTRAD
1345:          		}
1346:          #endif
1347:          #ifdef	PRECISION
1348:          		if(c < prec)
1349:          			c = prec;
1350:          		else if(prec < c)
1351:          			prec = c;
1352:          #endif
1353:          #if	defined(WIDTH) && defined(NEGSIGN)
1354:          		if(width && flag & NEGSIGN)
1486  083F     MOVF 0x3F, W
1487  043E     IORWF width, W
1488  1903     BTFSC STATUS, 0x2
1489  2C92     GOTO 0x492
148A  083D     MOVF flag, W
148B  3903     ANDLW 0x3
148C  1903     BTFSC STATUS, 0x2
148D  2C92     GOTO 0x492
1355:          			width--;
148E  30FF     MOVLW 0xFF
148F  07BE     ADDWF width, F
1490  1C03     BTFSS STATUS, 0x0
1491  03BF     DECF 0x3F, F
1356:          #ifdef	PRECISION
1357:          		if(flag & PRECISION) {
1358:          			if(width > prec)
1359:          				width -= prec;
1360:          			else
1361:          				width = 0;
1362:          		}
1363:          #endif
1364:          #ifdef	ALTERN
1365:          #ifdef	EIGHT
1366:          		if((flag & (
1367:          #ifdef	FILL
1368:          						FILL|
1369:          #endif
1370:          							BASEM|ALTERN)) == (EIGHT|ALTERN)) {
1371:          			if(width)
1372:          				width--;
1373:          		} else
1374:          #endif	// EIGHT
1375:          #if	defined(SIXTEEN)
1376:          #ifdef	BASEM
1377:          		if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1378:          #else
1379:          		if(flag & ALTERN) {
1380:          #endif
1381:          			if(width > 2)
1382:          				width -= 2;
1383:          			else
1384:          				width = 0;
1385:          		}
1386:          #endif	// SIXTEEN
1387:          #endif	// ALTERN
1388:          #endif	// WIDTH
1389:          #ifdef	WIDTH
1390:          		if(width > c)
1492  0840     MOVF c, W
1493  00B8     MOVWF 0x38
1494  01B9     CLRF 0x39
1495  1BB8     BTFSC 0x38, 0x7
1496  03B9     DECF 0x39, F
1497  0839     MOVF 0x39, W
1498  3A80     XORLW 0x80
1499  00BA     MOVWF sign
149A  083F     MOVF 0x3F, W
149B  3A80     XORLW 0x80
149C  023A     SUBWF sign, W
149D  1D03     BTFSS STATUS, 0x2
149E  2CA1     GOTO 0x4A1
149F  083E     MOVF width, W
14A0  0238     SUBWF 0x38, W
14A1  1803     BTFSC STATUS, 0x0
14A2  2CB0     GOTO 0x4B0
1391:          			width -= c;
14A3  1283     BCF STATUS, 0x5
14A4  1303     BCF STATUS, 0x6
14A5  0840     MOVF c, W
14A6  00B8     MOVWF 0x38
14A7  01B9     CLRF 0x39
14A8  1BB8     BTFSC 0x38, 0x7
14A9  03B9     DECF 0x39, F
14AA  02BE     SUBWF width, F
14AB  0839     MOVF 0x39, W
14AC  1C03     BTFSS STATUS, 0x0
14AD  03BF     DECF 0x3F, F
14AE  02BF     SUBWF 0x3F, F
14AF  2CB4     GOTO 0x4B4
1392:          		else
1393:          			width = 0;
14B0  1283     BCF STATUS, 0x5
14B1  1303     BCF STATUS, 0x6
14B2  01BE     CLRF width
14B3  01BF     CLRF 0x3F
1394:          #endif
1395:          #ifdef	FILL
1396:          		if(flag & FILL) {
14B4  1D3D     BTFSS flag, 0x2
14B5  2CCF     GOTO 0x4CF
1397:          #ifdef	MANSIGN
1398:          			if(flag & MANSIGN)
1399:          				putsign();
1400:          #elif defined(NEGSIGN)
1401:          			if(flag & NEGSIGN)
14B6  083D     MOVF flag, W
14B7  3903     ANDLW 0x3
14B8  1903     BTFSC STATUS, 0x2
14B9  2CC0     GOTO 0x4C0
1402:          				pputc('-');
14BA  0844     MOVF sp, W
14BB  0084     MOVWF FSR
14BC  302D     MOVLW 0x2D
14BD  1783     BSF STATUS, 0x7
14BE  0080     MOVWF INDF
14BF  0AC4     INCF sp, F
1403:          #endif
1404:          #if defined(MANSIGN) || defined(NEGSIGN) && defined(SPCSIGN)
1405:          			else
1406:          #endif	// MANSIGN
1407:          #ifdef	SPCSIGN
1408:          			if(flag & SPCSIGN)
1409:          				pputc(' ');
1410:          #endif
1411:          #if defined(ALTERN) && defined(SIXTEEN)
1412:          			else if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1413:          				pputc('0');
1414:          #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
1415:          				pputc(flag & UPCASE ? 'X' : 'x');
1416:          #elif defined(HEXUPCASE)
1417:          				pputc('X');
1418:          #else
1419:          				pputc('x');
1420:          #endif	// HEXUPCASE
1421:          			}
1422:          #endif	// ALTERN
1423:          #ifdef	WIDTH
1424:          			if(width)
14C0  083F     MOVF 0x3F, W
14C1  043E     IORWF width, W
14C2  1903     BTFSC STATUS, 0x2
14C3  2CEB     GOTO 0x4EB
1425:          				do
1426:          					pputc('0');
14C4  0844     MOVF sp, W
14C5  0084     MOVWF FSR
14C6  3030     MOVLW 0x30
14C7  1783     BSF STATUS, 0x7
14C8  0080     MOVWF INDF
14CA  0AC4     INCF sp, F
1427:          				while(--width);
14C9  30FF     MOVLW 0xFF
14CB  07BE     ADDWF width, F
14CC  1C03     BTFSS STATUS, 0x0
14CD  03BF     DECF 0x3F, F
14CE  2CC0     GOTO 0x4C0
1428:          #endif	// WIDTH
1429:          		} else
1430:          #endif	//FILL
1431:          		{
1432:          #ifdef	WIDTH
1433:          			if(width
1434:          #ifdef	LEFT
1435:          					&& !(flag & LEFT)
1436:          #endif
1437:          					)
14CF  083F     MOVF 0x3F, W
14D0  043E     IORWF width, W
14D1  1903     BTFSC STATUS, 0x2
14D2  2CE1     GOTO 0x4E1
1438:          				do
1439:          					pputc(' ');
14D3  0844     MOVF sp, W
14D4  0084     MOVWF FSR
14D5  3020     MOVLW 0x20
14D6  1783     BSF STATUS, 0x7
14D7  0080     MOVWF INDF
14D9  0AC4     INCF sp, F
1440:          				while(--width);
14D8  30FF     MOVLW 0xFF
14DA  07BE     ADDWF width, F
14DB  1C03     BTFSS STATUS, 0x0
14DC  03BF     DECF 0x3F, F
14DD  083F     MOVF 0x3F, W
14DE  043E     IORWF width, W
14DF  1D03     BTFSS STATUS, 0x2
14E0  2CD3     GOTO 0x4D3
1441:          #endif	// WIDTH
1442:          #ifdef	MANSIGN
1443:          			if(flag & MANSIGN)
1444:          				putsign();
1445:          #else
1446:          #ifdef	NEGSIGN
1447:          			if(flag & NEGSIGN)
14E1  083D     MOVF flag, W
14E2  3903     ANDLW 0x3
14E3  1903     BTFSC STATUS, 0x2
14E4  2CEB     GOTO 0x4EB
1448:          				pputc('-');
14E5  0844     MOVF sp, W
14E6  0084     MOVWF FSR
14E7  302D     MOVLW 0x2D
14E8  1783     BSF STATUS, 0x7
14E9  0080     MOVWF INDF
14EA  0AC4     INCF sp, F
1449:          #endif
1450:          #endif	// MANSIGN
1451:          #ifdef	SPCSIGN
1452:          			else if(flag & SPCSIGN)
1453:          				pputc(' ');
1454:          #endif
1455:          #ifdef	ALTERN
1456:          #ifdef	EIGHT
1457:          			if((flag & (BASEM|ALTERN)) == (EIGHT|ALTERN))
1458:          				pputc('0');
1459:          			else
1460:          #endif	// EIGHT
1461:          #ifdef	SIXTEEN
1462:          #ifdef	BASEM
1463:          			if((flag & (BASEM|ALTERN)) == (SIXTEEN|ALTERN)) {
1464:          #else
1465:          			if(flag & ALTERN) {
1466:          #endif
1467:          				pputc('0');
1468:          #if	defined(HEXUPCASE) && defined(HEXLOWCASE)
1469:          				pputc(flag & UPCASE ? 'X' : 'x');
1470:          #elif defined(HEXUPCASE)
1471:          				pputc('X');
1472:          #else
1473:          				pputc('x');
1474:          #endif
1475:          			}
1476:          #endif	// SIXTEEN
1477:          #endif	// ALTERN
1478:          		}
1479:          #if	defined(SIXTEEN) || defined(TEN) || defined(EIGHT) || defined(UNSIGN)
1480:          #ifndef	PRECISION
1481:          		prec = c;
14EB  0840     MOVF c, W
14EC  00BB     MOVWF prec
1482:          #endif
1483:          		while(prec--) {
14ED  2D1C     GOTO 0x51C
151C  03BB     DECF prec, F
151D  0F3B     INCFSZ prec, W
151E  2CEE     GOTO 0x4EE
1484:          #ifdef	MULTRAD
1485:          			switch((unsigned char)(flag & BASEM))
1486:          #endif
1487:          			{
1488:          
1489:          #if	defined(TEN) || defined(UNSIGN)
1490:          #ifdef	MULTRAD
1491:          #ifdef	TEN
1492:          		case TEN:
1493:          #endif
1494:          #ifdef	UNSIGN
1495:          		case UNSIGN:
1496:          #endif
1497:          #endif	// MULTRAD
1498:          				c = (val / dpowers[prec]) % 10 + '0';
14EE  300A     MOVLW 0xA
14EF  00AB     MOVWF Data
14F0  01AC     CLRF sec
14F1  1003     BCF STATUS, 0x0
14F2  0D3B     RLF prec, W
14F3  3E12     ADDLW 0x12
14F4  0084     MOVWF FSR
14F5  3098     MOVLW 0x98
14F6  1803     BTFSC STATUS, 0x0
14F7  3E01     ADDLW 0x1
14F8  00FF     MOVWF 0x7F
14F9  160A     BSF PCLATH, 0x4
14FA  158A     BSF PCLATH, 0x3
14FB  2000     CALL 0x0
14FC  160A     BSF PCLATH, 0x4
14FD  118A     BCF PCLATH, 0x3
14FE  00A4     MOVWF x
14FF  160A     BSF PCLATH, 0x4
1500  158A     BSF PCLATH, 0x3
1501  2000     CALL 0x0
1502  160A     BSF PCLATH, 0x4
1503  118A     BCF PCLATH, 0x3
1504  00A5     MOVWF dato
1505  0842     MOVF 0x42, W
1506  00A7     MOVWF x
1507  0841     MOVF _val, W
1508  00A6     MOVWF y
1509  2533     CALL 0x533
150A  160A     BSF PCLATH, 0x4
150B  118A     BCF PCLATH, 0x3
150C  0825     MOVF dato, W
150D  00AE     MOVWF day
150E  0824     MOVF x, W
150F  00AD     MOVWF hr
1510  255D     CALL 0x55D
1511  160A     BSF PCLATH, 0x4
1512  118A     BCF PCLATH, 0x3
1513  082B     MOVF Data, W
1514  3E30     ADDLW 0x30
1515  00C0     MOVWF c
1499:          #ifdef	MULTRAD
1500:          				break;
1501:          #endif
1502:          #endif	// TEN || UNSIGN
1503:          
1504:          #ifdef	SIXTEEN
1505:          #ifdef	MULTRAD
1506:          			case SIXTEEN:
1507:          #endif
1508:          			{
1509:          				unsigned char idx = (val / hexpowers[prec]) & 0xF;
1510:          #if	defined(HEXLOWCASE) && defined(HEXUPCASE)
1511:          				c = (flag & UPCASE ? "0123456789ABCDEF" : "0123456789abcdef")[idx];
1512:          #elif	defined(HEXUPCASE)
1513:          				c = "0123456789ABCDEF"[idx];
1514:          #else
1515:          				c = "0123456789abcdef"[idx];
1516:          #endif	//HEXCASE
1517:          			}
1518:          #ifdef	MULTRAD
1519:          				break;
1520:          #endif
1521:          #endif
1522:          
1523:          #ifdef	EIGHT
1524:          #ifdef	MULTRAD
1525:          			case EIGHT:
1526:          #endif	// MULTRAD
1527:          				c = ((val / octpowers[prec]) & 07) + '0';
1528:          #ifdef	MULTRAD
1529:          				break;
1530:          #endif	// MULTRAD
1531:          #endif	// EIGHT
1532:          			}
1533:          			pputc(c);
1516  0844     MOVF sp, W
1517  0084     MOVWF FSR
1518  0840     MOVF c, W
1519  1783     BSF STATUS, 0x7
151A  0080     MOVWF INDF
151B  0AC4     INCF sp, F
1534:          		}
1535:          #endif	// 16 or 10 or 8
1536:          #ifdef	LEFT
1537:          		if((flag & LEFT) && width > 0)
1538:          			do
1539:          				pputc(' ');
1540:          			while(--width);
1541:          #endif	// LEFT
1542:          	}
1543:          #ifdef	ANYFORMAT
1544:          alldone:
1545:          #endif	// ANYFORMAT
1546:          #if	!defined(PRINTF) && (defined(SPRINTF) || defined(VSPRINTF))
1547:          	*sp = 0;
1520  0844     MOVF sp, W
1521  0084     MOVWF FSR
1522  1783     BSF STATUS, 0x7
1523  0180     CLRF INDF
1548:          #endif
1549:          	return ccnt;
1550:          }
1524  0008     RETURN
1551:          
---  /opt/microchip/xc8/v1.31/sources/common/bmul.c  ----------------------------------------------------
1:             // 8 x 8 bit multiplication with 8 bit result
2:             
3:             unsigned char
4:             __bmul(unsigned char multiplier, unsigned char multiplicand)
0BDB  00A6     MOVWF y
5:             {
6:             	unsigned char product;
7:             
8:             	product = 0;
0BDC  01A5     CLRF dato
9:             	do {
10:            		if(multiplier & 1)
0BDD  0824     MOVF x, W
0BDE  1826     BTFSC y, 0x0
11:            			product += multiplicand;
0BDD  0824     MOVF x, W
0BDF  07A5     ADDWF dato, F
12:            		multiplicand <<= 1;
0BE0  1003     BCF STATUS, 0x0
0BE1  0DA4     RLF x, F
13:            		multiplier >>= 1;
0BE2  1003     BCF STATUS, 0x0
0BE3  0CA6     RRF y, F
14:            	} while(multiplier != 0);
0BE4  08A6     MOVF y, F
0BE5  1D03     BTFSS STATUS, 0x2
0BE6  2BDD     GOTO 0x3DD
15:            	return product;
0BE7  0825     MOVF dato, W
16:            }
0BE8  0008     RETURN
17:            
---  /opt/microchip/xc8/v1.31/sources/common/awmod.c  ---------------------------------------------------
1:             // integer signed unsigned modulus
2:             
3:             signed int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __awmod(signed int divisor, signed int dividend)
078C  01F5     CLRF Pin
084C  01A9     CLRF mth
7:             #else
8:             __awmod(signed int dividend, signed int divisor)
9:             #endif
10:            {
11:            	unsigned char	counter, sign;
12:            
13:            	sign = 0;
078C  01F5     CLRF Pin
084C  01A9     CLRF mth
14:            	if(dividend < 0) {
078D  1FF3     BTFSS counter, 0x7
078E  2F96     GOTO 0x796
084D  1FA7     BTFSS x, 0x7
084E  2856     GOTO 0x56
15:            		dividend = -dividend;
078F  09F2     COMF dividend, F
0790  09F3     COMF counter, F
0791  0AF2     INCF dividend, F
0792  1903     BTFSC STATUS, 0x2
0793  0AF3     INCF counter, F
084F  09A6     COMF y, F
0850  09A7     COMF x, F
0851  0AA6     INCF y, F
0852  1903     BTFSC STATUS, 0x2
0853  0AA7     INCF x, F
16:            		sign = 1;
0794  01F5     CLRF Pin
0795  0AF5     INCF Pin, F
0854  01A9     CLRF mth
0855  0AA9     INCF mth, F
17:            	}
18:            	if(divisor < 0)
0796  1FF1     BTFSS canal, 0x7
0797  2F9D     GOTO 0x79D
0856  1FA5     BTFSS dato, 0x7
0857  285D     GOTO 0x5D
19:            		divisor = -divisor;
0798  09F0     COMF tiempo, F
0799  09F1     COMF canal, F
079A  0AF0     INCF tiempo, F
079B  1903     BTFSC STATUS, 0x2
079C  0AF1     INCF canal, F
0858  09A4     COMF x, F
0859  09A5     COMF dato, F
085A  0AA4     INCF x, F
085B  1903     BTFSC STATUS, 0x2
085C  0AA5     INCF dato, F
20:            	if(divisor != 0) {
079D  0871     MOVF canal, W
079E  0470     IORWF tiempo, W
079F  1903     BTFSC STATUS, 0x2
07A0  2FBC     GOTO 0x7BC
085D  0825     MOVF dato, W
085E  0424     IORWF x, W
085F  1903     BTFSC STATUS, 0x2
0860  287C     GOTO 0x7C
21:            		counter = 1;
07A1  01F4     CLRF counter
0861  01A8     CLRF i
22:            		while(((unsigned int)divisor & 0x8000U) == 0) {
07A3  1BF1     BTFSC canal, 0x7
07A4  2FA9     GOTO 0x7A9
07A8  2FA2     GOTO 0x7A2
0863  1BA5     BTFSC dato, 0x7
0864  2869     GOTO 0x69
0868  2862     GOTO 0x62
23:            			divisor <<= 1;
07A2  0AF4     INCF counter, F
07A5  1003     BCF STATUS, 0x0
07A6  0DF0     RLF tiempo, F
07A7  0DF1     RLF canal, F
0862  0AA8     INCF i, F
0865  1003     BCF STATUS, 0x0
0866  0DA4     RLF x, F
0867  0DA5     RLF dato, F
24:            			counter++;
07A2  0AF4     INCF counter, F
0862  0AA8     INCF i, F
25:            		}
26:            		do {
27:            			if((unsigned int)divisor <= (unsigned int)dividend)
07A9  0871     MOVF canal, W
07AA  0273     SUBWF counter, W
07AB  1D03     BTFSS STATUS, 0x2
07AC  2FAF     GOTO 0x7AF
07AD  0870     MOVF tiempo, W
07AE  0272     SUBWF dividend, W
07AF  1C03     BTFSS STATUS, 0x0
07B0  2FB8     GOTO 0x7B8
0869  0825     MOVF dato, W
086A  0227     SUBWF x, W
086B  1D03     BTFSS STATUS, 0x2
086C  286F     GOTO 0x6F
086D  0824     MOVF x, W
086E  0226     SUBWF y, W
086F  1C03     BTFSS STATUS, 0x0
0870  2878     GOTO 0x78
28:            				dividend -= divisor;
07B1  0870     MOVF tiempo, W
07B2  02F2     SUBWF dividend, F
07B3  0871     MOVF canal, W
07B4  1C03     BTFSS STATUS, 0x0
07B5  03F3     DECF counter, F
07B6  02F3     SUBWF counter, F
0871  0824     MOVF x, W
0872  02A6     SUBWF y, F
0873  0825     MOVF dato, W
0874  1C03     BTFSS STATUS, 0x0
0875  03A7     DECF x, F
0876  02A7     SUBWF x, F
29:            			*(unsigned int *)&divisor >>= 1;
07B7  1003     BCF STATUS, 0x0
07B8  0CF1     RRF canal, F
07B9  0CF0     RRF tiempo, F
0877  1003     BCF STATUS, 0x0
0878  0CA5     RRF dato, F
0879  0CA4     RRF x, F
30:            		} while(--counter != 0);
07BA  0BF4     DECFSZ counter, F
07BB  2FA9     GOTO 0x7A9
087A  0BA8     DECFSZ i, F
087B  2869     GOTO 0x69
31:            	}
32:            	if(sign)
07BC  0875     MOVF Pin, W
07BD  1903     BTFSC STATUS, 0x2
07BE  2FC4     GOTO 0x7C4
087C  0829     MOVF mth, W
087D  1903     BTFSC STATUS, 0x2
087E  2884     GOTO 0x84
33:            		dividend = -dividend;
07BF  09F2     COMF dividend, F
07C0  09F3     COMF counter, F
07C1  0AF2     INCF dividend, F
07C2  1903     BTFSC STATUS, 0x2
07C3  0AF3     INCF counter, F
087F  09A6     COMF y, F
0880  09A7     COMF x, F
0881  0AA6     INCF y, F
0882  1903     BTFSC STATUS, 0x2
0883  0AA7     INCF x, F
34:            	return dividend;
07C4  0873     MOVF counter, W
07C5  00F1     MOVWF canal
07C6  0872     MOVF dividend, W
07C7  00F0     MOVWF tiempo
0884  0827     MOVF x, W
0885  00A5     MOVWF dato
0886  0826     MOVF y, W
0887  00A4     MOVWF x
35:            }
07C8  0008     RETURN
0888  0008     RETURN
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/pwm.c  --------------------------------
1:             #include <xc.h>
2:             #include <stdint.h>         /* For uint8_t definition */
3:             #include <stdbool.h>        /* For true/false definition */
4:             #include "system.h"
5:             #include "pwm.h"
6:             #include "user.h"
7:             /*The following steps should be taken when configuring
8:             the CCP module for PWM operation:
9:             1. Set the PWM period by writing to the PR2 register.
10:            2. Set the PWM duty cycle by writing to the
11:            CCPR1L register and CCP1CON<5:4> bits.
12:            3. Make the CCP1 pin an output by clearing the
13:            TRISC<2> bit.
14:            4. Set the TMR2 prescale value and enable Timer2
15:            by writing to T2CON.
16:            5. Configure the CCP1 module for PWM operation.*/
17:            #define FrecuenciaPWM 2440UL
18:            #define PeriodoPWM 1/FrecuenciaPWM
19:            #define PRESCALERTIMER2 16
20:            #define asignaPR2 _XTAL_FREQ/PRESCALERTIMER2/4*PeriodoPWM-1
21:            #define DUTY 256
22:            #define DutyCicle DUTY*PRESCALERTIMER2/_XTAL_FREQ
23:            void set_periodo_buzzer(void) {
24:                //PWM Period = [(PR2) + 1] * 4 * TOSC *(TMR2 Prescale Value)
25:                //PR2=PWM PERIOD/(4*TOSC*TMR2 Prescale Value)-1
26:                //para una frecuencia de __XTAL_FREQ/4=5Mhz
27:                PR2 = asignaPR2; //periodo;;//periodo; //asigno el periodo
1090  307F     MOVLW 0x7F
1091  1683     BSF STATUS, 0x5
1092  0092     MOVWF T2CON
28:                T2CONbits.TMR2ON = 1; //Habilito el timer2
1093  1283     BCF STATUS, 0x5
1094  1512     BSF T2CON, 0x2
29:                T2CONbits.T2CKPS = 2; //prescaler en 16
1095  0812     MOVF T2CON, W
1096  39FC     ANDLW 0xFC
1097  3802     IORLW 0x2
1098  0092     MOVWF T2CON
30:                // CCP1CONbits.CCP1M=0b1100; //Configuro el CCp1 como PWM
31:                RB2 = 0;
1099  1106     BCF PORTB, 0x2
32:                TRISC2 = 0; //pongo el pin RC2/PWM1 como salida
109A  1683     BSF STATUS, 0x5
109B  1107     BCF PORTC, 0x2
33:                #warning No olvidar que si el PWM_duty > PWM_period no queda bien definida la frecuencia
34:                set_duty(DUTY);
109C  1283     BCF STATUS, 0x5
35:            }
36:            
37:            /*/PWM Duty Cycle =(CCPR1L:CCP1CON<5:4>)*TOSC*(TMR2 Prescale Value)*/
38:            void set_duty(unsigned int duty) {
39:            
40:            #define PWM10Bits
41:                //pwm modo 10bits
42:            #ifdef PWM10Bits
43:                CCPR1L = duty >> 2;
10A1  0825     MOVF dato, W
10A2  00A7     MOVWF x
10A3  0824     MOVF x, W
10A4  00A6     MOVWF y
10A5  1003     BCF STATUS, 0x0
10A6  0CA7     RRF x, F
10A7  0CA6     RRF y, F
10A8  1003     BCF STATUS, 0x0
10A9  0CA7     RRF x, F
10AA  0CA6     RRF y, F
10AB  0826     MOVF y, W
10AC  0095     MOVWF CCPR1
44:            #endif
45:                CCP1CON = (CCP1CON & 0xCF) | ((duty << 4) & 0x30);
10AD  0824     MOVF x, W
10AE  00A6     MOVWF y
10AF  0E26     SWAPF y, W
10B0  39F0     ANDLW 0xF0
10B1  00A6     MOVWF y
10B2  3930     ANDLW 0x30
10B3  00A7     MOVWF x
10B4  0817     MOVF CCP1CON, W
10B5  39CF     ANDLW 0xCF
10B6  0427     IORWF x, W
10B7  0097     MOVWF CCP1CON
46:            
47:            
48:            
49:            }
10B8  0008     RETURN
50:            
51:            void buzzer_off(void) {
0FF7  30F0     MOVLW 0xF0
1FDC  30F0     MOVLW 0xF0
52:                //activapor=0;
53:                CCP1CONbits.CCP1M = 0; //desactiva pwm
0FF7  30F0     MOVLW 0xF0
0FF8  1283     BCF STATUS, 0x5
0FF9  0597     ANDWF CCP1CON, F
1FDC  30F0     MOVLW 0xF0
1FDD  1283     BCF STATUS, 0x5
1FDE  1303     BCF STATUS, 0x6
1FDF  0597     ANDWF CCP1CON, F
54:                PORTCbits.RC2 = 0; //pongo el pin de reloj en bajo
0FFA  1107     BCF PORTC, 0x2
1FE0  1107     BCF PORTC, 0x2
55:            
56:            }
0FFB  0008     RETURN
1FE1  0008     RETURN
57:            
58:            void buzzer_on(unsigned char tiempo) {//tiempo especifica en multiplos de 40ms cuanto tiempo est encendido el buzzer
0FE1  00F0     MOVWF tiempo
1FEA  1283     BCF STATUS, 0x5
1FEB  1303     BCF STATUS, 0x6
1FEC  00A4     MOVWF x
59:                activapwmpor = tiempo;
0FE2  00AB     MOVWF Data
1FED  1683     BSF STATUS, 0x5
1FEE  00AB     MOVWF Data
60:                CCP1CONbits.CCP1M = 0b1100; //activa pwm
0FE3  1283     BCF STATUS, 0x5
0FE4  0817     MOVF CCP1CON, W
0FE5  39F0     ANDLW 0xF0
0FE6  380C     IORLW 0xC
0FE7  0097     MOVWF CCP1CON
1FEF  1283     BCF STATUS, 0x5
1FF0  0817     MOVF CCP1CON, W
1FF1  39F0     ANDLW 0xF0
1FF2  380C     IORLW 0xC
1FF3  0097     MOVWF CCP1CON
61:            }
0FE8  0008     RETURN
1FF4  0008     RETURN
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/main.c  -------------------------------
1:             // Real Time Clock & NVRAM
2:             // Hardware isl1208 of Dallas Maxim
3:             // With interface I2C
4:             #ifndef __PICCPRO__
5:             #define __PICCPRO__
6:             #endif
7:             
8:             #if defined(__XC)
9:             #include <xc.h>         /* XC8 General Include File */
10:            #elif defined(HI_TECH_C)
11:            #include <htc.h>        /* HiTech General Include File */
12:            #endif
13:            #include <stdint.h>        /* For uint8_t definition */
14:            #include <stdbool.h>       /* For true/false definition */
15:            #include <stdio.h>
16:            #include "system.h"        /* System funct/params, like osc/peripheral config */
17:            #include "user.h"          /* User funct/params, such as InitApp */
18:            #include "Pulsadores.h"
19:            #include "pwm.h"
20:            #include "adcPic16.h"
21:            #include <string.h>
22:            #include "_isl1208.h"
23:            #include "HardI2C.h"
24:            #include "usart1.h"
25:            #include "LCDGeneric.h"
26:            
27:            #define USE_INTERRUPTS 1
28:            
29:            ///////////////////////////////////////////////////////////////////////////////
30:            
31:            void lee_y_transmite_date_and_time(void) {
32:                isl1208_get_date(&fecha.day, &fecha.month, &fecha.yr, &fecha.dow);
0934  306D     MOVLW 0x6D
0935  1283     BCF STATUS, 0x5
0936  00A9     MOVWF mth
0937  306E     MOVLW 0x6E
0938  00AA     MOVWF year
0939  306F     MOVLW 0x6F
093A  00AB     MOVWF Data
093B  306C     MOVLW 0x6C
093C  2231     CALL 0x231
093D  120A     BCF PCLATH, 0x4
093E  158A     BSF PCLATH, 0x3
33:                isl1208_get_time(&horarioactual.hrs, &horarioactual.min, &horarioactual.sec);
093F  30D3     MOVLW 0xD3
34:            }
35:            
36:            void main() {
37:                TMR1IE = 0; //   disable_interrupts(int_timer1);
10B9  1683     BSF STATUS, 0x5
10BA  100C     BCF PIR1, 0x0
38:                RCIE = 0; //    disable_interrupts(int_rda);
10BB  128C     BCF PIR1, 0x5
39:                RBIE = 0;
10BC  118B     BCF INTCON, 0x3
40:                INTE = 0; //disable_interrupts(int_ext);
10BD  120B     BCF INTCON, 0x4
41:                T0CS = 0; // TMR0 Clock Source Select bit: internal
10BE  1281     BCF TMR0, 0x5
42:                PSA = 0; //Prescaler is assigned to the Timer0 module
10BF  1181     BCF TMR0, 0x3
43:                OPTION_REGbits.PS = 0b101; //: Prescaler Rate Select bits 1/64
10C0  0801     MOVF TMR0, W
10C1  39F8     ANDLW 0xF8
10C2  3805     IORLW 0x5
10C3  0081     MOVWF TMR0
44:                //setup_timer_1(T1_INTERNAL | T1_DIV_BY_1);
45:                T1CON = 0; //deshabilito el Timer1
10C4  1283     BCF STATUS, 0x5
10C5  0190     CLRF T1CON
46:                //configura_USART();
47:                setup_i2c(I2C_MASTER);
10C6  3038     MOVLW 0x38
10C7  120A     BCF PCLATH, 0x4
10C8  158A     BSF PCLATH, 0x3
10C9  2003     CALL 0x3
10CA  160A     BSF PCLATH, 0x4
10CB  118A     BCF PCLATH, 0x3
48:            
49:                TRISB = 0b00111111; //Configuro las entradas de las teclas y la entrada del reloj
10CC  303F     MOVLW 0x3F
10CD  1683     BSF STATUS, 0x5
10CE  0086     MOVWF PORTB
50:                PORTB = 0;
10CF  1283     BCF STATUS, 0x5
10D0  0186     CLRF PORTB
51:                TRISC0 = 0; //Configuro el pin de activacion de la bomba como salida
10D1  1683     BSF STATUS, 0x5
10D2  1007     BCF PORTC, 0x0
52:                TRISD = 0x00;
10D3  0188     CLRF PORTD
53:                PORTD = 0;
10D4  1283     BCF STATUS, 0x5
10D5  0188     CLRF PORTD
54:                TRISE = 0b00000000;
10D6  1683     BSF STATUS, 0x5
10D7  0189     CLRF PORTE
55:                PORTE = 0;
10D8  1283     BCF STATUS, 0x5
10D9  0189     CLRF PORTE
56:            
57:                vInitLCD();
10DA  160A     BSF PCLATH, 0x4
10DB  118A     BCF PCLATH, 0x3
10DC  2254     CALL 0x254
10DD  160A     BSF PCLATH, 0x4
10DE  118A     BCF PCLATH, 0x3
58:                static char * cadena;
59:                set_periodo_buzzer(); //configuro el pwm para una frecuencia de 2.44khz
10DF  160A     BSF PCLATH, 0x4
10E0  118A     BCF PCLATH, 0x3
10E1  2090     CALL 0x90
10E2  160A     BSF PCLATH, 0x4
10E3  118A     BCF PCLATH, 0x3
60:                buzzer_on(3);
10E4  3003     MOVLW 0x3
10E5  160A     BSF PCLATH, 0x4
10E6  158A     BSF PCLATH, 0x3
10E7  27EA     CALL 0x7EA
10E8  160A     BSF PCLATH, 0x4
10E9  118A     BCF PCLATH, 0x3
61:                __delay_ms(200);
10EA  3006     MOVLW 0x6
10EB  1683     BSF STATUS, 0x5
10EC  00DD     MOVWF 0x5D
10ED  3013     MOVLW 0x13
10EE  00DC     MOVWF f1
10EF  30B1     MOVLW 0xB1
10F0  00DB     MOVWF 0x5B
10F1  0BDB     DECFSZ 0x5B, F
10F2  28F1     GOTO 0xF1
10F3  0BDC     DECFSZ f1, F
10F4  28F1     GOTO 0xF1
10F5  0BDD     DECFSZ 0x5D, F
10F6  28F1     GOTO 0xF1
10F7  28F8     GOTO 0xF8
62:                buzzer_off();
10F8  160A     BSF PCLATH, 0x4
10F9  158A     BSF PCLATH, 0x3
10FA  27DC     CALL 0x7DC
10FB  160A     BSF PCLATH, 0x4
10FC  118A     BCF PCLATH, 0x3
63:                __delay_ms(200);
10FD  3006     MOVLW 0x6
10FE  1683     BSF STATUS, 0x5
10FF  00DD     MOVWF 0x5D
1100  3013     MOVLW 0x13
1101  00DC     MOVWF f1
1102  30B1     MOVLW 0xB1
1103  00DB     MOVWF 0x5B
1104  0BDB     DECFSZ 0x5B, F
1105  2904     GOTO 0x104
1106  0BDC     DECFSZ f1, F
1107  2904     GOTO 0x104
1108  0BDD     DECFSZ 0x5D, F
1109  2904     GOTO 0x104
110A  290B     GOTO 0x10B
64:                buzzer_on(3);
110B  3003     MOVLW 0x3
110C  160A     BSF PCLATH, 0x4
110D  158A     BSF PCLATH, 0x3
110E  27EA     CALL 0x7EA
110F  160A     BSF PCLATH, 0x4
1110  118A     BCF PCLATH, 0x3
65:                __delay_ms(200);
1111  3006     MOVLW 0x6
1112  1683     BSF STATUS, 0x5
1113  00DD     MOVWF 0x5D
1114  3013     MOVLW 0x13
1115  00DC     MOVWF f1
1116  30B1     MOVLW 0xB1
1117  00DB     MOVWF 0x5B
1118  0BDB     DECFSZ 0x5B, F
1119  2918     GOTO 0x118
111A  0BDC     DECFSZ f1, F
111B  2918     GOTO 0x118
111C  0BDD     DECFSZ 0x5D, F
111D  2918     GOTO 0x118
111E  291F     GOTO 0x11F
66:                buzzer_off();
111F  160A     BSF PCLATH, 0x4
1120  158A     BSF PCLATH, 0x3
1121  27DC     CALL 0x7DC
1122  160A     BSF PCLATH, 0x4
1123  118A     BCF PCLATH, 0x3
67:            
68:                setADCChannel(MIDECORRIENTE);
1124  3000     MOVLW 0x0
1125  160A     BSF PCLATH, 0x4
1126  158A     BSF PCLATH, 0x3
1127  27F5     CALL 0x7F5
1128  160A     BSF PCLATH, 0x4
1129  118A     BCF PCLATH, 0x3
69:                __delay_us(20);
112A  3021     MOVLW 0x21
112B  1683     BSF STATUS, 0x5
112C  00DB     MOVWF 0x5B
112D  0BDB     DECFSZ 0x5B, F
112E  292D     GOTO 0x12D
70:                openADC();
112F  160A     BSF PCLATH, 0x4
1130  118A     BCF PCLATH, 0x3
1131  2041     CALL 0x41
1132  160A     BSF PCLATH, 0x4
1133  118A     BCF PCLATH, 0x3
71:            
72:                // <editor-fold defaultstate="collapsed" desc="Lectura de datos guardados en EEPROM">
73:                periodoencendido = eeprom_read(0);
1134  3000     MOVLW 0x0
1135  160A     BSF PCLATH, 0x4
1136  118A     BCF PCLATH, 0x3
1137  2056     CALL 0x56
1138  160A     BSF PCLATH, 0x4
1139  118A     BCF PCLATH, 0x3
113A  1683     BSF STATUS, 0x5
113B  1303     BCF STATUS, 0x6
113C  00C5     MOVWF f1
74:                if (periodoencendido > TIEMPOMAXIMOPERIODO) periodoencendido = 0;
113D  3007     MOVLW 0x7
113E  0245     SUBWF f1, W
113F  1803     BTFSC STATUS, 0x0
1140  01C5     CLRF f1
75:                tiempoencendido = eeprom_read(1);
1141  3001     MOVLW 0x1
1142  160A     BSF PCLATH, 0x4
1143  118A     BCF PCLATH, 0x3
1144  2056     CALL 0x56
1145  160A     BSF PCLATH, 0x4
1146  118A     BCF PCLATH, 0x3
1147  1683     BSF STATUS, 0x5
1148  1303     BCF STATUS, 0x6
1149  00C9     MOVWF f2
76:                if (tiempoencendido > TIEMPOMAXIMOENCENDIDO) tiempoencendido = 15;
114A  303D     MOVLW 0x3D
114B  0249     SUBWF f2, W
114C  1C03     BTFSS STATUS, 0x0
114D  2950     GOTO 0x150
114E  300F     MOVLW 0xF
114F  00C9     MOVWF f2
77:                usa_falla_de_corriente = eeprom_read(2);
1150  3002     MOVLW 0x2
1151  160A     BSF PCLATH, 0x4
1152  118A     BCF PCLATH, 0x3
1153  2056     CALL 0x56
1154  160A     BSF PCLATH, 0x4
1155  118A     BCF PCLATH, 0x3
1156  1683     BSF STATUS, 0x5
1157  1303     BCF STATUS, 0x6
1158  00DA     MOVWF 0x5A
78:                if (usa_falla_de_corriente > 1) usa_falla_de_corriente = 1;
1159  3002     MOVLW 0x2
115A  025A     SUBWF 0x5A, W
115B  1C03     BTFSS STATUS, 0x0
115C  295F     GOTO 0x15F
115D  01DA     CLRF 0x5A
115E  0ADA     INCF 0x5A, F
79:                tiempofalla = eeprom_read(3);
115F  3003     MOVLW 0x3
1160  160A     BSF PCLATH, 0x4
1161  118A     BCF PCLATH, 0x3
1162  2056     CALL 0x56
1163  160A     BSF PCLATH, 0x4
1164  118A     BCF PCLATH, 0x3
1165  1683     BSF STATUS, 0x5
1166  1303     BCF STATUS, 0x6
1167  00CA     MOVWF 0x4A
80:                if (tiempofalla > TIEMPOMAXIMOFALLA)tiempofalla = 5;
1168  300B     MOVLW 0xB
1169  024A     SUBWF 0x4A, W
116A  1C03     BTFSS STATUS, 0x0
116B  296E     GOTO 0x16E
116C  3005     MOVLW 0x5
116D  00CA     MOVWF 0x4A
81:                //si se produjo un error en la EEPROM, asigno valores predefinidos
82:                // </editor-fold>
83:            
84:                // <editor-fold defaultstate="collapsed" desc="Lectura del estado actual del RTC">
85:            
86:                if (ISL1208_ready()) {
116E  120A     BCF PCLATH, 0x4
116F  158A     BSF PCLATH, 0x3
1170  2146     CALL 0x146
1171  160A     BSF PCLATH, 0x4
1172  118A     BCF PCLATH, 0x3
1173  3A00     XORLW 0x0
1174  1903     BTFSC STATUS, 0x2
1175  297A     GOTO 0x17A
87:                    sprintf(cadenaamostrar, "RTC OK");
1176  3046     MOVLW 0x46
1177  00B0     MOVWF f
1178  3099     MOVLW 0x99
1179  297D     GOTO 0x17D
88:            
89:                } else {
90:                    sprintf(cadenaamostrar, "RTC ERRO");
117A  3019     MOVLW 0x19
117B  00B0     MOVWF f
117C  3099     MOVLW 0x99
117D  00B1     MOVWF 0x31
117E  30A6     MOVLW 0xA6
117F  160A     BSF PCLATH, 0x4
1180  118A     BCF PCLATH, 0x3
1181  236C     CALL 0x36C
1182  160A     BSF PCLATH, 0x4
1183  118A     BCF PCLATH, 0x3
91:                };
92:                tiempoapagadolcd = 15; //enciende el backlight del lcd por 15 segundos
1184  300F     MOVLW 0xF
1185  1683     BSF STATUS, 0x5
1186  00C8     MOVWF 0x48
93:                vBackLightLCD_On();
1187  160A     BSF PCLATH, 0x4
1188  118A     BCF PCLATH, 0x3
1189  203D     CALL 0x3D
118A  160A     BSF PCLATH, 0x4
118B  118A     BCF PCLATH, 0x3
94:            
95:                vGotoxyLCD(1, 1);
118C  3001     MOVLW 0x1
118D  01A6     CLRF y
118E  0AA6     INCF y, F
118F  160A     BSF PCLATH, 0x4
1190  118A     BCF PCLATH, 0x3
1191  2209     CALL 0x209
1192  160A     BSF PCLATH, 0x4
1193  118A     BCF PCLATH, 0x3
96:                cadena = cadenaamostrar;
1194  30A6     MOVLW 0xA6
1195  1683     BSF STATUS, 0x5
1196  00CD     MOVWF 0x4D
97:                while (*cadena != '\0')
1197  084D     MOVF 0x4D, W
1198  0084     MOVWF FSR
1199  1783     BSF STATUS, 0x7
119A  0880     MOVF INDF, F
119B  1903     BTFSC STATUS, 0x2
119C  29A9     GOTO 0x1A9
11A8  2997     GOTO 0x197
98:                    vLCD_Putc(*cadena++);
119D  084D     MOVF 0x4D, W
119E  0084     MOVWF FSR
119F  0800     MOVF INDF, W
11A0  160A     BSF PCLATH, 0x4
11A1  118A     BCF PCLATH, 0x3
11A2  222C     CALL 0x22C
11A3  160A     BSF PCLATH, 0x4
11A4  118A     BCF PCLATH, 0x3
11A5  1683     BSF STATUS, 0x5
11A6  1303     BCF STATUS, 0x6
11A7  0ACD     INCF 0x4D, F
99:            
100:               __delay_ms(500);
11A9  300D     MOVLW 0xD
11AA  00DD     MOVWF 0x5D
11AB  30AF     MOVLW 0xAF
11AC  00DC     MOVWF f1
11AD  30C1     MOVLW 0xC1
11AE  00DB     MOVWF 0x5B
11AF  0BDB     DECFSZ 0x5B, F
11B0  29AF     GOTO 0x1AF
11B1  0BDC     DECFSZ f1, F
11B2  29AF     GOTO 0x1AF
11B3  0BDD     DECFSZ 0x5D, F
11B4  29AF     GOTO 0x1AF
11B5  0000     NOP
101:           
102:               fecha.day = 1;
11B6  1283     BCF STATUS, 0x5
11B7  1303     BCF STATUS, 0x6
11B9  01EC     CLRF fecha
11BA  0AEC     INCF fecha, F
103:               fecha.month = 1;
11BB  01ED     CLRF 0x6D
11BC  0AED     INCF 0x6D, F
104:               fecha.yr = 15;
11B8  300F     MOVLW 0xF
11BD  00EE     MOVWF 0x6E
105:               fecha.dow = 4;
11BE  3004     MOVLW 0x4
11BF  00EF     MOVWF 0x6F
106:           
107:               isl1208SR.Valor = 0x00;
11C0  1683     BSF STATUS, 0x5
11C1  01D9     CLRF 0x59
108:               isl1208SR.Valor = ISL1208_Read_status();
11C2  120A     BCF PCLATH, 0x4
11C3  158A     BSF PCLATH, 0x3
11C4  2182     CALL 0x182
11C5  160A     BSF PCLATH, 0x4
11C6  118A     BCF PCLATH, 0x3
11C7  1683     BSF STATUS, 0x5
11C8  00D9     MOVWF 0x59
109:               if (isl1208SR.RTCF) {//Si se reseteo el RTC, envio directamente a configurar la hora
11C9  1C59     BTFSS 0x59, 0x0
11CA  29D3     GOTO 0x1D3
110:                   isl1208_init();
11CB  120A     BCF PCLATH, 0x4
11CC  158A     BSF PCLATH, 0x3
11CD  212C     CALL 0x12C
11CE  160A     BSF PCLATH, 0x4
11CF  118A     BCF PCLATH, 0x3
111:                   menuactual = SUBMENU_CONFIGURAHORA;
11D0  3003     MOVLW 0x3
11D1  00C4     MOVWF sp
112:           
113:               } else {
11D2  29FA     GOTO 0x1FA
114:           
115:                   lee_y_transmite_date_and_time();
11D3  120A     BCF PCLATH, 0x4
11D4  158A     BSF PCLATH, 0x3
11D5  2134     CALL 0x134
11D6  160A     BSF PCLATH, 0x4
11D7  118A     BCF PCLATH, 0x3
116:                   isl1208_get_time_enc(&horarioenc.hrs, &horarioenc.min, &horarioenc.sec);
11D8  30D6     MOVLW 0xD6
11D9  1283     BCF STATUS, 0x5
11DA  00A9     MOVWF mth
11DB  30D5     MOVLW 0xD5
11DC  00AA     MOVWF year
11DD  30D7     MOVLW 0xD7
11DE  120A     BCF PCLATH, 0x4
11DF  158A     BSF PCLATH, 0x3
11E0  21F8     CALL 0x1F8
11E1  160A     BSF PCLATH, 0x4
11E2  118A     BCF PCLATH, 0x3
117:                   isl1208_get_dow_enc(&fechaenc.dow);
11E3  30D1     MOVLW 0xD1
11E4  120A     BCF PCLATH, 0x4
11E5  158A     BSF PCLATH, 0x3
11E6  219D     CALL 0x19D
11E7  160A     BSF PCLATH, 0x4
11E8  118A     BCF PCLATH, 0x3
118:           
119:                   if (isl1208SR.ALM) {
11E9  1D59     BTFSS 0x59, 0x2
11EA  29FA     GOTO 0x1FA
120:                       //Si se activo la alarma cuando estaba apagado el sistema se borra esa bandera
121:                       isl1208SR.ALM = 0; //reseteo la indicacion de alarma del RTC
11EC  1159     BCF 0x59, 0x2
122:                       ISL1208_Set_status(&isl1208SR.Valor);
11EB  30D9     MOVLW 0xD9
11ED  120A     BCF PCLATH, 0x4
11EE  158A     BSF PCLATH, 0x3
11EF  216C     CALL 0x16C
11F0  160A     BSF PCLATH, 0x4
11F1  118A     BCF PCLATH, 0x3
123:                       //TODO (implementado no probado )ver si transcurri el periodoencendido, para activar la bomba cuando corresponda
124:                       //Si se activo la alarma, lo que hago es encender la bomba a la hora grabada,en el mismo dia si la hora actual es menor o al da siguiente si la hora actual es mayor, por nica vez
125:                       //desactivando la alarma por dow
126:                       isl1208_set_dow_enc(0x00, 0);
11F2  1283     BCF STATUS, 0x5
11F3  3000     MOVLW 0x0
11F4  01AB     CLRF Data
11F5  120A     BCF PCLATH, 0x4
11F6  158A     BSF PCLATH, 0x3
11F7  2275     CALL 0x275
11F8  160A     BSF PCLATH, 0x4
11F9  118A     BCF PCLATH, 0x3
127:                       //
128:                   }
129:               }
130:               // </editor-fold>
131:           
132:               // <editor-fold defaultstate="collapsed" desc="Habilita Interrupciones">
133:           
134:               interruptADC_on();
11FA  120A     BCF PCLATH, 0x4
11FB  158A     BSF PCLATH, 0x3
11FC  2001     CALL 0x1
135:               INTEDG = 0;
11FD  1301     BCF TMR0, 0x6
136:               INTE = 1; // enable_interrupts(int_ext2);
11FE  160B     BSF INTCON, 0x4
137:               TMR0IE = 1;
11FF  168B     BSF INTCON, 0x5
138:               ADIF = 0;
1200  1283     BCF STATUS, 0x5
1201  130C     BCF PIR1, 0x6
139:               INTF = 0; // borro las banderas de interrupcion
1202  108B     BCF INTCON, 0x1
140:               TMR0IF = 0;
1203  110B     BCF INTCON, 0x2
141:               PEIE = 1;
1204  170B     BSF INTCON, 0x6
142:               ei(); //enable_interrupts(global);
1205  178B     BSF INTCON, 0x7
1206  120A     BCF PCLATH, 0x4
1207  118A     BCF PCLATH, 0x3
1208  2B61     GOTO 0x361
143:               // </editor-fold>
144:           
145:               while (1) {
146:                   // <editor-fold defaultstate="collapsed" desc="Inicia Procesa los men">
147:           
148:                   ////////////////////////////////////////
149:                   switch (menuactual) {
0361  1683     BSF STATUS, 0x5
0362  1303     BCF STATUS, 0x6
0363  0844     MOVF sp, W
0364  0084     MOVWF FSR
0365  300E     MOVLW 0xE
0366  0204     SUBWF FSR, W
0367  1803     BTFSC STATUS, 0x0
0368  2B70     GOTO 0x370
0369  3007     MOVLW 0x7
036A  008A     MOVWF PCLATH
036B  1003     BCF STATUS, 0x0
036C  0D04     RLF FSR, W
036D  0704     ADDWF FSR, W
036E  3EC9     ADDLW 0xC9
036F  0082     MOVWF PCL
07C9  120A     BCF PCLATH, 0x4
07CA  118A     BCF PCLATH, 0x3
07CB  2839     GOTO 0x39
07CC  120A     BCF PCLATH, 0x4
07CD  118A     BCF PCLATH, 0x3
07CE  2876     GOTO 0x76
07CF  120A     BCF PCLATH, 0x4
07D0  118A     BCF PCLATH, 0x3
07D1  2A91     GOTO 0x291
07D2  120A     BCF PCLATH, 0x4
07D3  118A     BCF PCLATH, 0x3
07D4  28CD     GOTO 0xCD
07D5  120A     BCF PCLATH, 0x4
07D6  118A     BCF PCLATH, 0x3
07D7  28F3     GOTO 0xF3
07D8  120A     BCF PCLATH, 0x4
07D9  118A     BCF PCLATH, 0x3
07DA  2924     GOTO 0x124
07DB  120A     BCF PCLATH, 0x4
07DC  118A     BCF PCLATH, 0x3
07DD  294A     GOTO 0x14A
07DE  120A     BCF PCLATH, 0x4
07DF  118A     BCF PCLATH, 0x3
07E0  2962     GOTO 0x162
07E1  120A     BCF PCLATH, 0x4
07E2  118A     BCF PCLATH, 0x3
07E3  2996     GOTO 0x196
07E4  120A     BCF PCLATH, 0x4
07E5  118A     BCF PCLATH, 0x3
07E6  29B0     GOTO 0x1B0
07E7  120A     BCF PCLATH, 0x4
07E8  118A     BCF PCLATH, 0x3
07E9  2A0A     GOTO 0x20A
07EA  120A     BCF PCLATH, 0x4
07EB  118A     BCF PCLATH, 0x3
07EC  29E5     GOTO 0x1E5
07ED  120A     BCF PCLATH, 0x4
07EE  118A     BCF PCLATH, 0x3
07EF  2A36     GOTO 0x236
07F0  120A     BCF PCLATH, 0x4
07F1  118A     BCF PCLATH, 0x3
07F2  2A65     GOTO 0x265
150:                       case MENU_INICIAL:
151:                       {
152:                           if (reseteafallas == FALLARESETEADA) {
0039  0B66     DECFSZ 0x66, W
003A  2848     GOTO 0x48
153:                               ultimafalla = NOHUBOFALLA;
003C  01CC     CLRF 0x4C
154:                               sprintf(cadenaamostrar, cadena_esp);
003B  301C     MOVLW 0x1C
003D  1283     BCF STATUS, 0x5
003E  00B0     MOVWF f
003F  3098     MOVLW 0x98
0040  00B1     MOVWF 0x31
0041  30A6     MOVLW 0xA6
0042  160A     BSF PCLATH, 0x4
0043  118A     BCF PCLATH, 0x3
0044  236C     CALL 0x36C
0045  120A     BCF PCLATH, 0x4
0046  118A     BCF PCLATH, 0x3
155:                           } else {
0047  2B70     GOTO 0x370
156:                               if (ultimafalla == HUBOFALLAVOLTAJE) {
0048  084C     MOVF 0x4C, W
0049  3A02     XORLW 0x2
004A  1D03     BTFSS STATUS, 0x2
004B  2858     GOTO 0x58
157:                                   sprintf(cadenaamostrar, "Falla: V");
004C  3022     MOVLW 0x22
004D  1283     BCF STATUS, 0x5
004E  00B0     MOVWF f
004F  3099     MOVLW 0x99
0050  00B1     MOVWF 0x31
0051  30A6     MOVLW 0xA6
0052  160A     BSF PCLATH, 0x4
0053  118A     BCF PCLATH, 0x3
0054  236C     CALL 0x36C
0055  120A     BCF PCLATH, 0x4
0056  118A     BCF PCLATH, 0x3
158:                               } else if (ultimafalla == HUBOFALLACORRIENTE) {
0057  2B70     GOTO 0x370
0058  0B4C     DECFSZ 0x4C, W
0059  2866     GOTO 0x66
159:                                   sprintf(cadenaamostrar, "Falla: C");
005A  30EC     MOVLW 0xEC
005B  1283     BCF STATUS, 0x5
005C  00B0     MOVWF f
005D  3098     MOVLW 0x98
005E  00B1     MOVWF 0x31
005F  30A6     MOVLW 0xA6
0060  160A     BSF PCLATH, 0x4
0061  118A     BCF PCLATH, 0x3
0062  236C     CALL 0x36C
0063  120A     BCF PCLATH, 0x4
0064  118A     BCF PCLATH, 0x3
160:                               } else if (ultimafalla == HUBOFALLANIVEL) {
0065  2B70     GOTO 0x370
0066  084C     MOVF 0x4C, W
0067  3A03     XORLW 0x3
0068  1D03     BTFSS STATUS, 0x2
0069  2B70     GOTO 0x370
161:                                   sprintf(cadenaamostrar, "Falla: N");
006A  3007     MOVLW 0x7
006B  1283     BCF STATUS, 0x5
006C  00B0     MOVWF f
006D  3099     MOVLW 0x99
006E  00B1     MOVWF 0x31
006F  30A6     MOVLW 0xA6
0070  160A     BSF PCLATH, 0x4
0071  118A     BCF PCLATH, 0x3
0072  236C     CALL 0x36C
0073  120A     BCF PCLATH, 0x4
0074  118A     BCF PCLATH, 0x3
0075  2B70     GOTO 0x370
162:                               }
163:                           }
164:           
165:                           break;
166:                       }
167:                       case MENU_MUESTRAHORA_FECHA:
168:                       {
169:                           horario = &horarioactual;
0076  30D2     MOVLW 0xD2
0077  00FD     MOVWF horario
170:                           //Se actualiza lo que se muestra en el display, solamente cuando hay cambios en lo que mostrar
171:           
172:                           if (flanco) {
0078  087C     MOVF flanco, W
0079  1903     BTFSC STATUS, 0x2
007A  28A4     GOTO 0xA4
173:                               sprintf(cadenaamostrar, "%02d:%02d   ", horarioactual.hrs, horarioactual.min);
007B  3041     MOVLW 0x41
007C  1283     BCF STATUS, 0x5
007D  00B0     MOVWF f
007E  3098     MOVLW 0x98
007F  00B1     MOVWF 0x31
0080  1683     BSF STATUS, 0x5
0081  0854     MOVF 0x54, W
0082  1283     BCF STATUS, 0x5
0083  00B2     MOVWF f2
0084  01B3     CLRF 0x33
0085  1683     BSF STATUS, 0x5
0086  0853     MOVF 0x53, W
0087  1283     BCF STATUS, 0x5
0088  00B4     MOVWF 0x34
0089  30A6     MOVLW 0xA6
008A  01B5     CLRF 0x35
008B  160A     BSF PCLATH, 0x4
008C  118A     BCF PCLATH, 0x3
008D  236C     CALL 0x36C
008E  120A     BCF PCLATH, 0x4
008F  118A     BCF PCLATH, 0x3
174:                               sprintf(cadenaamostrar2, "%02d/%02d/%02d", fecha.day, fecha.month, fecha.yr);
0090  3025     MOVLW 0x25
0091  00B0     MOVWF f
0092  3098     MOVLW 0x98
0093  00B1     MOVWF 0x31
0094  086C     MOVF fecha, W
0095  00B2     MOVWF f2
0096  01B3     CLRF 0x33
0097  086D     MOVF 0x6D, W
0098  00B4     MOVWF 0x34
0099  01B5     CLRF 0x35
009A  086E     MOVF 0x6E, W
009B  00B6     MOVWF 0x36
009C  30AF     MOVLW 0xAF
009D  01B7     CLRF 0x37
009E  160A     BSF PCLATH, 0x4
009F  118A     BCF PCLATH, 0x3
00A0  236C     CALL 0x36C
00A1  120A     BCF PCLATH, 0x4
00A2  118A     BCF PCLATH, 0x3
175:                           } else {
00A3  2B70     GOTO 0x370
176:                               sprintf(cadenaamostrar, "%02d %02d   ", horarioactual.hrs, horarioactual.min);
00A4  3034     MOVLW 0x34
00A5  1283     BCF STATUS, 0x5
00A6  00B0     MOVWF f
00A7  3098     MOVLW 0x98
00A8  00B1     MOVWF 0x31
00A9  1683     BSF STATUS, 0x5
00AA  0854     MOVF 0x54, W
00AB  1283     BCF STATUS, 0x5
00AC  00B2     MOVWF f2
00AD  01B3     CLRF 0x33
00AE  1683     BSF STATUS, 0x5
00AF  0853     MOVF 0x53, W
00B0  1283     BCF STATUS, 0x5
00B1  00B4     MOVWF 0x34
00B2  30A6     MOVLW 0xA6
00B3  01B5     CLRF 0x35
00B4  160A     BSF PCLATH, 0x4
00B5  118A     BCF PCLATH, 0x3
00B6  236C     CALL 0x36C
00B7  120A     BCF PCLATH, 0x4
00B8  118A     BCF PCLATH, 0x3
177:                               sprintf(cadenaamostrar2, "%02d/%02d/%02d", fecha.day, fecha.month, fecha.yr);
00B9  3025     MOVLW 0x25
00BA  00B0     MOVWF f
00BB  3098     MOVLW 0x98
00BC  00B1     MOVWF 0x31
00BD  086C     MOVF fecha, W
00BE  00B2     MOVWF f2
00BF  01B3     CLRF 0x33
00C0  086D     MOVF 0x6D, W
00C1  00B4     MOVWF 0x34
00C2  01B5     CLRF 0x35
00C3  086E     MOVF 0x6E, W
00C4  00B6     MOVWF 0x36
00C5  30AF     MOVLW 0xAF
00C6  01B7     CLRF 0x37
00C7  160A     BSF PCLATH, 0x4
00C8  118A     BCF PCLATH, 0x3
00C9  236C     CALL 0x36C
00CA  120A     BCF PCLATH, 0x4
00CB  118A     BCF PCLATH, 0x3
00CC  2B70     GOTO 0x370
178:                           }
179:                           break;
180:                       }
181:           
182:                       case SUBMENU_CONFIGURAHORA:
183:                       {
184:                           modificafecha = HORA;
00CD  30D2     MOVLW 0xD2
00CE  01E5     CLRF 0x65
185:                           horario = &horarioactual;
00CD  30D2     MOVLW 0xD2
00CF  00FD     MOVWF horario
186:                           if (flanco || haycambio) {
00D0  08FC     MOVF flanco, F
00D1  1903     BTFSC STATUS, 0x2
00D2  0841     MOVF _val, W
00D4  1D03     BTFSS STATUS, 0x2
00D5  28FD     GOTO 0xFD
187:                               sprintf(cadenaamostrar, "SET HORA");
188:                               sprintf(cadenaamostrar2, "%02d:%02d   ", horarioactual.hrs, horarioactual.min);
189:                           } else {
190:                               sprintf(cadenaamostrar, "SET HORA");
00D3  30E3     MOVLW 0xE3
00D6  1283     BCF STATUS, 0x5
00D7  00B0     MOVWF f
00D8  3098     MOVLW 0x98
00D9  00B1     MOVWF 0x31
00DA  30A6     MOVLW 0xA6
00DB  160A     BSF PCLATH, 0x4
00DC  118A     BCF PCLATH, 0x3
00DD  236C     CALL 0x36C
00DE  120A     BCF PCLATH, 0x4
00DF  118A     BCF PCLATH, 0x3
191:                               sprintf(cadenaamostrar2, "  :%02d   ", horarioactual.min);
00E0  308B     MOVLW 0x8B
00E1  00B0     MOVWF f
00E2  3098     MOVLW 0x98
00E3  00B1     MOVWF 0x31
00E4  1683     BSF STATUS, 0x5
00E5  0853     MOVF 0x53, W
00E6  1283     BCF STATUS, 0x5
00E7  00B2     MOVWF f2
00E8  30AF     MOVLW 0xAF
00E9  01B3     CLRF 0x33
00EA  160A     BSF PCLATH, 0x4
00EB  118A     BCF PCLATH, 0x3
00EC  236C     CALL 0x36C
00ED  120A     BCF PCLATH, 0x4
00EE  118A     BCF PCLATH, 0x3
192:                           }
193:                           bandera_graba_hora = 1;
00EF  1683     BSF STATUS, 0x5
00F0  01B0     CLRF f
00F1  0AB0     INCF f, F
194:                           break;
00F2  2B70     GOTO 0x370
195:                       }
196:                       case SUBMENU_CONFIGURAMINUTOS:
00F3  30D2     MOVLW 0xD2
197:                       {
198:                           modificafecha = MINUTOS;
00F4  01E5     CLRF 0x65
00F5  0AE5     INCF 0x65, F
199:                           horario = &horarioactual;
00F3  30D2     MOVLW 0xD2
00F6  00FD     MOVWF horario
200:                           if (flanco || haycambio) {
00F7  08FC     MOVF flanco, F
00F8  1903     BTFSC STATUS, 0x2
00F9  0841     MOVF _val, W
00FB  1903     BTFSC STATUS, 0x2
00FC  2913     GOTO 0x113
201:                               sprintf(cadenaamostrar, "SET HORA");
00FA  30E3     MOVLW 0xE3
00FD  1283     BCF STATUS, 0x5
00FE  00B0     MOVWF f
00FF  3098     MOVLW 0x98
0100  00B1     MOVWF 0x31
0101  30A6     MOVLW 0xA6
0102  160A     BSF PCLATH, 0x4
0103  118A     BCF PCLATH, 0x3
0104  236C     CALL 0x36C
0105  120A     BCF PCLATH, 0x4
0106  118A     BCF PCLATH, 0x3
202:                               sprintf(cadenaamostrar2, "%02d:%02d   ", horarioactual.hrs, horarioactual.min);
0107  3041     MOVLW 0x41
0108  00B0     MOVWF f
0109  3098     MOVLW 0x98
010A  00B1     MOVWF 0x31
010B  1683     BSF STATUS, 0x5
010C  0854     MOVF 0x54, W
010D  1283     BCF STATUS, 0x5
010E  00B2     MOVWF f2
010F  01B3     CLRF 0x33
0110  1683     BSF STATUS, 0x5
0111  0853     MOVF 0x53, W
0112  29CF     GOTO 0x1CF
203:                           } else {
204:                               sprintf(cadenaamostrar, "SET HORA");
0113  1283     BCF STATUS, 0x5
0114  00B0     MOVWF f
0115  3098     MOVLW 0x98
0116  00B1     MOVWF 0x31
0117  30A6     MOVLW 0xA6
0118  160A     BSF PCLATH, 0x4
0119  118A     BCF PCLATH, 0x3
011A  236C     CALL 0x36C
011B  120A     BCF PCLATH, 0x4
011C  118A     BCF PCLATH, 0x3
205:                               sprintf(cadenaamostrar2, "%02d:     ", horarioactual.hrs);
011D  3075     MOVLW 0x75
011E  00B0     MOVWF f
011F  3098     MOVLW 0x98
0120  00B1     MOVWF 0x31
0121  1683     BSF STATUS, 0x5
0122  0854     MOVF 0x54, W
0123  28E6     GOTO 0xE6
206:                           }
207:                           bandera_graba_hora = 1;
208:                           break;
209:                       }
210:                       case SUBMENU_CONFIGURADIA:
211:                       {
212:                           modificafecha = DIA;
0124  3002     MOVLW 0x2
0125  00E5     MOVWF 0x65
213:           
214:                           if (flanco || haycambio) {
0126  08FC     MOVF flanco, F
0127  1903     BTFSC STATUS, 0x2
0128  0841     MOVF _val, W
012A  1D03     BTFSS STATUS, 0x2
012B  296A     GOTO 0x16A
215:                               sprintf(cadenaamostrar, "SET FECH");
216:                               sprintf(cadenaamostrar2, "%02d/%02d/%02d", fecha.day, fecha.month, fecha.yr);
217:                           } else {
218:                               sprintf(cadenaamostrar, "SET FECH");
0129  30F5     MOVLW 0xF5
012C  1283     BCF STATUS, 0x5
012D  00B0     MOVWF f
012E  3098     MOVLW 0x98
012F  00B1     MOVWF 0x31
0130  30A6     MOVLW 0xA6
0131  160A     BSF PCLATH, 0x4
0132  118A     BCF PCLATH, 0x3
0133  236C     CALL 0x36C
0134  120A     BCF PCLATH, 0x4
0135  118A     BCF PCLATH, 0x3
219:                               sprintf(cadenaamostrar2, "  /%02d/%02d", fecha.month, fecha.yr);
0136  3068     MOVLW 0x68
0137  00B0     MOVWF f
0138  3098     MOVLW 0x98
0139  00B1     MOVWF 0x31
013A  086D     MOVF 0x6D, W
013B  00B2     MOVWF f2
013C  01B3     CLRF 0x33
013D  086E     MOVF 0x6E, W
013E  00B4     MOVWF 0x34
013F  30AF     MOVLW 0xAF
0140  01B5     CLRF 0x35
0141  160A     BSF PCLATH, 0x4
0142  118A     BCF PCLATH, 0x3
0143  236C     CALL 0x36C
0144  120A     BCF PCLATH, 0x4
0145  118A     BCF PCLATH, 0x3
220:                           }
221:                           bandera_graba_fecha = 1;
0146  1683     BSF STATUS, 0x5
0147  01AE     CLRF day
0148  0AAE     INCF day, F
222:                           break;
0149  2B70     GOTO 0x370
223:                       }
224:                       case SUBMENU_CONFIGURAMES:
225:                       {
226:                           modificafecha = MES;
014A  3003     MOVLW 0x3
014B  00E5     MOVWF 0x65
227:           
228:                           if (flanco || haycambio) {
014C  08FC     MOVF flanco, F
014D  1903     BTFSC STATUS, 0x2
014E  0841     MOVF _val, W
0150  1D03     BTFSS STATUS, 0x2
0151  296A     GOTO 0x16A
229:                               sprintf(cadenaamostrar, "SET FECH");
230:                               sprintf(cadenaamostrar2, "%02d/%02d/%02d", fecha.day, fecha.month, fecha.yr);
231:                           } else {
232:                               sprintf(cadenaamostrar, "SET FECH");
014F  30F5     MOVLW 0xF5
0152  1283     BCF STATUS, 0x5
0153  00B0     MOVWF f
0154  3098     MOVLW 0x98
0155  00B1     MOVWF 0x31
0156  30A6     MOVLW 0xA6
0157  160A     BSF PCLATH, 0x4
0158  118A     BCF PCLATH, 0x3
0159  236C     CALL 0x36C
015A  120A     BCF PCLATH, 0x4
015B  118A     BCF PCLATH, 0x3
233:                               sprintf(cadenaamostrar2, "%02d/  /%02d", fecha.day, fecha.yr);
015C  305B     MOVLW 0x5B
015D  00B0     MOVWF f
015E  3098     MOVLW 0x98
015F  00B1     MOVWF 0x31
0160  086C     MOVF fecha, W
0161  293B     GOTO 0x13B
234:                           }
235:                           bandera_graba_fecha = 1;
236:                           break;
237:                       }
238:                       case SUBMENU_CONFIGURAANIO:
239:                       {
240:                           modificafecha = ANIO;
0162  3004     MOVLW 0x4
0163  00E5     MOVWF 0x65
241:           
242:                           if (flanco || haycambio) {
0164  08FC     MOVF flanco, F
0165  1903     BTFSC STATUS, 0x2
0166  0841     MOVF _val, W
0168  1903     BTFSC STATUS, 0x2
0169  2983     GOTO 0x183
243:                               sprintf(cadenaamostrar, "SET FECH");
0167  30F5     MOVLW 0xF5
016A  1283     BCF STATUS, 0x5
016B  00B0     MOVWF f
016C  3098     MOVLW 0x98
016D  00B1     MOVWF 0x31
016E  30A6     MOVLW 0xA6
016F  160A     BSF PCLATH, 0x4
0170  118A     BCF PCLATH, 0x3
0171  236C     CALL 0x36C
0172  120A     BCF PCLATH, 0x4
0173  118A     BCF PCLATH, 0x3
244:                               sprintf(cadenaamostrar2, "%02d/%02d/%02d", fecha.day, fecha.month, fecha.yr);
0174  3025     MOVLW 0x25
0175  00B0     MOVWF f
0176  3098     MOVLW 0x98
0177  00B1     MOVWF 0x31
0178  086C     MOVF fecha, W
0179  00B2     MOVWF f2
017A  01B3     CLRF 0x33
017B  086D     MOVF 0x6D, W
017C  00B4     MOVWF 0x34
017D  01B5     CLRF 0x35
017E  086E     MOVF 0x6E, W
017F  00B6     MOVWF 0x36
0180  30AF     MOVLW 0xAF
0181  01B7     CLRF 0x37
0182  2941     GOTO 0x141
245:                           } else {
246:                               sprintf(cadenaamostrar, "SET FECH");
0183  1283     BCF STATUS, 0x5
0184  00B0     MOVWF f
0185  3098     MOVLW 0x98
0186  00B1     MOVWF 0x31
0187  30A6     MOVLW 0xA6
0188  160A     BSF PCLATH, 0x4
0189  118A     BCF PCLATH, 0x3
018A  236C     CALL 0x36C
018B  120A     BCF PCLATH, 0x4
018C  118A     BCF PCLATH, 0x3
247:                               sprintf(cadenaamostrar2, "%02d/%02d/  ", fecha.day, fecha.month);
018D  304E     MOVLW 0x4E
018E  00B0     MOVWF f
018F  3098     MOVLW 0x98
0190  00B1     MOVWF 0x31
0191  086C     MOVF fecha, W
0192  00B2     MOVWF f2
0193  01B3     CLRF 0x33
0194  086D     MOVF 0x6D, W
0195  293E     GOTO 0x13E
248:                           }
249:                           bandera_graba_fecha = 1;
250:                           break;
251:                       }
252:                       case SUBMENU_CONFIGURAHORAENCENDIDO:
253:                       {
254:                           modificafecha = HORA;
0196  30D5     MOVLW 0xD5
0197  01E5     CLRF 0x65
255:                           horario = &horarioenc;
0196  30D5     MOVLW 0xD5
0198  00FD     MOVWF horario
256:                           if (flanco || haycambio) {
0199  08FC     MOVF flanco, F
019A  1903     BTFSC STATUS, 0x2
019B  0841     MOVF _val, W
019D  1D03     BTFSS STATUS, 0x2
019E  29BA     GOTO 0x1BA
257:                               sprintf(cadenaamostrar, "SET ENC ");
258:                               sprintf(cadenaamostrar2, "%02d:%02d   ", horarioenc.hrs, horarioenc.min);
259:                           } else {
260:                               sprintf(cadenaamostrar, "SET ENC ");
019C  30C8     MOVLW 0xC8
019F  1283     BCF STATUS, 0x5
01A0  00B0     MOVWF f
01A1  3098     MOVLW 0x98
01A2  00B1     MOVWF 0x31
01A3  30A6     MOVLW 0xA6
01A4  160A     BSF PCLATH, 0x4
01A5  118A     BCF PCLATH, 0x3
01A6  236C     CALL 0x36C
01A7  120A     BCF PCLATH, 0x4
01A8  118A     BCF PCLATH, 0x3
261:                               sprintf(cadenaamostrar2, "  :%02d   ", horarioenc.min);
01A9  308B     MOVLW 0x8B
01AA  00B0     MOVWF f
01AB  3098     MOVLW 0x98
01AC  00B1     MOVWF 0x31
01AD  1683     BSF STATUS, 0x5
01AE  0856     MOVF cntr, W
01AF  28E6     GOTO 0xE6
262:                           }
263:                           bandera_graba_hora = 1;
264:                           break;
265:                       }
266:                       case SUBMENU_CONFIGURAMINUTOSENCENDIDO:
01B0  30D5     MOVLW 0xD5
267:                       {
268:                           modificafecha = MINUTOS;
01B1  01E5     CLRF 0x65
01B2  0AE5     INCF 0x65, F
269:                           horario = &horarioenc;
01B0  30D5     MOVLW 0xD5
01B3  00FD     MOVWF horario
270:                           if (flanco || haycambio) {
01B4  08FC     MOVF flanco, F
01B5  1903     BTFSC STATUS, 0x2
01B6  0841     MOVF _val, W
01B8  1903     BTFSC STATUS, 0x2
01B9  29D4     GOTO 0x1D4
271:                               sprintf(cadenaamostrar, "SET ENC ");
01B7  30C8     MOVLW 0xC8
01BA  1283     BCF STATUS, 0x5
01BB  00B0     MOVWF f
01BC  3098     MOVLW 0x98
01BD  00B1     MOVWF 0x31
01BE  30A6     MOVLW 0xA6
01BF  160A     BSF PCLATH, 0x4
01C0  118A     BCF PCLATH, 0x3
01C1  236C     CALL 0x36C
01C2  120A     BCF PCLATH, 0x4
01C3  118A     BCF PCLATH, 0x3
272:                               sprintf(cadenaamostrar2, "%02d:%02d   ", horarioenc.hrs, horarioenc.min);
01C4  3041     MOVLW 0x41
01C5  00B0     MOVWF f
01C6  3098     MOVLW 0x98
01C7  00B1     MOVWF 0x31
01C8  1683     BSF STATUS, 0x5
01C9  0857     MOVF sign, W
01CA  1283     BCF STATUS, 0x5
01CB  00B2     MOVWF f2
01CC  01B3     CLRF 0x33
01CD  1683     BSF STATUS, 0x5
01CE  0856     MOVF cntr, W
01CF  1283     BCF STATUS, 0x5
01D0  00B4     MOVWF 0x34
01D1  30AF     MOVLW 0xAF
01D2  01B5     CLRF 0x35
01D3  28EA     GOTO 0xEA
273:                           } else {
274:                               sprintf(cadenaamostrar, "SET ENC ");
01D4  1283     BCF STATUS, 0x5
01D5  00B0     MOVWF f
01D6  3098     MOVLW 0x98
01D7  00B1     MOVWF 0x31
01D8  30A6     MOVLW 0xA6
01D9  160A     BSF PCLATH, 0x4
01DA  118A     BCF PCLATH, 0x3
01DB  236C     CALL 0x36C
01DC  120A     BCF PCLATH, 0x4
01DD  118A     BCF PCLATH, 0x3
275:                               sprintf(cadenaamostrar2, "%02d:     ", horarioenc.hrs);
01DE  3075     MOVLW 0x75
01DF  00B0     MOVWF f
01E0  3098     MOVLW 0x98
01E1  00B1     MOVWF 0x31
01E2  1683     BSF STATUS, 0x5
01E3  0857     MOVF sign, W
01E4  28E6     GOTO 0xE6
276:                           }
277:                           bandera_graba_hora = 1;
278:                           break;
279:                       }
280:                       case SUBMENU_CONFIGURAPERIODOENCENDIDO:
281:                       {
282:                           modificafecha = PERIODOENCENDIDO;
01E5  3009     MOVLW 0x9
01E6  00E5     MOVWF 0x65
283:           
284:                           if (flanco || haycambio) {
01E7  08FC     MOVF flanco, F
01E8  1903     BTFSC STATUS, 0x2
01E9  0841     MOVF _val, W
01EB  1D03     BTFSS STATUS, 0x2
01EC  2A12     GOTO 0x212
285:                               sprintf(cadenaamostrar, "ENC: %02d'", tiempoencendido);
286:                               sprintf(cadenaamostrar2, "c/%u dias", periodoencendido + 1);
287:                           } else {
288:                               sprintf(cadenaamostrar, "ENC: %02d'", tiempoencendido);
01EA  30A1     MOVLW 0xA1
01ED  1283     BCF STATUS, 0x5
01EE  00B0     MOVWF f
01EF  3098     MOVLW 0x98
01F0  00B1     MOVWF 0x31
01F1  1683     BSF STATUS, 0x5
01F2  0849     MOVF f2, W
01F3  1283     BCF STATUS, 0x5
01F4  00B2     MOVWF f2
01F5  30A6     MOVLW 0xA6
01F6  01B3     CLRF 0x33
01F7  160A     BSF PCLATH, 0x4
01F8  118A     BCF PCLATH, 0x3
01F9  236C     CALL 0x36C
01FA  120A     BCF PCLATH, 0x4
01FB  118A     BCF PCLATH, 0x3
289:                               sprintf(cadenaamostrar2, "c/  dias");
01FC  303D     MOVLW 0x3D
01FD  00B0     MOVWF f
01FE  3099     MOVLW 0x99
01FF  00B1     MOVWF 0x31
0200  30AF     MOVLW 0xAF
0201  160A     BSF PCLATH, 0x4
0202  118A     BCF PCLATH, 0x3
0203  236C     CALL 0x36C
0204  120A     BCF PCLATH, 0x4
0205  118A     BCF PCLATH, 0x3
290:                           }
291:                           bandera_graba_periodoytiempoencendido = 1;
0206  1683     BSF STATUS, 0x5
0207  01B1     CLRF 0x31
0208  0AB1     INCF 0x31, F
292:                           break;
0209  2B70     GOTO 0x370
293:                       }
294:           
295:                       case SUBMENU_CONFIGURATIEMPOENCENDIDO:
296:                       {
297:                           modificafecha = TIEMPOENCENDIDO;
020A  3007     MOVLW 0x7
020B  00E5     MOVWF 0x65
298:           
299:                           if (flanco || haycambio) {
020C  08FC     MOVF flanco, F
020D  1903     BTFSC STATUS, 0x2
020E  0841     MOVF _val, W
020F  1903     BTFSC STATUS, 0x2
0210  2A1D     GOTO 0x21D
300:                               sprintf(cadenaamostrar, "ENC: %02d'", tiempoencendido);
0211  30A1     MOVLW 0xA1
0212  1283     BCF STATUS, 0x5
0213  00B0     MOVWF f
0214  3098     MOVLW 0x98
0215  00B1     MOVWF 0x31
0216  1683     BSF STATUS, 0x5
0217  0849     MOVF f2, W
0218  1283     BCF STATUS, 0x5
0219  00B2     MOVWF f2
021A  30A6     MOVLW 0xA6
021B  01B3     CLRF 0x33
021C  2A23     GOTO 0x223
301:                               sprintf(cadenaamostrar2, "c/%u dias", periodoencendido + 1);
302:                           } else {
303:                               sprintf(cadenaamostrar, "ENC:   '");
021D  30DA     MOVLW 0xDA
021E  1283     BCF STATUS, 0x5
021F  00B0     MOVWF f
0220  3098     MOVLW 0x98
0221  00B1     MOVWF 0x31
0222  30A6     MOVLW 0xA6
0223  160A     BSF PCLATH, 0x4
0224  118A     BCF PCLATH, 0x3
0225  236C     CALL 0x36C
0226  120A     BCF PCLATH, 0x4
0227  118A     BCF PCLATH, 0x3
304:                               sprintf(cadenaamostrar2, "c/%u dias", periodoencendido + 1);
0228  30AC     MOVLW 0xAC
0229  00B0     MOVWF f
022A  3098     MOVLW 0x98
022B  00B1     MOVWF 0x31
022C  1683     BSF STATUS, 0x5
022D  0845     MOVF f1, W
022E  3E01     ADDLW 0x1
022F  1283     BCF STATUS, 0x5
0230  00B2     MOVWF f2
0231  3000     MOVLW 0x0
0232  1803     BTFSC STATUS, 0x0
0233  3001     MOVLW 0x1
0234  00B3     MOVWF 0x33
0235  2A00     GOTO 0x200
305:                           }
306:                           bandera_graba_periodoytiempoencendido = 1;
307:                           break;
308:                       }
309:                       case MENU_CONFIGURAFALLACORRIENTE:
310:                       {
311:                           modificafecha = SINO;
0236  3006     MOVLW 0x6
0237  00E5     MOVWF 0x65
312:                           banderasino = &usa_falla_de_corriente;
0238  30DA     MOVLW 0xDA
0239  00B6     MOVWF 0x36
313:                           if (flanco || haycambio) {
023A  08FC     MOVF flanco, F
023B  1903     BTFSC STATUS, 0x2
023C  0841     MOVF _val, W
023D  1903     BTFSC STATUS, 0x2
023E  2A4C     GOTO 0x24C
314:                               if (usa_falla_de_corriente) {
023F  085A     MOVF 0x5A, W
0240  1903     BTFSC STATUS, 0x2
0241  2A47     GOTO 0x247
315:                                   sprintf(cadenaamostrar, "FC:   SI");
0242  30FE     MOVLW 0xFE
0243  1283     BCF STATUS, 0x5
0244  00B0     MOVWF f
0245  3098     MOVLW 0x98
0246  2A50     GOTO 0x250
316:                                   sprintf(cadenaamostrar2, cadena_esp);
317:                               } else {
318:                                   sprintf(cadenaamostrar, "FC:   NO");
0247  3010     MOVLW 0x10
0248  1283     BCF STATUS, 0x5
0249  00B0     MOVWF f
024A  3099     MOVLW 0x99
024B  2A50     GOTO 0x250
319:                                   sprintf(cadenaamostrar2, cadena_esp);
320:                               }
321:                           } else {
322:                               sprintf(cadenaamostrar, "FC:     ");
024C  30B6     MOVLW 0xB6
024D  1283     BCF STATUS, 0x5
024E  00B0     MOVWF f
024F  3098     MOVLW 0x98
0250  00B1     MOVWF 0x31
0251  30A6     MOVLW 0xA6
0252  160A     BSF PCLATH, 0x4
0253  118A     BCF PCLATH, 0x3
0254  236C     CALL 0x36C
0255  120A     BCF PCLATH, 0x4
0256  118A     BCF PCLATH, 0x3
323:                               sprintf(cadenaamostrar2, cadena_esp);
0257  301C     MOVLW 0x1C
0258  00B0     MOVWF f
0259  3098     MOVLW 0x98
025A  00B1     MOVWF 0x31
025B  30AF     MOVLW 0xAF
025C  160A     BSF PCLATH, 0x4
025D  118A     BCF PCLATH, 0x3
025E  236C     CALL 0x36C
025F  120A     BCF PCLATH, 0x4
0260  118A     BCF PCLATH, 0x3
324:                           }
325:                           bandera_graba_usa_falla_de_corriente = 1;
0261  1683     BSF STATUS, 0x5
0262  01B3     CLRF 0x33
0263  0AB3     INCF 0x33, F
326:                           break;
0264  2B70     GOTO 0x370
327:                       }
328:                       case MENU_CONFIGURATIEMPOFALLACORRIENTE:
329:                       {
330:                           modificafecha = TIEMPOFALLA;
0265  3008     MOVLW 0x8
0266  00E5     MOVWF 0x65
331:           
332:                           if (flanco || haycambio) {
0267  08FC     MOVF flanco, F
0268  1903     BTFSC STATUS, 0x2
0269  0841     MOVF _val, W
026A  1903     BTFSC STATUS, 0x2
026B  2A78     GOTO 0x278
333:                               sprintf(cadenaamostrar, "TFC: %02d'", tiempofalla);
026C  3096     MOVLW 0x96
026D  1283     BCF STATUS, 0x5
026E  00B0     MOVWF f
026F  3098     MOVLW 0x98
0270  00B1     MOVWF 0x31
0271  1683     BSF STATUS, 0x5
0272  084A     MOVF 0x4A, W
0273  1283     BCF STATUS, 0x5
0274  00B2     MOVWF f2
0275  30A6     MOVLW 0xA6
0276  01B3     CLRF 0x33
0277  2A7E     GOTO 0x27E
334:                               sprintf(cadenaamostrar2, cadena_esp);
335:                           } else {
336:                               sprintf(cadenaamostrar, "TFC:   '");
0278  30D1     MOVLW 0xD1
0279  1283     BCF STATUS, 0x5
027A  00B0     MOVWF f
027B  3098     MOVLW 0x98
027C  00B1     MOVWF 0x31
027D  30A6     MOVLW 0xA6
027E  160A     BSF PCLATH, 0x4
027F  118A     BCF PCLATH, 0x3
0280  236C     CALL 0x36C
0281  120A     BCF PCLATH, 0x4
0282  118A     BCF PCLATH, 0x3
337:                               sprintf(cadenaamostrar2, cadena_esp);
0283  301C     MOVLW 0x1C
0284  00B0     MOVWF f
0285  3098     MOVLW 0x98
0286  00B1     MOVWF 0x31
0287  30AF     MOVLW 0xAF
0288  160A     BSF PCLATH, 0x4
0289  118A     BCF PCLATH, 0x3
028A  236C     CALL 0x36C
028B  120A     BCF PCLATH, 0x4
028C  118A     BCF PCLATH, 0x3
338:                           }
339:                           bandera_graba_tiempofalla = 1;
028D  1683     BSF STATUS, 0x5
028E  01B2     CLRF f2
028F  0AB2     INCF f2, F
340:                           break;
0290  2B70     GOTO 0x370
341:                       }
342:                       case MENU_MUESTRAMEDICIONES:
343:                       {
344:                           //convierto el valor decimal a float
345:                           //para una entrada de 3.3V la lectura es 1023
346:                           //para 0 V la lectura es 0
347:                           //para una maxima lectura quiero que en el display se observe 50A
348:                           //Deseo que tambien me muestre 1 decimal, separo la parte entera y la decimal
349:                           //como la resolucion es 1024, cada bit corresponde a 50A/1024=0.048828125A
350:                           //cada 20 muestras tengo aproximdamente 1A
351:           
352:                           adcenteroI = (unsigned int) mediciondecorriente;
0291  0823     MOVF 0x23, W
0292  1283     BCF STATUS, 0x5
0293  00A7     MOVWF x
0294  1683     BSF STATUS, 0x5
0295  0822     MOVF 0x22, W
0296  1283     BCF STATUS, 0x5
0297  00A6     MOVWF y
0298  1683     BSF STATUS, 0x5
0299  0821     MOVF 0x21, W
029A  1283     BCF STATUS, 0x5
029B  00A5     MOVWF dato
029C  1683     BSF STATUS, 0x5
029D  0820     MOVF 0x20, W
029E  1283     BCF STATUS, 0x5
029F  00A4     MOVWF x
02A0  120A     BCF PCLATH, 0x4
02A1  158A     BSF PCLATH, 0x3
02A2  20D5     CALL 0xD5
02A3  120A     BCF PCLATH, 0x4
02A4  118A     BCF PCLATH, 0x3
02A5  0825     MOVF dato, W
02A6  1683     BSF STATUS, 0x5
02A7  1703     BSF STATUS, 0x6
02A8  00A1     MOVWF 0x21
02A9  1283     BCF STATUS, 0x5
02AA  1303     BCF STATUS, 0x6
02AB  0824     MOVF x, W
02AC  1683     BSF STATUS, 0x5
02AD  1703     BSF STATUS, 0x6
02AE  00A0     MOVWF 0x20
353:                           adcdecimalI = (unsigned int) ((mediciondecorriente - (unsigned int) mediciondecorriente)*10);
02AF  1303     BCF STATUS, 0x6
02B0  0823     MOVF 0x23, W
02B1  1283     BCF STATUS, 0x5
02B2  00C4     MOVWF sp
02B3  1683     BSF STATUS, 0x5
02B4  0822     MOVF 0x22, W
02B5  1283     BCF STATUS, 0x5
02B6  00C3     MOVWF 0x43
02B7  1683     BSF STATUS, 0x5
02B8  0821     MOVF 0x21, W
02B9  1283     BCF STATUS, 0x5
02BA  00C2     MOVWF 0x42
02BB  1683     BSF STATUS, 0x5
02BC  0820     MOVF 0x20, W
02BD  1283     BCF STATUS, 0x5
02BE  00C1     MOVWF _val
02BF  1683     BSF STATUS, 0x5
02C0  0823     MOVF 0x23, W
02C1  1283     BCF STATUS, 0x5
02C2  00A7     MOVWF x
02C3  1683     BSF STATUS, 0x5
02C4  0822     MOVF 0x22, W
02C5  1283     BCF STATUS, 0x5
02C6  00A6     MOVWF y
02C7  1683     BSF STATUS, 0x5
02C8  0821     MOVF 0x21, W
02C9  1283     BCF STATUS, 0x5
02CA  00A5     MOVWF dato
02CB  1683     BSF STATUS, 0x5
02CC  0820     MOVF 0x20, W
02CD  1283     BCF STATUS, 0x5
02CE  00A4     MOVWF x
02CF  120A     BCF PCLATH, 0x4
02D0  158A     BSF PCLATH, 0x3
02D1  20D5     CALL 0xD5
02D2  120A     BCF PCLATH, 0x4
02D3  118A     BCF PCLATH, 0x3
02D4  0825     MOVF dato, W
02D5  00AF     MOVWF counter
02D6  0824     MOVF x, W
02D7  00AE     MOVWF day
02D8  160A     BSF PCLATH, 0x4
02D9  118A     BCF PCLATH, 0x3
02DA  259A     CALL 0x59A
02DB  120A     BCF PCLATH, 0x4
02DC  118A     BCF PCLATH, 0x3
02DD  0831     MOVF 0x31, W
02DE  00C0     MOVWF c
02DF  0830     MOVF f, W
02E0  00BF     MOVWF 0x3F
02E1  082F     MOVF counter, W
02E2  00BE     MOVWF width
02E3  082E     MOVF day, W
02E4  00BD     MOVWF flag
02E5  160A     BSF PCLATH, 0x4
02E6  118A     BCF PCLATH, 0x3
02E7  25AD     CALL 0x5AD
02E8  120A     BCF PCLATH, 0x4
02E9  118A     BCF PCLATH, 0x3
02EA  0840     MOVF c, W
02EB  00CC     MOVWF 0x4C
02EC  083F     MOVF 0x3F, W
02ED  00CB     MOVWF 0x4B
02EE  083E     MOVF width, W
02EF  00CA     MOVWF 0x4A
02F0  083D     MOVF flag, W
02F1  00C9     MOVWF f2
02F2  3041     MOVLW 0x41
02F3  00C8     MOVWF 0x48
02F4  3020     MOVLW 0x20
02F5  00C7     MOVWF 0x47
02F6  01C6     CLRF 0x46
02F7  01C5     CLRF f1
02F8  160A     BSF PCLATH, 0x4
02F9  118A     BCF PCLATH, 0x3
02FA  2642     CALL 0x642
02FB  120A     BCF PCLATH, 0x4
02FC  118A     BCF PCLATH, 0x3
02FD  0848     MOVF 0x48, W
02FE  1683     BSF STATUS, 0x5
02FF  00E1     MOVWF 0x61
0300  1283     BCF STATUS, 0x5
0301  0847     MOVF 0x47, W
0302  1683     BSF STATUS, 0x5
0303  00E0     MOVWF 0x60
0304  1283     BCF STATUS, 0x5
0305  0846     MOVF 0x46, W
0306  1683     BSF STATUS, 0x5
0307  00DF     MOVWF 0x5F
0308  1283     BCF STATUS, 0x5
0309  0845     MOVF f1, W
030A  1683     BSF STATUS, 0x5
030B  00DE     MOVWF 0x5E
030C  0861     MOVF 0x61, W
030D  1283     BCF STATUS, 0x5
030E  00A7     MOVWF x
030F  1683     BSF STATUS, 0x5
0310  0860     MOVF 0x60, W
0311  1283     BCF STATUS, 0x5
0312  00A6     MOVWF y
0313  1683     BSF STATUS, 0x5
0314  085F     MOVF 0x5F, W
0315  1283     BCF STATUS, 0x5
0316  00A5     MOVWF dato
0317  1683     BSF STATUS, 0x5
0318  085E     MOVF 0x5E, W
0319  1283     BCF STATUS, 0x5
031A  00A4     MOVWF x
031B  120A     BCF PCLATH, 0x4
031C  158A     BSF PCLATH, 0x3
031D  20D5     CALL 0xD5
031E  120A     BCF PCLATH, 0x4
031F  118A     BCF PCLATH, 0x3
0320  0825     MOVF dato, W
0321  1683     BSF STATUS, 0x5
0322  1703     BSF STATUS, 0x6
0323  009F     MOVWF ADCON0
0324  1283     BCF STATUS, 0x5
0325  1303     BCF STATUS, 0x6
0326  0824     MOVF x, W
0327  1683     BSF STATUS, 0x5
0328  1703     BSF STATUS, 0x6
0329  009E     MOVWF ADRESH
354:                           sprintf(cadenaamostrar, "%2u.%uA   ", (unsigned int) adcenteroI, (unsigned int) adcdecimalI);
032A  3080     MOVLW 0x80
032B  1283     BCF STATUS, 0x5
032C  1303     BCF STATUS, 0x6
032D  00B0     MOVWF f
032E  3098     MOVLW 0x98
032F  00B1     MOVWF 0x31
0330  1683     BSF STATUS, 0x5
0331  1703     BSF STATUS, 0x6
0332  0821     MOVF 0x21, W
0333  1283     BCF STATUS, 0x5
0334  1303     BCF STATUS, 0x6
0335  00B3     MOVWF 0x33
0336  1683     BSF STATUS, 0x5
0337  1703     BSF STATUS, 0x6
0338  0820     MOVF 0x20, W
0339  1283     BCF STATUS, 0x5
033A  1303     BCF STATUS, 0x6
033B  00B2     MOVWF f2
033C  1683     BSF STATUS, 0x5
033D  1703     BSF STATUS, 0x6
033E  081F     MOVF ADCON0, W
033F  1283     BCF STATUS, 0x5
0340  1303     BCF STATUS, 0x6
0341  00B5     MOVWF 0x35
0342  1683     BSF STATUS, 0x5
0343  1703     BSF STATUS, 0x6
0344  081E     MOVF ADRESH, W
0345  1283     BCF STATUS, 0x5
0346  1303     BCF STATUS, 0x6
0347  00B4     MOVWF 0x34
0348  30A6     MOVLW 0xA6
0349  160A     BSF PCLATH, 0x4
034A  118A     BCF PCLATH, 0x3
034B  236C     CALL 0x36C
034C  120A     BCF PCLATH, 0x4
034D  118A     BCF PCLATH, 0x3
355:                           sprintf(cadenaamostrar2, "%3uV    ", (unsigned int) adcenteroV);
034E  30BF     MOVLW 0xBF
034F  00B0     MOVWF f
0350  3098     MOVLW 0x98
0351  00B1     MOVWF 0x31
0352  1683     BSF STATUS, 0x5
0353  0828     MOVF i, W
0354  1283     BCF STATUS, 0x5
0355  00B3     MOVWF 0x33
0356  1683     BSF STATUS, 0x5
0357  0827     MOVF x, W
0358  1283     BCF STATUS, 0x5
0359  00B2     MOVWF f2
035A  30AF     MOVLW 0xAF
035B  160A     BSF PCLATH, 0x4
035C  118A     BCF PCLATH, 0x3
035D  236C     CALL 0x36C
035E  120A     BCF PCLATH, 0x4
035F  118A     BCF PCLATH, 0x3
356:                           break;
0360  2B70     GOTO 0x370
357:                       }
358:                       default:
359:                           break;
360:                   };
361:                   //////////////////////////////////////////////////////////
362:                   //Finaliza Procesa los men
363:                   // </editor-fold>
364:           
365:                   // <editor-fold defaultstate="collapsed" desc="Muestra estado de la bomba">
366:                   /////////////////////////////////////////////////////////
367:                   if (menuactual == MENU_INICIAL) {
0370  1683     BSF STATUS, 0x5
0371  08C4     MOVF sp, F
0372  1903     BTFSC STATUS, 0x2
0373  2B8D     GOTO 0x38D
0374  2BBC     GOTO 0x3BC
368:                       switch (estadobomba) {
038D  083F     MOVF 0x3F, W
038E  3A00     XORLW 0x0
038F  1903     BTFSC STATUS, 0x2
0390  2B75     GOTO 0x375
0391  3A01     XORLW 0x1
0392  1903     BTFSC STATUS, 0x2
0393  2B81     GOTO 0x381
0394  2BB3     GOTO 0x3B3
369:                           case BOMBAAPAGADA:
370:                           {
371:                               sprintf(cadenaamostrar2, "     off");
0375  302B     MOVLW 0x2B
0376  1283     BCF STATUS, 0x5
0377  00B0     MOVWF f
0378  3099     MOVLW 0x99
0379  00B1     MOVWF 0x31
037A  30AF     MOVLW 0xAF
037B  160A     BSF PCLATH, 0x4
037C  118A     BCF PCLATH, 0x3
037D  236C     CALL 0x36C
037E  120A     BCF PCLATH, 0x4
037F  118A     BCF PCLATH, 0x3
372:                               break;
0380  2BB3     GOTO 0x3B3
373:                           }
374:                           case BOMBAENCENDIDA:
375:                           {
376:                               sprintf(cadenaamostrar2, "      on");
0381  3034     MOVLW 0x34
0382  1283     BCF STATUS, 0x5
0383  00B0     MOVWF f
0384  3099     MOVLW 0x99
0385  00B1     MOVWF 0x31
0386  30AF     MOVLW 0xAF
0387  160A     BSF PCLATH, 0x4
0388  118A     BCF PCLATH, 0x3
0389  236C     CALL 0x36C
038A  120A     BCF PCLATH, 0x4
038B  118A     BCF PCLATH, 0x3
377:                               break;
038C  2BB3     GOTO 0x3B3
378:                           }
379:                           default:
380:                               break;
381:                       }
382:                       switch (manual_automatico) {
03B3  1683     BSF STATUS, 0x5
03B4  0864     MOVF f3, W
03B5  3A00     XORLW 0x0
03B6  1903     BTFSC STATUS, 0x2
03B7  2B95     GOTO 0x395
03B8  3A01     XORLW 0x1
03B9  1903     BTFSC STATUS, 0x2
03BA  2BA4     GOTO 0x3A4
03BB  2BBC     GOTO 0x3BC
383:                           case MANUAL:
384:                           {
385:                               strncpy(cadenaamostrar2, "MAN:", 4);
0395  304D     MOVLW 0x4D
0396  1283     BCF STATUS, 0x5
0397  00A4     MOVWF x
0398  3099     MOVLW 0x99
0399  00A5     MOVWF dato
039A  3004     MOVLW 0x4
039B  00A6     MOVWF y
039C  30AF     MOVLW 0xAF
039D  01A7     CLRF x
039E  120A     BCF PCLATH, 0x4
039F  158A     BSF PCLATH, 0x3
03A0  2014     CALL 0x14
03A1  120A     BCF PCLATH, 0x4
03A2  118A     BCF PCLATH, 0x3
386:                               break;
03A3  2BBC     GOTO 0x3BC
387:                           }
388:                           case AUTOMATICO:
389:                           {
390:                               strncpy(cadenaamostrar2, "AUT:", 4);
03A4  3052     MOVLW 0x52
03A5  1283     BCF STATUS, 0x5
03A6  00A4     MOVWF x
03A7  3099     MOVLW 0x99
03A8  00A5     MOVWF dato
03A9  3004     MOVLW 0x4
03AA  00A6     MOVWF y
03AB  30AF     MOVLW 0xAF
03AC  01A7     CLRF x
03AD  120A     BCF PCLATH, 0x4
03AE  158A     BSF PCLATH, 0x3
03AF  2014     CALL 0x14
03B0  120A     BCF PCLATH, 0x4
03B1  118A     BCF PCLATH, 0x3
391:                               break;
03B2  2BBC     GOTO 0x3BC
392:                           }
393:                           default:
394:                               break;
395:                       }
396:                   }
397:                   // </editor-fold>
398:           
399:                   // <editor-fold defaultstate="collapsed" desc="Verifica estados de falla">
400:           
401:                   if (!usa_falla_de_corriente) {
03BC  1683     BSF STATUS, 0x5
03BD  08DA     MOVF 0x5A, F
03BE  1D03     BTFSS STATUS, 0x2
03BF  2BC3     GOTO 0x3C3
402:                       estadofallacorriente = CORRIENTENORMAL;
03C0  01E2     CLRF 0x62
03C1  0AE2     INCF 0x62, F
403:                       //TODO Agregado el uso o no de falla de corriente (probar si funciona)
404:                   } else {
03C2  2BCC     GOTO 0x3CC
405:                       if (estadofallacorriente == FALLACORRIENTE) {
03C3  08E2     MOVF 0x62, F
03C4  1D03     BTFSS STATUS, 0x2
03C5  2BCC     GOTO 0x3CC
406:                           reseteafallas = FALLAPRESENTE;
03C6  01E6     CLRF 0x66
407:                           ultimafalla = HUBOFALLACORRIENTE;
03C7  01CC     CLRF 0x4C
03C8  0ACC     INCF 0x4C, F
408:                           if (estadobomba == BOMBAAPAGADA) {
03C9  08BF     MOVF 0x3F, F
03CA  1903     BTFSC STATUS, 0x2
03CB  2BC0     GOTO 0x3C0
409:                               estadofallacorriente = CORRIENTENORMAL;
410:                           }
411:                       }
412:                   }
413:                   if (estadonivel == NIVELBAJO) {
03CC  08E3     MOVF 0x63, F
03CD  1D03     BTFSS STATUS, 0x2
03CE  2BD7     GOTO 0x3D7
414:                       reseteafallas = FALLAPRESENTE;
03D0  01E6     CLRF 0x66
415:                       ultimafalla = HUBOFALLANIVEL;
03CF  3003     MOVLW 0x3
03D1  00CC     MOVWF 0x4C
416:                       if (estadobomba == BOMBAAPAGADA) {
03D2  08BF     MOVF 0x3F, F
03D3  1D03     BTFSS STATUS, 0x2
03D4  2BD7     GOTO 0x3D7
417:                           estadonivel = NIVELNORMAL;
03D5  01E3     CLRF 0x63
03D6  0AE3     INCF 0x63, F
418:                       }
419:                   }
420:                   if (estadofallavoltaje == FALLAVOLTAJE) {
03D7  08C0     MOVF c, F
03D8  1D03     BTFSS STATUS, 0x2
03D9  2BDD     GOTO 0x3DD
421:                       reseteafallas = FALLAPRESENTE;
03DB  01E6     CLRF 0x66
422:                       ultimafalla = HUBOFALLAVOLTAJE;
03DA  3002     MOVLW 0x2
03DC  00CC     MOVWF 0x4C
423:                   }
424:                   if ((estadonivel == NIVELNORMAL) && (estadofallacorriente == CORRIENTENORMAL) && (estadofallavoltaje == VOLTAJENORMAL)) {
03DD  0B63     DECFSZ 0x63, W
03DE  2BE4     GOTO 0x3E4
03DF  0B62     DECFSZ 0x62, W
03E0  2BE4     GOTO 0x3E4
03E1  0B40     DECFSZ c, W
03E2  2BE4     GOTO 0x3E4
03E3  2BE5     GOTO 0x3E5
425:           
426:           
427:                   } else {
428:                       activabomba = APAGABOMBA;
03E4  01AA     CLRF year
429:                   }
430:                   //////////////////////////////////////////////////////
431:                   //Fin Verifica estados de falla
432:                   // </editor-fold>
433:           
434:                   // <editor-fold defaultstate="collapsed" desc="Inicio de procesamiento de medicion de voltaje, corriente">
435:                   //Inicio de procesamiento de medicion de voltaje, corriente
436:                   /////////////////////////////////////////////////////////////
437:                   //convierto el valor decimal a float
438:                   //para una entrada de 3.3V la lectura es 1023
439:                   //para 0 V la lectura es 0
440:                   //para una maxima lectura quiero que en el display se observe 50A
441:                   //Deseo que tambien me muestre 1 decimal, separo la parte entera y la decimal
442:                   //como la resolucion es 1024, cada bit corresponde a 50A/1024=0.048828125A
443:                   //cada 20 muestras tengo aproximdamente 1A
444:                   mediciondevoltaje = (float) medidaV_adc * 440 / 1024;
03E5  3044     MOVLW 0x44
03E6  1283     BCF STATUS, 0x5
03E7  00DB     MOVWF 0x5B
03E8  3080     MOVLW 0x80
03E9  00DA     MOVWF 0x5A
03EA  3043     MOVLW 0x43
03EB  01D9     CLRF 0x59
03EC  01D8     CLRF f2
03ED  00C8     MOVWF 0x48
03EE  30DC     MOVLW 0xDC
03EF  00C7     MOVWF 0x47
03F0  01C6     CLRF 0x46
03F1  01C5     CLRF f1
03F2  1683     BSF STATUS, 0x5
03F3  1703     BSF STATUS, 0x6
03F4  0825     MOVF dato, W
03F5  1283     BCF STATUS, 0x5
03F6  1303     BCF STATUS, 0x6
03F7  00AF     MOVWF counter
03F8  1683     BSF STATUS, 0x5
03F9  1703     BSF STATUS, 0x6
03FA  0824     MOVF x, W
03FB  1283     BCF STATUS, 0x5
03FC  1303     BCF STATUS, 0x6
03FD  00AE     MOVWF day
03FE  160A     BSF PCLATH, 0x4
03FF  118A     BCF PCLATH, 0x3
0400  259A     CALL 0x59A
0401  120A     BCF PCLATH, 0x4
0402  118A     BCF PCLATH, 0x3
0403  0831     MOVF 0x31, W
0404  00CC     MOVWF 0x4C
0405  0830     MOVF f, W
0406  00CB     MOVWF 0x4B
0407  082F     MOVF counter, W
0408  00CA     MOVWF 0x4A
0409  082E     MOVF day, W
040A  00C9     MOVWF f2
040B  160A     BSF PCLATH, 0x4
040C  118A     BCF PCLATH, 0x3
040D  2642     CALL 0x642
040E  120A     BCF PCLATH, 0x4
040F  118A     BCF PCLATH, 0x3
0410  0848     MOVF 0x48, W
0411  00DF     MOVWF 0x5F
0412  0847     MOVF 0x47, W
0413  00DE     MOVWF 0x5E
0414  0846     MOVF 0x46, W
0415  00DD     MOVWF 0x5D
0416  0845     MOVF f1, W
0417  00DC     MOVWF f1
0418  160A     BSF PCLATH, 0x4
0419  118A     BCF PCLATH, 0x3
041A  25C9     CALL 0x5C9
041B  120A     BCF PCLATH, 0x4
041C  118A     BCF PCLATH, 0x3
041D  085B     MOVF 0x5B, W
041E  1683     BSF STATUS, 0x5
041F  1703     BSF STATUS, 0x6
0420  009D     MOVWF CCP2CON
0421  1283     BCF STATUS, 0x5
0422  1303     BCF STATUS, 0x6
0423  085A     MOVF 0x5A, W
0424  1683     BSF STATUS, 0x5
0425  1703     BSF STATUS, 0x6
0426  009C     MOVWF CCPR2H
0427  1283     BCF STATUS, 0x5
0428  1303     BCF STATUS, 0x6
0429  0859     MOVF 0x59, W
042A  1683     BSF STATUS, 0x5
042B  1703     BSF STATUS, 0x6
042C  009B     MOVWF CCPR2
042D  1283     BCF STATUS, 0x5
042E  1303     BCF STATUS, 0x6
042F  0858     MOVF f2, W
0430  1683     BSF STATUS, 0x5
0431  1703     BSF STATUS, 0x6
0432  009A     MOVWF RCREG
445:                   adcenteroV = (unsigned int) mediciondevoltaje;
0433  081D     MOVF CCP2CON, W
0434  1283     BCF STATUS, 0x5
0435  1303     BCF STATUS, 0x6
0436  00A7     MOVWF x
0437  1683     BSF STATUS, 0x5
0438  1703     BSF STATUS, 0x6
0439  081C     MOVF CCPR2H, W
043A  1283     BCF STATUS, 0x5
043B  1303     BCF STATUS, 0x6
043C  00A6     MOVWF y
043D  1683     BSF STATUS, 0x5
043E  1703     BSF STATUS, 0x6
043F  081B     MOVF CCPR2, W
0440  1283     BCF STATUS, 0x5
0441  1303     BCF STATUS, 0x6
0442  00A5     MOVWF dato
0443  1683     BSF STATUS, 0x5
0444  1703     BSF STATUS, 0x6
0445  081A     MOVF RCREG, W
0446  1283     BCF STATUS, 0x5
0447  1303     BCF STATUS, 0x6
0448  00A4     MOVWF x
0449  120A     BCF PCLATH, 0x4
044A  158A     BSF PCLATH, 0x3
044B  20D5     CALL 0xD5
044C  120A     BCF PCLATH, 0x4
044D  118A     BCF PCLATH, 0x3
044E  0825     MOVF dato, W
044F  1683     BSF STATUS, 0x5
0450  00A8     MOVWF i
0451  1283     BCF STATUS, 0x5
0452  0824     MOVF x, W
0453  1683     BSF STATUS, 0x5
0454  00A7     MOVWF x
446:                   //Se lee el voltaje de alimentacin constantemente
447:                   if (adcenteroV <= VOLTAJEMAXIMO && adcenteroV >= VOLTAJEMINIMO) {
0455  3000     MOVLW 0x0
0456  0228     SUBWF i, W
0457  30F1     MOVLW 0xF1
0458  1903     BTFSC STATUS, 0x2
0459  0227     SUBWF x, W
045A  1803     BTFSC STATUS, 0x0
045B  2C66     GOTO 0x466
045C  3000     MOVLW 0x0
045D  0228     SUBWF i, W
045E  30BE     MOVLW 0xBE
045F  1903     BTFSC STATUS, 0x2
0460  0227     SUBWF x, W
0462  1C03     BTFSS STATUS, 0x0
0463  2C67     GOTO 0x467
448:                       estadofallavoltaje = VOLTAJENORMAL;
0461  01C0     CLRF c
0464  0AC0     INCF c, F
449:                   } else {
0465  2C67     GOTO 0x467
450:                       estadofallavoltaje = FALLAVOLTAJE;
0466  01C0     CLRF c
451:                   }
452:                   mediciondecorriente = (float) medidaI_adc * 50 / 1024;
0467  3044     MOVLW 0x44
0468  1283     BCF STATUS, 0x5
0469  00DB     MOVWF 0x5B
046A  3080     MOVLW 0x80
046B  00DA     MOVWF 0x5A
046C  3042     MOVLW 0x42
046D  01D9     CLRF 0x59
046E  01D8     CLRF f2
046F  00C8     MOVWF 0x48
0470  3048     MOVLW 0x48
0471  00C7     MOVWF 0x47
0472  01C6     CLRF 0x46
0473  01C5     CLRF f1
0474  1683     BSF STATUS, 0x5
0475  1703     BSF STATUS, 0x6
0476  0823     MOVF 0x23, W
0477  1283     BCF STATUS, 0x5
0478  1303     BCF STATUS, 0x6
0479  00AF     MOVWF counter
047A  1683     BSF STATUS, 0x5
047B  1703     BSF STATUS, 0x6
047C  0822     MOVF 0x22, W
047D  1283     BCF STATUS, 0x5
047E  1303     BCF STATUS, 0x6
047F  00AE     MOVWF day
0480  160A     BSF PCLATH, 0x4
0481  118A     BCF PCLATH, 0x3
0482  259A     CALL 0x59A
0483  120A     BCF PCLATH, 0x4
0484  118A     BCF PCLATH, 0x3
0485  0831     MOVF 0x31, W
0486  00CC     MOVWF 0x4C
0487  0830     MOVF f, W
0488  00CB     MOVWF 0x4B
0489  082F     MOVF counter, W
048A  00CA     MOVWF 0x4A
048B  082E     MOVF day, W
048C  00C9     MOVWF f2
048D  160A     BSF PCLATH, 0x4
048E  118A     BCF PCLATH, 0x3
048F  2642     CALL 0x642
0490  120A     BCF PCLATH, 0x4
0491  118A     BCF PCLATH, 0x3
0492  0848     MOVF 0x48, W
0493  00DF     MOVWF 0x5F
0494  0847     MOVF 0x47, W
0495  00DE     MOVWF 0x5E
0496  0846     MOVF 0x46, W
0497  00DD     MOVWF 0x5D
0498  0845     MOVF f1, W
0499  00DC     MOVWF f1
049A  160A     BSF PCLATH, 0x4
049B  118A     BCF PCLATH, 0x3
049C  25C9     CALL 0x5C9
049D  120A     BCF PCLATH, 0x4
049E  118A     BCF PCLATH, 0x3
049F  085B     MOVF 0x5B, W
04A0  1683     BSF STATUS, 0x5
04A1  00A3     MOVWF 0x23
04A2  1283     BCF STATUS, 0x5
04A3  085A     MOVF 0x5A, W
04A4  1683     BSF STATUS, 0x5
04A5  00A2     MOVWF 0x22
04A6  1283     BCF STATUS, 0x5
04A7  0859     MOVF 0x59, W
04A8  1683     BSF STATUS, 0x5
04A9  00A1     MOVWF 0x21
04AA  1283     BCF STATUS, 0x5
04AB  0858     MOVF f2, W
04AC  1683     BSF STATUS, 0x5
04AD  00A0     MOVWF 0x20
453:                   /////////////////////////////////////////////////////////////
454:                   //Fin de procesamiento de medicion de voltaje, corriente
455:                   // </editor-fold>
456:           
457:                   // <editor-fold defaultstate="collapsed" desc="Activa o desactiva la Bomba">
458:                   //Activa o desactiva la Bomba
459:                   ///////////////////////////////////////////////////////
460:                   switch (activabomba) {
04AE  2CBA     GOTO 0x4BA
04BA  082A     MOVF year, W
04BB  3A00     XORLW 0x0
04BC  1903     BTFSC STATUS, 0x2
04BD  2CB5     GOTO 0x4B5
04BE  3A01     XORLW 0x1
04BF  1903     BTFSC STATUS, 0x2
04C0  2CAF     GOTO 0x4AF
04C1  2D3A     GOTO 0x53A
461:                       case ENCIENDEBOMBA:
462:                       {
463:                           salidabomba = 1;
04AF  1283     BCF STATUS, 0x5
04B0  1407     BSF PORTC, 0x0
464:                           estadobomba = 1;
04B1  1683     BSF STATUS, 0x5
04B2  01BF     CLRF 0x3F
04B3  0ABF     INCF 0x3F, F
465:                           // vBackLightLCD_On();
466:                           break;
04B4  2D3A     GOTO 0x53A
467:                       }
468:                       case APAGABOMBA:
469:                       {
470:                           salidabomba = 0;
04B5  1283     BCF STATUS, 0x5
04B6  1007     BCF PORTC, 0x0
471:                           estadobomba = 0;
04B7  1683     BSF STATUS, 0x5
04B8  01BF     CLRF 0x3F
472:                           // vBackLightLCD_Off();
473:                           break;
04B9  2D3A     GOTO 0x53A
474:                       }
475:                       default:
476:                           break;
477:                   }
478:                   //////////////////////////////////////////////////////
479:                   //Fin Activa o desactiva la Bomba
480:                   // </editor-fold>
481:           
482:                   // <editor-fold defaultstate="collapsed" desc="Procesa Alarma">
483:                   //Inicio Procesa Alarma
484:                   ///////////////////////////////////////////////////////
485:                   switch (alarma_encendido) {
053A  082D     MOVF hr, W
053B  3A00     XORLW 0x0
053C  1903     BTFSC STATUS, 0x2
053D  2D42     GOTO 0x542
053E  3A01     XORLW 0x1
053F  1903     BTFSC STATUS, 0x2
0540  2CC2     GOTO 0x4C2
0541  2D42     GOTO 0x542
486:                       case NOALARMA:
487:                       {
488:                           break;
489:                       }
490:                       case SIALARMA:
491:                       {
492:                           if (manual_automatico == AUTOMATICO) {
04C2  0B64     DECFSZ f3, W
04C3  2CCD     GOTO 0x4CD
493:                               bandera_orden_Alarma_bomba = 1;
04C5  01B4     CLRF 0x34
04C6  0AB4     INCF 0x34, F
494:                               buzzer_on(3);
04C4  3003     MOVLW 0x3
04C7  160A     BSF PCLATH, 0x4
04C8  158A     BSF PCLATH, 0x3
04C9  27EA     CALL 0x7EA
04CA  120A     BCF PCLATH, 0x4
04CB  118A     BCF PCLATH, 0x3
495:                           } else {
04CC  2CCE     GOTO 0x4CE
496:                               bandera_orden_Alarma_bomba = 0;
04CD  01B4     CLRF 0x34
497:                           }
498:                           alarma_encendido = NOALARMA;
04CE  1683     BSF STATUS, 0x5
04CF  01AD     CLRF hr
499:                           isl1208SR.Valor = ISL1208_Read_status();
04D0  120A     BCF PCLATH, 0x4
04D1  158A     BSF PCLATH, 0x3
04D2  2182     CALL 0x182
04D3  120A     BCF PCLATH, 0x4
04D4  118A     BCF PCLATH, 0x3
04D5  1683     BSF STATUS, 0x5
04D6  00D9     MOVWF 0x59
500:                           isl1208SR.ALM = 0; //reseteo la indicacion de alarma del RTC
04D8  1159     BCF 0x59, 0x2
501:           
502:                           ISL1208_Set_status(&isl1208SR.Valor);
04D7  30D9     MOVLW 0xD9
04D9  120A     BCF PCLATH, 0x4
04DA  158A     BSF PCLATH, 0x3
04DB  216C     CALL 0x16C
04DC  120A     BCF PCLATH, 0x4
04DD  118A     BCF PCLATH, 0x3
503:                           //Leo el valor de la alarma
504:                           isl1208_get_time_enc(&horarioenc.hrs, &horarioenc.min, &horarioenc.sec);
04DE  30D6     MOVLW 0xD6
04DF  1283     BCF STATUS, 0x5
04E0  00A9     MOVWF mth
04E1  30D5     MOVLW 0xD5
04E2  00AA     MOVWF year
04E3  30D7     MOVLW 0xD7
04E4  120A     BCF PCLATH, 0x4
04E5  158A     BSF PCLATH, 0x3
04E6  21F8     CALL 0x1F8
04E7  120A     BCF PCLATH, 0x4
04E8  118A     BCF PCLATH, 0x3
505:                           isl1208_get_dow_enc(&fechaenc.dow);
04E9  30D1     MOVLW 0xD1
04EA  120A     BCF PCLATH, 0x4
04EB  158A     BSF PCLATH, 0x3
04EC  219D     CALL 0x19D
04ED  120A     BCF PCLATH, 0x4
04EE  118A     BCF PCLATH, 0x3
506:                           /*TODO (implementado no probado )aca debo sumarle a fecha.dow el valor de periodoencendido
507:                            * para que respete cada cuantos dias se enciende la bomba
508:                            por ejemplo si la alarma se activo el lunes (1) y periodoencendido+1=3+1 es cada cuatro dias 4
509:                            debo hacer 1+4=5, 5%7=5 se deberia encender el viernes (5)
510:                            otro ejemplo si se encendio el jueves (4) y es cada 4 dias, 4+4=8, entonces 8%7=1 (lunes)
511:                            periodoencendido va de 0 a 6
512:                            0 corresponde a dia por dia (se debe desactivar la alarma por dow)
513:                            1 corresponde a cada dos dias
514:                            2 cada 3 dias
515:                            ...
516:                            6 cada 7 dias
517:                            */
518:                           fechaenc.dow = (fecha.dow + periodoencendido + 1) % 7;
04EF  1283     BCF STATUS, 0x5
04F0  086F     MOVF 0x6F, W
04F1  00A6     MOVWF y
04F2  01A7     CLRF x
04F3  1683     BSF STATUS, 0x5
04F4  0845     MOVF f1, W
04F5  1283     BCF STATUS, 0x5
04F6  07A6     ADDWF y, F
04F7  1803     BTFSC STATUS, 0x0
04F8  0AA7     INCF x, F
04F9  0AA6     INCF y, F
04FA  1903     BTFSC STATUS, 0x2
04FB  0AA7     INCF x, F
04FC  3007     MOVLW 0x7
04FD  00A4     MOVWF x
04FE  01A5     CLRF dato
04FF  120A     BCF PCLATH, 0x4
0500  158A     BSF PCLATH, 0x3
0501  204C     CALL 0x4C
0502  120A     BCF PCLATH, 0x4
0503  118A     BCF PCLATH, 0x3
0504  0824     MOVF x, W
0505  1683     BSF STATUS, 0x5
0506  00D1     MOVWF exp
519:                           isl1208_set_dow_enc(&fechaenc.dow, periodoencendido);
0507  0845     MOVF f1, W
0508  1283     BCF STATUS, 0x5
0509  00AB     MOVWF Data
050A  30D1     MOVLW 0xD1
050B  120A     BCF PCLATH, 0x4
050C  158A     BSF PCLATH, 0x3
050D  2275     CALL 0x275
050E  120A     BCF PCLATH, 0x4
050F  118A     BCF PCLATH, 0x3
520:                           horarioapagado.Valor = horarioenc.Valor;
0510  0855     MOVF 0x55, W
0511  00A4     MOVWF x
0512  0856     MOVF cntr, W
0513  00A5     MOVWF dato
0514  0857     MOVF sign, W
0515  00A6     MOVWF y
521:                           if (horarioapagado.min + tiempoencendido >= 60) {
0516  0825     MOVF dato, W
0517  0749     ADDWF f2, W
0518  00DB     MOVWF 0x5B
0519  01DC     CLRF f1
051A  0DDC     RLF f1, F
051B  085C     MOVF f1, W
051C  3A80     XORLW 0x80
051D  00FF     MOVWF 0x7F
051E  3080     MOVLW 0x80
051F  027F     SUBWF 0x7F, W
0520  1D03     BTFSS STATUS, 0x2
0521  2D24     GOTO 0x524
0522  303C     MOVLW 0x3C
0523  025B     SUBWF 0x5B, W
0524  1C03     BTFSS STATUS, 0x0
0525  2D34     GOTO 0x534
522:                               horarioapagado.min = horarioapagado.min + tiempoencendido - 60;
0526  1683     BSF STATUS, 0x5
0527  1303     BCF STATUS, 0x6
0528  0849     MOVF f2, W
0529  0725     ADDWF dato, W
052A  3EC4     ADDLW 0xC4
052B  00A5     MOVWF dato
523:                               if (horarioapagado.hrs == 23) {
052C  0826     MOVF y, W
052D  3A17     XORLW 0x17
052E  1D03     BTFSS STATUS, 0x2
052F  2D32     GOTO 0x532
524:                                   horarioapagado.hrs = 0;
0530  01A6     CLRF y
525:                               } else {
0531  2D42     GOTO 0x542
526:                                   horarioapagado.hrs++;
0532  0AA6     INCF y, F
0533  2D42     GOTO 0x542
527:                               }
528:                           } else {
529:                               horarioapagado.min = horarioapagado.min + tiempoencendido;
0534  1683     BSF STATUS, 0x5
0535  1303     BCF STATUS, 0x6
0536  0849     MOVF f2, W
0537  0725     ADDWF dato, W
0538  00A5     MOVWF dato
0539  2D42     GOTO 0x542
530:                           }
531:                           break;
532:                       }
533:                       default:
534:                           break;
535:                   }
536:                   //////////////////////////////////////////////////////
537:                   //Fin Procesa Alarma
538:                   // </editor-fold>
539:           
540:                   // <editor-fold defaultstate="collapsed" desc="Verifica secuencia de arranque">
541:                   /*para que el motor arranque se debe cumplir que:
542:                    * el voltaje sea normal,
543:                    * si est en manual, se haya pulsado el boton on_off
544:                    * si est en automatico se haya activado la alarma por interrupcion
545:                    * el nivel no sea bajo,
546:                    * la corriente sea normal, por lo menos despues de un tiempo despues del arranque
547:                    */
548:                   if (estadofallavoltaje == VOLTAJENORMAL) {
0542  0B40     DECFSZ c, W
0543  2E43     GOTO 0x643
549:                       if (manual_automatico == MANUAL) {
0544  08E4     MOVF f3, F
0545  1D03     BTFSS STATUS, 0x2
0546  2DD9     GOTO 0x5D9
550:                           if (bandera_orden_on_off_bomba) {
0547  0835     MOVF 0x35, W
0548  1903     BTFSC STATUS, 0x2
0549  2DD6     GOTO 0x5D6
551:                               if (indica_secuencia_arranque == 0) {
054A  08C2     MOVF 0x42, F
054B  1D03     BTFSS STATUS, 0x2
054C  2D7E     GOTO 0x57E
552:                                   if (tiempo_secuencia_arranque == 0) {
054D  08C7     MOVF 0x47, F
054E  1D03     BTFSS STATUS, 0x2
054F  2D59     GOTO 0x559
553:                                       activabomba = ENCIENDEBOMBA; //Enciendo la bomba para empezar a medir la corriente
0551  01AA     CLRF year
0552  0AAA     INCF year, F
554:                                       estadofallacorriente = CORRIENTENORMAL;
0553  01E2     CLRF 0x62
0554  0AE2     INCF 0x62, F
555:                                       estadonivel = NIVELNORMAL;
0555  01E3     CLRF 0x63
0556  0AE3     INCF 0x63, F
556:                                       tiempo_secuencia_arranque = TIEMPOSECUENCIAARRANQUE;
0550  300F     MOVLW 0xF
0557  00C7     MOVWF 0x47
557:                                   } else {
0558  2E43     GOTO 0x643
558:                                       // Una vez que se activo la bomba debo ver el estado de la corriente  para ver si no se pasa de los valores normales
559:                                       if (mediciondecorriente <= CORRIENTEMAXIMA) {
0559  3042     MOVLW 0x42
055A  1283     BCF STATUS, 0x5
055B  00A7     MOVWF x
055C  3034     MOVLW 0x34
055D  00A6     MOVWF y
055E  01A5     CLRF dato
055F  01A4     CLRF x
0560  1683     BSF STATUS, 0x5
0561  0823     MOVF 0x23, W
0562  1283     BCF STATUS, 0x5
0563  00AB     MOVWF Data
0564  1683     BSF STATUS, 0x5
0565  0822     MOVF 0x22, W
0566  1283     BCF STATUS, 0x5
0567  00AA     MOVWF year
0568  1683     BSF STATUS, 0x5
0569  0821     MOVF 0x21, W
056A  1283     BCF STATUS, 0x5
056B  00A9     MOVWF mth
056C  1683     BSF STATUS, 0x5
056D  0820     MOVF 0x20, W
056E  1283     BCF STATUS, 0x5
056F  00A8     MOVWF i
0570  120A     BCF PCLATH, 0x4
0571  158A     BSF PCLATH, 0x3
0572  2089     CALL 0x89
0573  120A     BCF PCLATH, 0x4
0574  118A     BCF PCLATH, 0x3
0575  1C03     BTFSS STATUS, 0x0
0576  2D7B     GOTO 0x57B
560:                                           estadofallacorriente = CORRIENTENORMAL;
0577  1683     BSF STATUS, 0x5
0578  01E2     CLRF 0x62
0579  0AE2     INCF 0x62, F
561:                                       } else {
057A  2E43     GOTO 0x643
562:                                           estadofallacorriente = FALLACORRIENTE;
057B  1683     BSF STATUS, 0x5
057C  01E2     CLRF 0x62
057D  2E43     GOTO 0x643
563:                                       }
564:           
565:                                   }
566:                               } else {
567:                                   //ya finalizo la secuencia de arranque, entonces veo si se estabiliz la corriente
568:                                   if (mediciondecorriente <= CORRIENTENORMALMAXIMA) {
057E  3041     MOVLW 0x41
057F  1283     BCF STATUS, 0x5
0580  00A7     MOVWF x
0581  3020     MOVLW 0x20
0582  00A6     MOVWF y
0583  01A5     CLRF dato
0584  01A4     CLRF x
0585  1683     BSF STATUS, 0x5
0586  0823     MOVF 0x23, W
0587  1283     BCF STATUS, 0x5
0588  00AB     MOVWF Data
0589  1683     BSF STATUS, 0x5
058A  0822     MOVF 0x22, W
058B  1283     BCF STATUS, 0x5
058C  00AA     MOVWF year
058D  1683     BSF STATUS, 0x5
058E  0821     MOVF 0x21, W
058F  1283     BCF STATUS, 0x5
0590  00A9     MOVWF mth
0591  1683     BSF STATUS, 0x5
0592  0820     MOVF 0x20, W
0593  1283     BCF STATUS, 0x5
0594  00A8     MOVWF i
0595  120A     BCF PCLATH, 0x4
0596  158A     BSF PCLATH, 0x3
0597  2089     CALL 0x89
0598  120A     BCF PCLATH, 0x4
0599  118A     BCF PCLATH, 0x3
059A  1C03     BTFSS STATUS, 0x0
059B  2DA1     GOTO 0x5A1
569:                                       estadofallacorriente = CORRIENTENORMAL;
059C  1683     BSF STATUS, 0x5
059D  01E2     CLRF 0x62
059E  0AE2     INCF 0x62, F
570:                                       cuenta_tiempofalla = 0;
059F  01BA     CLRF sign
571:                                   } else {
05A0  2DB1     GOTO 0x5B1
572:                                       //aca verifica si la falla est presente mucho tiempo con tiempofalla
573:                                       if (indica_tiempo_falla == 0) {
05A1  1683     BSF STATUS, 0x5
05A2  08C3     MOVF 0x43, F
05A3  1D03     BTFSS STATUS, 0x2
05A4  2DAB     GOTO 0x5AB
574:                                           if (cuenta_tiempofalla == 0) {
05A5  08BA     MOVF sign, F
05A6  1D03     BTFSS STATUS, 0x2
05A7  2DB1     GOTO 0x5B1
575:                                               cuenta_tiempofalla = tiempofalla;
05A8  084A     MOVF 0x4A, W
05A9  00BA     MOVWF sign
05AA  2DB1     GOTO 0x5B1
576:                                           }
577:                                       } else {
578:                                           //Expiro el tiempo de falla con una falla de sobrecorriente, debo apagar la bomba
579:                                           estadofallacorriente = FALLACORRIENTE;
05AB  01E2     CLRF 0x62
580:                                           indica_tiempo_falla = 0;
05AC  01C3     CLRF 0x43
581:                                           cuenta_tiempofalla = 0;
05AD  01BA     CLRF sign
582:                                           indica_secuencia_arranque = 0;
05AE  01C2     CLRF 0x42
583:                                           tiempo_secuencia_arranque = 0;
05AF  01C7     CLRF 0x47
584:                                           bandera_orden_on_off_bomba = 0; //cambia la bandera de orden de encendido de bomba
05B0  01B5     CLRF 0x35
585:                                       }
586:           
587:           
588:                                   }
589:                                   if (mediciondecorriente >= CORRIENTENORMALMINIMA) {
05B1  0823     MOVF 0x23, W
05B2  1283     BCF STATUS, 0x5
05B3  00A7     MOVWF x
05B4  1683     BSF STATUS, 0x5
05B5  0822     MOVF 0x22, W
05B6  1283     BCF STATUS, 0x5
05B7  00A6     MOVWF y
05B8  1683     BSF STATUS, 0x5
05B9  0821     MOVF 0x21, W
05BA  1283     BCF STATUS, 0x5
05BB  00A5     MOVWF dato
05BC  1683     BSF STATUS, 0x5
05BD  0820     MOVF 0x20, W
05BE  1283     BCF STATUS, 0x5
05BF  00A4     MOVWF x
05C0  303F     MOVLW 0x3F
05C1  00AB     MOVWF Data
05C2  3080     MOVLW 0x80
05C3  00AA     MOVWF year
05C4  01A9     CLRF mth
05C5  01A8     CLRF i
05C6  120A     BCF PCLATH, 0x4
05C7  158A     BSF PCLATH, 0x3
05C8  2089     CALL 0x89
05C9  120A     BCF PCLATH, 0x4
05CA  118A     BCF PCLATH, 0x3
05CB  1C03     BTFSS STATUS, 0x0
05CC  2DD1     GOTO 0x5D1
590:                                       estadonivel = NIVELNORMAL;
05CD  1683     BSF STATUS, 0x5
05CE  01E3     CLRF 0x63
05CF  0AE3     INCF 0x63, F
591:           
592:                                   } else {
05D0  2E43     GOTO 0x643
593:                                       indica_secuencia_arranque = 0;
05D1  1683     BSF STATUS, 0x5
05D2  01C2     CLRF 0x42
594:                                       tiempo_secuencia_arranque = 0;
05D3  01C7     CLRF 0x47
595:                                       bandera_orden_on_off_bomba = 0;
05D4  01B5     CLRF 0x35
05D5  2E42     GOTO 0x642
596:                                       estadonivel = NIVELBAJO;
597:                                   }
598:                               }
599:                           } else {
600:                               indica_secuencia_arranque = 0;
05D6  01C2     CLRF 0x42
601:                               tiempo_secuencia_arranque = 0;
05D7  01C7     CLRF 0x47
05D8  2E3C     GOTO 0x63C
602:                               activabomba = APAGABOMBA;
603:                           }
604:                       } else {
605:                           if (bandera_orden_Alarma_bomba) {
05D9  0834     MOVF 0x34, W
05DA  1903     BTFSC STATUS, 0x2
05DB  2DD6     GOTO 0x5D6
606:                               if (indica_secuencia_arranque == 0) {
05DC  08C2     MOVF 0x42, F
05DD  1903     BTFSC STATUS, 0x2
05DE  2D4D     GOTO 0x54D
607:                                   if (tiempo_secuencia_arranque == 0) {
608:                                       activabomba = ENCIENDEBOMBA; //Enciendo la bomba para empezar a medir la corriente
609:                                       estadofallacorriente = CORRIENTENORMAL;
610:                                       estadonivel = NIVELNORMAL;
611:                                       tiempo_secuencia_arranque = TIEMPOSECUENCIAARRANQUE;
612:                                   } else {
613:                                       //Una vez que se activo la bomba debo ver el estado de la corriente  para ver si no se pasa de los valores normales
614:                                       if (mediciondecorriente <= CORRIENTEMAXIMA) {
615:                                           estadofallacorriente = CORRIENTENORMAL;
616:                                       } else {
617:                                           estadofallacorriente = FALLACORRIENTE;
618:                                       }
619:           
620:                                   }
621:                               } else {
622:                                   // ya finalizo la secuencia de arranque, entonces veo si se estabiliz la corriente
623:                                   if (mediciondecorriente <= CORRIENTENORMALMAXIMA) {
05DF  3041     MOVLW 0x41
05E0  1283     BCF STATUS, 0x5
05E1  00A7     MOVWF x
05E2  3020     MOVLW 0x20
05E3  00A6     MOVWF y
05E4  01A5     CLRF dato
05E5  01A4     CLRF x
05E6  1683     BSF STATUS, 0x5
05E7  0823     MOVF 0x23, W
05E8  1283     BCF STATUS, 0x5
05E9  00AB     MOVWF Data
05EA  1683     BSF STATUS, 0x5
05EB  0822     MOVF 0x22, W
05EC  1283     BCF STATUS, 0x5
05ED  00AA     MOVWF year
05EE  1683     BSF STATUS, 0x5
05EF  0821     MOVF 0x21, W
05F0  1283     BCF STATUS, 0x5
05F1  00A9     MOVWF mth
05F2  1683     BSF STATUS, 0x5
05F3  0820     MOVF 0x20, W
05F4  1283     BCF STATUS, 0x5
05F5  00A8     MOVWF i
05F6  120A     BCF PCLATH, 0x4
05F7  158A     BSF PCLATH, 0x3
05F8  2089     CALL 0x89
05F9  120A     BCF PCLATH, 0x4
05FA  118A     BCF PCLATH, 0x3
05FB  1C03     BTFSS STATUS, 0x0
05FC  2E02     GOTO 0x602
624:                                       estadofallacorriente = CORRIENTENORMAL;
05FD  1683     BSF STATUS, 0x5
05FE  01E2     CLRF 0x62
05FF  0AE2     INCF 0x62, F
625:                                       cuenta_tiempofalla = 0;
0600  01BA     CLRF sign
626:                                   } else {
0601  2E12     GOTO 0x612
627:                                       //aca verifica si la falla est presente mucho tiempo con tiempofalla
628:                                       if (indica_tiempo_falla == 0) {
0602  1683     BSF STATUS, 0x5
0603  08C3     MOVF 0x43, F
0604  1D03     BTFSS STATUS, 0x2
0605  2E0C     GOTO 0x60C
629:                                           if (cuenta_tiempofalla == 0) {
0606  08BA     MOVF sign, F
0607  1D03     BTFSS STATUS, 0x2
0608  2E12     GOTO 0x612
630:                                               cuenta_tiempofalla = tiempofalla;
0609  084A     MOVF 0x4A, W
060A  00BA     MOVWF sign
060B  2E12     GOTO 0x612
631:                                           }
632:                                       } else {
633:                                           //Expiro el tiempo de falla con una falla de sobrecorriente, debo apagar la bomba
634:                                           estadofallacorriente = FALLACORRIENTE;
060C  01E2     CLRF 0x62
635:                                           indica_tiempo_falla = 0;
060D  01C3     CLRF 0x43
636:                                           cuenta_tiempofalla = 0;
060E  01BA     CLRF sign
637:                                           indica_secuencia_arranque = 0;
060F  01C2     CLRF 0x42
638:                                           tiempo_secuencia_arranque = 0;
0610  01C7     CLRF 0x47
639:                                           bandera_orden_Alarma_bomba = 0; //cambia la bandera de orden de encendido de bomba
0611  01B4     CLRF 0x34
640:                                       }
641:           
642:           
643:                                   }
644:                                   if (mediciondecorriente >= CORRIENTENORMALMINIMA) {
0612  0823     MOVF 0x23, W
0613  1283     BCF STATUS, 0x5
0614  00A7     MOVWF x
0615  1683     BSF STATUS, 0x5
0616  0822     MOVF 0x22, W
0617  1283     BCF STATUS, 0x5
0618  00A6     MOVWF y
0619  1683     BSF STATUS, 0x5
061A  0821     MOVF 0x21, W
061B  1283     BCF STATUS, 0x5
061C  00A5     MOVWF dato
061D  1683     BSF STATUS, 0x5
061E  0820     MOVF 0x20, W
061F  1283     BCF STATUS, 0x5
0620  00A4     MOVWF x
0621  303F     MOVLW 0x3F
0622  00AB     MOVWF Data
0623  3080     MOVLW 0x80
0624  00AA     MOVWF year
0625  01A9     CLRF mth
0626  01A8     CLRF i
0627  120A     BCF PCLATH, 0x4
0628  158A     BSF PCLATH, 0x3
0629  2089     CALL 0x89
062A  120A     BCF PCLATH, 0x4
062B  118A     BCF PCLATH, 0x3
062C  1C03     BTFSS STATUS, 0x0
062D  2E3E     GOTO 0x63E
645:                                       estadonivel = NIVELNORMAL;
062E  1683     BSF STATUS, 0x5
062F  01E3     CLRF 0x63
0630  0AE3     INCF 0x63, F
646:                                       //Ac debo apagar la bomba cuando pase el tiempo de encendido de la bomba
647:                                       if (horarioapagado.hrs == horarioactual.hrs && horarioapagado.min == horarioactual.min) {
0631  0826     MOVF y, W
0632  0654     XORWF 0x54, W
0633  1D03     BTFSS STATUS, 0x2
0634  2E43     GOTO 0x643
0635  0825     MOVF dato, W
0636  0653     XORWF 0x53, W
0637  1D03     BTFSS STATUS, 0x2
0638  2E43     GOTO 0x643
648:                                           indica_secuencia_arranque = 0;
0639  01C2     CLRF 0x42
649:                                           tiempo_secuencia_arranque = 0;
063A  01C7     CLRF 0x47
650:                                           bandera_orden_Alarma_bomba = 0;
063B  01B4     CLRF 0x34
651:                                           activabomba = APAGABOMBA;
063C  01AA     CLRF year
063D  2E43     GOTO 0x643
652:                                       }
653:                                   } else {
654:           
655:                                       indica_secuencia_arranque = 0;
063E  1683     BSF STATUS, 0x5
063F  01C2     CLRF 0x42
656:                                       tiempo_secuencia_arranque = 0;
0640  01C7     CLRF 0x47
657:                                       bandera_orden_Alarma_bomba = 0;
0641  01B4     CLRF 0x34
658:                                       estadonivel = NIVELBAJO;
0642  01E3     CLRF 0x63
659:           
660:                                   }
661:                               }
662:                           } else {
663:                               indica_secuencia_arranque = 0;
664:                               tiempo_secuencia_arranque = 0;
665:                               activabomba = APAGABOMBA;
666:                           }
667:                       }
668:           
669:           
670:                   }
671:           
672:           
673:           
674:                   // </editor-fold>
675:           
676:                   // <editor-fold defaultstate="collapsed" desc="Actualiza Display">
677:                   //Actualiza Display
678:                   /////////////////////////////////////////////
679:                   if (refrescadisplay) {
0643  0846     MOVF 0x46, W
0644  1903     BTFSC STATUS, 0x2
0645  2E84     GOTO 0x684
680:                       vGotoxyLCD(1, 1);
0646  1283     BCF STATUS, 0x5
0647  3001     MOVLW 0x1
0648  01A6     CLRF y
0649  0AA6     INCF y, F
064A  160A     BSF PCLATH, 0x4
064B  118A     BCF PCLATH, 0x3
064C  2209     CALL 0x209
064D  120A     BCF PCLATH, 0x4
064E  118A     BCF PCLATH, 0x3
681:                       cadena = cadenaamostrar;
064F  30A6     MOVLW 0xA6
0650  1683     BSF STATUS, 0x5
0651  00CD     MOVWF 0x4D
682:                       while (*cadena != '\0')
0652  084D     MOVF 0x4D, W
0653  0084     MOVWF FSR
0654  1783     BSF STATUS, 0x7
0655  0880     MOVF INDF, F
0656  1903     BTFSC STATUS, 0x2
0657  2E64     GOTO 0x664
0663  2E52     GOTO 0x652
683:                           vLCD_Putc(*cadena++);
0658  084D     MOVF 0x4D, W
0659  0084     MOVWF FSR
065A  0800     MOVF INDF, W
065B  160A     BSF PCLATH, 0x4
065C  118A     BCF PCLATH, 0x3
065D  222C     CALL 0x22C
065E  120A     BCF PCLATH, 0x4
065F  118A     BCF PCLATH, 0x3
0660  1683     BSF STATUS, 0x5
0661  1303     BCF STATUS, 0x6
0662  0ACD     INCF 0x4D, F
684:                       vGotoxyLCD(1, 2);
0664  3002     MOVLW 0x2
0665  1283     BCF STATUS, 0x5
0666  00A6     MOVWF y
0667  3001     MOVLW 0x1
0668  160A     BSF PCLATH, 0x4
0669  118A     BCF PCLATH, 0x3
066A  2209     CALL 0x209
066B  120A     BCF PCLATH, 0x4
066C  118A     BCF PCLATH, 0x3
685:                       cadena = cadenaamostrar2;
066D  30AF     MOVLW 0xAF
066E  1683     BSF STATUS, 0x5
066F  00CD     MOVWF 0x4D
686:                       while (*cadena != '\0')
0670  084D     MOVF 0x4D, W
0671  0084     MOVWF FSR
0672  1783     BSF STATUS, 0x7
0673  0880     MOVF INDF, F
0674  1903     BTFSC STATUS, 0x2
0675  2E82     GOTO 0x682
0681  2E70     GOTO 0x670
687:                           vLCD_Putc(*cadena++);
0676  084D     MOVF 0x4D, W
0677  0084     MOVWF FSR
0678  0800     MOVF INDF, W
0679  160A     BSF PCLATH, 0x4
067A  118A     BCF PCLATH, 0x3
067B  222C     CALL 0x22C
067C  120A     BCF PCLATH, 0x4
067D  118A     BCF PCLATH, 0x3
067E  1683     BSF STATUS, 0x5
067F  1303     BCF STATUS, 0x6
0680  0ACD     INCF 0x4D, F
688:                       haycambio = 0;
0682  01C1     CLRF _val
689:                       refrescadisplay = 0;
0683  01C6     CLRF 0x46
690:                   }
691:                   ////////////////////////////////////////////////
692:                   //Fin Actualiza Display
693:                   // </editor-fold>
694:           
695:                   // <editor-fold defaultstate="collapsed" desc="Graba datos">
696:                   // <editor-fold defaultstate="collapsed" desc="Graba Nuevos datos en el RTC">
697:                   //Graba Nuevos datos en el RC
698:                   /////////////////////////////////////////////////
699:                   if (bandera_graba_global) {
0684  082F     MOVF counter, W
0685  1903     BTFSC STATUS, 0x2
0686  2EDF     GOTO 0x6DF
700:                       if (bandera_graba_hora) {
0687  0830     MOVF f, W
0688  1903     BTFSC STATUS, 0x2
0689  2EC8     GOTO 0x6C8
701:                           if (horario == &horarioactual) {
068A  087D     MOVF horario, W
068B  3AD2     XORLW 0xD2
068C  1D03     BTFSS STATUS, 0x2
068D  2EA4     GOTO 0x6A4
702:                               isl1208_set_time((*horario).hrs, (*horario).min, 00);
068E  0A7D     INCF horario, W
068F  0084     MOVWF FSR
0690  1383     BCF STATUS, 0x7
0691  0800     MOVF INDF, W
0692  1283     BCF STATUS, 0x5
0693  00AB     MOVWF Data
0694  01AC     CLRF sec
0695  087D     MOVF horario, W
0696  3E02     ADDLW 0x2
0697  0084     MOVWF FSR
0698  0800     MOVF INDF, W
0699  120A     BCF PCLATH, 0x4
069A  158A     BSF PCLATH, 0x3
069B  22C3     CALL 0x2C3
069C  120A     BCF PCLATH, 0x4
069D  118A     BCF PCLATH, 0x3
703:                               buzzer_on(10);
069E  300A     MOVLW 0xA
069F  160A     BSF PCLATH, 0x4
06A0  158A     BSF PCLATH, 0x3
06A1  27EA     CALL 0x7EA
06A2  120A     BCF PCLATH, 0x4
06A3  118A     BCF PCLATH, 0x3
704:                           }
705:                           if (horario == &horarioenc) {
06A4  087D     MOVF horario, W
06A5  3AD5     XORLW 0xD5
06A6  1903     BTFSC STATUS, 0x2
06A7  2EAA     GOTO 0x6AA
06A8  1683     BSF STATUS, 0x5
06A9  2EC8     GOTO 0x6C8
706:                               isl1208_set_time_enc((*horario).hrs, (*horario).min, 00);
06AA  0A7D     INCF horario, W
06AB  0084     MOVWF FSR
06AC  1383     BCF STATUS, 0x7
06AD  0800     MOVF INDF, W
06AE  1283     BCF STATUS, 0x5
06AF  00AB     MOVWF Data
06B0  01AC     CLRF sec
06B1  087D     MOVF horario, W
06B2  3E02     ADDLW 0x2
06B3  0084     MOVWF FSR
06B4  0800     MOVF INDF, W
06B5  120A     BCF PCLATH, 0x4
06B6  158A     BSF PCLATH, 0x3
06B7  229A     CALL 0x29A
06B8  120A     BCF PCLATH, 0x4
06B9  118A     BCF PCLATH, 0x3
707:                               //cuando grabo los datos quiero que toque el dia siguiente o en el mismo dia a la hora especificada
708:                               //por lo tanto desactivo la alarma por dow
709:                               //fechaenc.dow = (fecha.dow + periodoencendido + 1) % 7;
710:                               isl1208_set_dow_enc(0x00, 0);
06BA  1283     BCF STATUS, 0x5
06BB  3000     MOVLW 0x0
06BC  01AB     CLRF Data
06BD  120A     BCF PCLATH, 0x4
06BE  158A     BSF PCLATH, 0x3
06BF  2275     CALL 0x275
06C0  120A     BCF PCLATH, 0x4
06C1  118A     BCF PCLATH, 0x3
711:                               buzzer_on(10);
06C2  300A     MOVLW 0xA
06C3  160A     BSF PCLATH, 0x4
06C4  158A     BSF PCLATH, 0x3
06C5  27EA     CALL 0x7EA
06C6  120A     BCF PCLATH, 0x4
06C7  118A     BCF PCLATH, 0x3
712:                           }
713:                       }
714:                       if (bandera_graba_fecha) {
06C8  1683     BSF STATUS, 0x5
06C9  082E     MOVF day, W
06CA  1903     BTFSC STATUS, 0x2
06CB  2EDF     GOTO 0x6DF
715:                           isl1208_set_date(&fecha.day, &fecha.month, &fecha.yr, &fecha.dow);
06CC  306D     MOVLW 0x6D
06CD  1283     BCF STATUS, 0x5
06CE  00AB     MOVWF Data
06CF  306E     MOVLW 0x6E
06D0  00AC     MOVWF sec
06D1  306F     MOVLW 0x6F
06D2  00AD     MOVWF hr
06D3  306C     MOVLW 0x6C
06D4  120A     BCF PCLATH, 0x4
06D5  158A     BSF PCLATH, 0x3
06D6  22FF     CALL 0x2FF
06D7  120A     BCF PCLATH, 0x4
06D8  118A     BCF PCLATH, 0x3
716:                           buzzer_on(10);
06D9  300A     MOVLW 0xA
06DA  160A     BSF PCLATH, 0x4
06DB  158A     BSF PCLATH, 0x3
06DC  27EA     CALL 0x7EA
06DD  120A     BCF PCLATH, 0x4
06DE  118A     BCF PCLATH, 0x3
717:                       }
718:                   }
719:                   //Si no hay datos para grabar en hora y fecha actualizo la hora y la fecha del RTC
720:                   if (actualizo_datos_rtc && bandera_graba_hora == 0 && bandera_graba_fecha == 0) {
06DF  1683     BSF STATUS, 0x5
06E0  082C     MOVF sec, W
06E1  1903     BTFSC STATUS, 0x2
06E2  2F00     GOTO 0x700
06E3  08B0     MOVF f, F
06E4  1D03     BTFSS STATUS, 0x2
06E5  2F00     GOTO 0x700
06E6  08AE     MOVF day, F
06E7  1D03     BTFSS STATUS, 0x2
06E8  2F00     GOTO 0x700
721:                       lee_y_transmite_date_and_time();
06E9  120A     BCF PCLATH, 0x4
06EA  158A     BSF PCLATH, 0x3
06EB  2134     CALL 0x134
06EC  120A     BCF PCLATH, 0x4
06ED  118A     BCF PCLATH, 0x3
722:                       isl1208_get_time_enc(&horarioenc.hrs, &horarioenc.min, &horarioenc.sec);
06EE  30D6     MOVLW 0xD6
06EF  1283     BCF STATUS, 0x5
06F0  00A9     MOVWF mth
06F1  30D5     MOVLW 0xD5
06F2  00AA     MOVWF year
06F3  30D7     MOVLW 0xD7
06F4  120A     BCF PCLATH, 0x4
06F5  158A     BSF PCLATH, 0x3
06F6  21F8     CALL 0x1F8
06F7  120A     BCF PCLATH, 0x4
06F8  118A     BCF PCLATH, 0x3
723:                       isl1208_get_dow_enc(&fechaenc.dow);
06F9  30D1     MOVLW 0xD1
06FA  120A     BCF PCLATH, 0x4
06FB  158A     BSF PCLATH, 0x3
06FC  219D     CALL 0x19D
06FD  120A     BCF PCLATH, 0x4
06FE  118A     BCF PCLATH, 0x3
724:                       actualizo_datos_rtc = 0;
06FF  01AC     CLRF sec
725:                   }
726:                   bandera_graba_hora = 0;
0700  01B0     CLRF f
727:                   bandera_graba_fecha = 0;
0701  01AE     CLRF day
728:                   //////////////////////////////////////////////////////////////////
729:                   //Finaliza Graba Nuevos datos en el RTC
730:                   // </editor-fold>
731:           
732:                   // <editor-fold defaultstate="collapsed" desc="Graba Nuevos datos en la EEPROM DEL PIC">
733:                   //DIRECCION 0: periodoencendido(cada cuanto se enciende la bomba en automatico), de 0 a 6 dias,
734:                   //DIRECCION 1: tiempoencendido (cuanto tiempo permanece encendida la bomba en automatico) 0 a 60 minutos
735:                   //DIRECCION 2: usa_falla_de_corriente (dice si se usa falla de corriente o no)
736:                   //DIRECCION 3: tiempofalla (cuanto tiempo puede estar en falla de corriente antes de apagar la bomba por seguridad) 0 a 10 segundos
737:           
738:                   if (bandera_graba_global) {
0702  082F     MOVF counter, W
0703  1903     BTFSC STATUS, 0x2
0704  2F49     GOTO 0x749
739:                       di();
0705  138B     BCF INTCON, 0x7
740:                       if (bandera_graba_periodoytiempoencendido) {
0706  0831     MOVF 0x31, W
0707  1903     BTFSC STATUS, 0x2
0708  2F22     GOTO 0x722
741:                           eeprom_write(0, periodoencendido);
0709  0845     MOVF f1, W
070A  1283     BCF STATUS, 0x5
070B  00A4     MOVWF x
070C  3000     MOVLW 0x0
070D  160A     BSF PCLATH, 0x4
070E  118A     BCF PCLATH, 0x3
070F  2071     CALL 0x71
0710  120A     BCF PCLATH, 0x4
0711  118A     BCF PCLATH, 0x3
742:                           eeprom_write(1, tiempoencendido);
0712  1303     BCF STATUS, 0x6
0713  0849     MOVF f2, W
0714  1283     BCF STATUS, 0x5
0715  00A4     MOVWF x
0716  3001     MOVLW 0x1
0717  160A     BSF PCLATH, 0x4
0718  118A     BCF PCLATH, 0x3
0719  2071     CALL 0x71
071A  120A     BCF PCLATH, 0x4
071B  118A     BCF PCLATH, 0x3
743:                           buzzer_on(10);
071C  300A     MOVLW 0xA
071D  160A     BSF PCLATH, 0x4
071E  158A     BSF PCLATH, 0x3
071F  27EA     CALL 0x7EA
0720  120A     BCF PCLATH, 0x4
0721  118A     BCF PCLATH, 0x3
744:                       }
745:                       if (bandera_graba_usa_falla_de_corriente) {
0722  1683     BSF STATUS, 0x5
0723  0833     MOVF 0x33, W
0724  1903     BTFSC STATUS, 0x2
0725  2F35     GOTO 0x735
746:                           eeprom_write(2, usa_falla_de_corriente);
0726  085A     MOVF 0x5A, W
0727  1283     BCF STATUS, 0x5
0728  00A4     MOVWF x
0729  3002     MOVLW 0x2
072A  160A     BSF PCLATH, 0x4
072B  118A     BCF PCLATH, 0x3
072C  2071     CALL 0x71
072D  120A     BCF PCLATH, 0x4
072E  118A     BCF PCLATH, 0x3
747:                           buzzer_on(10);
072F  300A     MOVLW 0xA
0730  160A     BSF PCLATH, 0x4
0731  158A     BSF PCLATH, 0x3
0732  27EA     CALL 0x7EA
0733  120A     BCF PCLATH, 0x4
0734  118A     BCF PCLATH, 0x3
748:                       }
749:                       if (bandera_graba_tiempofalla) {
0735  1683     BSF STATUS, 0x5
0736  0832     MOVF f2, W
0737  1903     BTFSC STATUS, 0x2
0738  2F48     GOTO 0x748
750:                           eeprom_write(3, tiempofalla);
0739  084A     MOVF 0x4A, W
073A  1283     BCF STATUS, 0x5
073B  00A4     MOVWF x
073C  3003     MOVLW 0x3
073D  160A     BSF PCLATH, 0x4
073E  118A     BCF PCLATH, 0x3
073F  2071     CALL 0x71
0740  120A     BCF PCLATH, 0x4
0741  118A     BCF PCLATH, 0x3
751:                           buzzer_on(10);
0742  300A     MOVLW 0xA
0743  160A     BSF PCLATH, 0x4
0744  158A     BSF PCLATH, 0x3
0745  27EA     CALL 0x7EA
0746  120A     BCF PCLATH, 0x4
0747  118A     BCF PCLATH, 0x3
752:                       }
753:                       ei();
0748  178B     BSF INTCON, 0x7
754:                   }
755:                   bandera_graba_global = 0;
0749  1683     BSF STATUS, 0x5
074A  01AF     CLRF counter
756:                   bandera_graba_periodoytiempoencendido = 0;
074B  01B1     CLRF 0x31
757:                   bandera_graba_usa_falla_de_corriente = 0;
074C  01B3     CLRF 0x33
758:                   bandera_graba_tiempofalla = 0;
074D  01B2     CLRF f2
759:                   // </editor-fold>
760:                   // </editor-fold>
761:                   NOP();
074E  0000     NOP
762:                   NOP();
074F  0000     NOP
763:               }
764:           }
765:           
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/interrupts.c  -------------------------
1:             
2:             /******************************************************************************/
3:             /*Files to Include                                                            */
4:             /******************************************************************************/
5:             
6:             #if defined(__XC)
7:             #include <xc.h>         /* XC8 General Include File */
8:             #elif defined(HI_TECH_C)
9:             #include <htc.h>        /* HiTech General Include File */
10:            #endif
11:            #include <stdbool.h>        /* For true/false definition */
12:            #include <stdint.h>
13:            #include "user.h"
14:            #include "system.h"
15:            
16:            #include "Pulsadores.h"
17:            #include "pwm.h"
18:            #include "adcPic16.h"
19:            #include "_isl1208.h"
20:            #include "LCDGeneric.h"
21:            /* Interrupt Routines                                                         */
22:            
23:            /******************************************************************************/
24:            
25:            void interrupt isr(void) {
0004  00FE     MOVWF 0x7E
0005  0E03     SWAPF STATUS, W
0006  1283     BCF STATUS, 0x5
0007  1303     BCF STATUS, 0x6
0008  00A1     MOVWF 0x21
0009  0804     MOVF FSR, W
000A  00A2     MOVWF 0x22
000B  080A     MOVF PCLATH, W
000C  00A3     MOVWF 0x23
000D  120A     BCF PCLATH, 0x4
000E  158A     BSF PCLATH, 0x3
000F  2C05     GOTO 0x405
0010  120A     BCF PCLATH, 0x4
0011  118A     BCF PCLATH, 0x3
0012  2813     GOTO 0x13
26:                if (ADIF && ADIE) {
0C05  1F0C     BTFSS PIR1, 0x6
0C06  2C2B     GOTO 0x42B
0C07  1683     BSF STATUS, 0x5
0C08  1F0C     BTFSS PIR1, 0x6
0C09  2C2B     GOTO 0x42B
27:                    // <editor-fold defaultstate="collapsed" desc="interrupcion adc">
28:                    if (getADCChannel() == MIDECORRIENTE) {
0C0A  27E9     CALL 0x7E9
0C0B  120A     BCF PCLATH, 0x4
0C0C  158A     BSF PCLATH, 0x3
0C0D  3800     IORLW 0x0
0C0E  1D03     BTFSS STATUS, 0x2
0C0F  2C1A     GOTO 0x41A
29:                        medidaI_adc = adcRead();
0C10  27DA     CALL 0x7DA
0C11  120A     BCF PCLATH, 0x4
0C12  158A     BSF PCLATH, 0x3
0C13  0871     MOVF canal, W
0C14  1703     BSF STATUS, 0x6
0C15  00A3     MOVWF 0x23
0C16  0870     MOVF tiempo, W
0C17  00A2     MOVWF 0x22
30:                        setADCChannel(MIDETENSION);
0C18  3001     MOVLW 0x1
0C19  2C21     GOTO 0x421
31:                    } else {
32:                        medidaV_adc = adcRead();
0C1A  27DA     CALL 0x7DA
0C1B  0871     MOVF canal, W
0C1C  1703     BSF STATUS, 0x6
0C1D  00A5     MOVWF dato
0C1E  0870     MOVF tiempo, W
0C1F  00A4     MOVWF x
33:                        /*TODO debo realizar un promedio en las mediciones para filtrar las
34:                        variaciones rpidas de tensin*/
35:                        setADCChannel(MIDECORRIENTE);
0C20  3000     MOVLW 0x0
0C21  120A     BCF PCLATH, 0x4
0C22  118A     BCF PCLATH, 0x3
0C23  27F3     CALL 0x7F3
0C24  120A     BCF PCLATH, 0x4
0C25  158A     BSF PCLATH, 0x3
36:                    }
37:                    ADIF = 0;
0C26  130C     BCF PIR1, 0x6
38:                    cambio_de_canal = 1;
0C27  1683     BSF STATUS, 0x5
0C28  01B7     CLRF 0x37
0C29  0AB7     INCF 0x37, F
39:                    // </editor-fold>
40:                } else if (INTF && INTE) { // INTERRUPCION por EXT2 Clock Out --------------------------------------------
0C2A  2F09     GOTO 0x709
0C2B  188B     BTFSC INTCON, 0x1
0C2C  1E0B     BTFSS INTCON, 0x4
0C2D  2C33     GOTO 0x433
41:                    // <editor-fold defaultstate="collapsed" desc="interrupcion intf">
42:                    alarma_encendido = SIALARMA;
0C2E  1683     BSF STATUS, 0x5
0C2F  01AD     CLRF hr
0C30  0AAD     INCF hr, F
43:                    INTF = 0;
0C31  108B     BCF INTCON, 0x1
44:                    // </editor-fold>
45:                } else if (T0IF && T0IE) {
0C32  2F09     GOTO 0x709
0C33  190B     BTFSC INTCON, 0x2
0C34  1E8B     BTFSS INTCON, 0x5
0C35  2F09     GOTO 0x709
46:                    // <editor-fold defaultstate="collapsed" desc="interrupcion timer0">
47:                    //Interrupcion por desborde del timer0. Tal como esta configurado, se el timer desborda cada
48:                    //0.0032768seg o sea 3.2768 ms, por lo tanto para que pase alrededor de 0.5segundo, se debe entrar 150 veces
49:                    //cada 3.2768ms realizamos una conversion analogica para obtener la medida de corriente
50:                    if (cambio_de_canal)
0C36  1683     BSF STATUS, 0x5
0C37  0837     MOVF 0x37, W
0C38  1903     BTFSC STATUS, 0x2
0C39  2C3C     GOTO 0x43C
51:                        cambio_de_canal = 0;
0C3A  01B7     CLRF 0x37
0C3B  2C3F     GOTO 0x43F
52:                    else
53:                        startADC();
0C3C  27F0     CALL 0x7F0
0C3D  120A     BCF PCLATH, 0x4
0C3E  158A     BSF PCLATH, 0x3
54:                    if (cuenta40ms < 12) {
0C3F  300C     MOVLW 0xC
0C40  1683     BSF STATUS, 0x5
0C41  0238     SUBWF 0x38, W
0C42  1803     BTFSC STATUS, 0x0
0C43  2C46     GOTO 0x446
55:                        cuenta40ms++;
0C44  0AB8     INCF 0x38, F
56:                    } else {
0C45  2CB1     GOTO 0x4B1
57:                        cuenta40ms = 0;
0C46  01B8     CLRF 0x38
58:                        if (activapwmpor > 0) {
0C47  082B     MOVF Data, W
0C48  1903     BTFSC STATUS, 0x2
0C49  2C4C     GOTO 0x44C
59:                            activapwmpor--;
0C4A  03AB     DECF Data, F
60:                        } else {
0C4B  2C51     GOTO 0x451
61:                            buzzer_off();
0C4C  27F7     CALL 0x7F7
0C4D  120A     BCF PCLATH, 0x4
0C4E  158A     BSF PCLATH, 0x3
62:                            activapwmpor = 0;
0C4F  1683     BSF STATUS, 0x5
0C50  01AB     CLRF Data
63:                        }
64:                        if (cuenta500ms < 11) {
0C51  300B     MOVLW 0xB
0C52  0239     SUBWF 0x39, W
0C53  1803     BTFSC STATUS, 0x0
0C54  2C57     GOTO 0x457
65:                            cuenta500ms++;
0C55  0AB9     INCF 0x39, F
66:            
67:            
68:                        } else {
0C56  2CB1     GOTO 0x4B1
69:                            cuenta500ms = 0;
0C57  3000     MOVLW 0x0
0C58  01B9     CLRF 0x39
70:                            flanco = !flanco;
0C57  3000     MOVLW 0x0
0C59  08FC     MOVF flanco, F
0C5A  1903     BTFSC STATUS, 0x2
0C5B  3001     MOVLW 0x1
0C5C  00FC     MOVWF flanco
71:            
72:                            //para que entre a lo que sigue cada 1 segundo aprovecho a leer el valor de flanco
73:                            if (flanco) {
0C5D  087C     MOVF flanco, W
0C5E  1903     BTFSC STATUS, 0x2
0C5F  2C91     GOTO 0x491
74:            
75:                                if (tiemporegresaamenuinicial != 0) {
0C60  084B     MOVF 0x4B, W
0C61  1903     BTFSC STATUS, 0x2
0C62  2C65     GOTO 0x465
76:                                    tiemporegresaamenuinicial--;
0C63  03CB     DECF 0x4B, F
77:                                } else {
0C64  2C69     GOTO 0x469
78:                                    if (menuactual != MENU_INICIAL) menuactual = MENU_INICIAL;
0C65  0844     MOVF sp, W
0C66  1903     BTFSC STATUS, 0x2
0C67  2C69     GOTO 0x469
0C68  01C4     CLRF sp
79:                                }
80:                                if (tiempoapagadolcd != 0) {
0C69  0848     MOVF 0x48, W
0C6A  1903     BTFSC STATUS, 0x2
0C6B  2C72     GOTO 0x472
81:                                    vBackLightLCD_On();
0C6C  27FC     CALL 0x7FC
0C6D  120A     BCF PCLATH, 0x4
0C6E  158A     BSF PCLATH, 0x3
82:                                    tiempoapagadolcd--;
0C6F  1683     BSF STATUS, 0x5
0C70  03C8     DECF 0x48, F
83:                                } else {
0C71  2C75     GOTO 0x475
84:                                    vBackLightLCD_Off();
0C72  27F3     CALL 0x7F3
0C73  120A     BCF PCLATH, 0x4
0C74  158A     BSF PCLATH, 0x3
85:                                }
86:            
87:                                if (indica_secuencia_arranque) {
0C75  1683     BSF STATUS, 0x5
0C76  0842     MOVF 0x42, W
0C77  1903     BTFSC STATUS, 0x2
0C78  2C82     GOTO 0x482
88:                                    if (cuenta_tiempofalla > 0) {
0C79  083A     MOVF sign, W
0C7A  1903     BTFSC STATUS, 0x2
0C7B  2C7D     GOTO 0x47D
89:                                        cuenta_tiempofalla--;
0C7C  03BA     DECF sign, F
90:                                    }
91:                                    if (cuenta_tiempofalla == 0) {
0C7D  08BA     MOVF sign, F
0C7E  1D03     BTFSS STATUS, 0x2
0C7F  2C82     GOTO 0x482
92:                                        indica_tiempo_falla = 1;
0C80  01C3     CLRF 0x43
0C81  0AC3     INCF 0x43, F
93:                                    }
94:                                }
95:                                if (bandera_orden_on_off_bomba || bandera_orden_Alarma_bomba) {
0C82  08B5     MOVF 0x35, F
0C83  1903     BTFSC STATUS, 0x2
0C84  0834     MOVF 0x34, W
0C85  1903     BTFSC STATUS, 0x2
0C86  2C93     GOTO 0x493
96:                                    if (tiempo_secuencia_arranque > 0) {
0C87  0847     MOVF 0x47, W
0C88  1903     BTFSC STATUS, 0x2
0C89  2C8B     GOTO 0x48B
97:                                        tiempo_secuencia_arranque--;
0C8A  03C7     DECF 0x47, F
98:                                    }
99:                                    if (tiempo_secuencia_arranque == 0) {
0C8B  08C7     MOVF 0x47, F
0C8C  1D03     BTFSS STATUS, 0x2
0C8D  2C93     GOTO 0x493
100:                                       indica_secuencia_arranque = 1;
0C8E  01C2     CLRF 0x42
0C8F  0AC2     INCF 0x42, F
0C90  2C93     GOTO 0x493
101:                                   }
102:                               }
103:                           } else {
104:                               actualizo_datos_rtc = 1;
0C91  01AC     CLRF sec
0C92  0AAC     INCF sec, F
105:                           }
0C93  303C     MOVLW 0x3C
106:           
107:                           refrescadisplay = 1;
0C94  01C6     CLRF 0x46
0C95  0AC6     INCF 0x46, F
108:                           if (cuentasegundos < 60) {
0C93  303C     MOVLW 0x3C
0C96  023E     SUBWF width, W
0C97  1803     BTFSC STATUS, 0x0
0C98  2C9B     GOTO 0x49B
109:           
110:                               cuentasegundos++;
0C99  0ABE     INCF width, F
111:                           } else {
0C9A  2CB1     GOTO 0x4B1
112:                               cuentasegundos = 0;
0C9B  303C     MOVLW 0x3C
0C9C  01BE     CLRF width
113:                               if (cuentaminutos < 60) {
0C9B  303C     MOVLW 0x3C
0C9D  023D     SUBWF flag, W
0C9E  1803     BTFSC STATUS, 0x0
0C9F  2CA2     GOTO 0x4A2
114:                                   cuentaminutos++;
0CA0  0ABD     INCF flag, F
115:                               } else {
0CA1  2CB1     GOTO 0x4B1
116:                                   cuentaminutos = 0;
0CA2  3018     MOVLW 0x18
0CA3  01BD     CLRF flag
117:                                   if (cuentahoras < 24) {
0CA2  3018     MOVLW 0x18
0CA4  023C     SUBWF ap, W
0CA5  1803     BTFSC STATUS, 0x0
0CA6  2CA9     GOTO 0x4A9
118:                                       cuentahoras++;
0CA7  0ABC     INCF ap, F
119:                                   } else
0CA8  2CAA     GOTO 0x4AA
120:                                       cuentahoras = 0;
0CA9  01BC     CLRF ap
121:                                   if (cuentadias < 30) {
0CAA  301E     MOVLW 0x1E
0CAB  023B     SUBWF prec, W
0CAC  1803     BTFSC STATUS, 0x0
0CAD  2CB0     GOTO 0x4B0
122:                                       cuentadias++;
0CAE  0ABB     INCF prec, F
123:                                   } else {
0CAF  2CB1     GOTO 0x4B1
124:                                       cuentadias = 0;
0CB0  01BB     CLRF prec
125:                                   }
126:                               }
127:           
128:                           }
129:                       }
130:                   }
131:                   // <editor-fold defaultstate="collapsed" desc="boton subir">
132:                   static char maximodia;
133:                   if (Pulsacion(0, BOTON_Subir, CON_REPETICION, LOGICA_INVERSA)) {
0CB1  3000     MOVLW 0x0
0CB2  1283     BCF STATUS, 0x5
0CB3  1906     BTFSC PORTB, 0x2
0CB4  3001     MOVLW 0x1
0CB5  00F5     MOVWF Pin
0CB6  3000     MOVLW 0x0
0CB7  01F6     CLRF TipoPin
0CB8  0AF6     INCF TipoPin, F
0CB9  01F7     CLRF Logica
0CBA  0AF7     INCF Logica, F
0CBB  2714     CALL 0x714
0CBC  120A     BCF PCLATH, 0x4
0CBD  158A     BSF PCLATH, 0x3
0CBE  3A00     XORLW 0x0
0CBF  1903     BTFSC STATUS, 0x2
0CC0  2DAA     GOTO 0x5AA
134:                       if (menuactual == MENU_INICIAL) {
0CC1  1683     BSF STATUS, 0x5
0CC2  1303     BCF STATUS, 0x6
0CC3  08C4     MOVF sp, F
0CC4  1D03     BTFSS STATUS, 0x2
0CC5  2CC8     GOTO 0x4C8
135:                           reseteafallas = FALLARESETEADA;
0CC6  01E6     CLRF 0x66
0CC7  0AE6     INCF 0x66, F
136:                       }
0CC8  300F     MOVLW 0xF
137:                       haycambio = 1;
0CC9  01C1     CLRF _val
0CCA  0AC1     INCF _val, F
138:                       tiempoapagadolcd = 15;
0CC8  300F     MOVLW 0xF
0CCB  00C8     MOVWF 0x48
139:                       tiemporegresaamenuinicial = 30; //espero 30 segundos antes de volver al menuinicial
0CCC  301E     MOVLW 0x1E
0CCD  00CB     MOVWF 0x4B
140:                       refrescadisplay = 1;
0CCE  01C6     CLRF 0x46
0CCF  0AC6     INCF 0x46, F
141:                       switch (modificafecha) {
0CD0  2D51     GOTO 0x551
0D51  0865     MOVF 0x65, W
0D52  0084     MOVWF FSR
0D53  300A     MOVLW 0xA
0D54  0204     SUBWF FSR, W
0D55  1803     BTFSC STATUS, 0x0
0D56  2D5E     GOTO 0x55E
0D57  3010     MOVLW 0x10
0D58  008A     MOVWF PCLATH
0D59  1003     BCF STATUS, 0x0
0D5A  0D04     RLF FSR, W
0D5B  0704     ADDWF FSR, W
0D5C  3E00     ADDLW 0x0
0D5D  0082     MOVWF PCL
1000  120A     BCF PCLATH, 0x4
1001  158A     BSF PCLATH, 0x3
1002  2CE0     GOTO 0x4E0
1003  120A     BCF PCLATH, 0x4
1004  158A     BSF PCLATH, 0x3
1005  2CD1     GOTO 0x4D1
1006  120A     BCF PCLATH, 0x4
1007  158A     BSF PCLATH, 0x3
1008  2CF8     GOTO 0x4F8
1009  120A     BCF PCLATH, 0x4
100A  158A     BSF PCLATH, 0x3
100B  2D04     GOTO 0x504
100C  120A     BCF PCLATH, 0x4
100D  158A     BSF PCLATH, 0x3
100E  2D10     GOTO 0x510
100F  120A     BCF PCLATH, 0x4
1010  158A     BSF PCLATH, 0x3
1011  2D5E     GOTO 0x55E
1012  120A     BCF PCLATH, 0x4
1013  158A     BSF PCLATH, 0x3
1014  2D1D     GOTO 0x51D
1015  120A     BCF PCLATH, 0x4
1016  158A     BSF PCLATH, 0x3
1017  2D2D     GOTO 0x52D
1018  120A     BCF PCLATH, 0x4
1019  158A     BSF PCLATH, 0x3
101A  2D39     GOTO 0x539
101B  120A     BCF PCLATH, 0x4
101C  158A     BSF PCLATH, 0x3
101D  2D45     GOTO 0x545
142:                           case MINUTOS:
143:                               //haycambio = 1;
144:                               if ((*horario).min < 59) (*horario).min++;
0CD1  0A7D     INCF horario, W
0CD2  0084     MOVWF FSR
0CD3  303B     MOVLW 0x3B
0CD4  1383     BCF STATUS, 0x7
0CD5  0200     SUBWF INDF, W
0CD6  0A7D     INCF horario, W
0CD8  1C03     BTFSS STATUS, 0x0
0CD9  2CEB     GOTO 0x4EB
145:                               else
146:                                   if ((*horario).min == 59) (*horario).min = 0;
0CD7  0084     MOVWF FSR
0CDA  0800     MOVF INDF, W
0CDB  3A3B     XORLW 0x3B
0CDC  1D03     BTFSS STATUS, 0x2
0CDD  2D5E     GOTO 0x55E
0CDE  0A7D     INCF horario, W
0CDF  2CF5     GOTO 0x4F5
147:                               break;
148:                           case HORA:
149:                               //haycambio = 1;
150:                               if ((*horario).hrs < 23) (*horario).hrs++;
0CE0  087D     MOVF horario, W
0CE1  3E02     ADDLW 0x2
0CE2  0084     MOVWF FSR
0CE3  3017     MOVLW 0x17
0CE4  1383     BCF STATUS, 0x7
0CE5  0200     SUBWF INDF, W
0CE6  087D     MOVF horario, W
0CE7  1803     BTFSC STATUS, 0x0
0CE8  2CED     GOTO 0x4ED
0CE9  3E02     ADDLW 0x2
0CEA  0084     MOVWF FSR
0CEB  0A80     INCF INDF, F
0CEC  2D5E     GOTO 0x55E
151:                               else
152:                                   if ((*horario).hrs == 23) (*horario).hrs = 0;
0CED  3E02     ADDLW 0x2
0CEE  0084     MOVWF FSR
0CEF  0800     MOVF INDF, W
0CF0  3A17     XORLW 0x17
0CF1  1D03     BTFSS STATUS, 0x2
0CF2  2D5E     GOTO 0x55E
0CF3  087D     MOVF horario, W
0CF4  3E02     ADDLW 0x2
0CF5  0084     MOVWF FSR
0CF6  0180     CLRF INDF
0CF7  2D5E     GOTO 0x55E
153:                               break;
154:                           case DIA:
155:                               //haycambio = 1;
156:                               if (fecha.day < maximodia) fecha.day++;
0CF8  1283     BCF STATUS, 0x5
0CF9  086B     MOVF maximodia, W
0CFA  026C     SUBWF fecha, W
0CFB  1C03     BTFSS STATUS, 0x0
0CFC  2D02     GOTO 0x502
157:                               else
158:                                   if (fecha.day == maximodia) fecha.day = 1;
0CFD  086C     MOVF fecha, W
0CFE  066B     XORWF maximodia, W
0CFF  1D03     BTFSS STATUS, 0x2
0D00  2D5E     GOTO 0x55E
0D01  01EC     CLRF fecha
0D02  0AEC     INCF fecha, F
0D03  2D5E     GOTO 0x55E
159:                               break;
160:                           case MES:
161:                               //haycambio = 1;
162:                               if (fecha.month < 12) fecha.month++;
0D04  300C     MOVLW 0xC
0D05  1283     BCF STATUS, 0x5
0D06  026D     SUBWF 0x6D, W
0D07  1C03     BTFSS STATUS, 0x0
0D08  2D0E     GOTO 0x50E
163:                               else
164:                                   if (fecha.month == 12) fecha.month = 1;
0D09  086D     MOVF 0x6D, W
0D0A  3A0C     XORLW 0xC
0D0B  1D03     BTFSS STATUS, 0x2
0D0C  2D5E     GOTO 0x55E
0D0D  01ED     CLRF 0x6D
0D0E  0AED     INCF 0x6D, F
0D0F  2D5E     GOTO 0x55E
165:                               break;
166:                           case ANIO:
167:                               //haycambio = 1;
168:                               if (fecha.yr < 99) fecha.yr++; //solamente vamos hasta el ao 00
0D10  3063     MOVLW 0x63
0D11  1283     BCF STATUS, 0x5
0D12  026E     SUBWF 0x6E, W
0D13  1803     BTFSC STATUS, 0x0
0D14  2D17     GOTO 0x517
0D15  0AEE     INCF 0x6E, F
0D16  2D5E     GOTO 0x55E
169:                               else
170:                                   if (fecha.yr == 99) fecha.yr = 0; //solamente contamos desde el ao 99
0D17  086E     MOVF 0x6E, W
0D18  3A63     XORLW 0x63
0D19  1D03     BTFSS STATUS, 0x2
0D1A  2D5E     GOTO 0x55E
0D1B  01EE     CLRF 0x6E
0D1C  2D5E     GOTO 0x55E
171:                               break;
172:                           case SINO:
173:                               *banderasino = !*banderasino;
0D1D  0836     MOVF 0x36, W
0D1E  0084     MOVWF FSR
0D1F  3000     MOVLW 0x0
0D20  1383     BCF STATUS, 0x7
0D21  0880     MOVF INDF, F
0D22  1903     BTFSC STATUS, 0x2
0D23  3001     MOVLW 0x1
0D24  1283     BCF STATUS, 0x5
0D25  00A0     MOVWF 0x20
0D26  1683     BSF STATUS, 0x5
0D27  0836     MOVF 0x36, W
0D28  0084     MOVWF FSR
0D29  1283     BCF STATUS, 0x5
0D2A  0820     MOVF 0x20, W
0D2B  0080     MOVWF INDF
174:                               break;
0D2C  2D5E     GOTO 0x55E
175:                           case TIEMPOENCENDIDO:
176:                               //haycambio = 1;
177:                               if (tiempoencendido < TIEMPOMAXIMOENCENDIDO) tiempoencendido++; //
0D2D  303C     MOVLW 0x3C
0D2E  0249     SUBWF f2, W
0D2F  1803     BTFSC STATUS, 0x0
0D30  2D33     GOTO 0x533
0D31  0AC9     INCF f2, F
0D32  2D5E     GOTO 0x55E
178:                               else
179:                                   if (tiempoencendido == TIEMPOMAXIMOENCENDIDO) tiempoencendido = 0;
0D33  0849     MOVF f2, W
0D34  3A3C     XORLW 0x3C
0D35  1D03     BTFSS STATUS, 0x2
0D36  2D5E     GOTO 0x55E
0D37  01C9     CLRF f2
0D38  2D5E     GOTO 0x55E
180:                               break;
181:                           case TIEMPOFALLA:
182:                               //haycambio = 1;
183:                               if (tiempofalla < TIEMPOMAXIMOFALLA) tiempofalla++; //
0D39  300A     MOVLW 0xA
0D3A  024A     SUBWF 0x4A, W
0D3B  1803     BTFSC STATUS, 0x0
0D3C  2D3F     GOTO 0x53F
0D3D  0ACA     INCF 0x4A, F
0D3E  2D5E     GOTO 0x55E
184:                               else
185:                                   if (tiempofalla == TIEMPOMAXIMOFALLA) tiempofalla = 0;
0D3F  084A     MOVF 0x4A, W
0D40  3A0A     XORLW 0xA
0D41  1D03     BTFSS STATUS, 0x2
0D42  2D5E     GOTO 0x55E
0D43  01CA     CLRF 0x4A
0D44  2D5E     GOTO 0x55E
186:                               break;
187:                           case PERIODOENCENDIDO:
188:                               //haycambio = 1;
189:                               if (periodoencendido < TIEMPOMAXIMOPERIODO) periodoencendido++; //
0D45  3006     MOVLW 0x6
0D46  0245     SUBWF f1, W
0D47  1803     BTFSC STATUS, 0x0
0D48  2D4B     GOTO 0x54B
0D49  0AC5     INCF f1, F
0D4A  2D5E     GOTO 0x55E
190:                               else
191:                                   if (periodoencendido == TIEMPOMAXIMOPERIODO) periodoencendido = 0;
0D4B  0845     MOVF f1, W
0D4C  3A06     XORLW 0x6
0D4D  1D03     BTFSS STATUS, 0x2
0D4E  2D5E     GOTO 0x55E
0D4F  01C5     CLRF f1
0D50  2D5E     GOTO 0x55E
192:                               break;
193:                           default:
194:                               break;
195:                       }
196:                       if (aniobisiesto(fecha.yr) && fecha.month == 2) {
0D5E  1283     BCF STATUS, 0x5
0D5F  086E     MOVF 0x6E, W
0D60  120A     BCF PCLATH, 0x4
0D61  118A     BCF PCLATH, 0x3
0D62  2751     CALL 0x751
0D63  120A     BCF PCLATH, 0x4
0D64  158A     BSF PCLATH, 0x3
0D65  0877     MOVF Logica, W
0D66  0476     IORWF TipoPin, W
0D67  1903     BTFSC STATUS, 0x2
0D68  2D6F     GOTO 0x56F
0D69  086D     MOVF 0x6D, W
0D6A  3A02     XORLW 0x2
0D6B  1D03     BTFSS STATUS, 0x2
0D6C  2D6F     GOTO 0x56F
197:                           maximodia = 29;
0D6D  301D     MOVLW 0x1D
0D6E  2D74     GOTO 0x574
198:                       } else if (fecha.month == 2)
0D6F  086D     MOVF 0x6D, W
0D70  3A02     XORLW 0x2
0D71  1D03     BTFSS STATUS, 0x2
0D72  2D75     GOTO 0x575
199:                           maximodia = 28;
0D73  301C     MOVLW 0x1C
0D74  00EB     MOVWF maximodia
200:                       if (fecha.month == 4 || fecha.month == 6 || fecha.month == 9 || fecha.month == 11) {
0D75  086D     MOVF 0x6D, W
0D76  3A04     XORLW 0x4
0D77  1903     BTFSC STATUS, 0x2
0D78  2D85     GOTO 0x585
0D79  086D     MOVF 0x6D, W
0D7A  3A06     XORLW 0x6
0D7B  1903     BTFSC STATUS, 0x2
0D7C  2D85     GOTO 0x585
0D7D  086D     MOVF 0x6D, W
0D7E  3A09     XORLW 0x9
0D7F  1903     BTFSC STATUS, 0x2
0D80  2D85     GOTO 0x585
0D81  086D     MOVF 0x6D, W
0D82  3A0B     XORLW 0xB
0D83  1D03     BTFSS STATUS, 0x2
0D84  2D87     GOTO 0x587
201:                           maximodia = 30;
0D85  301E     MOVLW 0x1E
0D86  00EB     MOVWF maximodia
202:                       }
203:                       if (fecha.month == 1 || fecha.month == 3 || fecha.month == 5 || fecha.month == 7 || fecha.month == 8 || fecha.month == 10 || fecha.month == 12) {
0D87  036D     DECF 0x6D, W
0D88  1903     BTFSC STATUS, 0x2
0D89  2DA2     GOTO 0x5A2
0D8A  086D     MOVF 0x6D, W
0D8B  3A03     XORLW 0x3
0D8C  1903     BTFSC STATUS, 0x2
0D8D  2DA2     GOTO 0x5A2
0D8E  086D     MOVF 0x6D, W
0D8F  3A05     XORLW 0x5
0D90  1903     BTFSC STATUS, 0x2
0D91  2DA2     GOTO 0x5A2
0D92  086D     MOVF 0x6D, W
0D93  3A07     XORLW 0x7
0D94  1903     BTFSC STATUS, 0x2
0D95  2DA2     GOTO 0x5A2
0D96  086D     MOVF 0x6D, W
0D97  3A08     XORLW 0x8
0D98  1903     BTFSC STATUS, 0x2
0D99  2DA2     GOTO 0x5A2
0D9A  086D     MOVF 0x6D, W
0D9B  3A0A     XORLW 0xA
0D9C  1903     BTFSC STATUS, 0x2
0D9D  2DA2     GOTO 0x5A2
0D9E  086D     MOVF 0x6D, W
0D9F  3A0C     XORLW 0xC
0DA0  1D03     BTFSS STATUS, 0x2
0DA1  2DA4     GOTO 0x5A4
204:                           maximodia = 31;
0DA2  301F     MOVLW 0x1F
0DA3  00EB     MOVWF maximodia
205:                       }
206:                       if (fecha.day > maximodia)
0DA4  086C     MOVF fecha, W
0DA5  026B     SUBWF maximodia, W
0DA6  1803     BTFSC STATUS, 0x0
0DA7  2DAA     GOTO 0x5AA
207:                           fecha.day = maximodia;
0DA8  086B     MOVF maximodia, W
0DA9  00EC     MOVWF fecha
208:                   }
209:                   // </editor-fold>
210:                   // <editor-fold defaultstate="collapsed" desc="boton bajar">
211:                   if (Pulsacion(1, BOTON_Bajar, CON_REPETICION, LOGICA_INVERSA)) {
0DAA  3000     MOVLW 0x0
0DAB  1283     BCF STATUS, 0x5
0DAC  1303     BCF STATUS, 0x6
0DAD  1886     BTFSC PORTB, 0x1
0DAE  3001     MOVLW 0x1
0DAF  00F5     MOVWF Pin
0DB0  3001     MOVLW 0x1
0DB1  01F6     CLRF TipoPin
0DB2  0AF6     INCF TipoPin, F
0DB3  01F7     CLRF Logica
0DB4  0AF7     INCF Logica, F
0DB5  2714     CALL 0x714
0DB6  120A     BCF PCLATH, 0x4
0DB7  158A     BSF PCLATH, 0x3
0DB8  3A00     XORLW 0x0
0DB9  1903     BTFSC STATUS, 0x2
0DBA  2EA1     GOTO 0x6A1
212:                       if (menuactual == MENU_INICIAL) {
0DBB  1683     BSF STATUS, 0x5
0DBC  1303     BCF STATUS, 0x6
0DBD  08C4     MOVF sp, F
0DBE  1D03     BTFSS STATUS, 0x2
0DBF  2DC2     GOTO 0x5C2
213:                           reseteafallas = FALLARESETEADA;
0DC0  01E6     CLRF 0x66
0DC1  0AE6     INCF 0x66, F
214:                       }
0DC2  300F     MOVLW 0xF
215:                       haycambio = 1;
0DC3  01C1     CLRF _val
0DC4  0AC1     INCF _val, F
216:                       tiempoapagadolcd = 15;
0DC2  300F     MOVLW 0xF
0DC5  00C8     MOVWF 0x48
217:                       tiemporegresaamenuinicial = 30; //espero 30 segundos antes de volver al menuinicial
0DC6  301E     MOVLW 0x1E
0DC7  00CB     MOVWF 0x4B
218:                       refrescadisplay = 1;
0DC8  01C6     CLRF 0x46
0DC9  0AC6     INCF 0x46, F
219:                       switch (modificafecha) {
0DCA  2E48     GOTO 0x648
0E48  0865     MOVF 0x65, W
0E49  0084     MOVWF FSR
0E4A  300A     MOVLW 0xA
0E4B  0204     SUBWF FSR, W
0E4C  1803     BTFSC STATUS, 0x0
0E4D  2E55     GOTO 0x655
0E4E  3010     MOVLW 0x10
0E4F  008A     MOVWF PCLATH
0E50  1003     BCF STATUS, 0x0
0E51  0D04     RLF FSR, W
0E52  0704     ADDWF FSR, W
0E53  3E1E     ADDLW 0x1E
0E54  0082     MOVWF PCL
101E  120A     BCF PCLATH, 0x4
101F  158A     BSF PCLATH, 0x3
1020  2DDC     GOTO 0x5DC
1021  120A     BCF PCLATH, 0x4
1022  158A     BSF PCLATH, 0x3
1023  2DCB     GOTO 0x5CB
1024  120A     BCF PCLATH, 0x4
1025  158A     BSF PCLATH, 0x3
1026  2DF3     GOTO 0x5F3
1027  120A     BCF PCLATH, 0x4
1028  158A     BSF PCLATH, 0x3
1029  2DFF     GOTO 0x5FF
102A  120A     BCF PCLATH, 0x4
102B  158A     BSF PCLATH, 0x3
102C  2E0B     GOTO 0x60B
102D  120A     BCF PCLATH, 0x4
102E  158A     BSF PCLATH, 0x3
102F  2E55     GOTO 0x655
1030  120A     BCF PCLATH, 0x4
1031  158A     BSF PCLATH, 0x3
1032  2E17     GOTO 0x617
1033  120A     BCF PCLATH, 0x4
1034  158A     BSF PCLATH, 0x3
1035  2E27     GOTO 0x627
1036  120A     BCF PCLATH, 0x4
1037  158A     BSF PCLATH, 0x3
1038  2E32     GOTO 0x632
1039  120A     BCF PCLATH, 0x4
103A  158A     BSF PCLATH, 0x3
103B  2E3D     GOTO 0x63D
103C  3FFF     ADDLW 0xFF
220:                           case MINUTOS:
221:                               //haycambio = 1;
222:                               if ((*horario).min > 0) (*horario).min--;
0DCB  0A7D     INCF horario, W
0DCC  0084     MOVWF FSR
0DCD  1383     BCF STATUS, 0x7
0DCE  0880     MOVF INDF, F
0DCF  1903     BTFSC STATUS, 0x2
0DD0  2DD3     GOTO 0x5D3
0DD1  0A7D     INCF horario, W
0DD2  2DE5     GOTO 0x5E5
223:                               else
224:                                   if ((*horario).min == 0) (*horario).min = 59;
0DD3  0A7D     INCF horario, W
0DD4  0084     MOVWF FSR
0DD5  0880     MOVF INDF, F
0DD6  1D03     BTFSS STATUS, 0x2
0DD7  2E55     GOTO 0x655
0DD8  0A7D     INCF horario, W
0DD9  0084     MOVWF FSR
0DDA  303B     MOVLW 0x3B
0DDB  2E25     GOTO 0x625
225:                               break;
226:                           case HORA:
227:                               //haycambio = 1;
228:                               if ((*horario).hrs > 0) (*horario).hrs--;
0DDC  087D     MOVF horario, W
0DDD  3E02     ADDLW 0x2
0DDE  0084     MOVWF FSR
0DDF  1383     BCF STATUS, 0x7
0DE0  0880     MOVF INDF, F
0DE1  1903     BTFSC STATUS, 0x2
0DE2  2DE8     GOTO 0x5E8
0DE3  087D     MOVF horario, W
0DE4  3E02     ADDLW 0x2
0DE5  0084     MOVWF FSR
0DE6  0380     DECF INDF, F
0DE7  2E55     GOTO 0x655
229:                               else
230:                                   if ((*horario).hrs == 0) (*horario).hrs = 23;
0DE8  087D     MOVF horario, W
0DE9  3E02     ADDLW 0x2
0DEA  0084     MOVWF FSR
0DEB  0880     MOVF INDF, F
0DEC  1D03     BTFSS STATUS, 0x2
0DED  2E55     GOTO 0x655
0DEE  087D     MOVF horario, W
0DEF  3E02     ADDLW 0x2
0DF0  0084     MOVWF FSR
0DF1  3017     MOVLW 0x17
0DF2  2E25     GOTO 0x625
231:                               break;
232:                           case DIA:
233:                               //haycambio = 1;
234:                               if (fecha.day > 1) fecha.day--;
0DF3  3002     MOVLW 0x2
0DF4  1283     BCF STATUS, 0x5
0DF5  026C     SUBWF fecha, W
0DF6  1C03     BTFSS STATUS, 0x0
0DF7  2DFA     GOTO 0x5FA
0DF8  03EC     DECF fecha, F
0DF9  2E55     GOTO 0x655
235:                               else
236:                                   if (fecha.day == 1) fecha.day = maximodia;
0DFA  0B6C     DECFSZ fecha, W
0DFB  2E55     GOTO 0x655
0DFC  086B     MOVF maximodia, W
0DFD  00EC     MOVWF fecha
0DFE  2E55     GOTO 0x655
237:                               break;
238:                           case MES:
239:                               //haycambio = 1;
240:                               if (fecha.month > 1) fecha.month--;
0DFF  3002     MOVLW 0x2
0E00  1283     BCF STATUS, 0x5
0E01  026D     SUBWF 0x6D, W
0E02  1C03     BTFSS STATUS, 0x0
0E03  2E06     GOTO 0x606
0E04  03ED     DECF 0x6D, F
0E05  2E55     GOTO 0x655
241:                               else
242:                                   if (fecha.month == 1) fecha.month = 12;
0E06  0B6D     DECFSZ 0x6D, W
0E07  2E55     GOTO 0x655
0E08  300C     MOVLW 0xC
0E09  00ED     MOVWF 0x6D
0E0A  2E55     GOTO 0x655
243:                               break;
244:                           case ANIO:
245:                               //haycambio = 1;
246:                               if (fecha.yr > 0) fecha.yr--; //solamente vamos hasta el ao 00
0E0B  1283     BCF STATUS, 0x5
0E0C  086E     MOVF 0x6E, W
0E0D  1903     BTFSC STATUS, 0x2
0E0E  2E11     GOTO 0x611
0E0F  03EE     DECF 0x6E, F
0E10  2E55     GOTO 0x655
247:                               else
248:                                   if (fecha.yr == 0) fecha.yr = 99; //solamente contamos desde el ao 99
0E11  08EE     MOVF 0x6E, F
0E12  1D03     BTFSS STATUS, 0x2
0E13  2E55     GOTO 0x655
0E14  3063     MOVLW 0x63
0E15  00EE     MOVWF 0x6E
0E16  2E55     GOTO 0x655
249:                               break;
250:                           case SINO:
251:                               *banderasino = !*banderasino;
0E17  0836     MOVF 0x36, W
0E18  0084     MOVWF FSR
0E19  3000     MOVLW 0x0
0E1A  1383     BCF STATUS, 0x7
0E1B  0880     MOVF INDF, F
0E1C  1903     BTFSC STATUS, 0x2
0E1D  3001     MOVLW 0x1
0E1E  1283     BCF STATUS, 0x5
0E1F  00A0     MOVWF 0x20
0E20  1683     BSF STATUS, 0x5
0E21  0836     MOVF 0x36, W
0E22  0084     MOVWF FSR
0E23  1283     BCF STATUS, 0x5
0E24  0820     MOVF 0x20, W
0E25  0080     MOVWF INDF
252:                               break;
0E26  2E55     GOTO 0x655
253:                           case TIEMPOENCENDIDO:
254:                               //haycambio = 1;
255:                               if (tiempoencendido > 0) tiempoencendido--; //
0E27  0849     MOVF f2, W
0E28  1903     BTFSC STATUS, 0x2
0E29  2E2C     GOTO 0x62C
0E2A  03C9     DECF f2, F
0E2B  2E55     GOTO 0x655
256:                               else
257:                                   if (tiempoencendido == 0) tiempoencendido = TIEMPOMAXIMOENCENDIDO;
0E2C  08C9     MOVF f2, F
0E2D  1D03     BTFSS STATUS, 0x2
0E2E  2E55     GOTO 0x655
0E2F  303C     MOVLW 0x3C
0E30  00C9     MOVWF f2
0E31  2E55     GOTO 0x655
258:                               break;
259:                           case TIEMPOFALLA:
260:                               //haycambio = 1;
261:                               if (tiempofalla > 0) tiempofalla--; //
0E32  084A     MOVF 0x4A, W
0E33  1903     BTFSC STATUS, 0x2
0E34  2E37     GOTO 0x637
0E35  03CA     DECF 0x4A, F
0E36  2E55     GOTO 0x655
262:                               else
263:                                   if (tiempofalla == 0) tiempofalla = TIEMPOMAXIMOFALLA;
0E37  08CA     MOVF 0x4A, F
0E38  1D03     BTFSS STATUS, 0x2
0E39  2E55     GOTO 0x655
0E3A  300A     MOVLW 0xA
0E3B  00CA     MOVWF 0x4A
0E3C  2E55     GOTO 0x655
264:                               break;
265:                           case PERIODOENCENDIDO:
266:                               //haycambio = 1;
267:                               if (periodoencendido > 0) periodoencendido--; //
0E3D  0845     MOVF f1, W
0E3E  1903     BTFSC STATUS, 0x2
0E3F  2E42     GOTO 0x642
0E40  03C5     DECF f1, F
0E41  2E55     GOTO 0x655
268:                               else
269:                                   if (periodoencendido == 0) periodoencendido = TIEMPOMAXIMOPERIODO;
0E42  08C5     MOVF f1, F
0E43  1D03     BTFSS STATUS, 0x2
0E44  2E55     GOTO 0x655
0E45  3006     MOVLW 0x6
0E46  00C5     MOVWF f1
0E47  2E55     GOTO 0x655
270:                               break;
271:                           default:
272:                               break;
273:                       }
274:                       if (aniobisiesto(fecha.yr) && fecha.month == 2) {
0E55  1283     BCF STATUS, 0x5
0E56  086E     MOVF 0x6E, W
0E57  120A     BCF PCLATH, 0x4
0E58  118A     BCF PCLATH, 0x3
0E59  2751     CALL 0x751
0E5A  120A     BCF PCLATH, 0x4
0E5B  158A     BSF PCLATH, 0x3
0E5C  0877     MOVF Logica, W
0E5D  0476     IORWF TipoPin, W
0E5E  1903     BTFSC STATUS, 0x2
0E5F  2E66     GOTO 0x666
0E60  086D     MOVF 0x6D, W
0E61  3A02     XORLW 0x2
0E62  1D03     BTFSS STATUS, 0x2
0E63  2E66     GOTO 0x666
275:                           maximodia = 29;
0E64  301D     MOVLW 0x1D
0E65  2E6B     GOTO 0x66B
276:                       } else if (fecha.month == 2)
0E66  086D     MOVF 0x6D, W
0E67  3A02     XORLW 0x2
0E68  1D03     BTFSS STATUS, 0x2
0E69  2E6C     GOTO 0x66C
277:                           maximodia = 28;
0E6A  301C     MOVLW 0x1C
0E6B  00EB     MOVWF maximodia
278:                       if (fecha.month == 4 || fecha.month == 6 || fecha.month == 9 || fecha.month == 11) {
0E6C  086D     MOVF 0x6D, W
0E6D  3A04     XORLW 0x4
0E6E  1903     BTFSC STATUS, 0x2
0E6F  2E7C     GOTO 0x67C
0E70  086D     MOVF 0x6D, W
0E71  3A06     XORLW 0x6
0E72  1903     BTFSC STATUS, 0x2
0E73  2E7C     GOTO 0x67C
0E74  086D     MOVF 0x6D, W
0E75  3A09     XORLW 0x9
0E76  1903     BTFSC STATUS, 0x2
0E77  2E7C     GOTO 0x67C
0E78  086D     MOVF 0x6D, W
0E79  3A0B     XORLW 0xB
0E7A  1D03     BTFSS STATUS, 0x2
0E7B  2E7E     GOTO 0x67E
279:                           maximodia = 30;
0E7C  301E     MOVLW 0x1E
0E7D  00EB     MOVWF maximodia
280:                       }
281:                       if (fecha.month == 1 || fecha.month == 3 || fecha.month == 5 || fecha.month == 7 || fecha.month == 8 || fecha.month == 10 || fecha.month == 12) {
0E7E  036D     DECF 0x6D, W
0E7F  1903     BTFSC STATUS, 0x2
0E80  2E99     GOTO 0x699
0E81  086D     MOVF 0x6D, W
0E82  3A03     XORLW 0x3
0E83  1903     BTFSC STATUS, 0x2
0E84  2E99     GOTO 0x699
0E85  086D     MOVF 0x6D, W
0E86  3A05     XORLW 0x5
0E87  1903     BTFSC STATUS, 0x2
0E88  2E99     GOTO 0x699
0E89  086D     MOVF 0x6D, W
0E8A  3A07     XORLW 0x7
0E8B  1903     BTFSC STATUS, 0x2
0E8C  2E99     GOTO 0x699
0E8D  086D     MOVF 0x6D, W
0E8E  3A08     XORLW 0x8
0E8F  1903     BTFSC STATUS, 0x2
0E90  2E99     GOTO 0x699
0E91  086D     MOVF 0x6D, W
0E92  3A0A     XORLW 0xA
0E93  1903     BTFSC STATUS, 0x2
0E94  2E99     GOTO 0x699
0E95  086D     MOVF 0x6D, W
0E96  3A0C     XORLW 0xC
0E97  1D03     BTFSS STATUS, 0x2
0E98  2E9B     GOTO 0x69B
282:                           maximodia = 31;
0E99  301F     MOVLW 0x1F
0E9A  00EB     MOVWF maximodia
283:                       }
284:                       if (fecha.day > maximodia)
0E9B  086C     MOVF fecha, W
0E9C  026B     SUBWF maximodia, W
0E9D  1803     BTFSC STATUS, 0x0
0E9E  2EA1     GOTO 0x6A1
285:                           fecha.day = maximodia;
0E9F  086B     MOVF maximodia, W
0EA0  00EC     MOVWF fecha
286:                   }
287:                   // </editor-fold>
288:                   // <editor-fold defaultstate="collapsed" desc="boton onoff">
289:           
290:           
291:                   //bandera_graba_global = 0;
292:                   if (Pulsacion(2, BOTON_ONOFF, SIN_REPETICION, LOGICA_INVERSA)) {
0EA1  3000     MOVLW 0x0
0EA2  1283     BCF STATUS, 0x5
0EA3  1303     BCF STATUS, 0x6
0EA4  1A86     BTFSC PORTB, 0x5
0EA5  3001     MOVLW 0x1
0EA6  00F5     MOVWF Pin
0EA7  3002     MOVLW 0x2
0EA8  01F6     CLRF TipoPin
0EA9  01F7     CLRF Logica
0EAA  0AF7     INCF Logica, F
0EAB  2714     CALL 0x714
0EAC  120A     BCF PCLATH, 0x4
0EAD  158A     BSF PCLATH, 0x3
0EAE  3A00     XORLW 0x0
0EAF  1903     BTFSC STATUS, 0x2
0EB0  2EC2     GOTO 0x6C2
293:                       tiempoapagadolcd = 15;
0EB1  300F     MOVLW 0xF
0EB2  1683     BSF STATUS, 0x5
0EB3  1303     BCF STATUS, 0x6
0EB4  00C8     MOVWF 0x48
294:                       tiemporegresaamenuinicial = 30; //espero 30 segundos antes de volver al menuinicial
0EB5  301E     MOVLW 0x1E
0EB6  00CB     MOVWF 0x4B
295:                       if (menuactual == MENU_INICIAL) {
0EB7  08C4     MOVF sp, F
0EB8  1D03     BTFSS STATUS, 0x2
0EB9  2EC0     GOTO 0x6C0
296:                           bandera_orden_on_off_bomba = !bandera_orden_on_off_bomba;
0EBA  3000     MOVLW 0x0
0EBB  08B5     MOVF 0x35, F
0EBC  1903     BTFSC STATUS, 0x2
0EBD  3001     MOVLW 0x1
0EBE  00B5     MOVWF 0x35
297:                       } else {
0EBF  2EC2     GOTO 0x6C2
298:                           bandera_graba_global = 1;
0EC0  01AF     CLRF counter
0EC1  0AAF     INCF counter, F
299:                       }
300:                   }
301:                   // </editor-fold>
302:                   // <editor-fold defaultstate="collapsed" desc="boton menu">
303:                   if (Pulsacion(3, BOTON_MENU, SIN_REPETICION, LOGICA_INVERSA)) {
0EC2  3000     MOVLW 0x0
0EC3  1283     BCF STATUS, 0x5
0EC4  1303     BCF STATUS, 0x6
0EC5  1986     BTFSC PORTB, 0x3
0EC6  3001     MOVLW 0x1
0EC7  00F5     MOVWF Pin
0EC8  3003     MOVLW 0x3
0EC9  01F6     CLRF TipoPin
0ECA  01F7     CLRF Logica
0ECB  0AF7     INCF Logica, F
0ECC  2714     CALL 0x714
0ECD  120A     BCF PCLATH, 0x4
0ECE  158A     BSF PCLATH, 0x3
0ECF  3A00     XORLW 0x0
0ED0  1903     BTFSC STATUS, 0x2
0ED1  2EE4     GOTO 0x6E4
304:                       tiempoapagadolcd = 15;
0ED2  300F     MOVLW 0xF
0ED3  1683     BSF STATUS, 0x5
0ED4  1303     BCF STATUS, 0x6
0ED5  00C8     MOVWF 0x48
305:                       tiemporegresaamenuinicial = 30; //espero 30 segundos antes de volver al menuinicial
0ED6  301E     MOVLW 0x1E
0ED7  00CB     MOVWF 0x4B
306:                       buzzer_on(3);
0ED8  3003     MOVLW 0x3
0ED9  27E1     CALL 0x7E1
0EDA  120A     BCF PCLATH, 0x4
0EDB  158A     BSF PCLATH, 0x3
307:                       if (menuactual < ULTIMOMENU)
0EDC  300D     MOVLW 0xD
0EDD  1683     BSF STATUS, 0x5
0EDE  0244     SUBWF sp, W
0EDF  1803     BTFSC STATUS, 0x0
0EE0  2EE3     GOTO 0x6E3
308:                           menuactual++;
0EE1  0AC4     INCF sp, F
0EE2  2EE4     GOTO 0x6E4
309:                       else
310:                           menuactual = 0;
0EE3  01C4     CLRF sp
311:                   }
312:                   // </editor-fold>
313:                   // <editor-fold defaultstate="collapsed" desc="boton manaut">
314:                   if (Pulsacion(4, BOTON_MANAUT, SIN_REPETICION, LOGICA_INVERSA)) {
0EE4  3000     MOVLW 0x0
0EE5  1283     BCF STATUS, 0x5
0EE6  1303     BCF STATUS, 0x6
0EE7  1A06     BTFSC PORTB, 0x4
0EE8  3001     MOVLW 0x1
0EE9  00F5     MOVWF Pin
0EEA  3004     MOVLW 0x4
0EEB  01F6     CLRF TipoPin
0EEC  01F7     CLRF Logica
0EED  0AF7     INCF Logica, F
0EEE  2714     CALL 0x714
0EEF  120A     BCF PCLATH, 0x4
0EF0  158A     BSF PCLATH, 0x3
0EF1  3A00     XORLW 0x0
0EF2  1903     BTFSC STATUS, 0x2
0EF3  2F08     GOTO 0x708
315:                       tiempoapagadolcd = 15;
0EF4  300F     MOVLW 0xF
0EF5  1683     BSF STATUS, 0x5
0EF6  1303     BCF STATUS, 0x6
0EF7  00C8     MOVWF 0x48
316:                       tiemporegresaamenuinicial = 30; //espero 30 segundos antes de volver al menuinicial
0EF8  301E     MOVLW 0x1E
0EF9  00CB     MOVWF 0x4B
317:                       if (menuactual == MENU_INICIAL) {
0EFA  08C4     MOVF sp, F
0EFB  1D03     BTFSS STATUS, 0x2
0EFC  2F05     GOTO 0x705
318:                           bandera_orden_on_off_bomba = 0;
0EFE  01B5     CLRF 0x35
319:                           bandera_orden_Alarma_bomba = 0;
0EFF  01B4     CLRF 0x34
320:                           manual_automatico = !manual_automatico;
0EFD  3000     MOVLW 0x0
0F00  08E4     MOVF f3, F
0F01  1903     BTFSC STATUS, 0x2
0F02  3001     MOVLW 0x1
0F03  00E4     MOVWF f3
321:                       } else {
0F04  2F06     GOTO 0x706
322:                           //Si no est en el men inicial, la pulsacin hace que se vuelva al men inicial(tecla ESC)
323:                           menuactual = MENU_INICIAL;
0F05  01C4     CLRF sp
324:                       }
325:                       buzzer_on(3);
0F06  3003     MOVLW 0x3
0F07  27E1     CALL 0x7E1
326:           
327:                   }
328:                   // </editor-fold>
329:                   T0IF = 0;
0F08  110B     BCF INTCON, 0x2
330:                   // </editor-fold>
331:               } else {
332:                   ///interrupciones no contempladas
333:               }
334:           }
0F09  1283     BCF STATUS, 0x5
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/adcPic16.c  ---------------------------
1:             #include <xc.h>
2:             #include <stdint.h>
3:             #include <stdbool.h>
4:             #include "system.h"
5:             #include "user.h"
6:             #include "adcPic16.h"
7:             
8:             void setADCChannel(char canal) {
07F3  00F1     MOVWF canal
1FF5  00A5     MOVWF dato
9:                 ADCON0bits.CHS = canal; //Selecciono el canal AD0
07F4  00F0     MOVWF tiempo
07F5  0DF0     RLF tiempo, F
07F6  0DF0     RLF tiempo, F
07F7  0DF0     RLF tiempo, F
07F8  1283     BCF STATUS, 0x5
07F9  1303     BCF STATUS, 0x6
07FA  081F     MOVF ADCON0, W
07FB  0670     XORWF tiempo, W
07FC  39C7     ANDLW 0xC7
07FD  0670     XORWF tiempo, W
07FE  009F     MOVWF ADCON0
1FF6  00A4     MOVWF x
1FF7  0DA4     RLF x, F
1FF8  0DA4     RLF x, F
1FF9  0DA4     RLF x, F
1FFA  081F     MOVF ADCON0, W
1FFB  0624     XORWF x, W
1FFC  39C7     ANDLW 0xC7
1FFD  0624     XORWF x, W
1FFE  009F     MOVWF ADCON0
10:            };
07FF  0008     RETURN
11:            
12:            char getADCChannel(void) {
13:                return ADCON0bits.CHS; //Selecciono el canal AD0
0FE9  1283     BCF STATUS, 0x5
0FEA  0C1F     RRF ADCON0, W
0FEB  00F0     MOVWF tiempo
0FEC  0CF0     RRF tiempo, F
0FED  0C70     RRF tiempo, W
0FEE  3907     ANDLW 0x7
14:            };
0FEF  0008     RETURN
15:            
16:            void openADC(void) {
17:            
18:                TRISA0 = 1; //configuro como entrada para el ADC0
1041  1683     BSF STATUS, 0x5
1042  1303     BCF STATUS, 0x6
1043  1405     BSF PORTA, 0x0
19:                TRISA1 = 1; //configuro como entrada para el ADC1
1044  1485     BSF PORTA, 0x1
20:                TRISA3 = 1; //Configuro como entrada para Vref+
1045  1585     BSF PORTA, 0x3
21:                TRISA2 = 0; //No usado
1046  1105     BCF PORTA, 0x2
22:                TRISA4 = 0;//No usado
1047  1205     BCF PORTA, 0x4
23:                TRISA5 = 0;//No usado
1048  1285     BCF PORTA, 0x5
24:                ADCON1bits.PCFG = 0b101; //An3 como VREF+ , AN0 y AN1 como entrada analogica, AN0 Corriente, AN1 Tension de red
1049  081F     MOVF ADCON0, W
104A  39F0     ANDLW 0xF0
104B  3805     IORLW 0x5
104C  009F     MOVWF ADCON0
25:                ADCON1bits.ADFM = 1; //justificado a la derecha
104D  179F     BSF ADCON0, 0x7
26:                ADCON1bits.ADCS2 = 1;
104E  171F     BSF ADCON0, 0x6
27:                ADCON0bits.ADCS = 0b10; //Tosc/64
104F  1283     BCF STATUS, 0x5
1050  081F     MOVF ADCON0, W
1051  393F     ANDLW 0x3F
1052  3880     IORLW 0x80
1053  009F     MOVWF ADCON0
28:                ADCON0bits.ADON = 1; //Activo el ADC
1054  141F     BSF ADCON0, 0x0
29:            
30:            }
1055  0008     RETURN
31:            
32:            unsigned int adcRead(void) {
33:            
34:                return ((unsigned int) ADRESH << 8) | ADRESL;
0FDA  081E     MOVF ADRESH, W
0FDB  00F1     MOVWF canal
0FDC  01F0     CLRF tiempo
0FDD  1683     BSF STATUS, 0x5
0FDE  081E     MOVF ADRESH, W
0FDF  04F0     IORWF tiempo, F
35:            }
0FE0  0008     RETURN
36:            
37:            void startADC(void) {
38:                ADCON0bits.GO_DONE = 1;
0FF0  1283     BCF STATUS, 0x5
0FF1  151F     BSF ADCON0, 0x2
39:            }
0FF2  0008     RETURN
40:            
41:            void interruptADC_on(void) {
42:                ADIE = 1;
0801  170C     BSF PIR1, 0x6
43:            }
0802  0008     RETURN
44:            
45:            void interruptADC_off(void) {
46:                ADIE = 0;
47:            }
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/_isl1208.c  ---------------------------
1:             //Cdigo original bajado de: http://picmania.garcia-cuervo.net/proyectos_aux_rtc.php
2:             //Gracias RedRaven
3:             ////////////////////////////////////////////////////////////////////////////////////////
4:             ///                               isl1208.C                                          ///
5:             ///                     Driver for Real Time Clock                                   ///
6:             ///                     modified by Pablo Fernando Manieri - Enero 2015              ///
7:             ///                                                                                  ///
8:             /// bool ISL1208_ready(void) - Testea si el RTC est presente                        ///
9:             /// void isl1208_init(val)                                                           ///
10:            ///                  - Enable oscillator without clearing the seconds register       ///
11:            ///                    used when PIC loses power and isl1208 run from 3V BAT         ///
12:            ///                  - Config Control Register with next parameters:                 ///
13:            ///                     isl1208_ALL_DISABLED          All disabled                   ///
14:            ///                     isl1208_OUT_ON_DISABLED_HIHG  Out to Hight on Disable Out    ///
15:            ///                     isl1208_OUT_ENABLED           Out Enabled                    ///
16:            ///                     isl1208_OUT_1_HZ              Freq. Out to 1 Hz              ///
17:            ///                     isl1208_OUT_4_KHZ             Freq. Out to 4.096 Khz         ///
18:            ///                     isl1208_OUT_8_KHZ             Freq. Out to 8.192 Khz         ///
19:            ///                     isl1208_OUT_32_KHZ            Freq. Out to 32.768 Khz        ///
20:            ///                                                                                  ///
21:            ///                     Example init:                                                ///
22:            ///                     isl1208_init(isl1208_ALL_DISABLED);                          ///
23:            ///                     isl1208_init(isl1208_OUT_ENABLED | isl1208_OUT_1_HZ);        ///
24:            ///                                                                                  ///
25:            /// void isl1208_set_date_time(day,mth,year,dow,hour,min,sec) - Set the date/time    ///
26:            ///                                                                                  ///
27:            /// void isl1208_get_date(day,mth,year,dow) - Get the date                           ///
28:            ///                                                                                  ///
29:            /// void isl1208_get_time(hr,min,sec) - Get the time                                 ///
30:            ///                                                                                  ///
31:            /// char isl1208_read_nvram_unsigned char(char addr) - Read unsigned char in address ///
32:            ///                                                                                  ///
33:            /// void isl1208_write_nvram_unsigned char(char addr, char value) - Write unsigned   ///
34:            ///                                                                  char in address ///
35:            ///                                                                                  ///
36:            /// void isl1208_get_day_of_week(char* ptr) - Get string Day Of Week                 ///
37:            ///                                                                                  ///
38:            ///                                                                                  ///
39:            ////////////////////////////////////////////////////////////////////////////////////////
40:            
41:            #include <xc.h>
42:            #include <stdio.h>
43:            #include <stdbool.h>       /* For true/false definition */
44:            #include "system.h"        /* System funct/params, like osc/peripheral config */
45:            #include "HardI2C.h"
46:            #include "_isl1208.h"
47:            #include "user.h"
48:            
49:            bool ISL1208_ready(void) {
50:                bool ack;
51:            
52:                start_i2c(); // If the write command is acknowledged,
0946  2374     CALL 0x374
0947  120A     BCF PCLATH, 0x4
0948  158A     BSF PCLATH, 0x3
53:                ack = write_i2c(isl1208_Write); // then the device is ready.
0949  30DE     MOVLW 0xDE
094A  234A     CALL 0x34A
094B  120A     BCF PCLATH, 0x4
094C  158A     BSF PCLATH, 0x3
094D  1283     BCF STATUS, 0x5
094E  00A5     MOVWF dato
54:                stop_i2c();
094F  237C     CALL 0x37C
55:                return !ack; // Invert ACK returned so TRUE = ACK OK
0950  1283     BCF STATUS, 0x5
0951  3000     MOVLW 0x0
0952  08A5     MOVF dato, F
0953  1903     BTFSC STATUS, 0x2
0954  3001     MOVLW 0x1
56:            }
0955  0008     RETURN
57:            
58:            void ISL1208_Set_status(unsigned char *SR) {
096C  1283     BCF STATUS, 0x5
096D  00A5     MOVWF dato
59:            
60:                start_i2c(); // If the write command is acknowledged,
096E  2374     CALL 0x374
096F  120A     BCF PCLATH, 0x4
0970  158A     BSF PCLATH, 0x3
61:                write_i2c(isl1208_Write); // then the device is ready.
0971  30DE     MOVLW 0xDE
0972  234A     CALL 0x34A
0973  120A     BCF PCLATH, 0x4
0974  158A     BSF PCLATH, 0x3
62:                write_i2c(0x07);
0975  3007     MOVLW 0x7
0976  234A     CALL 0x34A
0977  120A     BCF PCLATH, 0x4
0978  158A     BSF PCLATH, 0x3
63:                write_i2c(*SR);
0979  1283     BCF STATUS, 0x5
097A  0825     MOVF dato, W
097B  0084     MOVWF FSR
097C  1383     BCF STATUS, 0x7
097D  0800     MOVF INDF, W
097E  234A     CALL 0x34A
097F  120A     BCF PCLATH, 0x4
0980  158A     BSF PCLATH, 0x3
64:                stop_i2c();
0981  2B7C     GOTO 0x37C
65:            
66:            }
67:            
68:            
69:            unsigned char ISL1208_Read_status(void) {
70:                char SR;
71:                start_i2c(); // If the write command is acknowledged,
0982  2374     CALL 0x374
0983  120A     BCF PCLATH, 0x4
0984  158A     BSF PCLATH, 0x3
72:                write_i2c(isl1208_Write); // then the device is ready.
0985  30DE     MOVLW 0xDE
0986  234A     CALL 0x34A
0987  120A     BCF PCLATH, 0x4
0988  158A     BSF PCLATH, 0x3
73:                write_i2c(0x07);
0989  3007     MOVLW 0x7
098A  234A     CALL 0x34A
098B  120A     BCF PCLATH, 0x4
098C  158A     BSF PCLATH, 0x3
74:                rstart_i2c(); 
098D  23B8     CALL 0x3B8
098E  120A     BCF PCLATH, 0x4
098F  158A     BSF PCLATH, 0x3
75:                write_i2c(isl1208_Read);
0990  30DF     MOVLW 0xDF
0991  234A     CALL 0x34A
0992  120A     BCF PCLATH, 0x4
0993  158A     BSF PCLATH, 0x3
76:                SR = read_i2c(NOACK);
0994  3001     MOVLW 0x1
0995  2384     CALL 0x384
0996  120A     BCF PCLATH, 0x4
0997  158A     BSF PCLATH, 0x3
0998  00A6     MOVWF y
77:                stop_i2c();
0999  237C     CALL 0x37C
78:                return SR;
099A  1283     BCF STATUS, 0x5
099B  0826     MOVF y, W
79:            }
099C  0008     RETURN
80:            
81:            unsigned char ISL1208_Read_Int(void) {
82:                char Int;
83:                start_i2c(); // If the write command is acknowledged,
84:                write_i2c(isl1208_Write); // then the device is ready.
85:                write_i2c(0x08);
86:                rstart_i2c();
87:                write_i2c(isl1208_Read);
88:                Int = read_i2c(NOACK);
89:                stop_i2c();
90:                return Int;
91:            }
92:            
93:            void ISL1208_Set_Int(unsigned char *Int) {
0956  1283     BCF STATUS, 0x5
0957  00A5     MOVWF dato
94:            
95:                start_i2c(); // If the write command is acknowledged,
0958  2374     CALL 0x374
0959  120A     BCF PCLATH, 0x4
095A  158A     BSF PCLATH, 0x3
96:                write_i2c(isl1208_Write); // then the device is ready.
095B  30DE     MOVLW 0xDE
095C  234A     CALL 0x34A
095D  120A     BCF PCLATH, 0x4
095E  158A     BSF PCLATH, 0x3
97:                write_i2c(0x08);
095F  3008     MOVLW 0x8
0960  234A     CALL 0x34A
0961  120A     BCF PCLATH, 0x4
0962  158A     BSF PCLATH, 0x3
98:                write_i2c(*Int);
0963  1283     BCF STATUS, 0x5
0964  0825     MOVF dato, W
0965  0084     MOVWF FSR
0966  1383     BCF STATUS, 0x7
0967  0800     MOVF INDF, W
0968  234A     CALL 0x34A
0969  120A     BCF PCLATH, 0x4
096A  158A     BSF PCLATH, 0x3
99:                stop_i2c();
096B  2B7C     GOTO 0x37C
100:              
101:           }
102:           
103:           
104:           
105:           void isl1208_init() {
092C  30F0     MOVLW 0xF0
106:           
107:           isl1208INT.ALME=1;//habilita la alarma
092D  1758     BSF f2, 0x6
108:           isl1208INT.FO=0;//deshabilita la salida de frecuencia
092C  30F0     MOVLW 0xF0
092E  05D8     ANDWF f2, F
109:           isl1208INT.FOBATB=1;//deshabilita la salida de fout/irq en modo backup
0930  1658     BSF f2, 0x4
110:           isl1208INT.IM=1;//alarma en modo irq
0931  17D8     BSF f2, 0x7
111:           isl1208INT.LPMODE=1;//deshabilita comunicacion en modo backup
0932  16D8     BSF f2, 0x5
112:           ISL1208_Set_Int(&isl1208INT.Valor);
092F  30D8     MOVLW 0xD8
0933  2956     GOTO 0x156
113:           }
114:           
115:           void isl1208_set_time(unsigned char hr, unsigned char min, unsigned char sec) {
0AC3  00AD     MOVWF hr
116:           
117:           #ifndef USE_INTERRUPTS
118:               //di();
119:           #endif
120:           
121:               sec &= 0x7F;
0AC5  13AC     BCF sec, 0x7
122:               min &= 0x7F;
0AC6  13AB     BCF Data, 0x7
123:               hr &= 0x3F;
0AC4  303F     MOVLW 0x3F
0AC7  05AD     ANDWF hr, F
124:               start_i2c();
0AC8  2374     CALL 0x374
0AC9  120A     BCF PCLATH, 0x4
0ACA  158A     BSF PCLATH, 0x3
125:               write_i2c(isl1208_Write);
0ACB  30DE     MOVLW 0xDE
0ACC  234A     CALL 0x34A
0ACD  120A     BCF PCLATH, 0x4
0ACE  158A     BSF PCLATH, 0x3
126:               write_i2c(0x07);
0ACF  3007     MOVLW 0x7
0AD0  234A     CALL 0x34A
0AD1  120A     BCF PCLATH, 0x4
0AD2  158A     BSF PCLATH, 0x3
127:               write_i2c(0b00010000);
0AD3  3010     MOVLW 0x10
0AD4  234A     CALL 0x34A
0AD5  120A     BCF PCLATH, 0x4
0AD6  158A     BSF PCLATH, 0x3
128:               stop_i2c();
0AD7  237C     CALL 0x37C
0AD8  120A     BCF PCLATH, 0x4
0AD9  158A     BSF PCLATH, 0x3
129:               start_i2c();
0ADA  2374     CALL 0x374
0ADB  120A     BCF PCLATH, 0x4
0ADC  158A     BSF PCLATH, 0x3
130:               write_i2c(isl1208_Write);
0ADD  30DE     MOVLW 0xDE
0ADE  234A     CALL 0x34A
0ADF  120A     BCF PCLATH, 0x4
0AE0  158A     BSF PCLATH, 0x3
131:               write_i2c(0x00);
0AE1  3000     MOVLW 0x0
0AE2  234A     CALL 0x34A
0AE3  120A     BCF PCLATH, 0x4
0AE4  158A     BSF PCLATH, 0x3
132:               write_i2c(isl1208_bin2bcd(sec));
0AE5  1283     BCF STATUS, 0x5
0AE6  082C     MOVF sec, W
0AE7  2362     CALL 0x362
0AE8  120A     BCF PCLATH, 0x4
0AE9  158A     BSF PCLATH, 0x3
0AEA  234A     CALL 0x34A
0AEB  120A     BCF PCLATH, 0x4
0AEC  158A     BSF PCLATH, 0x3
133:               write_i2c(isl1208_bin2bcd(min));
0AED  1283     BCF STATUS, 0x5
0AEE  082B     MOVF Data, W
0AEF  2362     CALL 0x362
0AF0  120A     BCF PCLATH, 0x4
0AF1  158A     BSF PCLATH, 0x3
0AF2  234A     CALL 0x34A
0AF3  120A     BCF PCLATH, 0x4
0AF4  158A     BSF PCLATH, 0x3
134:               write_i2c(isl1208_bin2bcd(hr) | 0b10000000);
0AF5  1283     BCF STATUS, 0x5
0AF6  082D     MOVF hr, W
0AF7  2362     CALL 0x362
0AF8  120A     BCF PCLATH, 0x4
0AF9  158A     BSF PCLATH, 0x3
0AFA  3880     IORLW 0x80
0AFB  234A     CALL 0x34A
0AFC  120A     BCF PCLATH, 0x4
0AFD  158A     BSF PCLATH, 0x3
135:               stop_i2c();
0AFE  2B7C     GOTO 0x37C
136:           
137:           #ifndef USE_INTERRUPTS
138:               //  ei();
139:           #endif
140:           
141:           }
142:           
143:           void isl1208_set_date(unsigned char* day, unsigned char* mth, unsigned char* year, unsigned char* dow) {
0AFF  00AE     MOVWF day
144:           
145:           #ifndef USE_INTERRUPTS
146:               //di();
147:           #endif
148:           
149:               start_i2c();
0B00  2374     CALL 0x374
0B01  120A     BCF PCLATH, 0x4
0B02  158A     BSF PCLATH, 0x3
150:               write_i2c(isl1208_Write);
0B03  30DE     MOVLW 0xDE
0B04  234A     CALL 0x34A
0B05  120A     BCF PCLATH, 0x4
0B06  158A     BSF PCLATH, 0x3
151:               write_i2c(0x07);
0B07  3007     MOVLW 0x7
0B08  234A     CALL 0x34A
0B09  120A     BCF PCLATH, 0x4
0B0A  158A     BSF PCLATH, 0x3
152:               write_i2c(0b00010000);
0B0B  3010     MOVLW 0x10
0B0C  234A     CALL 0x34A
0B0D  120A     BCF PCLATH, 0x4
0B0E  158A     BSF PCLATH, 0x3
153:               stop_i2c();
0B0F  237C     CALL 0x37C
0B10  120A     BCF PCLATH, 0x4
0B11  158A     BSF PCLATH, 0x3
154:               start_i2c();
0B12  2374     CALL 0x374
0B13  120A     BCF PCLATH, 0x4
0B14  158A     BSF PCLATH, 0x3
155:               write_i2c(isl1208_Write);
0B15  30DE     MOVLW 0xDE
0B16  234A     CALL 0x34A
0B17  120A     BCF PCLATH, 0x4
0B18  158A     BSF PCLATH, 0x3
156:               write_i2c(0x03);
0B19  3003     MOVLW 0x3
0B1A  234A     CALL 0x34A
0B1B  120A     BCF PCLATH, 0x4
0B1C  158A     BSF PCLATH, 0x3
157:               write_i2c(isl1208_bin2bcd(*day));
0B1D  1283     BCF STATUS, 0x5
0B1E  082E     MOVF day, W
0B1F  0084     MOVWF FSR
0B20  1383     BCF STATUS, 0x7
0B21  0800     MOVF INDF, W
0B22  2362     CALL 0x362
0B23  120A     BCF PCLATH, 0x4
0B24  158A     BSF PCLATH, 0x3
0B25  234A     CALL 0x34A
0B26  120A     BCF PCLATH, 0x4
0B27  158A     BSF PCLATH, 0x3
158:               write_i2c(isl1208_bin2bcd(*mth));
0B28  1283     BCF STATUS, 0x5
0B29  082B     MOVF Data, W
0B2A  0084     MOVWF FSR
0B2B  1383     BCF STATUS, 0x7
0B2C  0800     MOVF INDF, W
0B2D  2362     CALL 0x362
0B2E  120A     BCF PCLATH, 0x4
0B2F  158A     BSF PCLATH, 0x3
0B30  234A     CALL 0x34A
0B31  120A     BCF PCLATH, 0x4
0B32  158A     BSF PCLATH, 0x3
159:               write_i2c(isl1208_bin2bcd(*year));
0B33  1283     BCF STATUS, 0x5
0B34  082C     MOVF sec, W
0B35  0084     MOVWF FSR
0B36  1383     BCF STATUS, 0x7
0B37  0800     MOVF INDF, W
0B38  2362     CALL 0x362
0B39  120A     BCF PCLATH, 0x4
0B3A  158A     BSF PCLATH, 0x3
0B3B  234A     CALL 0x34A
0B3C  120A     BCF PCLATH, 0x4
0B3D  158A     BSF PCLATH, 0x3
160:               write_i2c(isl1208_bin2bcd(*dow));
0B3E  1283     BCF STATUS, 0x5
0B3F  082D     MOVF hr, W
0B40  0084     MOVWF FSR
0B41  1383     BCF STATUS, 0x7
0B42  0800     MOVF INDF, W
0B43  2362     CALL 0x362
0B44  120A     BCF PCLATH, 0x4
0B45  158A     BSF PCLATH, 0x3
0B46  234A     CALL 0x34A
0B47  120A     BCF PCLATH, 0x4
0B48  158A     BSF PCLATH, 0x3
161:               stop_i2c();
0B49  2B7C     GOTO 0x37C
162:           
163:           #ifndef USE_INTERRUPTS
164:               //  ei();
165:           #endif
166:           
167:           }
168:           
169:           void isl1208_get_date(unsigned char* day, unsigned char* mth, unsigned char* year, unsigned char *dow) {
0A31  00AC     MOVWF sec
170:           
171:           #ifndef USE_INTERRUPTS
172:               // di();
173:           #endif
174:           
175:               start_i2c();
0A32  2374     CALL 0x374
0A33  120A     BCF PCLATH, 0x4
0A34  158A     BSF PCLATH, 0x3
176:               write_i2c(isl1208_Write);
0A35  30DE     MOVLW 0xDE
0A36  234A     CALL 0x34A
0A37  120A     BCF PCLATH, 0x4
0A38  158A     BSF PCLATH, 0x3
177:               write_i2c(0x03);
0A39  3003     MOVLW 0x3
0A3A  234A     CALL 0x34A
0A3B  120A     BCF PCLATH, 0x4
0A3C  158A     BSF PCLATH, 0x3
178:               rstart_i2c();
0A3D  23B8     CALL 0x3B8
0A3E  120A     BCF PCLATH, 0x4
0A3F  158A     BSF PCLATH, 0x3
179:               write_i2c(isl1208_Read);
0A40  30DF     MOVLW 0xDF
0A41  234A     CALL 0x34A
0A42  120A     BCF PCLATH, 0x4
0A43  158A     BSF PCLATH, 0x3
180:               *day = isl1208_bcd2bin(read_i2c(ACK) & 0x3f);
0A44  1283     BCF STATUS, 0x5
0A45  082C     MOVF sec, W
0A46  0084     MOVWF FSR
0A47  3000     MOVLW 0x0
0A48  2384     CALL 0x384
0A49  120A     BCF PCLATH, 0x4
0A4A  158A     BSF PCLATH, 0x3
0A4B  393F     ANDLW 0x3F
0A4C  23AE     CALL 0x3AE
0A4D  120A     BCF PCLATH, 0x4
0A4E  158A     BSF PCLATH, 0x3
0A4F  1383     BCF STATUS, 0x7
0A50  0080     MOVWF INDF
181:               *mth = isl1208_bcd2bin(read_i2c(ACK) & 0x1f);
0A51  0829     MOVF mth, W
0A52  0084     MOVWF FSR
0A53  3000     MOVLW 0x0
0A54  2384     CALL 0x384
0A55  120A     BCF PCLATH, 0x4
0A56  158A     BSF PCLATH, 0x3
0A57  391F     ANDLW 0x1F
0A58  23AE     CALL 0x3AE
0A59  120A     BCF PCLATH, 0x4
0A5A  158A     BSF PCLATH, 0x3
0A5B  1383     BCF STATUS, 0x7
0A5C  0080     MOVWF INDF
182:               *year = isl1208_bcd2bin(read_i2c(ACK));
0A5D  082A     MOVF year, W
0A5E  0084     MOVWF FSR
0A5F  3000     MOVLW 0x0
0A60  2384     CALL 0x384
0A61  120A     BCF PCLATH, 0x4
0A62  158A     BSF PCLATH, 0x3
0A63  23AE     CALL 0x3AE
0A64  120A     BCF PCLATH, 0x4
0A65  158A     BSF PCLATH, 0x3
0A66  1383     BCF STATUS, 0x7
0A67  0080     MOVWF INDF
183:               *dow = isl1208_bcd2bin(read_i2c(NOACK) & 0x07);
0A68  082B     MOVF Data, W
0A69  0084     MOVWF FSR
0A6A  3001     MOVLW 0x1
0A6B  2384     CALL 0x384
0A6C  120A     BCF PCLATH, 0x4
0A6D  158A     BSF PCLATH, 0x3
0A6E  3907     ANDLW 0x7
0A6F  23AE     CALL 0x3AE
0A70  120A     BCF PCLATH, 0x4
0A71  158A     BSF PCLATH, 0x3
0A72  1383     BCF STATUS, 0x7
0A73  0080     MOVWF INDF
184:               stop_i2c();
0A74  2B7C     GOTO 0x37C
185:           #ifndef USE_INTERRUPTS
186:               // ei();
187:           #endif
188:           
189:           }
190:           
191:           void isl1208_get_time(unsigned char *hr, unsigned char* min, unsigned char *sec) {
09BF  00AB     MOVWF Data
192:           
193:           #ifndef USE_INTERRUPTS
194:               // di();
195:           #endif
196:           
197:               start_i2c();
09C0  2374     CALL 0x374
09C1  120A     BCF PCLATH, 0x4
09C2  158A     BSF PCLATH, 0x3
198:               write_i2c(isl1208_Write);
09C3  30DE     MOVLW 0xDE
09C4  234A     CALL 0x34A
09C5  120A     BCF PCLATH, 0x4
09C6  158A     BSF PCLATH, 0x3
199:               write_i2c(0x00);
09C7  3000     MOVLW 0x0
09C8  234A     CALL 0x34A
09C9  120A     BCF PCLATH, 0x4
09CA  158A     BSF PCLATH, 0x3
200:           
201:               rstart_i2c();
09CB  23B8     CALL 0x3B8
09CC  120A     BCF PCLATH, 0x4
09CD  158A     BSF PCLATH, 0x3
202:               write_i2c(isl1208_Read);
09CE  30DF     MOVLW 0xDF
09CF  234A     CALL 0x34A
09D0  120A     BCF PCLATH, 0x4
09D1  158A     BSF PCLATH, 0x3
203:               *sec = isl1208_bcd2bin(read_i2c(ACK) & 0x7f);
09D2  1283     BCF STATUS, 0x5
09D3  082A     MOVF year, W
09D4  0084     MOVWF FSR
09D5  3000     MOVLW 0x0
09D6  2384     CALL 0x384
09D7  120A     BCF PCLATH, 0x4
09D8  158A     BSF PCLATH, 0x3
09D9  397F     ANDLW 0x7F
09DA  23AE     CALL 0x3AE
09DB  120A     BCF PCLATH, 0x4
09DC  158A     BSF PCLATH, 0x3
09DD  1383     BCF STATUS, 0x7
09DE  0080     MOVWF INDF
204:               * min = isl1208_bcd2bin(read_i2c(ACK) & 0x7f);
09DF  0829     MOVF mth, W
09E0  0084     MOVWF FSR
09E1  3000     MOVLW 0x0
09E2  2384     CALL 0x384
09E3  120A     BCF PCLATH, 0x4
09E4  158A     BSF PCLATH, 0x3
09E5  397F     ANDLW 0x7F
09E6  23AE     CALL 0x3AE
09E7  120A     BCF PCLATH, 0x4
09E8  158A     BSF PCLATH, 0x3
09E9  1383     BCF STATUS, 0x7
09EA  0080     MOVWF INDF
205:               * hr = isl1208_bcd2bin(read_i2c(NOACK) & 0x3f);
09EB  082B     MOVF Data, W
09EC  0084     MOVWF FSR
09ED  3001     MOVLW 0x1
09EE  2384     CALL 0x384
09EF  120A     BCF PCLATH, 0x4
09F0  158A     BSF PCLATH, 0x3
09F1  393F     ANDLW 0x3F
09F2  23AE     CALL 0x3AE
09F3  120A     BCF PCLATH, 0x4
09F4  158A     BSF PCLATH, 0x3
09F5  1383     BCF STATUS, 0x7
09F6  0080     MOVWF INDF
206:               stop_i2c();
09F7  2B7C     GOTO 0x37C
207:           
208:           #ifndef USE_INTERRUPTS
209:               // ei();
210:           #endif
211:           
212:           }
213:           
214:           void isl1208_set_time_enc(unsigned char hr, unsigned char min, unsigned char sec) {
0A9A  00AD     MOVWF hr
215:           #ifndef USE_INTERRUPTS
216:               //di();
217:           #endif
218:               min &=0x7F;
0A9C  13AB     BCF Data, 0x7
219:               hr &= 0x3F;
0A9B  303F     MOVLW 0x3F
0A9D  05AD     ANDWF hr, F
220:               
221:               start_i2c();
0A9E  2374     CALL 0x374
0A9F  120A     BCF PCLATH, 0x4
0AA0  158A     BSF PCLATH, 0x3
222:               write_i2c(isl1208_Write);
0AA1  30DE     MOVLW 0xDE
0AA2  234A     CALL 0x34A
0AA3  120A     BCF PCLATH, 0x4
0AA4  158A     BSF PCLATH, 0x3
223:               write_i2c(0x0C);
0AA5  300C     MOVLW 0xC
0AA6  234A     CALL 0x34A
0AA7  120A     BCF PCLATH, 0x4
0AA8  158A     BSF PCLATH, 0x3
224:               write_i2c(isl1208_bin2bcd(0));
0AA9  3000     MOVLW 0x0
0AAA  2362     CALL 0x362
0AAB  120A     BCF PCLATH, 0x4
0AAC  158A     BSF PCLATH, 0x3
0AAD  234A     CALL 0x34A
0AAE  120A     BCF PCLATH, 0x4
0AAF  158A     BSF PCLATH, 0x3
225:               write_i2c(isl1208_bin2bcd(min)| 0b10000000); //habilita la alarma de minutos
0AB0  1283     BCF STATUS, 0x5
0AB1  082B     MOVF Data, W
0AB2  2362     CALL 0x362
0AB3  120A     BCF PCLATH, 0x4
0AB4  158A     BSF PCLATH, 0x3
0AB5  3880     IORLW 0x80
0AB6  234A     CALL 0x34A
0AB7  120A     BCF PCLATH, 0x4
0AB8  158A     BSF PCLATH, 0x3
226:               write_i2c(isl1208_bin2bcd(hr) | 0b10000000); //habilita la alarma de horas
0AB9  1283     BCF STATUS, 0x5
0ABA  082D     MOVF hr, W
0ABB  2362     CALL 0x362
0ABC  120A     BCF PCLATH, 0x4
0ABD  158A     BSF PCLATH, 0x3
0ABE  3880     IORLW 0x80
0ABF  234A     CALL 0x34A
0AC0  120A     BCF PCLATH, 0x4
0AC1  158A     BSF PCLATH, 0x3
227:               stop_i2c();
0AC2  2B7C     GOTO 0x37C
228:           
229:           #ifndef USE_INTERRUPTS
230:               //  ei();
231:           #endif
232:           
233:           }
234:           void isl1208_set_dow_enc(unsigned char *dow,unsigned char periodoencendido) {
0A75  00AC     MOVWF sec
235:           
236:           #ifndef USE_INTERRUPTS
237:               //di();
238:           #endif
239:               *dow &=0x07;
0A76  0084     MOVWF FSR
0A77  3007     MOVLW 0x7
0A78  1383     BCF STATUS, 0x7
0A79  0580     ANDWF INDF, F
240:               start_i2c();
0A7A  2374     CALL 0x374
0A7B  120A     BCF PCLATH, 0x4
0A7C  158A     BSF PCLATH, 0x3
241:               write_i2c(isl1208_Write);
0A7D  30DE     MOVLW 0xDE
0A7E  234A     CALL 0x34A
0A7F  120A     BCF PCLATH, 0x4
0A80  158A     BSF PCLATH, 0x3
242:               write_i2c(0x11);
0A81  3011     MOVLW 0x11
0A82  234A     CALL 0x34A
0A83  120A     BCF PCLATH, 0x4
0A84  158A     BSF PCLATH, 0x3
243:               if (periodoencendido!=0){
0A85  1283     BCF STATUS, 0x5
0A86  082B     MOVF Data, W
0A87  1903     BTFSC STATUS, 0x2
0A88  2A92     GOTO 0x292
244:               write_i2c(isl1208_bin2bcd(*dow)| 0b10000000); //habilita la alarma de dow
0A89  082C     MOVF sec, W
0A8A  0084     MOVWF FSR
0A8B  1383     BCF STATUS, 0x7
0A8C  0800     MOVF INDF, W
0A8D  2362     CALL 0x362
0A8E  120A     BCF PCLATH, 0x4
0A8F  158A     BSF PCLATH, 0x3
0A90  3880     IORLW 0x80
0A91  2A96     GOTO 0x296
245:               }else{
246:               write_i2c(isl1208_bin2bcd(0b00000000)); //deshabilita la alarma de dow cuando se debe repetir la alarma todos los dias
0A92  3000     MOVLW 0x0
0A93  2362     CALL 0x362
0A94  120A     BCF PCLATH, 0x4
0A95  158A     BSF PCLATH, 0x3
0A96  234A     CALL 0x34A
0A97  120A     BCF PCLATH, 0x4
0A98  158A     BSF PCLATH, 0x3
247:               }
248:               stop_i2c();
0A99  2B7C     GOTO 0x37C
249:           
250:           #ifndef USE_INTERRUPTS
251:               //  ei();
252:           #endif
253:           
254:           }
255:           
256:           void isl1208_get_dow_enc(unsigned char *dow) {
099D  1283     BCF STATUS, 0x5
099E  00A9     MOVWF mth
257:           
258:           #ifndef USE_INTERRUPTS
259:               //di();
260:           #endif
261:           
262:               start_i2c();
099F  2374     CALL 0x374
09A0  120A     BCF PCLATH, 0x4
09A1  158A     BSF PCLATH, 0x3
263:               write_i2c(isl1208_Write);
09A2  30DE     MOVLW 0xDE
09A3  234A     CALL 0x34A
09A4  120A     BCF PCLATH, 0x4
09A5  158A     BSF PCLATH, 0x3
264:               write_i2c(0x11);
09A6  3011     MOVLW 0x11
09A7  234A     CALL 0x34A
09A8  120A     BCF PCLATH, 0x4
09A9  158A     BSF PCLATH, 0x3
265:               rstart_i2c();
09AA  23B8     CALL 0x3B8
09AB  120A     BCF PCLATH, 0x4
09AC  158A     BSF PCLATH, 0x3
266:               write_i2c(isl1208_Read);
09AD  30DF     MOVLW 0xDF
09AE  234A     CALL 0x34A
09AF  120A     BCF PCLATH, 0x4
09B0  158A     BSF PCLATH, 0x3
267:               *dow = isl1208_bcd2bin(read_i2c(NOACK) & 0x07);
09B1  1283     BCF STATUS, 0x5
09B2  0829     MOVF mth, W
09B3  0084     MOVWF FSR
09B4  3001     MOVLW 0x1
09B5  2384     CALL 0x384
09B6  120A     BCF PCLATH, 0x4
09B7  158A     BSF PCLATH, 0x3
09B8  3907     ANDLW 0x7
09B9  23AE     CALL 0x3AE
09BA  120A     BCF PCLATH, 0x4
09BB  158A     BSF PCLATH, 0x3
09BC  1383     BCF STATUS, 0x7
09BD  0080     MOVWF INDF
268:               stop_i2c();
09BE  2B7C     GOTO 0x37C
269:           
270:           #ifndef USE_INTERRUPTS
271:               //  ei();
272:           #endif
273:           
274:           }
275:           void isl1208_get_time_enc(unsigned char *hr, unsigned char* min, unsigned char *sec) {
09F8  00AB     MOVWF Data
276:           
277:           #ifndef USE_INTERRUPTS
278:               // di();
279:           #endif
280:           
281:               start_i2c();
09F9  2374     CALL 0x374
09FA  120A     BCF PCLATH, 0x4
09FB  158A     BSF PCLATH, 0x3
282:               write_i2c(isl1208_Write);
09FC  30DE     MOVLW 0xDE
09FD  234A     CALL 0x34A
09FE  120A     BCF PCLATH, 0x4
09FF  158A     BSF PCLATH, 0x3
283:               write_i2c(0x0C);
0A00  300C     MOVLW 0xC
0A01  234A     CALL 0x34A
0A02  120A     BCF PCLATH, 0x4
0A03  158A     BSF PCLATH, 0x3
284:           
285:               rstart_i2c();
0A04  23B8     CALL 0x3B8
0A05  120A     BCF PCLATH, 0x4
0A06  158A     BSF PCLATH, 0x3
286:               write_i2c(isl1208_Read);
0A07  30DF     MOVLW 0xDF
0A08  234A     CALL 0x34A
0A09  120A     BCF PCLATH, 0x4
0A0A  158A     BSF PCLATH, 0x3
287:               *sec = isl1208_bcd2bin(read_i2c(ACK) & 0x7f);
0A0B  1283     BCF STATUS, 0x5
0A0C  082A     MOVF year, W
0A0D  0084     MOVWF FSR
0A0E  3000     MOVLW 0x0
0A0F  2384     CALL 0x384
0A10  120A     BCF PCLATH, 0x4
0A11  158A     BSF PCLATH, 0x3
0A12  397F     ANDLW 0x7F
0A13  23AE     CALL 0x3AE
0A14  120A     BCF PCLATH, 0x4
0A15  158A     BSF PCLATH, 0x3
0A16  1383     BCF STATUS, 0x7
0A17  0080     MOVWF INDF
288:               * min = isl1208_bcd2bin(read_i2c(ACK) & 0x7f);
0A18  0829     MOVF mth, W
0A19  0084     MOVWF FSR
0A1A  3000     MOVLW 0x0
0A1B  2384     CALL 0x384
0A1C  120A     BCF PCLATH, 0x4
0A1D  158A     BSF PCLATH, 0x3
0A1E  397F     ANDLW 0x7F
0A1F  23AE     CALL 0x3AE
0A20  120A     BCF PCLATH, 0x4
0A21  158A     BSF PCLATH, 0x3
0A22  1383     BCF STATUS, 0x7
0A23  0080     MOVWF INDF
289:               * hr = isl1208_bcd2bin(read_i2c(NOACK) & 0x3f);
0A24  082B     MOVF Data, W
0A25  0084     MOVWF FSR
0A26  3001     MOVLW 0x1
0A27  2384     CALL 0x384
0A28  120A     BCF PCLATH, 0x4
0A29  158A     BSF PCLATH, 0x3
0A2A  393F     ANDLW 0x3F
0A2B  23AE     CALL 0x3AE
0A2C  120A     BCF PCLATH, 0x4
0A2D  158A     BSF PCLATH, 0x3
0A2E  1383     BCF STATUS, 0x7
0A2F  0080     MOVWF INDF
290:               stop_i2c();
0A30  2B7C     GOTO 0x37C
291:           
292:           #ifndef USE_INTERRUPTS
293:               // ei();
294:           #endif
295:           
296:           }
297:           
298:           char isl1208_read_nvram_byte(char addr) {
299:           
300:               char retval;
301:           
302:           #ifndef USE_INTERRUPTS
303:               // di();
304:           #endif
305:           
306:               start_i2c();
307:               write_i2c(isl1208_Write);
308:               write_i2c(addr);
309:           
310:               start_i2c();
311:               write_i2c(isl1208_Read);
312:               retval = read_i2c(NOACK);
313:               stop_i2c();
314:           
315:           
316:           
317:           #ifndef USE_INTERRUPTS
318:               // ei();
319:           #endif
320:               return (retval);
321:           }
322:           
323:           void isl1208_write_nvram_byte(char addr, char value) {
324:           
325:           #ifndef USE_INTERRUPTS
326:               //di();
327:           #endif
328:           
329:               start_i2c();
330:               write_i2c(isl1208_Write);
331:               write_i2c(addr);
332:               write_i2c(value);
333:               stop_i2c();
334:           
335:           #ifndef USE_INTERRUPTS
336:               // ei();
337:           #endif
338:           
339:           }
340:           int aniobisiesto(unsigned char year)
0751  00FA     MOVWF j
341:           {
342:               return ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0);
0752  01F9     CLRF Indice
0753  0AF9     INCF Indice, F
0754  3903     ANDLW 0x3
0755  1D03     BTFSS STATUS, 0x2
0756  2F60     GOTO 0x760
0757  3064     MOVLW 0x64
0758  00F0     MOVWF tiempo
0759  087A     MOVF j, W
075A  2770     CALL 0x770
075B  120A     BCF PCLATH, 0x4
075C  118A     BCF PCLATH, 0x3
075D  3800     IORLW 0x0
075E  1D03     BTFSS STATUS, 0x2
075F  2F6C     GOTO 0x76C
0760  3090     MOVLW 0x90
0761  00F0     MOVWF tiempo
0762  3001     MOVLW 0x1
0763  00F1     MOVWF canal
0764  087A     MOVF j, W
0765  00F2     MOVWF dividend
0766  01F3     CLRF counter
0767  278C     CALL 0x78C
0768  0871     MOVF canal, W
0769  0470     IORWF tiempo, W
076A  1D03     BTFSS STATUS, 0x2
076B  01F9     CLRF Indice
076C  0879     MOVF Indice, W
076D  00F6     MOVWF TipoPin
076E  01F7     CLRF Logica
343:           }
076F  0008     RETURN
344:           unsigned char dia_de_la_semana(unsigned char *dia, unsigned char *mes, unsigned char *anio){
345:           //se usa el algoritmo de Zeller
346:              unsigned char a,y,m,dow;
347:           
348:              a = (14 -*mes) / 12;
349:           y = *anio - a;
350:           m = *mes + 12 * a - 2;
351:           
352:           //Para el calendario Juliano:
353:           //d = (5 + dia + y + y/4 + (31*m)/12) mod 7
354:           
355:           //Para el calendario Gregoriano:
356:            dow = (*dia + y + y/4 - y/100 + y/400 + (31*m)/12) % 7;
357:           
358:           //El resultado es un cero (0) para el domingo, 1 para el lunes? 6 para el sbado
359:           
360:            return (dow);
361:           }
362:           ///////////////////////////////////////////////////////////////////////////////
363:           
364:           unsigned char isl1208_bin2bcd(unsigned char binary_value) {
0B62  1283     BCF STATUS, 0x5
0B63  00AA     MOVWF year
365:               return ((binary_value / 10) << 4) +binary_value % 10;
0B64  300A     MOVLW 0xA
0B65  00A4     MOVWF x
0B66  082A     MOVF year, W
0B67  23C0     CALL 0x3C0
0B68  120A     BCF PCLATH, 0x4
0B69  158A     BSF PCLATH, 0x3
0B6A  00A9     MOVWF mth
0B6B  0E29     SWAPF mth, W
0B6C  39F0     ANDLW 0xF0
0B6D  00A9     MOVWF mth
0B6E  300A     MOVLW 0xA
0B6F  00A4     MOVWF x
0B70  082A     MOVF year, W
0B71  23E9     CALL 0x3E9
0B72  0729     ADDWF mth, W
366:           
367:           }
0B73  0008     RETURN
368:           
369:           unsigned char isl1208_bcd2bin(unsigned char bcd_value) {
0BAE  00A8     MOVWF i
370:               return (bcd_value & 0x0F) + (bcd_value >> 4) * 10;
0BAF  390F     ANDLW 0xF
0BB0  00A7     MOVWF x
0BB1  300A     MOVLW 0xA
0BB2  00A4     MOVWF x
0BB3  0E28     SWAPF i, W
0BB4  390F     ANDLW 0xF
0BB5  23DB     CALL 0x3DB
0BB6  0727     ADDWF x, W
371:           }
0BB7  0008     RETURN
372:           
373:           
374:           /*unsigned int ISL1208::bcd2bin(unsigned char val)
375:           {
376:               return (val & 0x0F) + (val >> 4) * 10;
377:           }
378:           
379:           char ISL1208::bin2bcd(unsigned int val)
380:           {
381:               return ((val / 10) << 4) + val % 10;
382:           }*/
383:           ///////////////////////////////////////////////////////////////////////////////
384:           
385:           
386:           
387:           
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/Pulsadores.c  -------------------------
1:             //Programa de gestin de pulsadores por Nocturno adaptado a xc8 por Pablo F. Manieri
2:             //Cdigo original bajado de: http://www.micropic.es/mpblog/2014/05/gestion-de-pulsadores/
3:             // Gracias Nocturno
4:             #include <xc.h>
5:             #include <stdint.h>
6:             #include <stdbool.h>
7:             #include "system.h"
8:             #include "user.h"
9:             #include "Pulsadores.h"
10:            
11:            /****** HARDWARE ********
12:            BOTON_Subir       	RB2
13:            BOTON_Bajar       	RB1
14:            BOTON_MENU       	RB3
15:            BOTON_MANAUT     	RB4
16:            BOTON_ONOFF		RB5
17:            **************************/
18:            
19:            bool Pulsacion(unsigned char Indice, unsigned char Pin, unsigned char TipoPin, bool Logica) {
0F14  00F9     MOVWF Indice
20:               /*
21:                  Esta funcin gestiona las entradas de pulsador, mediante el control de un retardo
22:                  antirrebotes y con la opcin de autorrepeticin de hasta 4 velocidades
23:                  
24:                  Para que funcione, hay que dimensionar la variable Entradas con el n de pulsadores
25:                  que queramos controlar.
26:                  
27:                  ENTRADAS
28:                     Indice: hace referencia al n de pulsador a chequear
29:                     Pin: indica el estado del pin del pulsador (lgica inversa)
30:                     TipoPIN:
31:                        TipoPin=0   -> No tiene autorrepeticin
32:                        TipoPin=1   -> Pin con autorrepeticin
33:                     
34:                  SALIDA
35:                     La funcin devuelve un 1 si el pulsador est en condiciones de ser procesado
36:                     y un 0 en caso contrario.
37:                  
38:               */
39:               static unsigned int Entradas[5]={0,0,0,0,0};  // Dimensionar en funcin del n de pulsadores
40:               unsigned int j;
41:              bool resultado=0;
0F15  01F8     CLRF resultado
42:               
43:               j=Entradas[Indice];  // Como leemos muchas veces el array, lo pasamos a variable local para 
0F16  1003     BCF STATUS, 0x0
0F17  0D79     RLF Indice, W
0F18  3E90     ADDLW 0x90
0F19  0084     MOVWF FSR
0F1A  1783     BSF STATUS, 0x7
0F1B  0800     MOVF INDF, W
0F1C  00FA     MOVWF j
0F1D  0A84     INCF FSR, F
0F1E  0800     MOVF INDF, W
0F1F  00FB     MOVWF 0x7B
44:                                    // incrementar la velocidad de ejecucin
45:                                    
46:               // Si se detecta pulsacin y antes no haba, devolvemos un 1 en resultado
47:               if ((((!Pin && Logica==LOGICA_INVERSA) || (Pin && Logica==LOGICA_DIRECTA)) && (j==0))) {
0F20  08F5     MOVF Pin, F
0F21  1903     BTFSC STATUS, 0x2
0F22  0377     DECF Logica, W
0F23  1903     BTFSC STATUS, 0x2
0F24  2F2B     GOTO 0x72B
0F25  0875     MOVF Pin, W
0F26  1903     BTFSC STATUS, 0x2
0F27  2F34     GOTO 0x734
0F28  08F7     MOVF Logica, F
0F29  1D03     BTFSS STATUS, 0x2
0F2A  2F34     GOTO 0x734
0F2B  087B     MOVF 0x7B, W
0F2C  047A     IORWF j, W
0F2D  1D03     BTFSS STATUS, 0x2
0F2E  2F34     GOTO 0x734
48:                     resultado=1;
0F2F  01F8     CLRF resultado
0F30  0AF8     INCF resultado, F
49:                     j=1;
0F31  01FA     CLRF j
0F32  0AFA     INCF j, F
0F33  01FB     CLRF 0x7B
50:               };
51:               
52:               // Cada vez que se entra a la funcin se incrementa una unidad el array
53:               if (j>0) 
0F34  087B     MOVF 0x7B, W
0F35  047A     IORWF j, W
0F36  1903     BTFSC STATUS, 0x2
0F37  2F41     GOTO 0x741
54:                     Entradas[Indice]++;
0F38  1003     BCF STATUS, 0x0
0F39  0D79     RLF Indice, W
0F3A  3E90     ADDLW 0x90
0F3B  0084     MOVWF FSR
0F3C  3001     MOVLW 0x1
0F3D  0780     ADDWF INDF, F
0F3E  0A84     INCF FSR, F
0F3F  1803     BTFSC STATUS, 0x0
0F40  0A80     INCF INDF, F
55:               
56:               // Si se detecta que ya no se est pulsando, inicializamos a 0 el array
57:               if (((Pin && Logica==LOGICA_INVERSA) || (!Pin && Logica==LOGICA_DIRECTA)) && j>ANTIRREBOTES)
0F41  0875     MOVF Pin, W
0F42  1903     BTFSC STATUS, 0x2
0F43  2F47     GOTO 0x747
0F44  0377     DECF Logica, W
0F45  1903     BTFSC STATUS, 0x2
0F46  2F4D     GOTO 0x74D
0F47  08F5     MOVF Pin, F
0F48  1D03     BTFSS STATUS, 0x2
0F49  2F5B     GOTO 0x75B
0F4A  08F7     MOVF Logica, F
0F4B  1D03     BTFSS STATUS, 0x2
0F4C  2F5B     GOTO 0x75B
0F4D  3000     MOVLW 0x0
0F4E  027B     SUBWF 0x7B, W
0F4F  3033     MOVLW 0x33
0F50  1903     BTFSC STATUS, 0x2
0F51  027A     SUBWF j, W
0F52  1C03     BTFSS STATUS, 0x0
0F53  2F5B     GOTO 0x75B
58:                  Entradas[Indice]=0;
0F54  1003     BCF STATUS, 0x0
0F55  0D79     RLF Indice, W
0F56  3E90     ADDLW 0x90
0F57  0084     MOVWF FSR
0F58  0180     CLRF INDF
0F59  0A84     INCF FSR, F
0F5A  0180     CLRF INDF
59:                  
60:               if (TipoPin) { // Si el pulsador tiene autorrepeticin
0F5B  0876     MOVF TipoPin, W
0F5C  1903     BTFSC STATUS, 0x2
0F5D  2FAA     GOTO 0x7AA
61:                 // Cuando se supera el n de ciclos 4, devolveremos un 1 con la frecuencia VELOCIDAD4
62:                   if ((j>=CAMBIO4) && !(j%VELOCIDAD4)){
0F5E  300F     MOVLW 0xF
0F5F  027B     SUBWF 0x7B, W
0F60  30A0     MOVLW 0xA0
0F61  1903     BTFSC STATUS, 0x2
0F62  027A     SUBWF j, W
0F63  1803     BTFSC STATUS, 0x0
0F64  187A     BTFSC j, 0x0
0F65  2F6B     GOTO 0x76B
63:                       resultado=1;
0F66  01F8     CLRF resultado
0F67  0AF8     INCF resultado, F
64:                  }else
0F68  1283     BCF STATUS, 0x5
0F69  1303     BCF STATUS, 0x6
0F6A  2FAA     GOTO 0x7AA
65:                   // Cuando se supera el n de ciclos 3, devolveremos un 1 con la frecuencia VELOCIDAD3
66:                  if ((j>=CAMBIO3) && !(j%VELOCIDAD3)){           
0F6B  3007     MOVLW 0x7
0F6C  027B     SUBWF 0x7B, W
0F6D  30D0     MOVLW 0xD0
0F6E  1903     BTFSC STATUS, 0x2
0F6F  027A     SUBWF j, W
0F70  1C03     BTFSS STATUS, 0x0
0F71  2F80     GOTO 0x780
0F72  300A     MOVLW 0xA
0F73  00F0     MOVWF tiempo
0F74  01F1     CLRF canal
0F75  087B     MOVF 0x7B, W
0F76  00F3     MOVWF counter
0F77  087A     MOVF j, W
0F78  00F2     MOVWF dividend
0F79  27B6     CALL 0x7B6
0F7A  120A     BCF PCLATH, 0x4
0F7B  158A     BSF PCLATH, 0x3
0F7C  0871     MOVF canal, W
0F7D  0470     IORWF tiempo, W
0F7E  1903     BTFSC STATUS, 0x2
0F7F  2F66     GOTO 0x766
67:                     resultado=1;
68:                  } else 
69:                     // Cuando se supera el n de ciclos 2, devolveremos un 1 con la frecuencia VELOCIDAD2
70:                     if ((j>=CAMBIO2) && !(j%VELOCIDAD2)){
0F80  3001     MOVLW 0x1
0F81  027B     SUBWF 0x7B, W
0F82  30F4     MOVLW 0xF4
0F83  1903     BTFSC STATUS, 0x2
0F84  027A     SUBWF j, W
0F85  1C03     BTFSS STATUS, 0x0
0F86  2F95     GOTO 0x795
0F87  3032     MOVLW 0x32
0F88  00F0     MOVWF tiempo
0F89  01F1     CLRF canal
0F8A  087B     MOVF 0x7B, W
0F8B  00F3     MOVWF counter
0F8C  087A     MOVF j, W
0F8D  00F2     MOVWF dividend
0F8E  27B6     CALL 0x7B6
0F8F  120A     BCF PCLATH, 0x4
0F90  158A     BSF PCLATH, 0x3
0F91  0871     MOVF canal, W
0F92  0470     IORWF tiempo, W
0F93  1903     BTFSC STATUS, 0x2
0F94  2F66     GOTO 0x766
71:                        resultado=1;
72:                  } else
73:                     // Cuando se supera el n de ciclos 1, devolveremos un 1 con la frecuencia VELOCIDAD1
74:                     if ((j>CAMBIO1) && !(j%VELOCIDAD1)){
0F95  3000     MOVLW 0x0
0F96  027B     SUBWF 0x7B, W
0F97  3065     MOVLW 0x65
0F98  1903     BTFSC STATUS, 0x2
0F99  027A     SUBWF j, W
0F9A  1C03     BTFSS STATUS, 0x0
0F9B  2FAA     GOTO 0x7AA
0F9C  3064     MOVLW 0x64
0F9D  00F0     MOVWF tiempo
0F9E  01F1     CLRF canal
0F9F  087B     MOVF 0x7B, W
0FA0  00F3     MOVWF counter
0FA1  087A     MOVF j, W
0FA2  00F2     MOVWF dividend
0FA3  27B6     CALL 0x7B6
0FA4  120A     BCF PCLATH, 0x4
0FA5  158A     BSF PCLATH, 0x3
0FA6  0871     MOVF canal, W
0FA7  0470     IORWF tiempo, W
0FA8  1903     BTFSC STATUS, 0x2
0FA9  2F66     GOTO 0x766
75:                        resultado=1;
76:                  };
77:               }
78:               if ((TipoPin==INMEDIATO)&&(j>=1))
0FAA  0876     MOVF TipoPin, W
0FAB  3A02     XORLW 0x2
0FAC  1D03     BTFSS STATUS, 0x2
0FAD  2FB4     GOTO 0x7B4
0FAE  087B     MOVF 0x7B, W
0FAF  047A     IORWF j, W
0FB0  1903     BTFSC STATUS, 0x2
0FB1  2FB4     GOTO 0x7B4
79:                   resultado=1;
0FB2  01F8     CLRF resultado
0FB3  0AF8     INCF resultado, F
80:               return (resultado);
0FB4  0878     MOVF resultado, W
81:            }
0FB5  0008     RETURN
82:            
83:            
84:               
85:            
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/LCDGeneric.c  -------------------------
1:             //Cdigo original bajado de: https://github.com/AleSuky/SkP32v1.1/blob/master/SW/Ejemplos/Micros-Designs/Source/LCDGeneric.c
2:             //Gracias Suky
3:             /**
4:                \version: 1.0
5:             
6:                
7:                \author Suky (Casanova Alejandro) 
8:                \web www.infopic.comlu.com
9:                \date 16/08/10
10:            
11:            
12:            ///////////////////////////////////////////////////////////////////////////
13:            ////                                                                   ////
14:            ////                                                                   ////
15:            ////        (C) Copyright 2010 www.infopic.comlu.com                   ////
16:            //// Este cdigo puede ser usado, modificado y distribuido libremente  ////
17:            //// sin eliminar esta cabecera y  sin garanta de ningn tipo.        ////
18:            ////                                                                   ////
19:            ////                                                                   ////
20:            /////////////////////////////////////////////////////////////////////////// 
21:               
22:             *- Version Log --------------------------------------------------------------*
23:             *   Fecha       Autor                Comentarios                             *
24:             *----------------------------------------------------------------------------*
25:             * 16/08/10      Suky               Original (Rev 1.0)                        *
26:             * 20/08/10      Suky               Se incluye CodeVisionAVR                  *
27:             *----------------------------------------------------------------------------* */
28:            #include "xc.h"
29:            #include "system.h"
30:            #include "LCDGeneric.h"
31:            
32:            UINT8 NLinea;
33:            
34:            UINT8 ui8BusyLCD(void){
35:            
36:            #ifdef LCD_USE_RW
37:            	 LCD_DATA_PIN_7 = 0;
133A  1388     BCF PORTD, 0x7
38:            	 LCD_DATA_PIN_6 = 0;
133B  1308     BCF PORTD, 0x6
39:            	 LCD_DATA_PIN_5 = 0;
133C  1288     BCF PORTD, 0x5
40:            	 LCD_DATA_PIN_4 = 0;
133D  1208     BCF PORTD, 0x4
41:            
42:                 LCD_TRIS_DATA_PIN_7 = CONFIG_INPUT;
133E  1683     BSF STATUS, 0x5
133F  1788     BSF PORTD, 0x7
43:                 LCD_TRIS_DATA_PIN_6 = CONFIG_INPUT;
1340  1708     BSF PORTD, 0x6
44:                 LCD_TRIS_DATA_PIN_5 = CONFIG_INPUT;
1341  1688     BSF PORTD, 0x5
45:                 LCD_TRIS_DATA_PIN_4 = CONFIG_INPUT;
1342  1608     BSF PORTD, 0x4
46:            
47:                 LCD_RW_PIN = 1;    
1343  1283     BCF STATUS, 0x5
1344  1488     BSF PORTD, 0x1
48:                 LCD_RS_PIN = 0; 
1345  1008     BCF PORTD, 0x0
49:            	 LCD_E_PIN=1;         
1346  1508     BSF PORTD, 0x2
50:                 __delay_1us();
1347  2B48     GOTO 0x348
1348  2B49     GOTO 0x349
1349  0000     NOP
51:            
52:                 if(LCD_READ_PIN_7==1){
134A  1283     BCF STATUS, 0x5
134B  1303     BCF STATUS, 0x6
134C  1F88     BTFSS PORTD, 0x7
134D  2B5D     GOTO 0x35D
53:                      LCD_E_PIN = 0; 
134E  1108     BCF PORTD, 0x2
54:            		  __delay_1us();
134F  2B50     GOTO 0x350
1350  2B51     GOTO 0x351
1351  0000     NOP
55:            		  LCD_E_PIN = 1;
1352  1283     BCF STATUS, 0x5
1353  1303     BCF STATUS, 0x6
1354  1508     BSF PORTD, 0x2
56:            		  __delay_1us();
1355  2B56     GOTO 0x356
1356  2B57     GOTO 0x357
1357  0000     NOP
57:            		  LCD_E_PIN = 0;
1358  1283     BCF STATUS, 0x5
1359  1303     BCF STATUS, 0x6
135A  1108     BCF PORTD, 0x2
58:                  	  LCD_RW_PIN = 0; 
135B  1088     BCF PORTD, 0x1
59:                      return 1;
135C  3401     RETLW 0x1
60:                 }else{
61:                      LCD_E_PIN = 0;
135D  1108     BCF PORTD, 0x2
62:            		  __delay_1us();
135E  2B5F     GOTO 0x35F
135F  2B60     GOTO 0x360
1360  0000     NOP
63:            		  LCD_E_PIN = 1;
1361  1283     BCF STATUS, 0x5
1362  1303     BCF STATUS, 0x6
1363  1508     BSF PORTD, 0x2
64:            		  __delay_1us();
1364  2B65     GOTO 0x365
1365  2B66     GOTO 0x366
1366  0000     NOP
65:            		  LCD_E_PIN = 0;
1367  1283     BCF STATUS, 0x5
1368  1303     BCF STATUS, 0x6
1369  1108     BCF PORTD, 0x2
66:            		  LCD_RW_PIN = 0;       
136A  1088     BCF PORTD, 0x1
67:                      return 0;
136B  3400     RETLW 0x0
68:                 }
69:            #else
70:            	 __delay_100us();
71:            	 return 0;
72:            #endif
73:            }
74:            
75:            void vWriteLCD(UINT8 Data,UINT8 Type){
12C9  00A5     MOVWF dato
76:            
77:            #ifdef LCD_USE_3PINES
78:            	UINT8 i, data_temp;
79:            #endif
80:            
81:            	while(ui8BusyLCD());
12CA  233A     CALL 0x33A
12CB  160A     BSF PCLATH, 0x4
12CC  118A     BCF PCLATH, 0x3
12CD  3800     IORLW 0x0
12CE  1D03     BTFSS STATUS, 0x2
12CF  2ACA     GOTO 0x2CA
82:            
83:            	#ifndef LCD_USE_3PINES
84:            		#ifdef LCD_USE_RW
85:            			LCD_RW_PIN = 0;
12D0  1088     BCF PORTD, 0x1
86:            		#endif   
87:            		if(Type){
12D1  0824     MOVF x, W
12D2  1903     BTFSC STATUS, 0x2
12D3  2AD6     GOTO 0x2D6
88:            			LCD_RS_PIN=1;
12D4  1408     BSF PORTD, 0x0
89:            		}else{
12D5  2AD7     GOTO 0x2D7
90:            			LCD_RS_PIN = 0;
12D6  1008     BCF PORTD, 0x0
91:            		}	  
92:            		LCD_TRIS_DATA_PIN_7 = CONFIG_OUTPUT;
12D7  1683     BSF STATUS, 0x5
12D8  1388     BCF PORTD, 0x7
93:            		LCD_TRIS_DATA_PIN_6 = CONFIG_OUTPUT;
12D9  1308     BCF PORTD, 0x6
94:            		LCD_TRIS_DATA_PIN_5 = CONFIG_OUTPUT;
12DA  1288     BCF PORTD, 0x5
95:            		LCD_TRIS_DATA_PIN_4 = CONFIG_OUTPUT;
12DB  1208     BCF PORTD, 0x4
96:            		
97:            		LCD_DATA_PIN_7 = !!(Data & 0x80);
12DC  1283     BCF STATUS, 0x5
12DD  1FA5     BTFSS dato, 0x7
12DE  2AE3     GOTO 0x2E3
12DF  1283     BCF STATUS, 0x5
12E0  1303     BCF STATUS, 0x6
12E1  1788     BSF PORTD, 0x7
12E2  2AE6     GOTO 0x2E6
12E3  1283     BCF STATUS, 0x5
12E4  1303     BCF STATUS, 0x6
12E5  1388     BCF PORTD, 0x7
98:            		LCD_DATA_PIN_6 = !!(Data & 0x40);
12E6  1F25     BTFSS dato, 0x6
12E7  2AEC     GOTO 0x2EC
12E8  1283     BCF STATUS, 0x5
12E9  1303     BCF STATUS, 0x6
12EA  1708     BSF PORTD, 0x6
12EB  2AEF     GOTO 0x2EF
12EC  1283     BCF STATUS, 0x5
12ED  1303     BCF STATUS, 0x6
12EE  1308     BCF PORTD, 0x6
99:            		LCD_DATA_PIN_5 = !!(Data & 0x20);
12EF  1EA5     BTFSS dato, 0x5
12F0  2AF5     GOTO 0x2F5
12F1  1283     BCF STATUS, 0x5
12F2  1303     BCF STATUS, 0x6
12F3  1688     BSF PORTD, 0x5
12F4  2AF8     GOTO 0x2F8
12F5  1283     BCF STATUS, 0x5
12F6  1303     BCF STATUS, 0x6
12F7  1288     BCF PORTD, 0x5
100:           		LCD_DATA_PIN_4 = !!(Data & 0x10);
12F8  1E25     BTFSS dato, 0x4
12F9  2AFE     GOTO 0x2FE
12FA  1283     BCF STATUS, 0x5
12FB  1303     BCF STATUS, 0x6
12FC  1608     BSF PORTD, 0x4
12FD  2B01     GOTO 0x301
12FE  1283     BCF STATUS, 0x5
12FF  1303     BCF STATUS, 0x6
1300  1208     BCF PORTD, 0x4
101:           	#else
102:           		data_temp=(Data>>4);  // Rs es bit 4
103:           		if(Type){
104:           			data_temp|=0x10;
105:           		}
106:           		for(i=0;i<8;i++){
107:           			LCD_DATA_PIN=!!(data_temp & 0x80);
108:           			data_temp<<=1;
109:           			LCD_CLOCK_PIN=1;
110:           			__delay_1us();
111:           			LCD_CLOCK_PIN=0;
112:           		}
113:           	#endif
114:           	__delay_1Cycle();
1301  0000     NOP
115:           	LCD_E_PIN = 1;
1302  1283     BCF STATUS, 0x5
1303  1303     BCF STATUS, 0x6
1304  1508     BSF PORTD, 0x2
116:           	__delay_1us();
1305  2B06     GOTO 0x306
1306  2B07     GOTO 0x307
1307  0000     NOP
117:           	LCD_E_PIN = 0;
1308  1283     BCF STATUS, 0x5
1309  1303     BCF STATUS, 0x6
130A  1108     BCF PORTD, 0x2
118:           	#ifndef LCD_USE_3PINES	
119:           		LCD_DATA_PIN_7 = !!(Data & 0x08);
130B  1DA5     BTFSS dato, 0x3
130C  2B11     GOTO 0x311
130D  1283     BCF STATUS, 0x5
130E  1303     BCF STATUS, 0x6
130F  1788     BSF PORTD, 0x7
1310  2B14     GOTO 0x314
1311  1283     BCF STATUS, 0x5
1312  1303     BCF STATUS, 0x6
1313  1388     BCF PORTD, 0x7
120:           		LCD_DATA_PIN_6 = !!(Data & 0x04);
1314  1D25     BTFSS dato, 0x2
1315  2B1A     GOTO 0x31A
1316  1283     BCF STATUS, 0x5
1317  1303     BCF STATUS, 0x6
1318  1708     BSF PORTD, 0x6
1319  2B1D     GOTO 0x31D
131A  1283     BCF STATUS, 0x5
131B  1303     BCF STATUS, 0x6
131C  1308     BCF PORTD, 0x6
121:           		LCD_DATA_PIN_5 = !!(Data & 0x02);
131D  1CA5     BTFSS dato, 0x1
131E  2B23     GOTO 0x323
131F  1283     BCF STATUS, 0x5
1320  1303     BCF STATUS, 0x6
1321  1688     BSF PORTD, 0x5
1322  2B26     GOTO 0x326
1323  1283     BCF STATUS, 0x5
1324  1303     BCF STATUS, 0x6
1325  1288     BCF PORTD, 0x5
122:           		LCD_DATA_PIN_4 = !!(Data & 0x01);
1326  1C25     BTFSS dato, 0x0
1327  2B2C     GOTO 0x32C
1328  1283     BCF STATUS, 0x5
1329  1303     BCF STATUS, 0x6
132A  1608     BSF PORTD, 0x4
132B  2B2F     GOTO 0x32F
132C  1283     BCF STATUS, 0x5
132D  1303     BCF STATUS, 0x6
132E  1208     BCF PORTD, 0x4
123:           	#else
124:           		data_temp=(Data&0x0F);  // Rs es bit 4
125:           		if(Type){
126:           			data_temp|=0x10;
127:           		}
128:           		for(i=0;i<8;i++){
129:           			LCD_DATA_PIN=!!(data_temp & 0x80);
130:           			data_temp<<=1;
131:           			LCD_CLOCK_PIN=1;
132:           			__delay_1us();
133:           			LCD_CLOCK_PIN=0;
134:           		}
135:           	#endif
136:           	__delay_1Cycle();	
132F  0000     NOP
137:           	LCD_E_PIN = 1;
1330  1283     BCF STATUS, 0x5
1331  1303     BCF STATUS, 0x6
1332  1508     BSF PORTD, 0x2
138:           	__delay_1us();
1333  2B34     GOTO 0x334
1334  2B35     GOTO 0x335
1335  0000     NOP
139:           	LCD_E_PIN = 0;
1336  1283     BCF STATUS, 0x5
1337  1303     BCF STATUS, 0x6
1338  1108     BCF PORTD, 0x2
140:           	
141:           } 
1339  0008     RETURN
142:           
143:           void vInitLCD(){
144:           UINT8 i;
145:           #ifdef LCD_USE_3PINES
146:           	UINT8 temp;
147:           #endif
148:           
149:           	for(i=0;i<8;i++){__delay_2ms();}
1254  01A8     CLRF i
1255  300D     MOVLW 0xD
1256  00A7     MOVWF x
1257  30FB     MOVLW 0xFB
1258  00A6     MOVWF y
1259  0BA6     DECFSZ y, F
125A  2A59     GOTO 0x259
125B  0BA7     DECFSZ x, F
125C  2A59     GOTO 0x259
125D  2A5E     GOTO 0x25E
125E  1283     BCF STATUS, 0x5
125F  1303     BCF STATUS, 0x6
1260  3008     MOVLW 0x8
1261  0AA8     INCF i, F
1262  0228     SUBWF i, W
1263  1C03     BTFSS STATUS, 0x0
1264  2A55     GOTO 0x255
150:           	NLinea=1;
1265  1683     BSF STATUS, 0x5
1266  01A9     CLRF mth
1267  0AA9     INCF mth, F
151:           	
152:           #ifndef LCD_USE_3PINES
153:           /* ** Configuracin de pines ** */	
154:           	LCD_DATA_PIN_7 = 0;
1268  1283     BCF STATUS, 0x5
1269  1388     BCF PORTD, 0x7
155:           	LCD_DATA_PIN_6 = 0;
126A  1308     BCF PORTD, 0x6
156:           	LCD_DATA_PIN_5 = 0;
126B  1288     BCF PORTD, 0x5
157:           	LCD_DATA_PIN_4 = 0;
126C  1208     BCF PORTD, 0x4
158:           	#ifdef LCD_USE_RW
159:           		LCD_RW_PIN = 0;
126D  1088     BCF PORTD, 0x1
160:           	#endif
161:           	LCD_RS_PIN = 0;
126E  1008     BCF PORTD, 0x0
162:           	LCD_E_PIN = 0;
126F  1108     BCF PORTD, 0x2
163:           	
164:           	LCD_TRIS_DATA_PIN_7 = CONFIG_OUTPUT;
1270  1683     BSF STATUS, 0x5
1271  1388     BCF PORTD, 0x7
165:           	LCD_TRIS_DATA_PIN_6 = CONFIG_OUTPUT;
1272  1308     BCF PORTD, 0x6
166:           	LCD_TRIS_DATA_PIN_5 = CONFIG_OUTPUT;
1273  1288     BCF PORTD, 0x5
167:           	LCD_TRIS_DATA_PIN_4 = CONFIG_OUTPUT;
1274  1208     BCF PORTD, 0x4
168:           	#ifdef LCD_USE_RW	
169:           		LCD_TRIS_RW = CONFIG_OUTPUT;
1275  1088     BCF PORTD, 0x1
170:           	#endif
171:           	LCD_TRIS_RS = CONFIG_OUTPUT;
1276  1008     BCF PORTD, 0x0
172:           	LCD_TRIS_E = CONFIG_OUTPUT;
1277  1108     BCF PORTD, 0x2
173:           #else
174:           	LCD_DATA_PIN = 0;
175:           	LCD_CLOCK_PIN = 0;
176:           	LCD_E_PIN = 0;
177:           
178:           	LCD_TRIS_DATA = CONFIG_OUTPUT;
179:           	LCD_TRIS_CLOCK = CONFIG_OUTPUT;
180:           	LCD_TRIS_E = CONFIG_OUTPUT;
181:           	
182:           	for(i=0;i<8;i++){
183:           		LCD_DATA_PIN=0;
184:           		LCD_CLOCK_PIN=1;
185:           		__delay_1us();
186:           		LCD_CLOCK_PIN=0;
187:           	}
188:           #endif
189:           /* ** INICIALIZACION ** */     
190:           #ifndef LCD_USE_3PINES
191:           	LCD_DATA_PIN_5 = 1;
1278  1283     BCF STATUS, 0x5
1279  1688     BSF PORTD, 0x5
192:           	LCD_DATA_PIN_4 = 1;
127A  1608     BSF PORTD, 0x4
193:           #else
194:           	temp=0x03;
195:           	for(i=0;i<8;i++){
196:           		LCD_DATA_PIN=!!(temp & 0x80);
197:           		temp<<=1;
198:           		LCD_CLOCK_PIN=1;
199:           		__delay_1us();
200:           		LCD_CLOCK_PIN=0;
201:           	}
202:           #endif
203:           	for(i=0;i<3;i++){
127B  01A8     CLRF i
1292  1283     BCF STATUS, 0x5
1293  1303     BCF STATUS, 0x6
1294  3003     MOVLW 0x3
1295  0AA8     INCF i, F
1296  0228     SUBWF i, W
1297  1C03     BTFSS STATUS, 0x0
1298  2A7C     GOTO 0x27C
204:           		LCD_E_PIN = 1;
127C  1508     BSF PORTD, 0x2
205:           		__delay_2ms();
127D  300D     MOVLW 0xD
127E  00A7     MOVWF x
127F  30FB     MOVLW 0xFB
1280  00A6     MOVWF y
1281  0BA6     DECFSZ y, F
1282  2A81     GOTO 0x281
1283  0BA7     DECFSZ x, F
1284  2A81     GOTO 0x281
1285  2A86     GOTO 0x286
206:           		LCD_E_PIN = 0;
1286  1283     BCF STATUS, 0x5
1287  1303     BCF STATUS, 0x6
1288  1108     BCF PORTD, 0x2
207:           	 	__delay_2ms();
1289  300D     MOVLW 0xD
128A  00A7     MOVWF x
128B  30FB     MOVLW 0xFB
128C  00A6     MOVWF y
128D  0BA6     DECFSZ y, F
128E  2A8D     GOTO 0x28D
128F  0BA7     DECFSZ x, F
1290  2A8D     GOTO 0x28D
1291  2A92     GOTO 0x292
208:           	}
209:           #ifndef LCD_USE_3PINES
210:           	LCD_DATA_PIN_4 = 0;
1299  1208     BCF PORTD, 0x4
211:           #else
212:           	temp=0x02;
213:           	for(i=0;i<8;i++){
214:           		LCD_DATA_PIN=!!(temp & 0x80);
215:           		temp<<=1;
216:           		LCD_CLOCK_PIN=1;
217:           		__delay_1us();
218:           		LCD_CLOCK_PIN=0;
219:           	}
220:           #endif
221:           	LCD_E_PIN = 1;
129A  1508     BSF PORTD, 0x2
222:           	__delay_1us();
129B  2A9C     GOTO 0x29C
129C  2A9D     GOTO 0x29D
129D  0000     NOP
223:           	LCD_E_PIN = 0;
129E  1283     BCF STATUS, 0x5
129F  1303     BCF STATUS, 0x6
12A0  1108     BCF PORTD, 0x2
224:           
225:           	vWriteLCD(0x20 | (LcdType<<2),LCD_COMMAND);  // Tipo display.-  
12A1  3028     MOVLW 0x28
12A2  01A4     CLRF x
12A3  22C9     CALL 0x2C9
12A4  160A     BSF PCLATH, 0x4
12A5  118A     BCF PCLATH, 0x3
226:           	__delay_2ms();     
12A6  300D     MOVLW 0xD
12A7  00A7     MOVWF x
12A8  30FB     MOVLW 0xFB
12A9  00A6     MOVWF y
12AA  0BA6     DECFSZ y, F
12AB  2AAA     GOTO 0x2AA
12AC  0BA7     DECFSZ x, F
12AD  2AAA     GOTO 0x2AA
12AE  2AAF     GOTO 0x2AF
227:           	vWriteLCD(0x01,LCD_COMMAND);	// Borramos display.-   
12AF  1283     BCF STATUS, 0x5
12B0  1303     BCF STATUS, 0x6
12B1  3001     MOVLW 0x1
12B2  01A4     CLRF x
12B3  22C9     CALL 0x2C9
12B4  160A     BSF PCLATH, 0x4
12B5  118A     BCF PCLATH, 0x3
228:           	__delay_2ms();           
12B6  300D     MOVLW 0xD
12B7  00A7     MOVWF x
12B8  30FB     MOVLW 0xFB
12B9  00A6     MOVWF y
12BA  0BA6     DECFSZ y, F
12BB  2ABA     GOTO 0x2BA
12BC  0BA7     DECFSZ x, F
12BD  2ABA     GOTO 0x2BA
12BE  2ABF     GOTO 0x2BF
229:           	vWriteLCD(0x06,LCD_COMMAND);	// Incrementa cursor.-
12BF  1283     BCF STATUS, 0x5
12C0  1303     BCF STATUS, 0x6
12C1  3006     MOVLW 0x6
12C2  01A4     CLRF x
12C3  22C9     CALL 0x2C9
12C4  160A     BSF PCLATH, 0x4
12C5  118A     BCF PCLATH, 0x3
230:           	vWriteLCD(0x0C,LCD_COMMAND);	// Encendemos display.-
12C6  300C     MOVLW 0xC
231:           }
232:           
233:           
234:           void vLCD_Putc(UINT8 Data){
122C  1283     BCF STATUS, 0x5
122D  00AB     MOVWF Data
235:           	
236:           	switch(Data){
122E  3A0A     XORLW 0xA
122F  1903     BTFSC STATUS, 0x2
1230  2A49     GOTO 0x249
1231  3A06     XORLW 0x6
1232  1903     BTFSC STATUS, 0x2
1233  2A36     GOTO 0x236
1234  2A50     GOTO 0x250
237:           		case '\f':
238:           			vWriteLCD(0x01,LCD_COMMAND);
1236  3001     MOVLW 0x1
1237  01A4     CLRF x
1238  22C9     CALL 0x2C9
1239  160A     BSF PCLATH, 0x4
123A  118A     BCF PCLATH, 0x3
239:           			NLinea=1;
123B  1683     BSF STATUS, 0x5
123D  01A9     CLRF mth
123E  0AA9     INCF mth, F
240:           			__delay_2ms();
123C  300D     MOVLW 0xD
123F  1283     BCF STATUS, 0x5
1240  00AA     MOVWF year
1241  30FB     MOVLW 0xFB
1242  00A9     MOVWF mth
1243  0BA9     DECFSZ mth, F
1244  2A43     GOTO 0x243
1245  0BAA     DECFSZ year, F
1246  2A43     GOTO 0x243
1247  2A48     GOTO 0x248
241:           		break;
1248  0008     RETURN
242:           		case '\n':
243:           			vGotoxyLCD(1,++NLinea);			
1249  1683     BSF STATUS, 0x5
124A  0AA9     INCF mth, F
124B  0829     MOVF mth, W
124C  1283     BCF STATUS, 0x5
124D  00A6     MOVWF y
124E  3001     MOVLW 0x1
124F  2A09     GOTO 0x209
244:           		break;
245:           		default:
246:           			vWriteLCD(Data,LCD_DATA);
1250  01A4     CLRF x
1251  0AA4     INCF x, F
1252  082B     MOVF Data, W
1253  2AC9     GOTO 0x2C9
247:           	}
248:           } 
1235  0008     RETURN
249:           
250:           void vGotoxyLCD(UINT8 x,UINT8 y){
1209  00A7     MOVWF x
251:           UINT8 Direccion;
252:           
253:           	switch(y){
120A  2A16     GOTO 0x216
1216  0826     MOVF y, W
1217  3A01     XORLW 0x1
1218  1903     BTFSC STATUS, 0x2
1219  2A0B     GOTO 0x20B
121A  3A03     XORLW 0x3
121B  1903     BTFSC STATUS, 0x2
121C  2A10     GOTO 0x210
121D  2A0B     GOTO 0x20B
254:           		case 1:Direccion = LCD_LINE_1_ADDRESS;NLinea=1;break;
120B  01A8     CLRF i
120C  1683     BSF STATUS, 0x5
120D  01A9     CLRF mth
120E  0AA9     INCF mth, F
120F  2A1E     GOTO 0x21E
255:           		case 2:Direccion = LCD_LINE_2_ADDRESS;NLinea=2;break;
1210  3040     MOVLW 0x40
1211  00A8     MOVWF i
1212  3002     MOVLW 0x2
1213  1683     BSF STATUS, 0x5
1214  00A9     MOVWF mth
1215  2A1E     GOTO 0x21E
256:           		#ifdef LCD_4LINES
257:           		case 3:Direccion = LCD_LINE_3_ADDRESS;NLinea=3;break;
258:           		case 4:Direccion = LCD_LINE_4_ADDRESS;NLinea=4;break;
259:           		#endif
260:           		default:Direccion = LCD_LINE_1_ADDRESS;NLinea=1;break;
261:           	}
262:           
263:           	Direccion+=x-1;
121E  1283     BCF STATUS, 0x5
121F  0827     MOVF x, W
1220  3EFF     ADDLW 0xFF
1221  07A8     ADDWF i, F
264:           	while(ui8BusyLCD());
1222  233A     CALL 0x33A
1223  160A     BSF PCLATH, 0x4
1224  118A     BCF PCLATH, 0x3
1225  3800     IORLW 0x0
1226  1D03     BTFSS STATUS, 0x2
1227  2A22     GOTO 0x222
265:           	vWriteLCD(0x80|Direccion,LCD_COMMAND);
1228  01A4     CLRF x
266:           }
267:           
268:           void vPuts_LCD(UINT8 *buffer){
269:           
270:           
271:               while(*buffer != '\0')    {
272:                  // vLCD_Putc(*buffer++);;
273:                   vWriteLCD(*buffer++,LCD_DATA);
274:               }
275:           }
276:           
277:           void vBlinkingLCD(void){
278:           	vWriteLCD(0b1101,LCD_COMMAND);
279:           }
280:           void vnoBlinkingLCD(void){
281:           	vWriteLCD(0b1100,LCD_COMMAND);
282:           }
283:           void vBackLightLCD_On(void){
0FFC  1188     BCF PORTD, 0x3
103D  1188     BCF PORTD, 0x3
284:               TRISD3=0;
0FFC  1188     BCF PORTD, 0x3
103D  1188     BCF PORTD, 0x3
285:               RD3=1;
0FFD  1283     BCF STATUS, 0x5
0FFE  1588     BSF PORTD, 0x3
103E  1283     BCF STATUS, 0x5
103F  1588     BSF PORTD, 0x3
286:           }
0FFF  0008     RETURN
1040  0008     RETURN
287:           void vBackLightLCD_Off(void){
288:               TRISD3=0;
0FF3  1188     BCF PORTD, 0x3
289:               RD3=0;
0FF4  1283     BCF STATUS, 0x5
0FF5  1188     BCF PORTD, 0x3
290:           }
0FF6  0008     RETURN
---  /home/fernando/MPLABXProjects/Control_BOMBA_RTC_ISL1208_V6.X/HardI2C.c  ----------------------------
1:             //Cdigo original bajado de: http://www.todopic.com.ar/foros/index.php?topic=38654.0
2:             //Gracias AngelGris
3:             /**************************************************************************
4:             *      Libreria para protocolo I2C Master por HardWare para HiTech        *
5:             ***************************************************************************
6:             
7:             ***************************************************************************
8:             *                                                                         *
9:             * Antes de incluir este archivo en nuestro programa hay que definir       *
10:            * algunos parametros. Estos son                                           *
11:            *                                                                         *
12:            * PIC_CLK        (se usa para calcular el valor de SSPADD)                *     
13:            * I2C_BAUD       (velocidad de transferencia)                             *
14:            *                                                                         *
15:            ***************************************************************************
16:            
17:            ***************************************************************************
18:            *                                                                         *
19:            * En esta libreria se encuentran las siguientes funciones                 *
20:            *                                                                         *
21:            * setup_i2c(char)               (inicializa el puerto I2C)                *
22:            * start_i2c()                   (envia start, inicia transmision)         *
23:            * rstar_i2c()                   (envia restart, reinicia transmision)     *
24:            * stop_i2c()                    (envia stop, termina transmision)         *
25:            * write_i2c(char)               (envia un byte)                           *
26:            * read_i2c(char)                (recibe un byte y envia ack o noack)      *
27:            *                                                                         *
28:            *  La funcion write_i2c() devuelve 0 si el dispositivo responde o 1 si el *
29:            * dispositivo no responde.                                                *
30:            *                                                                         *
31:            *  A la funcion read_i2c() hay que pasarle 0 si se quiere responder al    *
32:            * disipositivo o 1 si no se quiere responder                              *
33:            *                                                                         *
34:            *  En esta libreria estan definidos los parametros I2C_MASTER, I2C_SLAVE, *
35:            * I2C_10BIT_ADDRESS. Eston son utilizados en la funcion setup_i2c(char)   *
36:            *                                                                         *
37:            *  Tambien estan definidos ACK y NOACK que son los utilizados para        *
38:            * responder o no al dispositivo                                           *
39:            *                                                                         *
40:            ***************************************************************************
41:            
42:            * Ejemplo de configuracion y utilizacion
43:            
44:             #define PIC_CLK   10000000   // cristal 10MHz
45:             #define I2C_BAUD  100000     // velocidad 100 KHz
46:             #include "HardI2c.c"
47:            
48:             void main (void);
49:             {
50:               unsigned char respuesta;
51:               unsigned char dato;  
52:             
53:               ......
54:               ......
55:               ......
56:               setup_i2c (I2C_MASTER);
57:               start_i2c();
58:               respuesta = write_i2c (0b10101110);    // comunicacion para escribir en una 24C02C
59:               if (respuesta == ACK)
60:               {
61:                 write_i2c (0x00);                    // indico la direccion a escribir
62:                 write_i2c (0xF5);                    // escribo el dato F5
63:                 write_i2c (0x06);                    // escribo el dato 06
64:               }
65:               stop_i2c();
66:            
67:               // colocar un delay necesario para que termine de grabar la memoria
68:            
69:               start_i2c();
70:               respuesta = write_i2c (0b10101110);    // comunicacion para escribir en una 24C02C
71:               if (respuesta == ACK)
72:               {
73:                 write_i2c (0x00);                    // indico la direccion de memoria
74:                 rstart_i2c();                       // reinicio la transmisin
75:                 respuesta = write_i2c (0b10101111);  // comunicacion para leer en una 24C02C
76:                 if (respuesta == ACK)
77:                 {
78:                   dato = read_i2c (ACK);             // leo el dato y respondo
79:                   dato = read_i2c (NOACK);           // leo el dato y no respondo
80:                 }
81:               }
82:               stop_i2c();
83:             }
84:            
85:            */
86:            #include <xc.h>
87:            #include <stdbool.h>       /* For true/false definition */
88:            #include "system.h"        /* System funct/params, like osc/peripheral config */
89:            #include "HardI2C.h"
90:            
91:            
92:            #if defined (PIC_CLK) && defined (I2C_BAUD)
93:            
94:            void setup_i2c (char x)
0803  00A4     MOVWF x
95:             {
96:                TRISC3 = 1;
0804  1683     BSF STATUS, 0x5
0805  1587     BSF PORTC, 0x3
97:            
98:                TRISC4 = 1;
0806  1607     BSF PORTC, 0x4
99:            
100:               SSPSTAT = 0;
0807  0194     CLRF SSPCON
101:               SSPCON = x;
0808  1283     BCF STATUS, 0x5
0809  0824     MOVF x, W
080A  0094     MOVWF SSPCON
102:               
103:               SSPCON2 = 0;
080B  1683     BSF STATUS, 0x5
080C  0191     CLRF TMR2
104:               // SSPCON2bits.RCEN=1;
105:               if (SSPM3 == 1) SSPADD = (unsigned char)((PIC_CLK/(4*I2C_BAUD)) - 1);
080D  1283     BCF STATUS, 0x5
080E  1D94     BTFSS SSPCON, 0x3
080F  0008     RETURN
0810  300B     MOVLW 0xB
0811  1683     BSF STATUS, 0x5
0812  0093     MOVWF SSPBUF
106:           
107:           }
0813  0008     RETURN
108:           
109:             char start_i2c (void)
110:             { 
111:               while (( SSPCON2 & 0x1F ) || R_nW );
0B74  1683     BSF STATUS, 0x5
0B75  0811     MOVF TMR2, W
0B76  391F     ANDLW 0x1F
0B77  1903     BTFSC STATUS, 0x2
0B78  1914     BTFSC SSPCON, 0x2
0B79  2B74     GOTO 0x374
112:               SEN = 1;
0B7A  1411     BSF TMR2, 0x0
113:               return !BCLIF;
114:             }
0B7B  0008     RETURN
115:           
116:             void rstart_i2c (void)
117:             {
118:               while (( SSPCON2 & 0x1F ) || R_nW );
0BB8  1683     BSF STATUS, 0x5
0BB9  0811     MOVF TMR2, W
0BBA  391F     ANDLW 0x1F
0BBB  1903     BTFSC STATUS, 0x2
0BBC  1914     BTFSC SSPCON, 0x2
0BBD  2BB8     GOTO 0x3B8
119:               RSEN = 1;
0BBE  1491     BSF TMR2, 0x1
120:             }
0BBF  0008     RETURN
121:           
122:             void stop_i2c (void)
123:             {
124:               while (( SSPCON2 & 0x1F ) || R_nW );
0B7C  1683     BSF STATUS, 0x5
0B7D  0811     MOVF TMR2, W
0B7E  391F     ANDLW 0x1F
0B7F  1903     BTFSC STATUS, 0x2
0B80  1914     BTFSC SSPCON, 0x2
0B81  2B7C     GOTO 0x37C
125:               PEN = 1;
0B82  1511     BSF TMR2, 0x2
126:             }
0B83  0008     RETURN
127:           
128:             char write_i2c (unsigned char data)
0B4A  1283     BCF STATUS, 0x5
0B4B  00A4     MOVWF x
129:             {
130:               if (SSPM3 == 1)
0B4C  1D94     BTFSS SSPCON, 0x3
0B4D  2B5E     GOTO 0x35E
131:               {
132:                 while (( SSPCON2 & 0x1F ) || R_nW );
0B4E  1683     BSF STATUS, 0x5
0B4F  0811     MOVF TMR2, W
0B50  391F     ANDLW 0x1F
0B51  1903     BTFSC STATUS, 0x2
0B52  1914     BTFSC SSPCON, 0x2
0B53  2B4E     GOTO 0x34E
133:                 SSPBUF = data;
0B54  1283     BCF STATUS, 0x5
0B55  0824     MOVF x, W
0B56  0093     MOVWF SSPBUF
134:                 while (R_nW == 1);
0B57  1683     BSF STATUS, 0x5
0B58  1914     BTFSC SSPCON, 0x2
0B59  2B57     GOTO 0x357
135:                 //while(ACKSTAT==1);
136:                 return ACKSTAT;
0B5A  3000     MOVLW 0x0
0B5B  1B11     BTFSC TMR2, 0x6
0B5C  3001     MOVLW 0x1
0B5D  0008     RETURN
137:               }
138:               else
139:               {
140:                 SSPBUF = data;
0B5E  0824     MOVF x, W
0B5F  0093     MOVWF SSPBUF
141:                 CKP = 1;
0B60  1614     BSF SSPCON, 0x4
142:                 return 0;
0B61  3400     RETLW 0x0
143:               }
144:             }
145:           
146:             unsigned char read_i2c (unsigned char respuesta)
0B84  1283     BCF STATUS, 0x5
0B85  00A4     MOVWF x
147:             {
148:               unsigned char dato;
149:           
150:               if (SSPM3 == 1)
0B86  1D94     BTFSS SSPCON, 0x3
0B87  2BAB     GOTO 0x3AB
151:               {
152:                 while (( SSPCON2 & 0x1F ) || R_nW );
0B88  1683     BSF STATUS, 0x5
0B89  0811     MOVF TMR2, W
0B8A  391F     ANDLW 0x1F
0B8B  1903     BTFSC STATUS, 0x2
0B8C  1914     BTFSC SSPCON, 0x2
0B8D  2B88     GOTO 0x388
153:                 RCEN = 1;
0B8E  1591     BSF TMR2, 0x3
154:                 while (( SSPCON2 & 0x1F ) || R_nW );
0B8F  0811     MOVF TMR2, W
0B90  391F     ANDLW 0x1F
0B91  1903     BTFSC STATUS, 0x2
0B92  1914     BTFSC SSPCON, 0x2
0B93  2B8F     GOTO 0x38F
155:                 dato = SSPBUF;
0B94  1283     BCF STATUS, 0x5
0B95  0813     MOVF SSPBUF, W
0B96  00A5     MOVWF dato
156:                 while (( SSPCON2 & 0x1F ) || R_nW );
0B97  1683     BSF STATUS, 0x5
0B98  0811     MOVF TMR2, W
0B99  391F     ANDLW 0x1F
0B9A  1903     BTFSC STATUS, 0x2
0B9B  1914     BTFSC SSPCON, 0x2
0B9C  2B97     GOTO 0x397
157:                 ACKDT = respuesta;
0B9D  1283     BCF STATUS, 0x5
0B9E  1C24     BTFSS x, 0x0
0B9F  2BA4     GOTO 0x3A4
0BA0  1683     BSF STATUS, 0x5
0BA1  1303     BCF STATUS, 0x6
0BA2  1691     BSF TMR2, 0x5
0BA3  2BA7     GOTO 0x3A7
0BA4  1683     BSF STATUS, 0x5
0BA5  1303     BCF STATUS, 0x6
0BA6  1291     BCF TMR2, 0x5
158:                 ACKEN = 1;
0BA7  1611     BSF TMR2, 0x4
159:                 return dato;
0BA8  1283     BCF STATUS, 0x5
0BA9  0825     MOVF dato, W
0BAA  0008     RETURN
160:               }
161:               else
162:               {
163:                 dato = SSPBUF;
0BAB  0813     MOVF SSPBUF, W
0BAC  00A5     MOVWF dato
164:                 return dato;
165:               }
166:             }
0BAD  0008     RETURN
167:           #else
168:             #error Faltan definir parametros
169:           #endif
